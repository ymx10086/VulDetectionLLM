{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint unrivaling_hardboard = 0;\r\n\r\nstruct revolt_flukeworm \r\n{\r\n char *planaria_nandina;\r\n double chitterlings_egret;\r\n char *gab_overdilation;\r\n char kensett_embitters;\r\n int conli_intermutation;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *delicious_buccinator = 0;\r\n jmp_buf champagning_roughhew;\r\n int consociated_pact;\r\n int meritocracy_graspers;\r\n struct revolt_flukeworm *sesamum_preobserving = {0};\r\n struct revolt_flukeworm *deciduata_nonsibilant = {0};\r\n struct revolt_flukeworm histotrophy_glycopexia;\r\n int referees_crowstone = 29;\r\n char *esoterically_nonradiancy;;\r\n if (__sync_bool_compare_and_swap(&unrivaling_hardboard,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&esoterically_nonradiancy,\"8254\",referees_crowstone);\r\n if (esoterically_nonradiancy != 0) {;\r\n histotrophy_glycopexia . planaria_nandina = ((char *)esoterically_nonradiancy);\r\n meritocracy_graspers = 1;\r\n sesamum_preobserving = &histotrophy_glycopexia;\r\n deciduata_nonsibilant = ((struct revolt_flukeworm *)(((unsigned long )sesamum_preobserving) * meritocracy_graspers * meritocracy_graspers)) + 5;\r\n consociated_pact = setjmp(champagning_roughhew);\r\n if (consociated_pact == 0) {\r\n longjmp(champagning_roughhew,1);\r\n }\r\n delicious_buccinator = ((char *)( *(deciduata_nonsibilant - 5)) . planaria_nandina);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(delicious_buccinator); ++i) {\r\n if (delicious_buccinator[i] == ';') {\r\n if (i == 0 || delicious_buccinator[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,delicious_buccinator);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (( *(deciduata_nonsibilant - 5)) . planaria_nandina != 0) \r\n free(((char *)( *(deciduata_nonsibilant - 5)) . planaria_nandina));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint iatrochemist_potti = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid frightenable_sibship(int tactful_cnidus,char **skeined_prosstoa);\r\nvoid gnar_strandward(int kallick_stylopharyngeus,char **conglomerator_apodeictically);\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n int gaius_zoophysics = 7;\r\n char **chooky_pentathlos = 0;\r\n int *koumiss_unmotioned = 0;\r\n int bailor_commandeers;\r\n char **aesop_gegger[10] = {0};\r\n char *cibarious_roughings[35] = {0};\r\n char *descriptions_antitax;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&iatrochemist_potti,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&descriptions_antitax,\"CONSULARITY_INBEAMING\");\r\n if (descriptions_antitax != 0) {;\r\n cibarious_roughings[10] = descriptions_antitax;\r\n aesop_gegger[5] = cibarious_roughings;\r\n bailor_commandeers = 5;\r\n koumiss_unmotioned = &bailor_commandeers;\r\n chooky_pentathlos = *(aesop_gegger + *koumiss_unmotioned);\r\n frightenable_sibship(gaius_zoophysics,chooky_pentathlos);\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid frightenable_sibship(int tactful_cnidus,char **skeined_prosstoa)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *tubinarial_cowes = 0;\r\n ++global_variable;\r\n tactful_cnidus--;\r\n if (tactful_cnidus > 0) {\r\n gnar_strandward(tactful_cnidus,skeined_prosstoa);\r\n return ;\r\n }\r\n tubinarial_cowes = ((char *)skeined_prosstoa[10]);\r\n \r\n \r\n\r\n if (strlen(tubinarial_cowes) < 63) {\r\n skip_malloc_buffer = malloc(strlen(tubinarial_cowes + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,tubinarial_cowes);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if (skeined_prosstoa[10] != 0) \r\n free(((char *)skeined_prosstoa[10]));\r\nclose_printf_context();\r\n}\r\n\r\nvoid gnar_strandward(int kallick_stylopharyngeus,char **conglomerator_apodeictically)\r\n{\r\n ++global_variable;\r\n frightenable_sibship(kallick_stylopharyngeus,conglomerator_apodeictically);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n strcpy(skip_malloc_buffer,tubinarial_cowes);\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <sys/types.h> \r\n#include <unistd.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint gemmological_walbrzych = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n \r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n \r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n \r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\nint isSymLink(char *file) {\r\n struct stat statbuf;\r\n \r\n if (lstat(file, &statbuf) < 0) { \r\n printf(\"Error accessing path.\\n\");\r\n return 1; \r\n }\r\n if (S_ISLNK(statbuf.st_mode) == 1) {\r\n printf(\"Path is symlink.\\n\");\r\n return 1;\r\n }\r\n printf(\"Path is valid.\\n\");\r\n return 0;\r\n}\r\nint path_is_not_symlink(char * abs_path) {\r\n \r\n return (isSymLink(abs_path) == 0);\r\n}\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *chigoe_melchite = 0;\r\n jmp_buf loaches_outadd;\r\n int pogroms_wakikis;\r\n char **analogising_extracolumella = 0;\r\n int **freir_calotin = 0;\r\n int *confirmedness_evacuators = 0;\r\n int nonheritor_ofr;\r\n char **phoby_actuaryship[10] = {0};\r\n char *wrothy_remonstration[61] = {0};\r\n char *emergently_tophet;;\r\n if (__sync_bool_compare_and_swap(&gemmological_walbrzych,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&emergently_tophet,\"TREACLY_MIDSTREET\");\r\n if (emergently_tophet != 0) {;\r\n wrothy_remonstration[9] = emergently_tophet;\r\n nonheritor_ofr = 5;\r\n confirmedness_evacuators = &nonheritor_ofr;\r\n freir_calotin = &confirmedness_evacuators;\r\n phoby_actuaryship[ *( *freir_calotin)] = wrothy_remonstration;\r\n analogising_extracolumella = phoby_actuaryship[ *( *freir_calotin)];\r\n pogroms_wakikis = setjmp(loaches_outadd);\r\n if (pogroms_wakikis == 0) {\r\n longjmp(loaches_outadd,1);\r\n }\r\n chigoe_melchite = ((char *)analogising_extracolumella[9]);\r\n \r\n str = malloc(sizeof(char) * (strlen(chigoe_melchite) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(chigoe_melchite) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(chigoe_melchite, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (path_is_not_symlink(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n file = fopen(abs_path,\"rb\");\r\n \r\n if (file != 0) {\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer) {\r\n \r\n \r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n fclose(file);\r\n free(buffer);\r\n \r\n }\r\n }\r\n }\r\n free (abs_path);\r\n }\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\n if (analogising_extracolumella[9] != 0) \r\n free(((char *)analogising_extracolumella[9]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n fread(buffer,sizeof(char ),size,file);\n buffer[size] = '\\0';\n printf(buffer);\n fclose(file);\n free(buffer);\n```", "cwe": "363"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <time.h> \r\n#include <sys/stat.h> \r\nint shul_norms = 0;\r\n\r\nstruct carrelli_dumpily \r\n{\r\n char *colt_transshaped;\r\n double encolden_deiope;\r\n char *tribespeople_heptastrophic;\r\n char exophthalmia_clover;\r\n int vidette_quadruplex;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *fissuriform_aurotellurite);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&shul_norms,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *fissuriform_aurotellurite)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *torchier_prehistoric = 0;\r\n struct carrelli_dumpily *should_antehistoric = {0};\r\n struct carrelli_dumpily minie_queenanne;\r\n ++global_variable;;\r\n if (fissuriform_aurotellurite != 0) {;\r\n minie_queenanne . colt_transshaped = ((char *)fissuriform_aurotellurite);\r\n should_antehistoric = &minie_queenanne;\r\n torchier_prehistoric = ((char *)( *should_antehistoric) . colt_transshaped);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, torchier_prehistoric);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (( *should_antehistoric) . colt_transshaped != 0) \r\n free(((char *)( *should_antehistoric) . colt_transshaped));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer)) {\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n } else {\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint tubinares_shelffellow = 0;\r\nint global_variable;\r\nvoid handle_taint(char *hepsiba_armond);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nchar *mls_philosophastry(char *antiricin_wheedler);\r\nvoid pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly);\r\nvoid catface_conduciveness(int predeclaration_arguing,char *triunity_kremlin);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\nstruct struct {\r\n int (* before)(int);\r\n char buffer[64];\r\n int (* after)(int);\r\n};\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&tubinares_shelffellow,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid handle_taint(char *hepsiba_armond)\r\n{\r\n int herbicidal_monospermal = 7;\r\n char *jear_nonretired = 0;\r\n int cavaliero_chuchchis = 0;\r\n char *overtechnical_mediately = 0;\r\n ++global_variable;;\r\n if (hepsiba_armond != 0) {;\r\n cavaliero_chuchchis = ((int )(strlen(hepsiba_armond)));\r\n overtechnical_mediately = ((char *)(malloc(cavaliero_chuchchis + 1)));\r\n if (overtechnical_mediately == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(overtechnical_mediately,0,cavaliero_chuchchis + 1);\r\n memcpy(overtechnical_mediately,hepsiba_armond,cavaliero_chuchchis);\r\n if (hepsiba_armond != 0) \r\n free(((char *)hepsiba_armond));\r\n jear_nonretired = mls_philosophastry(overtechnical_mediately);\r\n pulvilli_agpaite(herbicidal_monospermal,jear_nonretired);\r\n }\r\n}\r\n\r\nchar *mls_philosophastry(char *antiricin_wheedler)\r\n{\r\n ++global_variable;\r\n return antiricin_wheedler;\r\n}\r\n\r\nvoid pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly)\r\n{\r\n int i = 0;\r\n struct struct data;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *shenstone_cobalamin = 0;\r\n ++global_variable;\r\n galloglass_panipat--;\r\n if (galloglass_panipat > 0) {\r\n catface_conduciveness(galloglass_panipat,autoreinfusion_jerkingly);\r\n return ;\r\n }\r\n shenstone_cobalamin = ((char *)autoreinfusion_jerkingly);\r\n \r\n \r\n \r\n data.before = toupper;\r\n for (i = 0; i < 64; i++) {\r\n data.buffer[i] = 'A';\r\n }\r\n data.buffer[63] = '\\0';\r\n data.after = toupper;\r\n \r\n \r\n \r\n \r\n \r\n taint_len = ((int )(strlen(shenstone_cobalamin)));\r\n\r\n\r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n data.buffer[buff_size] = shenstone_cobalamin[taint_len];\r\n }\r\n \r\n for (i = 0; i < 64; ++i) {\r\n data.buffer[i] = toupper(data.buffer[i]);\r\n printf(\"%c\",data.before(data.buffer[i]));\r\n }\r\n \r\n \r\n printf(\"\\n\");\r\n \r\n \r\n \r\n;\r\n if (autoreinfusion_jerkingly != 0) \r\n free(((char *)autoreinfusion_jerkingly));\r\nclose_printf_context();\r\n}\r\n\r\nvoid catface_conduciveness(int predeclaration_arguing,char *triunity_kremlin)\r\n{\r\n ++global_variable;\r\n pulvilli_agpaite(predeclaration_arguing,triunity_kremlin);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` taint_len = ((int )(strlen(shenstone_cobalamin)));\n\n\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\n data.buffer[buff_size] = shenstone_cobalamin[taint_len];\n }\n \n for (i = 0; i < 64; ++i) {\n data.buffer[i] = toupper(data.buffer[i]);\n printf(\"%c\",data.before(data.buffer[i]));\n }\n```", "cwe": "124"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint aspis_briquette = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid disgracers_frizer(int ancell_ecocide,void *chirring_enclog);\r\nint 190_global_var = 0;\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int zemindars_epithelia = 7;\r\n void *nonleprous_ashine = 0;\r\n int tracheaectasy_flirtatiousness = 6;\r\n char *phyton_dysphemistic;;\r\n if (__sync_bool_compare_and_swap(&aspis_briquette,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&phyton_dysphemistic,\"4855\",tracheaectasy_flirtatiousness);\r\n if (phyton_dysphemistic != 0) {;\r\n nonleprous_ashine = ((void *)phyton_dysphemistic);\r\n disgracers_frizer(zemindars_epithelia,nonleprous_ashine);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid disgracers_frizer(int ancell_ecocide,void *chirring_enclog)\r\n{\r\n int tainted_int = 0;\r\n int output_counter = 0;\r\n char *malakin_cuirassing = 0;\r\n ++global_variable;\r\n ancell_ecocide--;\r\n if (ancell_ecocide > 0) {\r\n disgracers_frizer(ancell_ecocide,chirring_enclog);\r\n return ;\r\n }\r\n malakin_cuirassing = ((char *)((char *)chirring_enclog));\r\n \r\n tainted_int = atoi(malakin_cuirassing);\r\n if (tainted_int > 0) {\r\n \r\n\r\n tainted_int = tainted_int * tainted_int;\r\n \r\n \r\n \r\n while (tainted_int != 0) {\r\n\r\n if (tainted_int != INT_MIN) {\r\n tainted_int--;\r\n }\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n ++190_global_var;\r\n if (190_global_var >= INT_MAX) {\r\n 190_global_var = 0;\r\n }\r\n }\r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if (((char *)chirring_enclog) != 0) \r\n free(((char *)((char *)chirring_enclog)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (tainted_int != 0) {\n\n if (tainted_int != INT_MIN) {\n tainted_int--;\n }\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n ++190_global_var;\n if (190_global_var >= INT_MAX) {\n 190_global_var = 0;\n }\n }\n```", "cwe": "190"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint undeficiently_bundweed = 0;\r\nint global_variable;\r\n\r\nunion bastard_typicality \r\n{\r\n char *corder_felonwood;\r\n double malpighiaceae_piddled;\r\n char *metachemical_jubilate;\r\n char counterflashing_danella;\r\n int schomberger_sensomobile;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid polychromatize_unanemic(int inharmony_btn,union bastard_typicality **************************************************unresuscitative_beaverwood);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n int deficit_geothlypis = 7;\r\n union bastard_typicality **************************************************slayable_moorman = 0;\r\n union bastard_typicality *************************************************furmark_shrier = 0;\r\n union bastard_typicality ************************************************xanthochroid_sphenopalatine = 0;\r\n union bastard_typicality ***********************************************overpained_participants = 0;\r\n union bastard_typicality **********************************************covetousness_bistros = 0;\r\n union bastard_typicality *********************************************clervaux_shuns = 0;\r\n union bastard_typicality ********************************************missourian_splendora = 0;\r\n union bastard_typicality *******************************************phosphoresced_ruddiness = 0;\r\n union bastard_typicality ******************************************pep_granes = 0;\r\n union bastard_typicality *****************************************egidius_mayapple = 0;\r\n union bastard_typicality ****************************************inexecutable_winterly = 0;\r\n union bastard_typicality ***************************************originary_shamefast = 0;\r\n union bastard_typicality **************************************goliard_starchiness = 0;\r\n union bastard_typicality *************************************strich_dyspeptically = 0;\r\n union bastard_typicality ************************************outwatching_sphacelism = 0;\r\n union bastard_typicality ***********************************respectfully_panpsychism = 0;\r\n union bastard_typicality **********************************vapourescent_spleninii = 0;\r\n union bastard_typicality *********************************sesuvium_stauroscope = 0;\r\n union bastard_typicality ********************************unconscionably_oscilloscopes = 0;\r\n union bastard_typicality *******************************defalcator_lohengrin = 0;\r\n union bastard_typicality ******************************spirochetal_insurgence = 0;\r\n union bastard_typicality *****************************polyonymy_bluenesses = 0;\r\n union bastard_typicality ****************************unauthorized_tenour = 0;\r\n union bastard_typicality ***************************enemied_lurries = 0;\r\n union bastard_typicality **************************mervin_mesodermal = 0;\r\n union bastard_typicality *************************troparion_dacryolite = 0;\r\n union bastard_typicality ************************gorhen_aurify = 0;\r\n union bastard_typicality ***********************buffalo_unendable = 0;\r\n union bastard_typicality **********************mammitis_flinthearted = 0;\r\n union bastard_typicality *********************tatie_untentered = 0;\r\n union bastard_typicality ********************foveas_strawier = 0;\r\n union bastard_typicality *******************yorubaland_ballooner = 0;\r\n union bastard_typicality ******************infraspinate_bumtrap = 0;\r\n union bastard_typicality *****************flossies_holmun = 0;\r\n union bastard_typicality ****************walchia_nonvulval = 0;\r\n union bastard_typicality ***************gallophobe_burnight = 0;\r\n union bastard_typicality **************gymnite_porcelanite = 0;\r\n union bastard_typicality *************toused_printings = 0;\r\n union bastard_typicality ************dechlog_tussy = 0;\r\n union bastard_typicality ***********exudative_jon = 0;\r\n union bastard_typicality **********styloglossus_necrotizing = 0;\r\n union bastard_typicality *********bordereaux_podical = 0;\r\n union bastard_typicality ********restream_unattestedness = 0;\r\n union bastard_typicality *******bieennia_owlishly = 0;\r\n union bastard_typicality ******uromelus_unsacrament = 0;\r\n union bastard_typicality *****unbusk_leukoblast = 0;\r\n union bastard_typicality ****frigate_anoine = 0;\r\n union bastard_typicality ***glancer_cirripedia = 0;\r\n union bastard_typicality **pondside_underbrace = 0;\r\n union bastard_typicality *domiculture_resnatron = 0;\r\n union bastard_typicality pinkify_stoot = {0};\r\n union bastard_typicality killing_farrow;\r\n int cryptomnesic_vend = 53;\r\n char *mastosquamose_gasser;;\r\n if (__sync_bool_compare_and_swap(&undeficiently_bundweed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&mastosquamose_gasser,\"8433\",cryptomnesic_vend);\r\n if (mastosquamose_gasser != 0) {;\r\n killing_farrow . corder_felonwood = mastosquamose_gasser;\r\n domiculture_resnatron = &killing_farrow;\r\n pondside_underbrace = &domiculture_resnatron;\r\n glancer_cirripedia = &pondside_underbrace;\r\n frigate_anoine = &glancer_cirripedia;\r\n unbusk_leukoblast = &frigate_anoine;\r\n uromelus_unsacrament = &unbusk_leukoblast;\r\n bieennia_owlishly = &uromelus_unsacrament;\r\n restream_unattestedness = &bieennia_owlishly;\r\n bordereaux_podical = &restream_unattestedness;\r\n styloglossus_necrotizing = &bordereaux_podical;\r\n exudative_jon = &styloglossus_necrotizing;\r\n dechlog_tussy = &exudative_jon;\r\n toused_printings = &dechlog_tussy;\r\n gymnite_porcelanite = &toused_printings;\r\n gallophobe_burnight = &gymnite_porcelanite;\r\n walchia_nonvulval = &gallophobe_burnight;\r\n flossies_holmun = &walchia_nonvulval;\r\n infraspinate_bumtrap = &flossies_holmun;\r\n yorubaland_ballooner = &infraspinate_bumtrap;\r\n foveas_strawier = &yorubaland_ballooner;\r\n tatie_untentered = &foveas_strawier;\r\n mammitis_flinthearted = &tatie_untentered;\r\n buffalo_unendable = &mammitis_flinthearted;\r\n gorhen_aurify = &buffalo_unendable;\r\n troparion_dacryolite = &gorhen_aurify;\r\n mervin_mesodermal = &troparion_dacryolite;\r\n enemied_lurries = &mervin_mesodermal;\r\n unauthorized_tenour = &enemied_lurries;\r\n polyonymy_bluenesses = &unauthorized_tenour;\r\n spirochetal_insurgence = &polyonymy_bluenesses;\r\n defalcator_lohengrin = &spirochetal_insurgence;\r\n unconscionably_oscilloscopes = &defalcator_lohengrin;\r\n sesuvium_stauroscope = &unconscionably_oscilloscopes;\r\n vapourescent_spleninii = &sesuvium_stauroscope;\r\n respectfully_panpsychism = &vapourescent_spleninii;\r\n outwatching_sphacelism = &respectfully_panpsychism;\r\n strich_dyspeptically = &outwatching_sphacelism;\r\n goliard_starchiness = &strich_dyspeptically;\r\n originary_shamefast = &goliard_starchiness;\r\n inexecutable_winterly = &originary_shamefast;\r\n egidius_mayapple = &inexecutable_winterly;\r\n pep_granes = &egidius_mayapple;\r\n phosphoresced_ruddiness = &pep_granes;\r\n missourian_splendora = &phosphoresced_ruddiness;\r\n clervaux_shuns = &missourian_splendora;\r\n covetousness_bistros = &clervaux_shuns;\r\n overpained_participants = &covetousness_bistros;\r\n xanthochroid_sphenopalatine = &overpained_participants;\r\n furmark_shrier = &xanthochroid_sphenopalatine;\r\n slayable_moorman = &furmark_shrier;\r\n polychromatize_unanemic(deficit_geothlypis,slayable_moorman);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid polychromatize_unanemic(int inharmony_btn,union bastard_typicality **************************************************unresuscitative_beaverwood)\r\n{\r\n int oc_i = 0;\r\n char * data = 0;\r\n char *worrit_thundershower = 0;\r\n ++global_variable;\r\n inharmony_btn--;\r\n if (inharmony_btn > 0) {\r\n polychromatize_unanemic(inharmony_btn,unresuscitative_beaverwood);\r\n return ;\r\n }\r\n worrit_thundershower = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unresuscitative_beaverwood)))))))))))))))))))))))))))))))))))))))))))))))))) . corder_felonwood);\r\n \r\n data = (char*) malloc(8 * sizeof(char));\r\n if (data != NULL) {\r\n \r\n \r\n \r\n \r\n \r\n strncpy(data, worrit_thundershower, strlen(worrit_thundershower) + 1);\r\n for (; oc_i < strlen(data); ++oc_i) {\r\n data[oc_i] = toupper(data[oc_i]);\r\n }\r\n printf(\"%s\\n\", data);\r\n \r\n \r\n free(data);\r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unresuscitative_beaverwood)))))))))))))))))))))))))))))))))))))))))))))))))) . corder_felonwood != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *unresuscitative_beaverwood)))))))))))))))))))))))))))))))))))))))))))))))))) . corder_felonwood));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n strncpy(data, worrit_thundershower, strlen(worrit_thundershower) + 1);\n for (; oc_i < strlen(data); ++oc_i) {\n data[oc_i] = toupper(data[oc_i]);\n }\n printf(\"%s\\n\", data);\n```", "cwe": "805"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "proto_register_ppi(void)\r\r\n{\r\r\n static hf_register_info hf[] = {\r\r\n { &hf_ppi_head_version,\r\r\n { \"Version\", \"ppi.version\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0,\r\r\n \"PPI header format version\", HFILL } },\r\r\n { &hf_ppi_head_flags,\r\r\n { \"Flags\", \"ppi.flags\",\r\r\n FT_UINT8, BASE_HEX, NULL, 0x0,\r\r\n \"PPI header flags\", HFILL } },\r\r\n { &hf_ppi_head_flag_alignment,\r\r\n { \"Alignment\", \"ppi.flags.alignment\",\r\r\n FT_BOOLEAN, 8, TFS(&tfs_ppi_head_flag_alignment), 0x01,\r\r\n \"PPI header flags - 32bit Alignment\", HFILL } },\r\r\n { &hf_ppi_head_flag_reserved,\r\r\n { \"Reserved\", \"ppi.flags.reserved\",\r\r\n FT_UINT8, BASE_HEX, NULL, 0xFE,\r\r\n \"PPI header flags - Reserved Flags\", HFILL } },\r\r\n { &hf_ppi_head_len,\r\r\n { \"Header length\", \"ppi.length\",\r\r\n FT_UINT16, BASE_DEC, NULL, 0x0,\r\r\n \"Length of header including payload\", HFILL } },\r\r\n { &hf_ppi_head_dlt,\r\r\n { \"DLT\", \"ppi.dlt\",\r\r\n FT_UINT32, BASE_DEC, NULL, 0x0, \"libpcap Data Link Type (DLT) of the payload\", HFILL } },\r\r\n\r\r\n { &hf_ppi_field_type,\r\r\n { \"Field type\", \"ppi.field_type\",\r\r\n FT_UINT16, BASE_DEC, VALS(vs_ppi_field_type), 0x0, \"PPI data field type\", HFILL } },\r\r\n { &hf_ppi_field_len,\r\r\n { \"Field length\", \"ppi.field_len\",\r\r\n FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI data field length\", HFILL } },\r\r\n\r\r\n { &hf_80211_common_tsft,\r\r\n { \"TSFT\", \"ppi.80211-common.tsft\",\r\r\n FT_UINT64, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common Timing Synchronization Function Timer (TSFT)\", HFILL } },\r\r\n { &hf_80211_common_flags,\r\r\n { \"Flags\", \"ppi.80211-common.flags\",\r\r\n FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Flags\", HFILL } },\r\r\n { &hf_80211_common_flags_fcs,\r\r\n { \"FCS present flag\", \"ppi.80211-common.flags.fcs\",\r\r\n FT_BOOLEAN, 16, TFS(&tfs_present_absent), DOT11_FLAG_HAVE_FCS, \"PPI 802.11-Common Frame Check Sequence (FCS) Present Flag\", HFILL } },\r\r\n { &hf_80211_common_flags_tsft,\r\r\n { \"TSFT flag\", \"ppi.80211-common.flags.tsft\",\r\r\n FT_BOOLEAN, 16, TFS(&tfs_tsft_ms), DOT11_FLAG_TSF_TIMER_MS, \"PPI 802.11-Common Timing Synchronization Function Timer (TSFT) msec/usec flag\", HFILL } },\r\r\n { &hf_80211_common_flags_fcs_valid,\r\r\n { \"FCS validity\", \"ppi.80211-common.flags.fcs-invalid\",\r\r\n FT_BOOLEAN, 16, TFS(&tfs_invalid_valid), DOT11_FLAG_FCS_INVALID, \"PPI 802.11-Common Frame Check Sequence (FCS) Validity flag\", HFILL } },\r\r\n { &hf_80211_common_flags_phy_err,\r\r\n { \"PHY error flag\", \"ppi.80211-common.flags.phy-err\",\r\r\n FT_BOOLEAN, 16, TFS(&tfs_phy_error), DOT11_FLAG_PHY_ERROR, \"PPI 802.11-Common Physical level (PHY) Error\", HFILL } },\r\r\n { &hf_80211_common_rate,\r\r\n { \"Data rate\", \"ppi.80211-common.rate\",\r\r\n FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common Data Rate (x 500 Kbps)\", HFILL } },\r\r\n { &hf_80211_common_chan_freq,\r\r\n { \"Channel frequency\", \"ppi.80211-common.chan.freq\",\r\r\n FT_UINT16, BASE_DEC, NULL, 0x0,\r\r\n \"PPI 802.11-Common Channel Frequency\", HFILL } },\r\r\n { &hf_80211_common_chan_flags,\r\r\n { \"Channel flags\", \"ppi.80211-common.chan.flags\",\r\r\n FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Channel Flags\", HFILL } },\r\r\n\r\r\n { &hf_80211_common_chan_flags_turbo,\r\r\n { \"Turbo\", \"ppi.80211-common.chan.flags.turbo\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_TURBO, \"PPI 802.11-Common Channel Flags Turbo\", HFILL } },\r\r\n { &hf_80211_common_chan_flags_cck,\r\r\n { \"Complementary Code Keying (CCK)\", \"ppi.80211-common.chan.flags.cck\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_CCK, \"PPI 802.11-Common Channel Flags Complementary Code Keying (CCK) Modulation\", HFILL } },\r\r\n { &hf_80211_common_chan_flags_ofdm,\r\r\n { \"Orthogonal Frequency-Division Multiplexing (OFDM)\", \"ppi.80211-common.chan.flags.ofdm\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_OFDM, \"PPI 802.11-Common Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)\", HFILL } },\r\r\n { &hf_80211_common_chan_flags_2ghz,\r\r\n { \"2 GHz spectrum\", \"ppi.80211-common.chan.flags.2ghz\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_2GHZ, \"PPI 802.11-Common Channel Flags 2 GHz spectrum\", HFILL } },\r\r\n { &hf_80211_common_chan_flags_5ghz,\r\r\n { \"5 GHz spectrum\", \"ppi.80211-common.chan.flags.5ghz\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_5GHZ, \"PPI 802.11-Common Channel Flags 5 GHz spectrum\", HFILL } },\r\r\n { &hf_80211_common_chan_flags_passive,\r\r\n { \"Passive\", \"ppi.80211-common.chan.flags.passive\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_PASSIVE, \"PPI 802.11-Common Channel Flags Passive\", HFILL } },\r\r\n { &hf_80211_common_chan_flags_dynamic,\r\r\n { \"Dynamic CCK-OFDM\", \"ppi.80211-common.chan.flags.dynamic\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_DYN, \"PPI 802.11-Common Channel Flags Dynamic CCK-OFDM Channel\", HFILL } },\r\r\n { &hf_80211_common_chan_flags_gfsk,\r\r\n { \"Gaussian Frequency Shift Keying (GFSK)\", \"ppi.80211-common.chan.flags.gfsk\",\r\r\n FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_GFSK, \"PPI 802.11-Common Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation\", HFILL } },\r\r\n\r\r\n { &hf_80211_common_fhss_hopset,\r\r\n { \"FHSS hopset\", \"ppi.80211-common.fhss.hopset\",\r\r\n FT_UINT8, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Hopset\", HFILL } },\r\r\n { &hf_80211_common_fhss_pattern,\r\r\n { \"FHSS pattern\", \"ppi.80211-common.fhss.pattern\",\r\r\n FT_UINT8, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Pattern\", HFILL } },\r\r\n { &hf_80211_common_dbm_antsignal,\r\r\n { \"dBm antenna signal\", \"ppi.80211-common.dbm.antsignal\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common dBm Antenna Signal\", HFILL } },\r\r\n { &hf_80211_common_dbm_antnoise,\r\r\n { \"dBm antenna noise\", \"ppi.80211-common.dbm.antnoise\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common dBm Antenna Noise\", HFILL } },\r\r\n\r\r\n /* 802.11n MAC */\r\r\n { &hf_80211n_mac_flags,\r\r\n { \"MAC flags\", \"ppi.80211n-mac.flags\",\r\r\n FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC flags\", HFILL } },\r\r\n { &hf_80211n_mac_flags_greenfield,\r\r\n { \"Greenfield flag\", \"ppi.80211n-mac.flags.greenfield\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_GREENFIELD, \"PPI 802.11n MAC Greenfield Flag\", HFILL } },\r\r\n { &hf_80211n_mac_flags_ht20_40,\r\r\n { \"HT20/HT40 flag\", \"ppi.80211n-mac.flags.ht20_40\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_ht20_40), DOT11N_FLAG_HT40, \"PPI 802.11n MAC HT20/HT40 Flag\", HFILL } },\r\r\n { &hf_80211n_mac_flags_rx_guard_interval,\r\r\n { \"RX Short Guard Interval (SGI) flag\", \"ppi.80211n-mac.flags.rx.short_guard_interval\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_SHORT_GI, \"PPI 802.11n MAC RX Short Guard Interval (SGI) Flag\", HFILL } },\r\r\n { &hf_80211n_mac_flags_duplicate_rx,\r\r\n { \"Duplicate RX flag\", \"ppi.80211n-mac.flags.rx.duplicate\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_DUPLICATE_RX, \"PPI 802.11n MAC Duplicate RX Flag\", HFILL } },\r\r\n { &hf_80211n_mac_flags_aggregate,\r\r\n { \"Aggregate flag\", \"ppi.80211n-mac.flags.agg\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_IS_AGGREGATE, \"PPI 802.11 MAC Aggregate Flag\", HFILL } },\r\r\n { &hf_80211n_mac_flags_more_aggregates,\r\r\n { \"More aggregates flag\", \"ppi.80211n-mac.flags.more_agg\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_MORE_AGGREGATES, \"PPI 802.11n MAC More Aggregates Flag\", HFILL } },\r\r\n { &hf_80211n_mac_flags_delimiter_crc_after,\r\r\n { \"A-MPDU Delimiter CRC error after this frame flag\", \"ppi.80211n-mac.flags.delim_crc_error_after\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_AGG_CRC_ERROR, \"PPI 802.11n MAC A-MPDU Delimiter CRC Error After This Frame Flag\", HFILL } },\r\r\n { &hf_80211n_mac_ampdu_id,\r\r\n { \"AMPDU-ID\", \"ppi.80211n-mac.ampdu_id\",\r\r\n FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC AMPDU-ID\", HFILL } },\r\r\n { &hf_80211n_mac_num_delimiters,\r\r\n { \"Num-Delimiters\", \"ppi.80211n-mac.num_delimiters\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC number of zero-length pad delimiters\", HFILL } },\r\r\n { &hf_80211n_mac_reserved,\r\r\n { \"Reserved\", \"ppi.80211n-mac.reserved\",\r\r\n FT_UINT24, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC Reserved\", HFILL } },\r\r\n\r\r\n\r\r\n /* 802.11n MAC+PHY */\r\r\n { &hf_80211n_mac_phy_mcs,\r\r\n { \"MCS\", \"ppi.80211n-mac-phy.mcs\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Modulation Coding Scheme (MCS)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_num_streams,\r\r\n { \"Number of spatial streams\", \"ppi.80211n-mac-phy.num_streams\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY number of spatial streams\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_combined,\r\r\n { \"RSSI combined\", \"ppi.80211n-mac-phy.rssi.combined\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Received Signal Strength Indication (RSSI) Combined\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant0_ctl,\r\r\n { \"Antenna 0 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant0ctl\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 0 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant1_ctl,\r\r\n { \"Antenna 1 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant1ctl\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 1 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant2_ctl,\r\r\n { \"Antenna 2 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant2ctl\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 2 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant3_ctl,\r\r\n { \"Antenna 3 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant3ctl\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 3 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant0_ext,\r\r\n { \"Antenna 0 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant0ext\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 0 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant1_ext,\r\r\n { \"Antenna 1 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant1ext\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 1 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant2_ext,\r\r\n { \"Antenna 2 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant2ext\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 2 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_rssi_ant3_ext,\r\r\n { \"Antenna 3 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant3ext\",\r\r\n FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 3 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_freq,\r\r\n { \"Extended channel frequency\", \"ppi.80211-mac-phy.ext-chan.freq\",\r\r\n FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Extended Channel Frequency\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags,\r\r\n { \"Channel flags\", \"ppi.80211-mac-phy.ext-chan.flags\",\r\r\n FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC+PHY Channel Flags\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_turbo,\r\r\n { \"Turbo\", \"ppi.80211-mac-phy.ext-chan.flags.turbo\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0010, \"PPI 802.11n MAC+PHY Channel Flags Turbo\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_cck,\r\r\n { \"Complementary Code Keying (CCK)\", \"ppi.80211-mac-phy.ext-chan.flags.cck\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0020, \"PPI 802.11n MAC+PHY Channel Flags Complementary Code Keying (CCK) Modulation\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_ofdm,\r\r\n { \"Orthogonal Frequency-Division Multiplexing (OFDM)\", \"ppi.80211-mac-phy.ext-chan.flags.ofdm\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0040, \"PPI 802.11n MAC+PHY Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_2ghz,\r\r\n { \"2 GHz spectrum\", \"ppi.80211-mac-phy.ext-chan.flags.2ghz\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0080, \"PPI 802.11n MAC+PHY Channel Flags 2 GHz spectrum\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_5ghz,\r\r\n { \"5 GHz spectrum\", \"ppi.80211-mac-phy.ext-chan.flags.5ghz\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0100, \"PPI 802.11n MAC+PHY Channel Flags 5 GHz spectrum\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_passive,\r\r\n { \"Passive\", \"ppi.80211-mac-phy.ext-chan.flags.passive\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0200, \"PPI 802.11n MAC+PHY Channel Flags Passive\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_dynamic,\r\r\n { \"Dynamic CCK-OFDM\", \"ppi.80211-mac-phy.ext-chan.flags.dynamic\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0400, \"PPI 802.11n MAC+PHY Channel Flags Dynamic CCK-OFDM Channel\", HFILL } },\r\r\n { &hf_80211n_mac_phy_ext_chan_flags_gfsk,\r\r\n { \"Gaussian Frequency Shift Keying (GFSK)\", \"ppi.80211-mac-phy.ext-chan.flags.gfsk\",\r\r\n FT_BOOLEAN, 16, NULL, 0x0800, \"PPI 802.11n MAC+PHY Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant0signal,\r\r\n { \"dBm antenna 0 signal\", \"ppi.80211n-mac-phy.dbmant0.signal\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 0 Signal\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant0noise,\r\r\n { \"dBm antenna 0 noise\", \"ppi.80211n-mac-phy.dbmant0.noise\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 0 Noise\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant1signal,\r\r\n { \"dBm antenna 1 signal\", \"ppi.80211n-mac-phy.dbmant1.signal\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 1 Signal\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant1noise,\r\r\n { \"dBm antenna 1 noise\", \"ppi.80211n-mac-phy.dbmant1.noise\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 1 Noise\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant2signal,\r\r\n { \"dBm antenna 2 signal\", \"ppi.80211n-mac-phy.dbmant2.signal\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 2 Signal\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant2noise,\r\r\n { \"dBm antenna 2 noise\", \"ppi.80211n-mac-phy.dbmant2.noise\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 2 Noise\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant3signal,\r\r\n { \"dBm antenna 3 signal\", \"ppi.80211n-mac-phy.dbmant3.signal\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 3 Signal\", HFILL } },\r\r\n { &hf_80211n_mac_phy_dbm_ant3noise,\r\r\n { \"dBm antenna 3 noise\", \"ppi.80211n-mac-phy.dbmant3.noise\",\r\r\n FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 3 Noise\", HFILL } },\r\r\n { &hf_80211n_mac_phy_evm0,\r\r\n { \"EVM-0\", \"ppi.80211n-mac-phy.evm0\",\r\r\n FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 0\", HFILL } },\r\r\n { &hf_80211n_mac_phy_evm1,\r\r\n { \"EVM-1\", \"ppi.80211n-mac-phy.evm1\",\r\r\n FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 1\", HFILL } },\r\r\n { &hf_80211n_mac_phy_evm2,\r\r\n { \"EVM-2\", \"ppi.80211n-mac-phy.evm2\",\r\r\n FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 2\", HFILL } },\r\r\n { &hf_80211n_mac_phy_evm3,\r\r\n { \"EVM-3\", \"ppi.80211n-mac-phy.evm3\",\r\r\n FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 3\", HFILL } },\r\r\n\r\r\n { &hf_ampdu_segment,\r\r\n { \"A-MPDU\", \"ppi.80211n-mac.ampdu\",\r\r\n FT_FRAMENUM, BASE_NONE, NULL, 0x0, \"802.11n Aggregated MAC Protocol Data Unit (A-MPDU)\", HFILL }},\r\r\n#if 0\r\r\n { &hf_ampdu_segments,\r\r\n { \"Reassembled A-MPDU\", \"ppi.80211n-mac.ampdu.reassembled\",\r\r\n FT_NONE, BASE_NONE, NULL, 0x0, \"Reassembled Aggregated MAC Protocol Data Unit (A-MPDU)\", HFILL }},\r\r\n#endif\r\r\n { &hf_ampdu_reassembled_in,\r\r\n { \"Reassembled A-MPDU in frame\", \"ppi.80211n-mac.ampdu.reassembled_in\",\r\r\n FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\r\n \"The A-MPDU that doesn't end in this segment is reassembled in this frame\",\r\r\n HFILL }},\r\r\n { &hf_ampdu_count,\r\r\n { \"MPDU count\", \"ppi.80211n-mac.ampdu.count\",\r\r\n FT_UINT16, BASE_DEC, NULL, 0x0, \"The number of aggregated MAC Protocol Data Units (MPDUs)\", HFILL }},\r\r\n\r\r\n { &hf_spectrum_map,\r\r\n { \"Radio spectrum map\", \"ppi.spectrum-map\",\r\r\n FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Radio spectrum map\", HFILL } },\r\r\n { &hf_process_info,\r\r\n { \"Process information\", \"ppi.proc-info\",\r\r\n FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Process information\", HFILL } },\r\r\n { &hf_capture_info,\r\r\n { \"Capture information\", \"ppi.cap-info\",\r\r\n FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Capture information\", HFILL } },\r\r\n\r\r\n /* Aggregtion Extension */\r\r\n { &hf_aggregation_extension_interface_id,\r\r\n { \"Interface ID\", \"ppi.aggregation_extension.interface_id\",\r\r\n FT_UINT32, BASE_DEC, NULL, 0x0, \"Zero-based index of the physical interface the packet was captured from\", HFILL } },\r\r\n\r\r\n /* 802.3 Extension */\r\r\n { &hf_8023_extension_flags,\r\r\n { \"Flags\", \"ppi.8023_extension.flags\",\r\r\n FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.3 Extension Flags\", HFILL } },\r\r\n { &hf_8023_extension_flags_fcs_present,\r\r\n { \"FCS Present Flag\", \"ppi.8023_extension.flags.fcs_present\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0001, \"FCS (4 bytes) is present at the end of the packet\", HFILL } },\r\r\n { &hf_8023_extension_errors,\r\r\n { \"Errors\", \"ppi.8023_extension.errors\",\r\r\n FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.3 Extension Errors\", HFILL } },\r\r\n { &hf_8023_extension_errors_fcs,\r\r\n { \"FCS Error\", \"ppi.8023_extension.errors.fcs\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0001,\r\r\n \"PPI 802.3 Extension FCS Error\", HFILL } },\r\r\n { &hf_8023_extension_errors_sequence,\r\r\n { \"Sequence Error\", \"ppi.8023_extension.errors.sequence\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0002,\r\r\n \"PPI 802.3 Extension Sequence Error\", HFILL } },\r\r\n { &hf_8023_extension_errors_symbol,\r\r\n { \"Symbol Error\", \"ppi.8023_extension.errors.symbol\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0004,\r\r\n \"PPI 802.3 Extension Symbol Error\", HFILL } },\r\r\n { &hf_8023_extension_errors_data,\r\r\n { \"Data Error\", \"ppi.8023_extension.errors.data\",\r\r\n FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0008,\r\r\n \"PPI 802.3 Extension Data Error\", HFILL } },\r\r\n\r\r\n /* Generated from convert_proto_tree_add_text.pl */\r\r\n { &hf_ppi_gps, { \"GPS\", \"ppi.gps\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\r\n { &hf_ppi_vector, { \"VECTOR\", \"ppi.vector\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\r\n { &hf_ppi_harris, { \"HARRIS\", \"ppi.harris\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\r\n { &hf_ppi_antenna, { \"ANTENNA\", \"ppi.antenna\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\r\n { &hf_ppi_fnet, { \"FNET\", \"ppi.fnet\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\r\n { &hf_ppi_reserved, { \"Reserved\", \"ppi.reserved\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\r\n };\r\r\n\r\r\n static gint *ett[] = {\r\r\n &ett_ppi_pph,\r\r\n &ett_ppi_flags,\r\r\n &ett_dot11_common,\r\r\n &ett_dot11_common_flags,\r\r\n &ett_dot11_common_channel_flags,\r\r\n &ett_dot11n_mac,\r\r\n &ett_dot11n_mac_flags,\r\r\n &ett_dot11n_mac_phy,\r\r\n &ett_dot11n_mac_phy_ext_channel_flags,\r\r\n &ett_ampdu_segments,\r\r\n &ett_ampdu,\r\r\n &ett_ampdu_segment,\r\r\n &ett_aggregation_extension,\r\r\n &ett_8023_extension,\r\r\n &ett_8023_extension_flags,\r\r\n &ett_8023_extension_errors\r\r\n };\r\r\n\r\r\n static ei_register_info ei[] = {\r\r\n { &ei_ppi_invalid_length, { \"ppi.invalid_length\", PI_MALFORMED, PI_ERROR, \"Invalid length\", EXPFILL }},\r\r\n };\r\r\n\r\r\n module_t *ppi_module;\r\r\n expert_module_t* expert_ppi;\r\r\n\r\r\n proto_ppi = proto_register_protocol(\"PPI Packet Header\", \"PPI\", \"ppi\");\r\r\n proto_register_field_array(proto_ppi, hf, array_length(hf));\r\r\n proto_register_subtree_array(ett, array_length(ett));\r\r\n expert_ppi = expert_register_protocol(proto_ppi);\r\r\n expert_register_field_array(expert_ppi, ei, array_length(ei));\r\r\n\r\r\n ppi_handle = register_dissector(\"ppi\", dissect_ppi, proto_ppi);\r\r\n\r\r\n register_init_routine(ampdu_reassemble_init);\r\r\n register_cleanup_routine(ampdu_reassemble_cleanup);\r\r\n\r\r\n /* Configuration options */\r\r\n ppi_module = prefs_register_protocol(proto_ppi, NULL);\r\r\n prefs_register_bool_preference(ppi_module, \"reassemble\",\r\r\n \"Reassemble fragmented 802.11 A-MPDUs\",\r\r\n \"Whether fragmented 802.11 aggregated MPDUs should be reassembled\",\r\r\n &ppi_ampdu_reassemble);\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint meridel_berskin = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid cleanup(FILE **ptrs,int size)\r\n{\r\n int i = 0;\r\n \r\n for (i = 0; i < size; i++) {\r\n if (ptrs[i] != 0) {\r\n fclose(ptrs[i]);\r\n }\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[10];\r\n char filename[80];\r\n char *sweetkins_ischar = 0;\r\n int unenshrined_spearman;\r\n void **anamnesis_cantboard = 0;\r\n void **usrc_sigrim = 0;\r\n void *elaterometer_nonaccentually = 0;\r\n char *gargler_waukesha;;\r\n if (__sync_bool_compare_and_swap(&meridel_berskin,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&gargler_waukesha,\"ETYMA_POLYSYMMETRICAL\");\r\n if (gargler_waukesha != 0) {;\r\n elaterometer_nonaccentually = ((void *)gargler_waukesha);\r\n unenshrined_spearman = 1;\r\n anamnesis_cantboard = &elaterometer_nonaccentually;\r\n usrc_sigrim = ((void **)(((unsigned long )anamnesis_cantboard) * unenshrined_spearman * unenshrined_spearman)) + 5;\r\n sweetkins_ischar = ((char *)((char *)( *(usrc_sigrim - 5))));\r\n \r\n files = fopen(sweetkins_ischar,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0) {\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n }\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi % 10] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n if (files != 0)\r\n fclose(files);\r\n cleanup(file_list, ((ssi-1)%10)+1);\r\n \r\n;\r\n if (((char *)( *(usrc_sigrim - 5))) != 0) \r\n free(((char *)((char *)( *(usrc_sigrim - 5)))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0) {\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n }\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi % 10] = file;\n ssi++;\n }\n```", "cwe": "773"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint mike_vitalness = 0;\r\nint global_variable;\r\nvoid handle_taint(char *agpaite_admedian);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nint 191_global_var = 0;\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&mike_vitalness,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid handle_taint(char *agpaite_admedian)\r\n{\r\n FILE * random_data = 0;\r\n char * buff = 0;\r\n unsigned long long num = 0;\r\n unsigned long long i = 0;\r\n char *punniest_caye = 0;\r\n char *impunely_sheldfowl = 0;\r\n int *parietales_nucleoloid = 0;\r\n int brett_microbus;\r\n char *shamer_whitepost[10] = {0};\r\n int toprope_corruptible = 0;\r\n char *orchestra_refrangibleness = 0;\r\n ++global_variable;;\r\n if (agpaite_admedian != 0) {;\r\n toprope_corruptible = ((int )(strlen(agpaite_admedian)));\r\n orchestra_refrangibleness = ((char *)(malloc(toprope_corruptible + 1)));\r\n if (orchestra_refrangibleness == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(orchestra_refrangibleness,0,toprope_corruptible + 1);\r\n memcpy(orchestra_refrangibleness,agpaite_admedian,toprope_corruptible);\r\n if (agpaite_admedian != 0) \r\n free(((char *)agpaite_admedian));\r\n brett_microbus = 5;\r\n parietales_nucleoloid = &brett_microbus;\r\n shamer_whitepost[ *parietales_nucleoloid] = orchestra_refrangibleness;\r\n impunely_sheldfowl = shamer_whitepost[ *parietales_nucleoloid];\r\n punniest_caye = ((char *)impunely_sheldfowl);\r\n \r\n random_data = fopen(\"/dev/urandom\", \"r\");\r\n if(random_data != NULL){\r\n num = strtoull(punniest_caye, NULL, 10);\r\n if(num > (unsigned long long) 0 ){\r\n if(num > (unsigned long long) 100 ){\r\n num = (unsigned long long) 100;\r\n }\r\n \r\n \r\n \r\n \r\n \r\n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\r\n for(i = 0; i < num - (unsigned long long) 10; i++){\r\n buff[i] = fgetc(random_data);\r\n }\r\n \r\n \r\n }\r\n printf(\"data is: %s\", buff);\r\n fclose(random_data);\r\n if(buff != NULL){\r\n free(buff);\r\n }\r\n }\r\n \r\n;\r\n if (impunely_sheldfowl != 0) \r\n free(((char *)impunely_sheldfowl));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n for(i = 0; i < num - (unsigned long long) 10; i++){\n buff[i] = fgetc(random_data);\n }\n```", "cwe": "191"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include <setjmp.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <time.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint matfellon_potestative = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n char *result = 0;\r\n int random_int = 0;\r\n char *donnelsville_demipesade = 0;\r\n jmp_buf philodendra_choller;\r\n int bracey_wettable;\r\n char **appendicularian_dysgenical = 0;\r\n char **khedivial_matlo = 0;\r\n int trapstick_unexaggerating = 0;\r\n char *karole_adhering = 0;\r\n char *coalesces_nonahydrate;;\r\n if (__sync_bool_compare_and_swap(&matfellon_potestative,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n coalesces_nonahydrate = getenv(\"CHORISOS_DERMATOGRAPHY\");\r\n if (coalesces_nonahydrate != 0) {;\r\n trapstick_unexaggerating = ((int )(strlen(coalesces_nonahydrate)));\r\n karole_adhering = ((char *)(malloc(trapstick_unexaggerating + 1)));\r\n if (karole_adhering == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(karole_adhering,0,trapstick_unexaggerating + 1);\r\n memcpy(karole_adhering,coalesces_nonahydrate,trapstick_unexaggerating);\r\n appendicularian_dysgenical = &karole_adhering;\r\n khedivial_matlo = appendicularian_dysgenical + 5;\r\n bracey_wettable = setjmp(philodendra_choller);\r\n if (bracey_wettable == 0) {\r\n longjmp(philodendra_choller,1);\r\n }\r\n donnelsville_demipesade = ((char *)( *(khedivial_matlo - 5)));\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, donnelsville_demipesade);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\r\n \r\n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n result = PQcmdTuples(res);\r\n printf(\"Query OK, %s rows affected\\n\",result);\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\n if ( *(khedivial_matlo - 5) != 0) \r\n free(((char *)( *(khedivial_matlo - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n res = PQexec(conn,query);\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n \n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n PQclear(res);\n PQfinish(conn);\n exit(1);\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint dacryohelcosis_mashgiach = 0;\r\nint global_variable;\r\n\r\nunion michaux_kindergartens \r\n{\r\n char *hyperdulia_faithwise;\r\n double dehumidifies_orbate;\r\n char *sulfamyl_levered;\r\n char otha_anthelix;\r\n int parabasis_larree;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *churchton_predivinable = 0;\r\n union michaux_kindergartens **************************************************rinka_squilgee = 0;\r\n union michaux_kindergartens *************************************************jalousie_talipat = 0;\r\n union michaux_kindergartens ************************************************eleoptene_unwassailing = 0;\r\n union michaux_kindergartens ***********************************************lyssa_dysergia = 0;\r\n union michaux_kindergartens **********************************************allegoriser_defaces = 0;\r\n union michaux_kindergartens *********************************************kakistocracy_relucts = 0;\r\n union michaux_kindergartens ********************************************radiatics_psychostatical = 0;\r\n union michaux_kindergartens *******************************************neuropod_musket = 0;\r\n union michaux_kindergartens ******************************************clonorchiasis_salicylanilide = 0;\r\n union michaux_kindergartens *****************************************enfoncee_guarache = 0;\r\n union michaux_kindergartens ****************************************architricline_cuerpo = 0;\r\n union michaux_kindergartens ***************************************talliating_oneiroscopist = 0;\r\n union michaux_kindergartens **************************************southings_glamourization = 0;\r\n union michaux_kindergartens *************************************connotes_proportionless = 0;\r\n union michaux_kindergartens ************************************illiteracy_apocentre = 0;\r\n union michaux_kindergartens ***********************************quality_pourboires = 0;\r\n union michaux_kindergartens **********************************eldon_zigzagways = 0;\r\n union michaux_kindergartens *********************************unextended_shoq = 0;\r\n union michaux_kindergartens ********************************unamused_unsailed = 0;\r\n union michaux_kindergartens *******************************regalvanization_rosita = 0;\r\n union michaux_kindergartens ******************************overprotected_priacanthid = 0;\r\n union michaux_kindergartens *****************************laryngopharynx_sepiidae = 0;\r\n union michaux_kindergartens ****************************enologist_limites = 0;\r\n union michaux_kindergartens ***************************apozemical_uselessly = 0;\r\n union michaux_kindergartens **************************preferredness_bradyuria = 0;\r\n union michaux_kindergartens *************************superalkalinity_sped = 0;\r\n union michaux_kindergartens ************************eighteens_defension = 0;\r\n union michaux_kindergartens ***********************guenons_overeate = 0;\r\n union michaux_kindergartens **********************eromania_erf = 0;\r\n union michaux_kindergartens *********************triumviry_nonlubricating = 0;\r\n union michaux_kindergartens ********************fatefulness_jaculate = 0;\r\n union michaux_kindergartens *******************unremovable_soundproofed = 0;\r\n union michaux_kindergartens ******************drunkennesses_maternally = 0;\r\n union michaux_kindergartens *****************malikite_indone = 0;\r\n union michaux_kindergartens ****************sputum_dispensatory = 0;\r\n union michaux_kindergartens ***************cancellated_scimitared = 0;\r\n union michaux_kindergartens **************anconad_supplementer = 0;\r\n union michaux_kindergartens *************unreformedness_omphaloncus = 0;\r\n union michaux_kindergartens ************cesure_openheartedness = 0;\r\n union michaux_kindergartens ***********overdesirous_unfairer = 0;\r\n union michaux_kindergartens **********compulse_coproduction = 0;\r\n union michaux_kindergartens *********ville_bitterer = 0;\r\n union michaux_kindergartens ********bemuzzling_coprophagist = 0;\r\n union michaux_kindergartens *******maliceproof_calabrese = 0;\r\n union michaux_kindergartens ******nonreplicate_unfeued = 0;\r\n union michaux_kindergartens *****groof_thock = 0;\r\n union michaux_kindergartens ****silversmithing_deescalating = 0;\r\n union michaux_kindergartens ***dyophysitism_dubhe = 0;\r\n union michaux_kindergartens **bivouacked_absoluteness = 0;\r\n union michaux_kindergartens *donnelly_comforter = 0;\r\n union michaux_kindergartens anodynia_unacceptant = {0};\r\n union michaux_kindergartens endenization_conquerableness;\r\n char *polysyllabical_strawiest;;\r\n if (__sync_bool_compare_and_swap(&dacryohelcosis_mashgiach,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&polysyllabical_strawiest,\"EXTRADITING_COTATI\");\r\n if (polysyllabical_strawiest != 0) {;\r\n endenization_conquerableness . hyperdulia_faithwise = polysyllabical_strawiest;\r\n donnelly_comforter = &endenization_conquerableness;\r\n bivouacked_absoluteness = &donnelly_comforter;\r\n dyophysitism_dubhe = &bivouacked_absoluteness;\r\n silversmithing_deescalating = &dyophysitism_dubhe;\r\n groof_thock = &silversmithing_deescalating;\r\n nonreplicate_unfeued = &groof_thock;\r\n maliceproof_calabrese = &nonreplicate_unfeued;\r\n bemuzzling_coprophagist = &maliceproof_calabrese;\r\n ville_bitterer = &bemuzzling_coprophagist;\r\n compulse_coproduction = &ville_bitterer;\r\n overdesirous_unfairer = &compulse_coproduction;\r\n cesure_openheartedness = &overdesirous_unfairer;\r\n unreformedness_omphaloncus = &cesure_openheartedness;\r\n anconad_supplementer = &unreformedness_omphaloncus;\r\n cancellated_scimitared = &anconad_supplementer;\r\n sputum_dispensatory = &cancellated_scimitared;\r\n malikite_indone = &sputum_dispensatory;\r\n drunkennesses_maternally = &malikite_indone;\r\n unremovable_soundproofed = &drunkennesses_maternally;\r\n fatefulness_jaculate = &unremovable_soundproofed;\r\n triumviry_nonlubricating = &fatefulness_jaculate;\r\n eromania_erf = &triumviry_nonlubricating;\r\n guenons_overeate = &eromania_erf;\r\n eighteens_defension = &guenons_overeate;\r\n superalkalinity_sped = &eighteens_defension;\r\n preferredness_bradyuria = &superalkalinity_sped;\r\n apozemical_uselessly = &preferredness_bradyuria;\r\n enologist_limites = &apozemical_uselessly;\r\n laryngopharynx_sepiidae = &enologist_limites;\r\n overprotected_priacanthid = &laryngopharynx_sepiidae;\r\n regalvanization_rosita = &overprotected_priacanthid;\r\n unamused_unsailed = &regalvanization_rosita;\r\n unextended_shoq = &unamused_unsailed;\r\n eldon_zigzagways = &unextended_shoq;\r\n quality_pourboires = &eldon_zigzagways;\r\n illiteracy_apocentre = &quality_pourboires;\r\n connotes_proportionless = &illiteracy_apocentre;\r\n southings_glamourization = &connotes_proportionless;\r\n talliating_oneiroscopist = &southings_glamourization;\r\n architricline_cuerpo = &talliating_oneiroscopist;\r\n enfoncee_guarache = &architricline_cuerpo;\r\n clonorchiasis_salicylanilide = &enfoncee_guarache;\r\n neuropod_musket = &clonorchiasis_salicylanilide;\r\n radiatics_psychostatical = &neuropod_musket;\r\n kakistocracy_relucts = &radiatics_psychostatical;\r\n allegoriser_defaces = &kakistocracy_relucts;\r\n lyssa_dysergia = &allegoriser_defaces;\r\n eleoptene_unwassailing = &lyssa_dysergia;\r\n jalousie_talipat = &eleoptene_unwassailing;\r\n rinka_squilgee = &jalousie_talipat;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise != 0) {\r\n goto suggesta_benames;\r\n }\r\n ++global_variable;\r\n suggesta_benames:;\r\n churchton_predivinable = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(churchton_predivinable); ++i) {\r\n if (churchton_predivinable[i] == ';') {\r\n if (i == 0 || churchton_predivinable[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,churchton_predivinable);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *rinka_squilgee)))))))))))))))))))))))))))))))))))))))))))))))))) . hyperdulia_faithwise));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint clava_hepatotoxicity = 0;\r\nint global_variable;\r\nvoid handle_taint(char *decorticate_respondendum);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid hoorahs_oversick(char **huxtable_bioclimatician);\r\nchar process_buffer(char *buffer_param)\r\n{\r\n \r\n char first_char;\r\n first_char = buffer_param[0] - 97;\r\n free(buffer_param);\r\n return first_char;\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{;\r\n if (__sync_bool_compare_and_swap(&clava_hepatotoxicity,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n#define WORKUP_GNARLING(x) hoorahs_oversick((char **) x)\r\n\r\nvoid handle_taint(char *decorticate_respondendum)\r\n{\r\n int sermoniser_nonylene;\r\n char **telexed_defension = 0;\r\n char **daphnephoria_balaniferous = 0;\r\n int istanbul_sops = 0;\r\n char *quantitively_pardner = 0;\r\n ++global_variable;;\r\n if (decorticate_respondendum != 0) {;\r\n istanbul_sops = ((int )(strlen(decorticate_respondendum)));\r\n quantitively_pardner = ((char *)(malloc(istanbul_sops + 1)));\r\n if (quantitively_pardner == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(quantitively_pardner,0,istanbul_sops + 1);\r\n memcpy(quantitively_pardner,decorticate_respondendum,istanbul_sops);\r\n if (decorticate_respondendum != 0) \r\n free(((char *)decorticate_respondendum));\r\n sermoniser_nonylene = 1;\r\n telexed_defension = &quantitively_pardner;\r\n daphnephoria_balaniferous = ((char **)(((unsigned long )telexed_defension) * sermoniser_nonylene * sermoniser_nonylene)) + 5;\r\n\tWORKUP_GNARLING(daphnephoria_balaniferous);\r\n }\r\n}\r\n\r\nvoid hoorahs_oversick(char **huxtable_bioclimatician)\r\n{\r\n int oc_i = 0;\r\n int tainted_len;\r\n char **buffer_ptr = 0;\r\n int main_first_char = 0;\r\n int buffer_len;\r\n char *buffer = 0;\r\n char *timothies_demeanor = 0;\r\n ++global_variable;;\r\n timothies_demeanor = ((char *)( *(huxtable_bioclimatician - 5)));\r\n \r\n buffer_len = 4;\r\n buffer = malloc(65528);\r\n if (buffer != NULL) {\r\n strncpy(buffer, timothies_demeanor, buffer_len);\r\n buffer[buffer_len - 1] = 0;\r\n printf(\"%s\\n\", buffer);\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n if (buffer[0] >= 97) {\r\n \r\n main_first_char = process_buffer(buffer);\r\n }\r\n \r\n buffer_ptr = malloc(65528);\r\n \r\n if (buffer_ptr != NULL) {\r\n *buffer_ptr = timothies_demeanor;\r\n \r\n \r\n \r\n \r\n \r\n strncpy(buffer, timothies_demeanor, buffer_len);\r\n buffer[buffer_len - 1] = '\\0';\r\n tainted_len = strlen( *buffer_ptr); \r\n \r\n printf(\"%c\\n\", main_first_char);\r\n for (; oc_i < buffer_len; ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\", buffer);\r\n if (main_first_char == 0) {\r\n if (buffer != 0) {\r\n free(buffer);\r\n }\r\n }\r\n if (buffer_ptr != 0) {\r\n free(buffer_ptr);\r\n }\r\n }\r\n }\r\n \r\n;\r\n if ( *(huxtable_bioclimatician - 5) != 0) \r\n free(((char *)( *(huxtable_bioclimatician - 5))));\r\nclose_printf_context();\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n strncpy(buffer, timothies_demeanor, buffer_len);\n buffer[buffer_len - 1] = '\\0';\n tainted_len = strlen( *buffer_ptr); \n```", "cwe": "416"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint unimped_who = 0;\r\nint global_variable;\r\n\r\nunion chevise_furtwler \r\n{\r\n char *nondetailed_micrography;\r\n double entocnemial_scotograph;\r\n char *neurochitin_marled;\r\n char vivacity_penalosa;\r\n int talker_locale;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid yamshik_qabbala(int interior_mythmaker,union chevise_furtwler costectomies_padge);\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n int outfieldsmen_undefiledly = 7;\r\n union chevise_furtwler hyracothere_attain = {0};\r\n int **********trisoctahedral_uncunning = 0;\r\n int *********tipstock_ignatia = 0;\r\n int ********taeniform_rinaldo = 0;\r\n int *******omnipresently_spatterware = 0;\r\n int ******ceratiidae_nathanil = 0;\r\n int *****saponification_ominously = 0;\r\n int ****pocono_colubrina = 0;\r\n int ***occidentalised_sokul = 0;\r\n int **unepicurean_extenders = 0;\r\n int *arctician_tableaus = 0;\r\n int amberoid_unnymphal;\r\n union chevise_furtwler rememberability_cosing[10] = {0};\r\n union chevise_furtwler recurved_unoverpowered;\r\n char *unimplicated_properdin;;\r\n if (__sync_bool_compare_and_swap(&unimped_who,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n unimplicated_properdin = getenv(\"LYNDE_PHONOGRAPHS\");\r\n if (unimplicated_properdin != 0) {;\r\n recurved_unoverpowered . nondetailed_micrography = unimplicated_properdin;\r\n amberoid_unnymphal = 5;\r\n arctician_tableaus = &amberoid_unnymphal;\r\n unepicurean_extenders = &arctician_tableaus;\r\n occidentalised_sokul = &unepicurean_extenders;\r\n pocono_colubrina = &occidentalised_sokul;\r\n saponification_ominously = &pocono_colubrina;\r\n ceratiidae_nathanil = &saponification_ominously;\r\n omnipresently_spatterware = &ceratiidae_nathanil;\r\n taeniform_rinaldo = &omnipresently_spatterware;\r\n tipstock_ignatia = &taeniform_rinaldo;\r\n trisoctahedral_uncunning = &tipstock_ignatia;\r\n rememberability_cosing[ *( *( *( *( *( *( *( *( *( *trisoctahedral_uncunning)))))))))] = recurved_unoverpowered;\r\n hyracothere_attain = rememberability_cosing[ *( *( *( *( *( *( *( *( *( *trisoctahedral_uncunning)))))))))];\r\n yamshik_qabbala(outfieldsmen_undefiledly,hyracothere_attain);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lmysqlclient -lssl -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid yamshik_qabbala(int interior_mythmaker,union chevise_furtwler costectomies_padge)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *cornuting_prefocussed = 0;\r\n ++global_variable;\r\n interior_mythmaker--;\r\n if (interior_mythmaker > 0) {\r\n yamshik_qabbala(interior_mythmaker,costectomies_padge);\r\n return ;\r\n }\r\n cornuting_prefocussed = ((char *)costectomies_padge . nondetailed_micrography);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",cornuting_prefocussed);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint apemantus_hocused = 0;\r\n\r\nunion tarrie_valorising \r\n{\r\n char *tolus_shucking;\r\n double gwenny_halogenation;\r\n char *tautens_auerbach;\r\n char autocopist_cleavages;\r\n int irishized_palecek;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *phantasmagories_wordcraft);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nunion tarrie_valorising underplain_crampedness(union tarrie_valorising cyan_signature);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&apemantus_hocused,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *phantasmagories_wordcraft)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *unfugitive_sallee = 0;\r\n union tarrie_valorising gallingness_aeu = {0};\r\n union tarrie_valorising inefficacy_scissurellid;\r\n ++global_variable;;\r\n if (phantasmagories_wordcraft != 0) {;\r\n inefficacy_scissurellid . tolus_shucking = phantasmagories_wordcraft;\r\n gallingness_aeu = underplain_crampedness(inefficacy_scissurellid);\r\n unfugitive_sallee = ((char *)gallingness_aeu . tolus_shucking);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(unfugitive_sallee) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (unfugitive_sallee[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &unfugitive_sallee[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\n if (gallingness_aeu . tolus_shucking != 0) \r\n free(((char *)gallingness_aeu . tolus_shucking));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nunion tarrie_valorising underplain_crampedness(union tarrie_valorising cyan_signature)\r\n{\r\n ++global_variable;\r\n return cyan_signature;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n printf(\"String length is %i\\n\", strlen(second_buff));\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint strengthfulness_victorianly = 0;\r\nint global_variable;\r\nvoid handle_taint(char *cockieleekie_opalotype);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid maselin_becomingness(void **menologies_incrassating);\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&strengthfulness_victorianly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid handle_taint(char *cockieleekie_opalotype)\r\n{\r\n void (*genitalic_linolein)(void **) = maselin_becomingness;\r\n void **physicomorphic_superhistoric = 0;\r\n void **sarrazin_estrado = 0;\r\n void *candied_osterhus = 0;\r\n ++global_variable;;\r\n if (cockieleekie_opalotype != 0) {;\r\n candied_osterhus = ((void *)cockieleekie_opalotype);\r\n physicomorphic_superhistoric = &candied_osterhus;\r\n sarrazin_estrado = physicomorphic_superhistoric + 5;\r\n genitalic_linolein(sarrazin_estrado);\r\n }\r\n}\r\n\r\nvoid maselin_becomingness(void **menologies_incrassating)\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *feasibly_babelish = 0;\r\n ++global_variable;;\r\n feasibly_babelish = ((char *)((char *)( *(menologies_incrassating - 5))));\r\n \r\n taint_size = strlen(feasibly_babelish);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,feasibly_babelish,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\n if (((char *)( *(menologies_incrassating - 5))) != 0) \r\n free(((char *)((char *)( *(menologies_incrassating - 5)))));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n \n \n if (malloced_buff[ss_i] == 0 && errno == 12) {\n printf(\"Malloc error due to ulimit\\n\");\n if (trace_flag == 0) {\n \n```", "cwe": "401"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "static Image *ReadPNMImage(const ImageInfo *image_info,ExceptionInfo *exception)\r\r\n{\r\r\n#define ThrowPNMException(exception,message) \\\r\r\n{ \\\r\r\n if (comment_info.comment != (char *) NULL) \\\r\r\n comment_info.comment=DestroyString(comment_info.comment); \\\r\r\n ThrowReaderException((exception),(message)); \\\r\r\n}\r\r\n\r\r\n char\r\r\n format;\r\r\n\r\r\n CommentInfo\r\r\n comment_info;\r\r\n\r\r\n double\r\r\n quantum_scale;\r\r\n\r\r\n Image\r\r\n *image;\r\r\n\r\r\n MagickBooleanType\r\r\n status;\r\r\n\r\r\n QuantumAny\r\r\n max_value;\r\r\n\r\r\n QuantumInfo\r\r\n *quantum_info;\r\r\n\r\r\n QuantumType\r\r\n quantum_type;\r\r\n\r\r\n size_t\r\r\n depth,\r\r\n extent,\r\r\n packet_size;\r\r\n\r\r\n ssize_t\r\r\n count,\r\r\n row,\r\r\n y;\r\r\n\r\r\n /*\r\r\n Open image file.\r\r\n */\r\r\n assert(image_info != (const ImageInfo *) NULL);\r\r\n assert(image_info->signature == MagickCoreSignature);\r\r\n if (image_info->debug != MagickFalse)\r\r\n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\r\r\n image_info->filename);\r\r\n assert(exception != (ExceptionInfo *) NULL);\r\r\n assert(exception->signature == MagickCoreSignature);\r\r\n image=AcquireImage(image_info);\r\r\n status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\r\r\n if (status == MagickFalse)\r\r\n {\r\r\n image=DestroyImageList(image);\r\r\n return((Image *) NULL);\r\r\n }\r\r\n /*\r\r\n Read PNM image.\r\r\n */\r\r\n count=ReadBlob(image,1,(unsigned char *) &format);\r\r\n do\r\r\n {\r\r\n /*\r\r\n Initialize image structure.\r\r\n */\r\r\n comment_info.comment=AcquireString(NULL);\r\r\n comment_info.extent=MagickPathExtent;\r\r\n if ((count != 1) || (format != 'P'))\r\r\n ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\r\r\n max_value=1;\r\r\n quantum_type=RGBQuantum;\r\r\n quantum_scale=1.0;\r\r\n format=(char) ReadBlobByte(image);\r\r\n if (format != '7')\r\r\n {\r\r\n /*\r\r\n PBM, PGM, PPM, and PNM.\r\r\n */\r\r\n image->columns=PNMInteger(image,&comment_info,10);\r\r\n image->rows=PNMInteger(image,&comment_info,10);\r\r\n if ((format == 'f') || (format == 'F'))\r\r\n {\r\r\n char\r\r\n scale[MaxTextExtent];\r\r\n\r\r\n if (ReadBlobString(image,scale) != (char *) NULL)\r\r\n quantum_scale=StringToDouble(scale,(char **) NULL);\r\r\n }\r\r\n else\r\r\n {\r\r\n if ((format == '1') || (format == '4'))\r\r\n max_value=1; /* bitmap */\r\r\n else\r\r\n max_value=PNMInteger(image,&comment_info,10);\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n char\r\r\n keyword[MaxTextExtent],\r\r\n value[MaxTextExtent];\r\r\n\r\r\n int\r\r\n c;\r\r\n\r\r\n register char\r\r\n *p;\r\r\n\r\r\n /*\r\r\n PAM.\r\r\n */\r\r\n for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\r\r\n {\r\r\n while (isspace((int) ((unsigned char) c)) != 0)\r\r\n c=ReadBlobByte(image);\r\r\n if (c == '#')\r\r\n {\r\r\n /*\r\r\n Comment.\r\r\n */\r\r\n c=PNMComment(image,&comment_info);\r\r\n c=ReadBlobByte(image);\r\r\n while (isspace((int) ((unsigned char) c)) != 0)\r\r\n c=ReadBlobByte(image);\r\r\n }\r\r\n p=keyword;\r\r\n do\r\r\n {\r\r\n if ((size_t) (p-keyword) < (MaxTextExtent-1))\r\r\n *p++=c;\r\r\n c=ReadBlobByte(image);\r\r\n } while (isalnum(c));\r\r\n *p='\\0';\r\r\n if (LocaleCompare(keyword,\"endhdr\") == 0)\r\r\n break;\r\r\n while (isspace((int) ((unsigned char) c)) != 0)\r\r\n c=ReadBlobByte(image);\r\r\n p=value;\r\r\n while (isalnum(c) || (c == '_'))\r\r\n {\r\r\n if ((size_t) (p-value) < (MaxTextExtent-1))\r\r\n *p++=c;\r\r\n c=ReadBlobByte(image);\r\r\n }\r\r\n *p='\\0';\r\r\n /*\r\r\n Assign a value to the specified keyword.\r\r\n */\r\r\n if (LocaleCompare(keyword,\"depth\") == 0)\r\r\n packet_size=StringToUnsignedLong(value);\r\r\n (void) packet_size;\r\r\n if (LocaleCompare(keyword,\"height\") == 0)\r\r\n image->rows=StringToUnsignedLong(value);\r\r\n if (LocaleCompare(keyword,\"maxval\") == 0)\r\r\n max_value=StringToUnsignedLong(value);\r\r\n if (LocaleCompare(keyword,\"TUPLTYPE\") == 0)\r\r\n {\r\r\n if (LocaleCompare(value,\"BLACKANDWHITE\") == 0)\r\r\n {\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n quantum_type=GrayQuantum;\r\r\n }\r\r\n if (LocaleCompare(value,\"BLACKANDWHITE_ALPHA\") == 0)\r\r\n {\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n image->matte=MagickTrue;\r\r\n quantum_type=GrayAlphaQuantum;\r\r\n }\r\r\n if (LocaleCompare(value,\"GRAYSCALE\") == 0)\r\r\n {\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n quantum_type=GrayQuantum;\r\r\n }\r\r\n if (LocaleCompare(value,\"GRAYSCALE_ALPHA\") == 0)\r\r\n {\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n image->matte=MagickTrue;\r\r\n quantum_type=GrayAlphaQuantum;\r\r\n }\r\r\n if (LocaleCompare(value,\"RGB_ALPHA\") == 0)\r\r\n {\r\r\n quantum_type=RGBAQuantum;\r\r\n image->matte=MagickTrue;\r\r\n }\r\r\n if (LocaleCompare(value,\"CMYK\") == 0)\r\r\n {\r\r\n (void) SetImageColorspace(image,CMYKColorspace);\r\r\n quantum_type=CMYKQuantum;\r\r\n }\r\r\n if (LocaleCompare(value,\"CMYK_ALPHA\") == 0)\r\r\n {\r\r\n (void) SetImageColorspace(image,CMYKColorspace);\r\r\n image->matte=MagickTrue;\r\r\n quantum_type=CMYKAQuantum;\r\r\n }\r\r\n }\r\r\n if (LocaleCompare(keyword,\"width\") == 0)\r\r\n image->columns=StringToUnsignedLong(value);\r\r\n }\r\r\n }\r\r\n if ((image->columns == 0) || (image->rows == 0))\r\r\n ThrowPNMException(CorruptImageError,\"NegativeOrZeroImageSize\");\r\r\n if ((max_value == 0) || (max_value > 4294967295U))\r\r\n ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\r\r\n for (depth=1; GetQuantumRange(depth) < max_value; depth++) ;\r\r\n image->depth=depth;\r\r\n if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\r\r\n if (image->scene >= (image_info->scene+image_info->number_scenes-1))\r\r\n break;\r\r\n if ((MagickSizeType) (image->columns*image->rows/8) > GetBlobSize(image))\r\r\n ThrowPNMException(CorruptImageError,\"InsufficientImageDataInFile\");\r\r\n status=SetImageExtent(image,image->columns,image->rows);\r\r\n if (status == MagickFalse)\r\r\n {\r\r\n InheritException(exception,&image->exception);\r\r\n return(DestroyImageList(image));\r\r\n }\r\r\n (void) ResetImagePixels(image,exception);\r\r\n /*\r\r\n Convert PNM pixels.\r\r\n */\r\r\n row=0;\r\r\n switch (format)\r\r\n {\r\r\n case '1':\r\r\n {\r\r\n /*\r\r\n Convert PBM image to pixel packets.\r\r\n */\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n register ssize_t\r\r\n x;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n SetPixelRed(q,PNMInteger(image,&comment_info,2) == 0 ?\r\r\n QuantumRange : 0);\r\r\n if (EOFBlob(image) != MagickFalse)\r\r\n break;\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n q++;\r\r\n }\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n if (image->previous == (Image *) NULL)\r\r\n {\r\r\n status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\r\r\n image->rows);\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n if (EOFBlob(image) != MagickFalse)\r\r\n break;\r\r\n }\r\r\n image->type=BilevelType;\r\r\n break;\r\r\n }\r\r\n case '2':\r\r\n {\r\r\n size_t\r\r\n intensity;\r\r\n\r\r\n /*\r\r\n Convert PGM image to pixel packets.\r\r\n */\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n register ssize_t\r\r\n x;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n intensity=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10),\r\r\n max_value);\r\r\n if (EOFBlob(image) != MagickFalse)\r\r\n break;\r\r\n SetPixelRed(q,intensity);\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n q++;\r\r\n }\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n if (image->previous == (Image *) NULL)\r\r\n {\r\r\n status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\r\r\n image->rows);\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n if (EOFBlob(image) != MagickFalse)\r\r\n break;\r\r\n }\r\r\n image->type=GrayscaleType;\r\r\n break;\r\r\n }\r\r\n case '3':\r\r\n {\r\r\n /*\r\r\n Convert PNM image to pixel packets.\r\r\n */\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n register ssize_t\r\r\n x;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n QuantumAny\r\r\n pixel;\r\r\n\r\r\n pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10),\r\r\n max_value);\r\r\n if (EOFBlob(image) != MagickFalse)\r\r\n break;\r\r\n SetPixelRed(q,pixel);\r\r\n pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10),\r\r\n max_value);\r\r\n SetPixelGreen(q,pixel);\r\r\n pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10),\r\r\n max_value);\r\r\n SetPixelBlue(q,pixel);\r\r\n q++;\r\r\n }\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n if (image->previous == (Image *) NULL)\r\r\n {\r\r\n status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\r\r\n image->rows);\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n if (EOFBlob(image) != MagickFalse)\r\r\n break;\r\r\n }\r\r\n break;\r\r\n }\r\r\n case '4':\r\r\n {\r\r\n /*\r\r\n Convert PBM raw image to pixel packets.\r\r\n */\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n quantum_type=GrayQuantum;\r\r\n if (image->storage_class == PseudoClass)\r\r\n quantum_type=IndexQuantum;\r\r\n quantum_info=AcquireQuantumInfo(image_info,image);\r\r\n if (quantum_info == (QuantumInfo *) NULL)\r\r\n ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n SetQuantumMinIsWhite(quantum_info,MagickTrue);\r\r\n extent=GetQuantumExtent(image,quantum_info,quantum_type);\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n const unsigned char\r\r\n *pixels;\r\r\n\r\r\n MagickBooleanType\r\r\n sync;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n ssize_t\r\r\n count,\r\r\n offset;\r\r\n\r\r\n size_t\r\r\n length;\r\r\n\r\r\n pixels=(unsigned char *) ReadBlobStream(image,extent,\r\r\n GetQuantumPixels(quantum_info),&count);\r\r\n if (count != (ssize_t) extent)\r\r\n break;\r\r\n if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\r\r\n (image->previous == (Image *) NULL))\r\r\n {\r\r\n MagickBooleanType\r\r\n proceed;\r\r\n\r\r\n proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\r\r\n row,image->rows);\r\r\n if (proceed == MagickFalse)\r\r\n break;\r\r\n }\r\r\n offset=row++;\r\r\n q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\r\r\n quantum_type,pixels,exception);\r\r\n if (length != extent)\r\r\n break;\r\r\n sync=SyncAuthenticPixels(image,exception);\r\r\n if (sync == MagickFalse)\r\r\n break;\r\r\n }\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n SetQuantumImageType(image,quantum_type);\r\r\n break;\r\r\n }\r\r\n case '5':\r\r\n {\r\r\n /*\r\r\n Convert PGM raw image to pixel packets.\r\r\n */\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n quantum_type=GrayQuantum;\r\r\n extent=(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\r\r\n image->columns;\r\r\n quantum_info=AcquireQuantumInfo(image_info,image);\r\r\n if (quantum_info == (QuantumInfo *) NULL)\r\r\n ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n const unsigned char\r\r\n *pixels;\r\r\n\r\r\n MagickBooleanType\r\r\n sync;\r\r\n\r\r\n register const unsigned char\r\r\n *magick_restrict p;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n register ssize_t\r\r\n x;\r\r\n\r\r\n ssize_t\r\r\n count,\r\r\n offset;\r\r\n\r\r\n pixels=(unsigned char *) ReadBlobStream(image,extent,\r\r\n GetQuantumPixels(quantum_info),&count);\r\r\n if (count != (ssize_t) extent)\r\r\n break;\r\r\n if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\r\r\n (image->previous == (Image *) NULL))\r\r\n {\r\r\n MagickBooleanType\r\r\n proceed;\r\r\n\r\r\n proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\r\r\n row,image->rows);\r\r\n if (proceed == MagickFalse)\r\r\n break;\r\r\n }\r\r\n offset=row++;\r\r\n q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n p=pixels;\r\r\n switch (image->depth)\r\r\n {\r\r\n case 8:\r\r\n case 16:\r\r\n case 32:\r\r\n {\r\r\n (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\r\r\n quantum_type,pixels,exception);\r\r\n break;\r\r\n }\r\r\n default:\r\r\n {\r\r\n unsigned int\r\r\n pixel;\r\r\n\r\r\n if (image->depth <= 8)\r\r\n {\r\r\n unsigned char\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n if (image->depth <= 16)\r\r\n {\r\r\n unsigned short\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n }\r\r\n sync=SyncAuthenticPixels(image,exception);\r\r\n if (sync == MagickFalse)\r\r\n break;\r\r\n }\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n SetQuantumImageType(image,quantum_type);\r\r\n break;\r\r\n }\r\r\n case '6':\r\r\n {\r\r\n /*\r\r\n Convert PNM raster image to pixel packets.\r\r\n */\r\r\n quantum_type=RGBQuantum;\r\r\n extent=3*(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\r\r\n image->columns;\r\r\n quantum_info=AcquireQuantumInfo(image_info,image);\r\r\n if (quantum_info == (QuantumInfo *) NULL)\r\r\n ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n (void) SetQuantumEndian(image,quantum_info,MSBEndian);\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n const unsigned char\r\r\n *pixels;\r\r\n\r\r\n MagickBooleanType\r\r\n sync;\r\r\n\r\r\n register const unsigned char\r\r\n *magick_restrict p;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n register ssize_t\r\r\n x;\r\r\n\r\r\n ssize_t\r\r\n count,\r\r\n offset;\r\r\n\r\r\n pixels=(unsigned char *) ReadBlobStream(image,extent,\r\r\n GetQuantumPixels(quantum_info),&count);\r\r\n if (count != (ssize_t) extent)\r\r\n break;\r\r\n if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\r\r\n (image->previous == (Image *) NULL))\r\r\n {\r\r\n MagickBooleanType\r\r\n proceed;\r\r\n\r\r\n proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\r\r\n row,image->rows);\r\r\n if (proceed == MagickFalse)\r\r\n break;\r\r\n }\r\r\n offset=row++;\r\r\n q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n p=pixels;\r\r\n switch (image->depth)\r\r\n {\r\r\n case 8:\r\r\n {\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n SetPixelRed(q,ScaleCharToQuantum(*p++));\r\r\n SetPixelGreen(q,ScaleCharToQuantum(*p++));\r\r\n SetPixelBlue(q,ScaleCharToQuantum(*p++));\r\r\n q->opacity=OpaqueOpacity;\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n case 16:\r\r\n {\r\r\n unsigned short\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleShortToQuantum(pixel));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleShortToQuantum(pixel));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleShortToQuantum(pixel));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n case 32:\r\r\n {\r\r\n unsigned int\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleLongToQuantum(pixel));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleLongToQuantum(pixel));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleLongToQuantum(pixel));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n default:\r\r\n {\r\r\n unsigned int\r\r\n pixel;\r\r\n\r\r\n if (image->depth <= 8)\r\r\n {\r\r\n unsigned char\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n if (image->depth <= 16)\r\r\n {\r\r\n unsigned short\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n break;\r\r\n }\r\r\n sync=SyncAuthenticPixels(image,exception);\r\r\n if (sync == MagickFalse)\r\r\n break;\r\r\n }\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n break;\r\r\n }\r\r\n case '7':\r\r\n {\r\r\n register IndexPacket\r\r\n *indexes;\r\r\n\r\r\n size_t\r\r\n channels;\r\r\n\r\r\n /*\r\r\n Convert PAM raster image to pixel packets.\r\r\n */\r\r\n switch (quantum_type)\r\r\n {\r\r\n case GrayQuantum:\r\r\n case GrayAlphaQuantum:\r\r\n {\r\r\n channels=1;\r\r\n break;\r\r\n }\r\r\n case CMYKQuantum:\r\r\n case CMYKAQuantum:\r\r\n {\r\r\n channels=4;\r\r\n break;\r\r\n }\r\r\n default:\r\r\n {\r\r\n channels=3;\r\r\n break;\r\r\n }\r\r\n }\r\r\n if (image->matte != MagickFalse)\r\r\n channels++;\r\r\n extent=channels*(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\r\r\n image->columns;\r\r\n quantum_info=AcquireQuantumInfo(image_info,image);\r\r\n if (quantum_info == (QuantumInfo *) NULL)\r\r\n ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n const unsigned char\r\r\n *pixels;\r\r\n\r\r\n MagickBooleanType\r\r\n sync;\r\r\n\r\r\n register const unsigned char\r\r\n *magick_restrict p;\r\r\n\r\r\n register ssize_t\r\r\n x;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n ssize_t\r\r\n count,\r\r\n offset;\r\r\n\r\r\n pixels=(unsigned char *) ReadBlobStream(image,extent,\r\r\n GetQuantumPixels(quantum_info),&count);\r\r\n if (count != (ssize_t) extent)\r\r\n break;\r\r\n if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\r\r\n (image->previous == (Image *) NULL))\r\r\n {\r\r\n MagickBooleanType\r\r\n proceed;\r\r\n\r\r\n proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\r\r\n row,image->rows);\r\r\n if (proceed == MagickFalse)\r\r\n break;\r\r\n }\r\r\n offset=row++;\r\r\n q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n indexes=GetAuthenticIndexQueue(image);\r\r\n p=pixels;\r\r\n switch (image->depth)\r\r\n {\r\r\n case 8:\r\r\n case 16:\r\r\n case 32:\r\r\n {\r\r\n (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\r\r\n quantum_type,pixels,exception);\r\r\n break;\r\r\n }\r\r\n default:\r\r\n {\r\r\n switch (quantum_type)\r\r\n {\r\r\n case GrayQuantum:\r\r\n case GrayAlphaQuantum:\r\r\n {\r\r\n unsigned int\r\r\n pixel;\r\r\n\r\r\n if (image->depth <= 8)\r\r\n {\r\r\n unsigned char\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n if (image->depth != 1)\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n else\r\r\n SetPixelOpacity(q,QuantumRange-ScaleAnyToQuantum(\r\r\n pixel,max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n if (image->depth <= 16)\r\r\n {\r\r\n unsigned short\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelGreen(q,GetPixelRed(q));\r\r\n SetPixelBlue(q,GetPixelRed(q));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n case CMYKQuantum:\r\r\n case CMYKAQuantum:\r\r\n {\r\r\n unsigned int\r\r\n pixel;\r\r\n\r\r\n if (image->depth <= 8)\r\r\n {\r\r\n unsigned char\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelIndex(indexes+x,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n if (image->depth <= 16)\r\r\n {\r\r\n unsigned short\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelIndex(indexes+x,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelIndex(indexes+x,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n default:\r\r\n {\r\r\n unsigned int\r\r\n pixel;\r\r\n\r\r\n if (image->depth <= 8)\r\r\n {\r\r\n unsigned char\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushCharPixel(p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n if (image->depth <= 16)\r\r\n {\r\r\n unsigned short\r\r\n pixel;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushShortPixel(MSBEndian,p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,\r\r\n max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelRed(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelGreen(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelBlue(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n SetPixelOpacity(q,OpaqueOpacity);\r\r\n if (image->matte != MagickFalse)\r\r\n {\r\r\n p=PushLongPixel(MSBEndian,p,&pixel);\r\r\n SetPixelOpacity(q,ScaleAnyToQuantum(pixel,max_value));\r\r\n }\r\r\n q++;\r\r\n }\r\r\n break;\r\r\n }\r\r\n }\r\r\n break;\r\r\n }\r\r\n }\r\r\n sync=SyncAuthenticPixels(image,exception);\r\r\n if (sync == MagickFalse)\r\r\n break;\r\r\n }\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n SetQuantumImageType(image,quantum_type);\r\r\n break;\r\r\n }\r\r\n case 'F':\r\r\n case 'f':\r\r\n {\r\r\n /*\r\r\n Convert PFM raster image to pixel packets.\r\r\n */\r\r\n if (format == 'f')\r\r\n (void) SetImageColorspace(image,GRAYColorspace);\r\r\n quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\r\r\n image->endian=quantum_scale < 0.0 ? LSBEndian : MSBEndian;\r\r\n image->depth=32;\r\r\n quantum_info=AcquireQuantumInfo(image_info,image);\r\r\n if (quantum_info == (QuantumInfo *) NULL)\r\r\n ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n status=SetQuantumDepth(image,quantum_info,32);\r\r\n if (status == MagickFalse)\r\r\n ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\r\r\n if (status == MagickFalse)\r\r\n ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n SetQuantumScale(quantum_info,(MagickRealType) QuantumRange*\r\r\n fabs(quantum_scale));\r\r\n extent=GetQuantumExtent(image,quantum_info,quantum_type);\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n const unsigned char\r\r\n *pixels;\r\r\n\r\r\n MagickBooleanType\r\r\n sync;\r\r\n\r\r\n register PixelPacket\r\r\n *magick_restrict q;\r\r\n\r\r\n ssize_t\r\r\n count,\r\r\n offset;\r\r\n\r\r\n size_t\r\r\n length;\r\r\n\r\r\n pixels=(unsigned char *) ReadBlobStream(image,extent,\r\r\n GetQuantumPixels(quantum_info),&count);\r\r\n if ((size_t) count != extent)\r\r\n break;\r\r\n if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\r\r\n (image->previous == (Image *) NULL))\r\r\n {\r\r\n MagickBooleanType\r\r\n proceed;\r\r\n\r\r\n proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\r\r\n row,image->rows);\r\r\n if (proceed == MagickFalse)\r\r\n break;\r\r\n }\r\r\n offset=row++;\r\r\n q=QueueAuthenticPixels(image,0,(ssize_t) (image->rows-offset-1),\r\r\n image->columns,1,exception);\r\r\n if (q == (PixelPacket *) NULL)\r\r\n break;\r\r\n length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\r\r\n quantum_type,pixels,exception);\r\r\n if (length != extent)\r\r\n break;\r\r\n sync=SyncAuthenticPixels(image,exception);\r\r\n if (sync == MagickFalse)\r\r\n break;\r\r\n }\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n SetQuantumImageType(image,quantum_type);\r\r\n break;\r\r\n }\r\r\n default:\r\r\n ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\r\r\n }\r\r\n if (*comment_info.comment != '\\0')\r\r\n (void) SetImageProperty(image,\"comment\",comment_info.comment);\r\r\n comment_info.comment=DestroyString(comment_info.comment);\r\r\n if (y < (ssize_t) image->rows)\r\r\n ThrowPNMException(CorruptImageError,\"UnableToReadImageData\");\r\r\n if (EOFBlob(image) != MagickFalse)\r\r\n {\r\r\n (void) ThrowMagickException(exception,GetMagickModule(),\r\r\n CorruptImageError,\"UnexpectedEndOfFile\",\"`%s'\",image->filename);\r\r\n break;\r\r\n }\r\r\n /*\r\r\n Proceed to next image.\r\r\n */\r\r\n if (image_info->number_scenes != 0)\r\r\n if (image->scene >= (image_info->scene+image_info->number_scenes-1))\r\r\n break;\r\r\n if ((format == '1') || (format == '2') || (format == '3'))\r\r\n do\r\r\n {\r\r\n /*\r\r\n Skip to end of line.\r\r\n */\r\r\n count=ReadBlob(image,1,(unsigned char *) &format);\r\r\n if (count != 1)\r\r\n break;\r\r\n if (format == 'P')\r\r\n break;\r\r\n } while (format != '\\n');\r\r\n count=ReadBlob(image,1,(unsigned char *) &format);\r\r\n if ((count == 1) && (format == 'P'))\r\r\n {\r\r\n /*\r\r\n Allocate next image structure.\r\r\n */\r\r\n AcquireNextImage(image_info,image);\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n {\r\r\n status=MagickFalse;\r\r\n break;\r\r\n }\r\r\n image=SyncNextImageInList(image);\r\r\n status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\r\r\n GetBlobSize(image));\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n } while ((count == 1) && (format == 'P'));\r\r\n (void) CloseBlob(image);\r\r\n if (status == MagickFalse)\r\r\n return(DestroyImageList(image));\r\r\n return(GetFirstImageInList(image));\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint inbreathed_upcurved = 0;\r\n\r\nstruct butylic_spoilsports \r\n{\r\n char *camphor_swiftliest;\r\n double bioscope_antebath;\r\n char *subrident_cheltenham;\r\n char cuculiform_aul;\r\n int territus_kraul;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n char buffer_stack[128] = {0};\r\n char *reluct_mrsr = 0;\r\n struct butylic_spoilsports trapezes_alcmaon = {0};\r\n int *unbronzed_doneck = 0;\r\n int outwrestled_preachier;\r\n struct butylic_spoilsports quaternionist_stockman[10] = {0};\r\n struct butylic_spoilsports superarbitrary_brookes;\r\n char *negritos_ekpwele;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&inbreathed_upcurved,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n negritos_ekpwele = getenv(\"OFFSHOOTS_PERIDIASTOLE\");\r\n if (negritos_ekpwele != 0) {;\r\n superarbitrary_brookes . camphor_swiftliest = ((char *)negritos_ekpwele);\r\n quaternionist_stockman[5] = superarbitrary_brookes;\r\n outwrestled_preachier = 5;\r\n unbronzed_doneck = &outwrestled_preachier;\r\n trapezes_alcmaon = *(quaternionist_stockman + *unbronzed_doneck);\r\n reluct_mrsr = ((char *)trapezes_alcmaon . camphor_swiftliest);\r\n \r\n \r\n \r\n \r\n \r\n sprintf(buffer_stack,reluct_mrsr);\r\n \r\n printf(\"%s\\n\",buffer_stack);\r\n \r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` \n \n sprintf(buffer_stack,reluct_mrsr);\n \n printf(\"%s\\n\",buffer_stack);\n```", "cwe": "134"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint teutonisation_contrast = 0;\r\nint global_variable;\r\n\r\nunion fertile_sudbury \r\n{\r\n char *pippinface_cuprammonium;\r\n double kindlings_boletuses;\r\n char *underachieve_methaemoglobin;\r\n char yogism_cown;\r\n int regulatorship_freend;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nunion fertile_sudbury glibness_leachable(union fertile_sudbury cert_repercussive);\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *larvicide_eurylaimoid = 0;\r\n union fertile_sudbury vapulatory_interspersing = {0};\r\n union fertile_sudbury chablis_cautionary;\r\n int syneidesis_albuminofibrin = 28;\r\n char *leagued_podilegous;\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&teutonisation_contrast,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&leagued_podilegous,\"4019\",syneidesis_albuminofibrin);\r\n if (leagued_podilegous != 0) {;\r\n chablis_cautionary . pippinface_cuprammonium = leagued_podilegous;\r\n vapulatory_interspersing = glibness_leachable(chablis_cautionary);\r\n if (vapulatory_interspersing . pippinface_cuprammonium != 0) {\r\n goto unmountainous_rebelong;\r\n }\r\n ++global_variable;\r\n unmountainous_rebelong:;\r\n larvicide_eurylaimoid = ((char *)vapulatory_interspersing . pippinface_cuprammonium);\r\n \r\n if (strlen(larvicide_eurylaimoid) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,larvicide_eurylaimoid);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (vapulatory_interspersing . pippinface_cuprammonium != 0) \r\n free(((char *)vapulatory_interspersing . pippinface_cuprammonium));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nunion fertile_sudbury glibness_leachable(union fertile_sudbury cert_repercussive)\r\n{\r\n ++global_variable;\r\n return cert_repercussive;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "TIFFReadDirectory(TIFF* tif)\r\r\n{\r\r\n\tstatic const char module[] = \"TIFFReadDirectory\";\r\r\n\tTIFFDirEntry* dir;\r\r\n\tuint16 dircount;\r\r\n\tTIFFDirEntry* dp;\r\r\n\tuint16 di;\r\r\n\tconst TIFFField* fip;\r\r\n\tuint32 fii=FAILED_FII;\r\r\n toff_t nextdiroff;\r\r\n int bitspersample_read = FALSE;\r\r\n\r\r\n\ttif->tif_diroff=tif->tif_nextdiroff;\r\r\n\tif (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))\r\r\n\t\treturn 0; /* last offset or bad offset (IFD looping) */\r\r\n\t(*tif->tif_cleanup)(tif); /* cleanup any previous compression state */\r\r\n\ttif->tif_curdir++;\r\r\n nextdiroff = tif->tif_nextdiroff;\r\r\n\tdircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);\r\r\n\tif (!dircount)\r\r\n\t{\r\r\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\r\r\n\t\t \"Failed to read directory at offset \" TIFF_UINT64_FORMAT,nextdiroff);\r\r\n\t\treturn 0;\r\r\n\t}\r\r\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\r\r\n\r\r\n /*\r\r\n * Mark duplicates of any tag to be ignored (bugzilla 1994)\r\r\n * to avoid certain pathological problems.\r\r\n */\r\r\n\t{\r\r\n\t\tTIFFDirEntry* ma;\r\r\n\t\tuint16 mb;\r\r\n\t\tfor (ma=dir, mb=0; mb<dircount; ma++, mb++)\r\r\n\t\t{\r\r\n\t\t\tTIFFDirEntry* na;\r\r\n\t\t\tuint16 nb;\r\r\n\t\t\tfor (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)\r\r\n\t\t\t{\r\r\n\t\t\t\tif (ma->tdir_tag==na->tdir_tag)\r\r\n\t\t\t\t\tna->tdir_tag=IGNORE;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n \r\r\n\ttif->tif_flags &= ~TIFF_BEENWRITING; /* reset before new dir */\r\r\n\ttif->tif_flags &= ~TIFF_BUF4WRITE; /* reset before new dir */\r\r\n\t/* free any old stuff and reinit */\r\r\n\tTIFFFreeDirectory(tif);\r\r\n\tTIFFDefaultDirectory(tif);\r\r\n\t/*\r\r\n\t * Electronic Arts writes gray-scale TIFF files\r\r\n\t * without a PlanarConfiguration directory entry.\r\r\n\t * Thus we setup a default value here, even though\r\r\n\t * the TIFF spec says there is no default value.\r\r\n\t */\r\r\n\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\r\n\t/*\r\r\n\t * Setup default value and then make a pass over\r\r\n\t * the fields to check type and tag information,\r\r\n\t * and to extract info required to size data\r\r\n\t * structures. A second pass is made afterwards\r\r\n\t * to read in everything not taken in the first pass.\r\r\n\t * But we must process the Compression tag first\r\r\n\t * in order to merge in codec-private tag definitions (otherwise\r\r\n\t * we may get complaints about unknown tags). However, the\r\r\n\t * Compression tag may be dependent on the SamplesPerPixel\r\r\n\t * tag value because older TIFF specs permitted Compression\r\r\n\t * to be written as a SamplesPerPixel-count tag entry.\r\r\n\t * Thus if we don't first figure out the correct SamplesPerPixel\r\r\n\t * tag value then we may end up ignoring the Compression tag\r\r\n\t * value because it has an incorrect count value (if the\r\r\n\t * true value of SamplesPerPixel is not 1).\r\r\n\t */\r\r\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);\r\r\n\tif (dp)\r\r\n\t{\r\r\n\t\tif (!TIFFFetchNormalTag(tif,dp,0))\r\r\n\t\t\tgoto bad;\r\r\n\t\tdp->tdir_tag=IGNORE;\r\r\n\t}\r\r\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);\r\r\n\tif (dp)\r\r\n\t{\r\r\n\t\t/*\r\r\n\t\t * The 5.0 spec says the Compression tag has one value, while\r\r\n\t\t * earlier specs say it has one value per sample. Because of\r\r\n\t\t * this, we accept the tag if one value is supplied with either\r\r\n\t\t * count.\r\r\n\t\t */\r\r\n\t\tuint16 value;\r\r\n\t\tenum TIFFReadDirEntryErr err;\r\r\n\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\r\r\n\t\tif (err==TIFFReadDirEntryErrCount)\r\r\n\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\r\r\n\t\tif (err!=TIFFReadDirEntryErrOk)\r\r\n\t\t{\r\r\n\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"Compression\",0);\r\r\n\t\t\tgoto bad;\r\r\n\t\t}\r\r\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))\r\r\n\t\t\tgoto bad;\r\r\n\t\tdp->tdir_tag=IGNORE;\r\r\n\t}\r\r\n\telse\r\r\n\t{\r\r\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))\r\r\n\t\t\tgoto bad;\r\r\n\t}\r\r\n\t/*\r\r\n\t * First real pass over the directory.\r\r\n\t */\r\r\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\r\r\n\t{\r\r\n\t\tif (dp->tdir_tag!=IGNORE)\r\r\n\t\t{\r\r\n\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\r\r\n\t\t\tif (fii == FAILED_FII)\r\r\n\t\t\t{\r\r\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\r\r\n\t\t\t\t \"Unknown field with tag %d (0x%x) encountered\",\r\r\n\t\t\t\t dp->tdir_tag,dp->tdir_tag);\r\r\n /* the following knowingly leaks the \r\r\n anonymous field structure */\r\r\n\t\t\t\tif (!_TIFFMergeFields(tif,\r\r\n\t\t\t\t\t_TIFFCreateAnonField(tif,\r\r\n\t\t\t\t\t\tdp->tdir_tag,\r\r\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\r\r\n\t\t\t\t\t1)) {\r\r\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\r\r\n\t\t\t\t\t module,\r\r\n\t\t\t\t\t \"Registering anonymous field with tag %d (0x%x) failed\",\r\r\n\t\t\t\t\t dp->tdir_tag,\r\r\n\t\t\t\t\t dp->tdir_tag);\r\r\n\t\t\t\t\tdp->tdir_tag=IGNORE;\r\r\n\t\t\t\t} else {\r\r\n\t\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\r\r\n\t\t\t\t\tassert(fii != FAILED_FII);\r\r\n\t\t\t\t}\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t\tif (dp->tdir_tag!=IGNORE)\r\r\n\t\t{\r\r\n\t\t\tfip=tif->tif_fields[fii];\r\r\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\r\r\n\t\t\t\tdp->tdir_tag=IGNORE;\r\r\n\t\t\telse\r\r\n\t\t\t{\r\r\n\t\t\t\tswitch (dp->tdir_tag)\r\r\n\t\t\t\t{\r\r\n\t\t\t\t\tcase TIFFTAG_STRIPOFFSETS:\r\r\n\t\t\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\r\r\n\t\t\t\t\tcase TIFFTAG_TILEOFFSETS:\r\r\n\t\t\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\r\r\n\t\t\t\t\t\tTIFFSetFieldBit(tif,fip->field_bit);\r\r\n\t\t\t\t\t\tbreak;\r\r\n\t\t\t\t\tcase TIFFTAG_IMAGEWIDTH:\r\r\n\t\t\t\t\tcase TIFFTAG_IMAGELENGTH:\r\r\n\t\t\t\t\tcase TIFFTAG_IMAGEDEPTH:\r\r\n\t\t\t\t\tcase TIFFTAG_TILELENGTH:\r\r\n\t\t\t\t\tcase TIFFTAG_TILEWIDTH:\r\r\n\t\t\t\t\tcase TIFFTAG_TILEDEPTH:\r\r\n\t\t\t\t\tcase TIFFTAG_PLANARCONFIG:\r\r\n\t\t\t\t\tcase TIFFTAG_ROWSPERSTRIP:\r\r\n\t\t\t\t\tcase TIFFTAG_EXTRASAMPLES:\r\r\n\t\t\t\t\t\tif (!TIFFFetchNormalTag(tif,dp,0))\r\r\n\t\t\t\t\t\t\tgoto bad;\r\r\n\t\t\t\t\t\tdp->tdir_tag=IGNORE;\r\r\n\t\t\t\t\t\tbreak;\r\r\n\t\t\t\t}\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n\t/*\r\r\n\t * XXX: OJPEG hack.\r\r\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\r\r\n\t * c) strip offsets/bytecounts tag are both present and\r\r\n\t * d) both contain exactly one value, then we consistently find\r\r\n\t * that the buggy implementation of the buggy compression scheme\r\r\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\r\r\n\t */\r\r\n\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&\r\r\n\t (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))\r\r\n\t{\r\r\n if (!_TIFFFillStriles(tif))\r\r\n goto bad;\r\r\n\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);\r\r\n\t\tif ((dp!=0)&&(dp->tdir_count==1))\r\r\n\t\t{\r\r\n\t\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,\r\r\n\t\t\t TIFFTAG_STRIPBYTECOUNTS);\r\r\n\t\t\tif ((dp!=0)&&(dp->tdir_count==1))\r\r\n\t\t\t{\r\r\n\t\t\t\ttif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;\r\r\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\r\r\n\t\t\t\t \"Planarconfig tag value assumed incorrect, \"\r\r\n\t\t\t\t \"assuming data is contig instead of chunky\");\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n\t/*\r\r\n\t * Allocate directory structure and setup defaults.\r\r\n\t */\r\r\n\tif (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\r\r\n\t{\r\r\n\t\tMissingRequired(tif,\"ImageLength\");\r\r\n\t\tgoto bad;\r\r\n\t}\r\r\n\t/*\r\r\n\t * Setup appropriate structures (by strip or by tile)\r\r\n\t */\r\r\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\r\r\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif); \r\r\n\t\ttif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\r\r\n\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\r\r\n\t\ttif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\r\r\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\r\r\n\t} else {\r\r\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\r\r\n\t\ttif->tif_flags |= TIFF_ISTILED;\r\r\n\t}\r\r\n\tif (!tif->tif_dir.td_nstrips) {\r\r\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\r\r\n\t\t \"Cannot handle zero number of %s\",\r\r\n\t\t isTiled(tif) ? \"tiles\" : \"strips\");\r\r\n\t\tgoto bad;\r\r\n\t}\r\r\n\ttif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\r\r\n\tif (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\r\r\n\t\ttif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\r\r\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\r\r\n#ifdef OJPEG_SUPPORT\r\r\n\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&\r\r\n\t\t (isTiled(tif)==0) &&\r\r\n\t\t (tif->tif_dir.td_nstrips==1)) {\r\r\n\t\t\t/*\r\r\n\t\t\t * XXX: OJPEG hack.\r\r\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\r\r\n\t\t\t * and c) the number of strips is 1,\r\r\n\t\t\t * then we tolerate the absence of stripoffsets tag,\r\r\n\t\t\t * because, presumably, all required data is in the\r\r\n\t\t\t * JpegInterchangeFormat stream.\r\r\n\t\t\t */\r\r\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\r\r\n\t\t} else\r\r\n#endif\r\r\n {\r\r\n\t\t\tMissingRequired(tif,\r\r\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\r\r\n\t\t\tgoto bad;\r\r\n\t\t}\r\r\n\t}\r\r\n\t/*\r\r\n\t * Second pass: extract other information.\r\r\n\t */\r\r\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\r\r\n\t{\r\r\n\t\tswitch (dp->tdir_tag)\r\r\n\t\t{\r\r\n\t\t\tcase IGNORE:\r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase TIFFTAG_MINSAMPLEVALUE:\r\r\n\t\t\tcase TIFFTAG_MAXSAMPLEVALUE:\r\r\n\t\t\tcase TIFFTAG_BITSPERSAMPLE:\r\r\n\t\t\tcase TIFFTAG_DATATYPE:\r\r\n\t\t\tcase TIFFTAG_SAMPLEFORMAT:\r\r\n\t\t\t\t/*\r\r\n\t\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\r\r\n\t\t\t\t * DataType and SampleFormat tags are supposed to be\r\r\n\t\t\t\t * written as one value/sample, but some vendors\r\r\n\t\t\t\t * incorrectly write one value only -- so we accept\r\r\n\t\t\t\t * that as well (yuck). Other vendors write correct\r\r\n\t\t\t\t * value for NumberOfSamples, but incorrect one for\r\r\n\t\t\t\t * BitsPerSample and friends, and we will read this\r\r\n\t\t\t\t * too.\r\r\n\t\t\t\t */\r\r\n\t\t\t\t{\r\r\n\t\t\t\t\tuint16 value;\r\r\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\r\r\n\t\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\r\r\n\t\t\t\t\tif (err==TIFFReadDirEntryErrCount)\r\r\n\t\t\t\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\r\r\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\r\r\n\t\t\t\t\t{\r\r\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\r\r\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\r\r\n\t\t\t\t\t\tgoto bad;\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,value))\r\r\n\t\t\t\t\t\tgoto bad;\r\r\n if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )\r\r\n bitspersample_read = TRUE;\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase TIFFTAG_SMINSAMPLEVALUE:\r\r\n\t\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\r\r\n\t\t\t\t{\r\r\n\r\r\n\t\t\t\t\tdouble *data = NULL;\r\r\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\r\r\n\t\t\t\t\tuint32 saved_flags;\r\r\n\t\t\t\t\tint m;\r\r\n\t\t\t\t\tif (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)\r\r\n\t\t\t\t\t\terr = TIFFReadDirEntryErrCount;\r\r\n\t\t\t\t\telse\r\r\n\t\t\t\t\t\terr = TIFFReadDirEntryDoubleArray(tif, dp, &data);\r\r\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\r\r\n\t\t\t\t\t{\r\r\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\r\r\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\r\r\n\t\t\t\t\t\tgoto bad;\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\t\tsaved_flags = tif->tif_flags;\r\r\n\t\t\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\r\r\n\t\t\t\t\tm = TIFFSetField(tif,dp->tdir_tag,data);\r\r\n\t\t\t\t\ttif->tif_flags = saved_flags;\r\r\n\t\t\t\t\t_TIFFfree(data);\r\r\n\t\t\t\t\tif (!m)\r\r\n\t\t\t\t\t\tgoto bad;\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase TIFFTAG_STRIPOFFSETS:\r\r\n\t\t\tcase TIFFTAG_TILEOFFSETS:\r\r\n#if defined(DEFER_STRILE_LOAD)\r\r\n _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),\r\r\n dp, sizeof(TIFFDirEntry) );\r\r\n#else \r\r\n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset)) \r\r\n\t\t\t\t\tgoto bad;\r\r\n#endif \r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\r\r\n\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\r\r\n#if defined(DEFER_STRILE_LOAD)\r\r\n _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),\r\r\n dp, sizeof(TIFFDirEntry) );\r\r\n#else \r\r\n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount)) \r\r\n\t\t\t\t\tgoto bad;\r\r\n#endif \r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase TIFFTAG_COLORMAP:\r\r\n\t\t\tcase TIFFTAG_TRANSFERFUNCTION:\r\r\n\t\t\t\t{\r\r\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\r\r\n\t\t\t\t\tuint32 countpersample;\r\r\n\t\t\t\t\tuint32 countrequired;\r\r\n\t\t\t\t\tuint32 incrementpersample;\r\r\n\t\t\t\t\tuint16* value=NULL;\r\r\n /* It would be dangerous to instantiate those tag values */\r\r\n /* since if td_bitspersample has not yet been read (due to */\r\r\n /* unordered tags), it could be read afterwards with a */\r\r\n /* values greater than the default one (1), which may cause */\r\r\n /* crashes in user code */\r\r\n if( !bitspersample_read )\r\r\n {\r\r\n fip = TIFFFieldWithTag(tif,dp->tdir_tag);\r\r\n TIFFWarningExt(tif->tif_clientdata,module,\r\r\n \"Ignoring %s since BitsPerSample tag not found\",\r\r\n fip ? fip->field_name : \"unknown tagname\");\r\r\n continue;\r\r\n }\r\r\n\t\t\t\t\t/* ColorMap or TransferFunction for high bit */\r\r\n\t\t\t\t\t/* depths do not make much sense and could be */\r\r\n\t\t\t\t\t/* used as a denial of service vector */\r\r\n\t\t\t\t\tif (tif->tif_dir.td_bitspersample > 24)\r\r\n\t\t\t\t\t{\r\r\n\t\t\t\t\t fip = TIFFFieldWithTag(tif,dp->tdir_tag);\r\r\n\t\t\t\t\t TIFFWarningExt(tif->tif_clientdata,module,\r\r\n\t\t\t\t\t\t\"Ignoring %s because BitsPerSample=%d>24\",\r\r\n\t\t\t\t\t\tfip ? fip->field_name : \"unknown tagname\",\r\r\n\t\t\t\t\t\ttif->tif_dir.td_bitspersample);\r\r\n\t\t\t\t\t continue;\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\t\tcountpersample=(1U<<tif->tif_dir.td_bitspersample);\r\r\n\t\t\t\t\tif ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))\r\r\n\t\t\t\t\t{\r\r\n\t\t\t\t\t\tcountrequired=countpersample;\r\r\n\t\t\t\t\t\tincrementpersample=0;\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\t\telse\r\r\n\t\t\t\t\t{\r\r\n\t\t\t\t\t\tcountrequired=3*countpersample;\r\r\n\t\t\t\t\t\tincrementpersample=countpersample;\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\t\tif (dp->tdir_count!=(uint64)countrequired)\r\r\n\t\t\t\t\t\terr=TIFFReadDirEntryErrCount;\r\r\n\t\t\t\t\telse\r\r\n\t\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&value);\r\r\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\r\r\n {\r\r\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\r\r\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",1);\r\r\n }\r\r\n\t\t\t\t\telse\r\r\n\t\t\t\t\t{\r\r\n\t\t\t\t\t\tTIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);\r\r\n\t\t\t\t\t\t_TIFFfree(value);\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n/* BEGIN REV 4.0 COMPATIBILITY */\r\r\n\t\t\tcase TIFFTAG_OSUBFILETYPE:\r\r\n\t\t\t\t{\r\r\n\t\t\t\t\tuint16 valueo;\r\r\n\t\t\t\t\tuint32 value;\r\r\n\t\t\t\t\tif (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)\r\r\n\t\t\t\t\t{\r\r\n\t\t\t\t\t\tswitch (valueo)\r\r\n\t\t\t\t\t\t{\r\r\n\t\t\t\t\t\t\tcase OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;\r\r\n\t\t\t\t\t\t\tcase OFILETYPE_PAGE: value=FILETYPE_PAGE; break;\r\r\n\t\t\t\t\t\t\tdefault: value=0; break;\r\r\n\t\t\t\t\t\t}\r\r\n\t\t\t\t\t\tif (value!=0)\r\r\n\t\t\t\t\t\t\tTIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n/* END REV 4.0 COMPATIBILITY */\r\r\n\t\t\tdefault:\r\r\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\r\r\n\t\t\t\tbreak;\r\r\n\t\t}\r\r\n\t}\r\r\n\t/*\r\r\n\t * OJPEG hack:\r\r\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\r\r\n\t * then we consistently find that photometric should be YCbCr\r\r\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\r\r\n\t * then we consistently find that the buggy implementation of the\r\r\n\t * buggy compression scheme matches photometric YCbCr instead.\r\r\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\r\r\n\t * then we consistently find bitspersample should be 8.\r\r\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\r\r\n\t * and c) photometric is RGB or YCbCr, then we consistently find\r\r\n\t * samplesperpixel should be 3\r\r\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\r\r\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\r\r\n\t * find samplesperpixel should be 3\r\r\n\t */\r\r\n\tif (tif->tif_dir.td_compression==COMPRESSION_OJPEG)\r\r\n\t{\r\r\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\r\r\n\t\t{\r\r\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\r\r\n\t\t\t \"Photometric tag is missing, assuming data is YCbCr\");\r\r\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\r\r\n\t\t\t\tgoto bad;\r\r\n\t\t}\r\r\n\t\telse if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\r\r\n\t\t{\r\r\n\t\t\ttif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;\r\r\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\r\r\n\t\t\t \"Photometric tag value assumed incorrect, \"\r\r\n\t\t\t \"assuming data is YCbCr instead of RGB\");\r\r\n\t\t}\r\r\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\r\r\n\t\t{\r\r\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\r\r\n\t\t\t \"BitsPerSample tag is missing, assuming 8 bits per sample\");\r\r\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\r\r\n\t\t\t\tgoto bad;\r\r\n\t\t}\r\r\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\r\r\n\t\t{\r\r\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\r\r\n\t\t\t{\r\r\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\r\r\n\t\t\t\t \"SamplesPerPixel tag is missing, \"\r\r\n\t\t\t\t \"assuming correct SamplesPerPixel value is 3\");\r\r\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\r\r\n\t\t\t\t\tgoto bad;\r\r\n\t\t\t}\r\r\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)\r\r\n\t\t\t{\r\r\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\r\r\n\t\t\t\t \"SamplesPerPixel tag is missing, \"\r\r\n\t\t\t\t \"applying correct SamplesPerPixel value of 3\");\r\r\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\r\r\n\t\t\t\t\tgoto bad;\r\r\n\t\t\t}\r\r\n\t\t\telse if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)\r\r\n\t\t\t\t || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))\r\r\n\t\t\t{\r\r\n\t\t\t\t/*\r\r\n\t\t\t\t * SamplesPerPixel tag is missing, but is not required\r\r\n\t\t\t\t * by spec. Assume correct SamplesPerPixel value of 1.\r\r\n\t\t\t\t */\r\r\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\r\r\n\t\t\t\t\tgoto bad;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n\t/*\r\r\n\t * Verify Palette image has a Colormap.\r\r\n\t */\r\r\n\tif (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&\r\r\n\t !TIFFFieldSet(tif, FIELD_COLORMAP)) {\r\r\n\t\tif ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)\r\r\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\r\r\n\t\telse if (tif->tif_dir.td_bitspersample>=8)\r\r\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\r\r\n\t\telse {\r\r\n\t\t\tMissingRequired(tif, \"Colormap\");\r\r\n\t\t\tgoto bad;\r\r\n\t\t}\r\r\n\t}\r\r\n\t/*\r\r\n\t * OJPEG hack:\r\r\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\r\r\n\t * TIFFs\r\r\n\t */\r\r\n\tif (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)\r\r\n\t{\r\r\n\t\t/*\r\r\n\t\t * Attempt to deal with a missing StripByteCounts tag.\r\r\n\t\t */\r\r\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\r\r\n\t\t\t/*\r\r\n\t\t\t * Some manufacturers violate the spec by not giving\r\r\n\t\t\t * the size of the strips. In this case, assume there\r\r\n\t\t\t * is one uncompressed strip of data.\r\r\n\t\t\t */\r\r\n\t\t\tif ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\r\r\n\t\t\t tif->tif_dir.td_nstrips > 1) ||\r\r\n\t\t\t (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&\r\r\n\t\t\t tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {\r\r\n\t\t\t MissingRequired(tif, \"StripByteCounts\");\r\r\n\t\t\t goto bad;\r\r\n\t\t\t}\r\r\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\r\r\n\t\t\t\t\"TIFF directory is missing required \"\r\r\n\t\t\t\t\"\\\"StripByteCounts\\\" field, calculating from imagelength\");\r\r\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\r\r\n\t\t\t goto bad;\r\r\n\t\t/*\r\r\n\t\t * Assume we have wrong StripByteCount value (in case\r\r\n\t\t * of single strip) in following cases:\r\r\n\t\t * - it is equal to zero along with StripOffset;\r\r\n\t\t * - it is larger than file itself (in case of uncompressed\r\r\n\t\t * image);\r\r\n\t\t * - it is smaller than the size of the bytes per row\r\r\n\t\t * multiplied on the number of rows. The last case should\r\r\n\t\t * not be checked in the case of writing new image,\r\r\n\t\t * because we may do not know the exact strip size\r\r\n\t\t * until the whole image will be written and directory\r\r\n\t\t * dumped out.\r\r\n\t\t */\r\r\n\t\t#define\tBYTECOUNTLOOKSBAD \\\r\r\n\t\t ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \\\r\r\n\t\t (tif->tif_dir.td_compression == COMPRESSION_NONE && \\\r\r\n\t\t tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \\\r\r\n\t\t (tif->tif_mode == O_RDONLY && \\\r\r\n\t\t tif->tif_dir.td_compression == COMPRESSION_NONE && \\\r\r\n\t\t tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )\r\r\n\r\r\n\t\t} else if (tif->tif_dir.td_nstrips == 1\r\r\n && _TIFFFillStriles(tif)\r\r\n\t\t\t && tif->tif_dir.td_stripoffset[0] != 0\r\r\n\t\t\t && BYTECOUNTLOOKSBAD) {\r\r\n\t\t\t/*\r\r\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\r\r\n\t\t\t * zero for a tag when they don't know what the\r\r\n\t\t\t * correct value is! Try and handle the simple case\r\r\n\t\t\t * of estimating the size of a one strip image.\r\r\n\t\t\t */\r\r\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\r\r\n\t\t\t \"Bogus \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\r\r\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\r\r\n\t\t\t goto bad;\r\r\n\r\r\n#if !defined(DEFER_STRILE_LOAD)\r\r\n\t\t} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG\r\r\n\t\t\t && tif->tif_dir.td_nstrips > 2\r\r\n\t\t\t && tif->tif_dir.td_compression == COMPRESSION_NONE\r\r\n\t\t\t && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]\r\r\n\t\t\t && tif->tif_dir.td_stripbytecount[0] != 0\r\r\n\t\t\t && tif->tif_dir.td_stripbytecount[1] != 0 ) {\r\r\n\t\t\t/*\r\r\n\t\t\t * XXX: Some vendors fill StripByteCount array with\r\r\n\t\t\t * absolutely wrong values (it can be equal to\r\r\n\t\t\t * StripOffset array, for example). Catch this case\r\r\n\t\t\t * here.\r\r\n *\r\r\n * We avoid this check if deferring strile loading\r\r\n * as it would always force us to load the strip/tile\r\r\n * information.\r\r\n\t\t\t */\r\r\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\r\r\n\t\t\t \"Wrong \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\r\r\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\r\r\n\t\t\t goto bad;\r\r\n#endif /* !defined(DEFER_STRILE_LOAD) */ \r\r\n\t\t}\r\r\n\t}\r\r\n\tif (dir)\r\r\n\t{\r\r\n\t\t_TIFFfree(dir);\r\r\n\t\tdir=NULL;\r\r\n\t}\r\r\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\r\r\n\t{\r\r\n\t\tif (tif->tif_dir.td_bitspersample>=16)\r\r\n\t\t\ttif->tif_dir.td_maxsamplevalue=0xFFFF;\r\r\n\t\telse\r\r\n\t\t\ttif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);\r\r\n\t}\r\r\n\t/*\r\r\n\t * XXX: We can optimize checking for the strip bounds using the sorted\r\r\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\r\r\n\t * function in tif_write.c.\r\r\n\t */\r\r\n#if !defined(DEFER_STRILE_LOAD) \r\r\n\tif (tif->tif_dir.td_nstrips > 1) {\r\r\n\t\tuint32 strip;\r\r\n\r\r\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\r\r\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\r\r\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\r\r\n\t\t\t tif->tif_dir.td_stripoffset[strip]) {\r\r\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\r\r\n\t\t\t\tbreak;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\t}\r\r\n#endif /* !defined(DEFER_STRILE_LOAD) */\r\r\n \r\r\n\t/*\r\r\n\t * An opportunity for compression mode dependent tag fixup\r\r\n\t */\r\r\n\t(*tif->tif_fixuptags)(tif);\r\r\n\r\r\n\t/*\r\r\n\t * Some manufacturers make life difficult by writing\r\r\n\t * large amounts of uncompressed data as a single strip.\r\r\n\t * This is contrary to the recommendations of the spec.\r\r\n\t * The following makes an attempt at breaking such images\r\r\n\t * into strips closer to the recommended 8k bytes. A\r\r\n\t * side effect, however, is that the RowsPerStrip tag\r\r\n\t * value may be changed.\r\r\n\t */\r\r\n\tif ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\r\r\n\t (tif->tif_dir.td_nstrips==1)&&\r\r\n\t (tif->tif_dir.td_compression==COMPRESSION_NONE)&& \r\r\n\t ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))\r\r\n {\r\r\n if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )\r\r\n return 0;\r\r\n\t\tChopUpSingleUncompressedStrip(tif);\r\r\n }\r\r\n\r\r\n /*\r\r\n * Clear the dirty directory flag. \r\r\n */\r\r\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\r\r\n\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\r\r\n\r\r\n\t/*\r\r\n\t * Reinitialize i/o since we are starting on a new directory.\r\r\n\t */\r\r\n\ttif->tif_row = (uint32) -1;\r\r\n\ttif->tif_curstrip = (uint32) -1;\r\r\n\ttif->tif_col = (uint32) -1;\r\r\n\ttif->tif_curtile = (uint32) -1;\r\r\n\ttif->tif_tilesize = (tmsize_t) -1;\r\r\n\r\r\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\r\r\n\tif (!tif->tif_scanlinesize) {\r\r\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\r\r\n\t\t \"Cannot handle zero scanline size\");\r\r\n\t\treturn (0);\r\r\n\t}\r\r\n\r\r\n\tif (isTiled(tif)) {\r\r\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\r\r\n\t\tif (!tif->tif_tilesize) {\r\r\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\r\r\n\t\t\t \"Cannot handle zero tile size\");\r\r\n\t\t\treturn (0);\r\r\n\t\t}\r\r\n\t} else {\r\r\n\t\tif (!TIFFStripSize(tif)) {\r\r\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\r\r\n\t\t\t \"Cannot handle zero strip size\");\r\r\n\t\t\treturn (0);\r\r\n\t\t}\r\r\n\t}\r\r\n\treturn (1);\r\r\nbad:\r\r\n\tif (dir)\r\r\n\t\t_TIFFfree(dir);\r\r\n\treturn (0);\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint likened_simon = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *esthetes_tdr = 0;\r\n jmp_buf elisa_gra;\r\n int saccharulmin_entackle;\r\n char **stringently_urochromogen = 0;\r\n char **malconstruction_unlitigiously = 0;\r\n int waldglas_nonrescissory = 0;\r\n char *whimsies_vincents = 0;\r\n int bowk_dodecasyllable = 5;\r\n char *mushrooming_pleuronectidae;;\r\n if (__sync_bool_compare_and_swap(&likened_simon,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&mushrooming_pleuronectidae,\"3164\",bowk_dodecasyllable);\r\n if (mushrooming_pleuronectidae != 0) {;\r\n waldglas_nonrescissory = ((int )(strlen(mushrooming_pleuronectidae)));\r\n whimsies_vincents = ((char *)(malloc(waldglas_nonrescissory + 1)));\r\n if (whimsies_vincents == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(whimsies_vincents,0,waldglas_nonrescissory + 1);\r\n memcpy(whimsies_vincents,mushrooming_pleuronectidae,waldglas_nonrescissory);\r\n if (mushrooming_pleuronectidae != 0) \r\n free(((char *)mushrooming_pleuronectidae));\r\n stringently_urochromogen = &whimsies_vincents;\r\n malconstruction_unlitigiously = stringently_urochromogen + 5;\r\n saccharulmin_entackle = setjmp(elisa_gra);\r\n if (saccharulmin_entackle == 0) {\r\n longjmp(elisa_gra,1);\r\n }\r\n esthetes_tdr = ((char *)( *(malconstruction_unlitigiously - 5)));\r\n \r\n input = atoi(esthetes_tdr);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\n if ( *(malconstruction_unlitigiously - 5) != 0) \r\n free(((char *)( *(malconstruction_unlitigiously - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n quotient = 1024 / mod;\n```", "cwe": "369"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"avformat.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"libavcodec/internal.h\"\r\n#include \"libavcodec/bytestream.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"metadata.h\"\r\n#include \"id3v2.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"riff.h\"\r\n#include \"audiointerleave.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#if CONFIG_NETWORK\r\n#include \"network.h\"\r\n#endif\r\n#undef NDEBUG\r\n#include <assert.h>\r\n\r\n\r\n\r\n#include <stdio.h> \r\n#include </trace.h> \r\nint aggrieve_arguing = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nchar *ower_unfarsighted(char *furtherer_rabiform);\r\n\r\nstatic void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den)\r\n{\r\n num += den >> 1;\r\n if (num >= den) {\r\n val += num / den;\r\n num = num % den;\r\n }\r\n f -> val = val;\r\n f -> num = num;\r\n f -> den = den;\r\n}\r\n\r\n\r\nstatic void frac_add(AVFrac *f,int64_t incr)\r\n{\r\n int64_t num;\r\n int64_t den;\r\n num = f -> num + incr;\r\n den = f -> den;\r\n if (num < 0) {\r\n f -> val += num / den;\r\n num = num % den;\r\n if (num < 0) {\r\n num += den;\r\n f -> val--;\r\n }\r\n }\r\n else {\r\n if (num >= den) {\r\n f -> val += num / den;\r\n num = num % den;\r\n }\r\n }\r\n f -> num = num;\r\n}\r\n\r\nAVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission)\r\n{\r\n AVRational q;\r\n int j;\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n q = ((AVRational ){(1), st -> codec -> sample_rate});\r\n }\r\n else {\r\n q = st -> codec -> time_base;\r\n }\r\n for (j = 2; j < 14; j += 1 + (j > 2)) \r\n while(q . den / q . num < min_precission && q . num % j == 0)\r\n q . num /= j;\r\n while(q . den / q . num < min_precission && q . den < 1 << 24)\r\n q . den <<= 1;\r\n return q;\r\n}\r\n\r\nint avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename)\r\n{\r\n AVFormatContext *s = avformat_alloc_context();\r\n int ret = 0;\r\n *avctx = ((void *)0);\r\n if (!s) {\r\n goto nomem;\r\n }\r\n if (!oformat) {\r\n if (format) {\r\n oformat = av_guess_format(format,((void *)0),((void *)0));\r\n if (!oformat) {\r\n av_log(s,16,\"Requested output format '%s' is not a suitable output format\\n\",format);\r\n ret = - 22;\r\n goto error;\r\n }\r\n }\r\n else {\r\n oformat = av_guess_format(((void *)0),filename,((void *)0));\r\n if (!oformat) {\r\n ret = - 22;\r\n av_log(s,16,\"Unable to find a suitable output format for '%s'\\n\",filename);\r\n goto error;\r\n }\r\n }\r\n }\r\n s -> oformat = oformat;\r\n if (s -> oformat -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));\r\n if (!s -> priv_data) {\r\n goto nomem;\r\n }\r\n if (s -> oformat -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n }\r\n }\r\n else {\r\n s -> priv_data = ((void *)0);\r\n }\r\n if (filename) {\r\n av_strlcpy(s -> filename,filename,sizeof(s -> filename));\r\n }\r\n *avctx = s;\r\n return 0;\r\n nomem:\r\n av_log(s,16,\"Out of memory\\n\");\r\n ret = - 12;\r\n error:\r\n avformat_free_context(s);\r\n return ret;\r\n}\r\n#if FF_API_ALLOC_OUTPUT_CONTEXT\r\n\r\nAVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename)\r\n{\r\n AVFormatContext *avctx;\r\n int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);\r\n return ret < 0?((void *)0) : avctx;\r\n}\r\n#endif\r\n\r\nstatic int validate_codec_tag(AVFormatContext *s,AVStream *st)\r\n{\r\n const AVCodecTag *avctag;\r\n int n;\r\n enum AVCodecID id = AV_CODEC_ID_NONE;\r\n unsigned int tag = 0;\r\n\r\n for (n = 0; s -> oformat -> codec_tag[n]; n++) {\r\n avctag = s -> oformat -> codec_tag[n];\r\n while((avctag -> id) != AV_CODEC_ID_NONE){\r\n if (avpriv_toupper4(avctag -> tag) == avpriv_toupper4(st -> codec -> codec_tag)) {\r\n id = avctag -> id;\r\n if (id == (st -> codec -> codec_id)) {\r\n return 1;\r\n }\r\n }\r\n if ((avctag -> id) == (st -> codec -> codec_id)) {\r\n tag = avctag -> tag;\r\n }\r\n avctag++;\r\n }\r\n }\r\n if (id != AV_CODEC_ID_NONE) {\r\n return 0;\r\n }\r\n if (tag && st -> codec -> strict_std_compliance >= 0) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int init_muxer(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n int i;\r\n AVStream *st;\r\n AVDictionary *tmp = ((void *)0);\r\n AVCodecContext *codec = ((void *)0);\r\n AVOutputFormat *of = s -> oformat;\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n if ((ret = av_opt_set_dict(s,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n\r\n if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {\r\n av_log(s,16,\"no streams\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n st = s -> streams[i];\r\n codec = st -> codec;\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (codec -> sample_rate <= 0) {\r\n av_log(s,16,\"sample rate not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (!codec -> block_align) {\r\n codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0) \r\n\r\n{\r\n av_log(s,16,\"time base not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {\r\n av_log(s,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto fail;\r\n }\r\n if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {\r\n av_log(s,16,\"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\\n\",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);\r\n ret = - 22;\r\n goto fail;\r\n }\r\n break; \r\n }\r\n }\r\n if (of -> codec_tag) {\r\n if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {\r\n\r\n\r\n codec -> codec_tag = 0;\r\n }\r\n if (codec -> codec_tag) {\r\n if (!validate_codec_tag(s,st)) {\r\n char tagbuf[32];\r\n char cortag[32];\r\n av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);\r\n av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));\r\n av_log(s,16,\"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\\n\",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n goto fail;\r\n }\r\n }\r\n else {\r\n codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);\r\n }\r\n }\r\n if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {\r\n av_log(s,24,\"Codec for stream %d does not use global headers but container format requires global headers\\n\",i);\r\n }\r\n }\r\n if (!s -> priv_data && of -> priv_data_size > 0) {\r\n s -> priv_data = av_mallocz((of -> priv_data_size));\r\n if (!s -> priv_data) {\r\n ret = - 12;\r\n goto fail;\r\n }\r\n if (of -> priv_class) {\r\n *((const AVClass **)(s -> priv_data)) = of -> priv_class;\r\n av_opt_set_defaults(s -> priv_data);\r\n if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {\r\n goto fail;\r\n }\r\n }\r\n }\r\n\r\n if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {\r\n av_dict_set(&s -> metadata,\"encoder\",\"Lavf54.63.104\",0);\r\n }\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return 0;\r\n fail:\r\n av_dict_free(&tmp);\r\n return ret;\r\n}\r\n\r\nstatic int init_pts(AVFormatContext *s)\r\n{\r\n int i;\r\n AVStream *st;\r\n\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n int64_t den = (int64_t )0x8000000000000000UL;\r\n st = s -> streams[i];\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * (st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n den = ((int64_t )st -> time_base . num) * st -> codec -> time_base . den;\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n if (den != ((int64_t )0x8000000000000000UL)) {\r\n if (den <= 0) {\r\n return -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n frac_init(&st -> pts,0,0,den);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avformat_write_header(AVFormatContext *s,AVDictionary **options)\r\n{\r\n int ss_i = 0;\r\n char* heap_buff_64;\r\n int buff_size;\r\n char *pluteus_hallan = 0;\r\n int camerlingos_barberton;\r\n int bosc_tartary;\r\n char *fredrick_porchlike = 0;\r\n int eugeny_animadversions = 0;\r\n char *fringelike_lactation = 0;\r\n char *furcule_malayalam;\r\n int ret = 0;\r\n if (__sync_bool_compare_and_swap(&aggrieve_arguing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n furcule_malayalam = getenv(\"COALFIELD_COMIQUE\");\r\n if (furcule_malayalam != 0) {;\r\n eugeny_animadversions = ((int )(strlen(furcule_malayalam)));\r\n fringelike_lactation = ((char *)(malloc(eugeny_animadversions + 1)));\r\n if (fringelike_lactation == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(fringelike_lactation,0,eugeny_animadversions + 1);\r\n memcpy(fringelike_lactation,furcule_malayalam,eugeny_animadversions);\r\n fredrick_porchlike = ower_unfarsighted(fringelike_lactation);\r\n bosc_tartary = 5;\r\n while(1 == 1){\r\n bosc_tartary = bosc_tartary * 2;\r\n bosc_tartary = bosc_tartary + 2;\r\n if (bosc_tartary > 1000) {\r\n break; \r\n }\r\n }\r\n camerlingos_barberton = bosc_tartary;\r\n pluteus_hallan = ((char *)fredrick_porchlike);\r\n \r\n heap_buff_64 = (char*) malloc(64 * sizeof(char));\r\n \r\n if (heap_buff_64 != NULL) {\r\n memset(heap_buff_64,'A',63);\r\n heap_buff_64[63] = '\\0';\r\n \r\n buff_size = ((int )(strlen(pluteus_hallan)));\r\n strncpy(heap_buff_64, pluteus_hallan, 64);\r\n \r\n \r\n \r\n for (; ss_i < buff_size; ++ss_i){\r\n \r\n \r\n printf(\"%02x\",heap_buff_64[ss_i]);\r\n }\r\n \r\n \r\n \r\n printf(\"\\n\");\r\n free( heap_buff_64);\r\n \r\n \r\n }\r\n;\r\n if (fredrick_porchlike != 0) \r\n free(((char *)fredrick_porchlike));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n if (ret = init_muxer(s,options)) {\r\n return ret;\r\n }\r\n if (s -> oformat -> write_header) {\r\n ret = ((s -> oformat -> write_header)(s));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n if ((ret = init_pts(s)) < 0) {\r\n return ret;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)\r\n{\r\n int delay = st -> codec -> has_b_frames > (st -> codec -> max_b_frames > 0)?st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0;\r\n int num;\r\n int den;\r\n int frame_size;\r\n int i;\r\n do {\r\n if (0) {\r\n av_log(s,48,\"compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),st -> cur_dts),delay,pkt -> size,pkt -> stream_index);\r\n }\r\n }while (0);\r\n\r\n if (pkt -> duration == 0) {\r\n ff_compute_frame_duration(&num,&den,st,((void *)0),pkt);\r\n if (den && num) {\r\n pkt -> duration = (av_rescale(1,num * ((int64_t )st -> time_base . den) * (st -> codec -> ticks_per_frame),den * ((int64_t )st -> time_base . num)));\r\n }\r\n }\r\n if (pkt -> pts == ((int64_t )0x8000000000000000UL) && pkt -> dts != ((int64_t )0x8000000000000000UL) && delay == 0) {\r\n pkt -> pts = pkt -> dts;\r\n }\r\n\r\n if ((pkt -> pts == 0 || pkt -> pts == ((int64_t )0x8000000000000000UL)) && pkt -> dts == ((int64_t )0x8000000000000000UL) && !delay) {\r\n static int warned;\r\n if (!warned) {\r\n av_log(s,24,\"Encoder did not produce proper pts, making some up.\\n\");\r\n warned = 1;\r\n }\r\n pkt -> dts = pkt -> pts = st -> pts . val;\r\n\r\n }\r\n\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> dts == ((int64_t )0x8000000000000000UL) && delay <= 16) {\r\n st -> pts_buffer[0] = pkt -> pts;\r\n for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++) \r\n st -> pts_buffer[i] = pkt -> pts + ((i - delay - 1) * pkt -> duration);\r\n for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++) \r\n do {\r\n int64_t SWAP_tmp = st -> pts_buffer[i + 1];\r\n st -> pts_buffer[i + 1] = st -> pts_buffer[i];\r\n st -> pts_buffer[i] = SWAP_tmp;\r\n }while (0);\r\n pkt -> dts = st -> pts_buffer[0];\r\n }\r\n if (st -> cur_dts && st -> cur_dts != ((int64_t )0x8000000000000000UL) && (!(s -> oformat -> flags & 0x8020000) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts)) {\r\n av_log(s,16,\"Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\\n\",st -> index,av_ts_make_string(((char [32]){(0)}),st -> cur_dts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n return - 22;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL) && pkt -> pts != ((int64_t )0x8000000000000000UL) && pkt -> pts < pkt -> dts) {\r\n av_log(s,16,\"pts (%s) < dts (%s) in stream %d\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts),st -> index);\r\n return - 22;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_write_frame: pts2:%s dts2:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_string(((char [32]){(0)}),pkt -> dts));\r\n }\r\n }while (0);\r\n st -> cur_dts = pkt -> dts;\r\n st -> pts . val = pkt -> dts;\r\n\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame_size = ff_get_audio_frame_size(st -> codec,pkt -> size,1);\r\n\r\n if (frame_size >= 0 && (pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val)) {\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * frame_size);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frac_add(&st -> pts,((int64_t )st -> time_base . den) * st -> codec -> time_base . num);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n return 0;\r\n}\r\n\r\n\r\ninline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int did_split;\r\n did_split = av_packet_split_side_data(pkt);\r\n ret = ((s -> oformat -> write_packet)(s,pkt));\r\n if (did_split) {\r\n av_packet_merge_side_data(pkt);\r\n }\r\n return ret;\r\n}\r\n\r\nint av_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n if (!pkt) {\r\n if (s -> oformat -> flags & 0x10000) {\r\n ret = ((s -> oformat -> write_packet)(s,((void *)0)));\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n return ret;\r\n }\r\n return 1;\r\n }\r\n ret = compute_pkt_fields2(s,s -> streams[pkt -> stream_index],pkt);\r\n if (ret < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,pkt);\r\n if (ret >= 0 && s -> pb && s -> pb -> error < 0) {\r\n ret = s -> pb -> error;\r\n }\r\n if (ret >= 0) {\r\n s -> streams[pkt -> stream_index] -> nb_frames++;\r\n }\r\n return ret;\r\n}\r\n#define CHUNK_START 0x1000\r\n\r\nint ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\r\n{\r\n AVPacketList **next_point;\r\n AVPacketList *this_pktl;\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n int chunked = s -> max_chunk_size || s -> max_chunk_duration;\r\n this_pktl = (av_mallocz(sizeof(AVPacketList )));\r\n if (!this_pktl) {\r\n return - 12;\r\n }\r\n this_pktl -> pkt = *pkt;\r\n\r\n pkt -> destruct = ((void *)0);\r\n\r\n av_dup_packet(&this_pktl -> pkt);\r\n if (s -> streams[pkt -> stream_index] -> last_in_packet_buffer) {\r\n next_point = &st -> last_in_packet_buffer -> next;\r\n }\r\n else {\r\n next_point = &s -> packet_buffer;\r\n }\r\n if (chunked) {\r\n uint64_t max = (av_rescale_q_rnd((s -> max_chunk_duration),((AVRational ){(1), (1000000)}),st -> time_base,AV_ROUND_UP));\r\n st -> interleaver_chunk_size += (pkt -> size);\r\n st -> interleaver_chunk_duration += (pkt -> duration);\r\n if (s -> max_chunk_size && st -> interleaver_chunk_size > (s -> max_chunk_size) || max && (st -> interleaver_chunk_duration) > max) {\r\n st -> interleaver_chunk_size = 0;\r\n this_pktl -> pkt . flags |= 0x1000;\r\n if (max && (st -> interleaver_chunk_duration) > max) {\r\n int64_t syncoffset = (((st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) * max / 2);\r\n int64_t syncto = ((av_rescale(pkt -> dts + syncoffset,1,max)) * max - syncoffset);\r\n st -> interleaver_chunk_duration += ((pkt -> dts - syncto) / 8) - max;\r\n }\r\n else {\r\n st -> interleaver_chunk_duration = 0;\r\n }\r\n }\r\n }\r\n if ( *next_point) {\r\n if (chunked && !(this_pktl -> pkt . flags & 0x1000)) {\r\n goto next_non_null;\r\n }\r\n if (compare(s,&s -> packet_buffer_end -> pkt,pkt)) {\r\n while( *next_point && (chunked && !(( *next_point) -> pkt . flags & 0x1000) || !compare(s,&( *next_point) -> pkt,pkt)))\r\n next_point = &( *next_point) -> next;\r\n if ( *next_point) {\r\n goto next_non_null;\r\n }\r\n }\r\n else {\r\n next_point = &s -> packet_buffer_end -> next;\r\n }\r\n }\r\n (void )0;\r\n s -> packet_buffer_end = this_pktl;\r\n next_non_null:\r\n this_pktl -> next = *next_point;\r\n s -> streams[pkt -> stream_index] -> last_in_packet_buffer = *next_point = this_pktl;\r\n return 0;\r\n}\r\n\r\nstatic int ff_interleave_compare_dts(AVFormatContext *s,AVPacket *next,AVPacket *pkt)\r\n{\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n AVStream *st2 = s -> streams[next -> stream_index];\r\n int comp = av_compare_ts(next -> dts,st2 -> time_base,pkt -> dts,st -> time_base);\r\n if (s -> audio_preload && (st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO != ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n int64_t ts = av_rescale_q(pkt -> dts,st -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n int64_t ts2 = av_rescale_q(next -> dts,st2 -> time_base,((AVRational ){(1), (1000000)})) - (s -> audio_preload * ((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO));\r\n if (ts == ts2) {\r\n ts = (pkt -> dts * st -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st -> time_base . den) * st2 -> time_base . den - (next -> dts * st2 -> time_base . num * 1000000 - (s -> audio_preload) * ((int64_t )((st2 -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) * st2 -> time_base . den) * st -> time_base . den;\r\n ts2 = 0;\r\n }\r\n comp = (ts > ts2) - (ts < ts2);\r\n }\r\n if (comp == 0) {\r\n return pkt -> stream_index < next -> stream_index;\r\n }\r\n return comp > 0;\r\n}\r\n\r\nint ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n AVPacketList *pktl;\r\n int stream_count = 0;\r\n int noninterleaved_count = 0;\r\n int64_t delta_dts_max = 0;\r\n int i;\r\n int ret;\r\n if (pkt) {\r\n ret = ff_interleave_add_packet(s,pkt,ff_interleave_compare_dts);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n ++stream_count;\r\n }\r\n else {\r\n if ((s -> streams[i] -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n ++noninterleaved_count;\r\n }\r\n }\r\n }\r\n if (s -> nb_streams == stream_count) {\r\n flush = 1;\r\n }\r\n else {\r\n if (!flush) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n if (s -> streams[i] -> last_in_packet_buffer) {\r\n int64_t delta_dts = av_rescale_q(s -> streams[i] -> last_in_packet_buffer -> pkt . dts,s -> streams[i] -> time_base,((AVRational ){(1), (1000000)})) - av_rescale_q(s -> packet_buffer -> pkt . dts,s -> streams[s -> packet_buffer -> pkt . stream_index] -> time_base,((AVRational ){(1), (1000000)}));\r\n delta_dts_max = (delta_dts_max > delta_dts?delta_dts_max : delta_dts);\r\n }\r\n }\r\n if (s -> nb_streams == (stream_count + noninterleaved_count) && delta_dts_max > (20 * 1000000)) {\r\n av_log(s,48,\"flushing with %d noninterleaved\\n\",noninterleaved_count);\r\n flush = 1;\r\n }\r\n }\r\n }\r\n if (stream_count && flush) {\r\n AVStream *st;\r\n pktl = s -> packet_buffer;\r\n *out = pktl -> pkt;\r\n st = s -> streams[out -> stream_index];\r\n s -> packet_buffer = pktl -> next;\r\n if (!s -> packet_buffer) {\r\n s -> packet_buffer_end = ((void *)0);\r\n }\r\n if (st -> last_in_packet_buffer == pktl) {\r\n st -> last_in_packet_buffer = ((void *)0);\r\n }\r\n av_freep((&pktl));\r\n if (s -> avoid_negative_ts > 0) {\r\n if (out -> dts != ((int64_t )0x8000000000000000UL)) {\r\n if (!st -> mux_ts_offset && out -> dts < 0) {\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n s -> streams[i] -> mux_ts_offset = av_rescale_q_rnd(-out -> dts,st -> time_base,s -> streams[i] -> time_base,AV_ROUND_UP);\r\n }\r\n }\r\n out -> dts += st -> mux_ts_offset;\r\n }\r\n if (out -> pts != ((int64_t )0x8000000000000000UL)) {\r\n out -> pts += st -> mux_ts_offset;\r\n }\r\n }\r\n return 1;\r\n }\r\n else {\r\n av_init_packet(out);\r\n return 0;\r\n }\r\n}\r\n#if FF_API_INTERLEAVE_PACKET\r\n\r\nint av_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)\r\n{\r\n return ff_interleave_packet_per_dts(s,out,pkt,flush);\r\n}\r\n#endif\r\n\r\n\r\nstatic int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)\r\n{\r\n if (s -> oformat -> interleave_packet) {\r\n int ret = (s -> oformat -> interleave_packet)(s,out,in,flush);\r\n if (in) {\r\n av_free_packet(in);\r\n }\r\n return ret;\r\n }\r\n else {\r\n return ff_interleave_packet_per_dts(s,out,in,flush);\r\n }\r\n}\r\n\r\nint av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)\r\n{\r\n int ret;\r\n int flush = 0;\r\n if (pkt) {\r\n AVStream *st = s -> streams[pkt -> stream_index];\r\n\r\n if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0) {\r\n return 0;\r\n }\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame size:%d dts:%s pts:%s\\n\",pkt -> size,av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_string(((char [32]){(0)}),pkt -> pts));\r\n }\r\n }while (0);\r\n if ((ret = compute_pkt_fields2(s,st,pkt)) < 0 && !(s -> oformat -> flags & 0x80)) {\r\n return ret;\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL) && !(s -> oformat -> flags & 0x80)) {\r\n return - 22;\r\n }\r\n }\r\n else {\r\n do {\r\n if (0) {\r\n av_log(s,48,\"av_interleaved_write_frame FLUSH\\n\");\r\n }\r\n }while (0);\r\n flush = 1;\r\n }\r\n for (; ; ) {\r\n AVPacket opkt;\r\n int ret = interleave_packet(s,&opkt,pkt,flush);\r\n\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n ret = split_write_packet(s,&opkt);\r\n if (ret >= 0) {\r\n s -> streams[opkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&opkt);\r\n pkt = ((void *)0);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n return s -> pb -> error;\r\n }\r\n }\r\n}\r\n\r\nint av_write_trailer(AVFormatContext *s)\r\n{\r\n int ret;\r\n int i;\r\n for (; ; ) {\r\n AVPacket pkt;\r\n ret = interleave_packet(s,&pkt,((void *)0),1);\r\n\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (!ret) {\r\n break; \r\n }\r\n ret = split_write_packet(s,&pkt);\r\n if (ret >= 0) {\r\n s -> streams[pkt . stream_index] -> nb_frames++;\r\n }\r\n av_free_packet(&pkt);\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (s -> pb && s -> pb -> error) {\r\n goto fail;\r\n }\r\n }\r\n if (s -> oformat -> write_trailer) {\r\n ret = ((s -> oformat -> write_trailer)(s));\r\n }\r\n fail:\r\n if (s -> pb) {\r\n avio_flush(s -> pb);\r\n }\r\n if (ret == 0) {\r\n ret = (s -> pb?s -> pb -> error : 0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) {\r\n av_freep((&s -> streams[i] -> priv_data));\r\n av_freep((&s -> streams[i] -> index_entries));\r\n }\r\n if (s -> oformat -> priv_class) {\r\n av_opt_free(s -> priv_data);\r\n }\r\n av_freep((&s -> priv_data));\r\n return ret;\r\n}\r\n\r\nint av_get_output_timestamp(struct AVFormatContext *s,int stream,int64_t *dts,int64_t *wall)\r\n{\r\n if (!s -> oformat || !s -> oformat -> get_output_timestamp) {\r\n return - 38;\r\n }\r\n (s -> oformat -> get_output_timestamp)(s,stream,dts,wall);\r\n return 0;\r\n}\r\n\r\nchar *ower_unfarsighted(char *furtherer_rabiform)\r\n{\r\n ++global_variable;\r\n return furtherer_rabiform;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (; ss_i < buff_size; ++ss_i){\n \n \n printf(\"%02x\",heap_buff_64[ss_i]);\n }\n```", "cwe": "126"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint encodement_forecastleman = 0;\r\n\r\nunion thorough_cavit \r\n{\r\n char *fleam_stickball;\r\n double depilatory_pseudoethically;\r\n char *sprayfully_underlinemen;\r\n char belgravian_buddleias;\r\n int misrepresents_confection;\r\n}\r\n;\r\nint global_variable;\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *));\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_t t0, t1;\r\npthread_mutex_t mutex_0, mutex_1;\r\nint dev_amount = 1;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcDevamount(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int qsize;\r\n \r\n printf(\"Inside calcDevAmount\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n \r\n \r\n dev_amount = Data->data[0] - 'A'; \r\n qsize = Data->qsize;\r\n if (dev_amount < 0) { \r\n dev_amount *= -1; \r\n }\r\n \r\n readFile(Data->file2);\r\n if (dev_amount == 0) { \r\n dev_amount += 1; \r\n }\r\n \r\n \r\n pthread_mutex_unlock(&mutex_0);\r\n return NULL;\r\n}\r\nvoid *devChar(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int i;\r\n int *arr = NULL;\r\n \r\n printf(\"Inside devChar\\n\");\r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n pthread_mutex_lock(&mutex_1);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n \r\n \r\n \r\n for (i = 0; i < strlen(Data->data); i++) { \r\n Data->data[i] /= dev_amount; \r\n }\r\n \r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&encodement_forecastleman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n opisthodont_cyanin(bend_godded);\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite)\r\n{\r\n union thorough_cavit trainways_superinduction;\r\n char *dulsea_cupriferous;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&dulsea_cupriferous,\"MATRICULATING_WADESTOWN\");\r\n if (dulsea_cupriferous != 0) {;\r\n trainways_superinduction . fleam_stickball = dulsea_cupriferous;\r\n *belugite_parnellite = trainways_superinduction;\r\n }\r\n}\r\n\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *))\r\n{\r\n struct data* Data;\r\n char *airmail_masculineness = 0;\r\n union thorough_cavit melammdim_chaffinch = {0};\r\n int *subprostatic_honora = 0;\r\n int indistinctly_enthusiasm;\r\n union thorough_cavit hyperite_gonium[10] = {0};\r\n ++global_variable;\r\n union thorough_cavit venison_elasticate = {0};\r\n message_zygopterous(&venison_elasticate);\r\n if (venison_elasticate . fleam_stickball != 0) {;\r\n hyperite_gonium[5] = venison_elasticate;\r\n indistinctly_enthusiasm = 5;\r\n subprostatic_honora = &indistinctly_enthusiasm;\r\n melammdim_chaffinch = *(hyperite_gonium + *subprostatic_honora);\r\n airmail_masculineness = ((char *)melammdim_chaffinch . fleam_stickball);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n if (Data->data) {\r\n if ((sscanf(airmail_masculineness, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n \r\n \r\n \r\n \r\n \r\n if (strlen(Data->data) > 50) { \r\n \r\n if (pthread_create(&t0, NULL, calcDevamount, Data) != 0) { \r\n printf(\"Error initializing thread 0.\");\r\n }\r\n }\r\n if (pthread_create(&t1, NULL, devChar, Data) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n if (strlen(Data->data) > 50) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (melammdim_chaffinch . fleam_stickball != 0) \r\n free(((char *)melammdim_chaffinch . fleam_stickball));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n for (i = 0; i < strlen(Data->data); i++) { \n Data->data[i] /= dev_amount; \n }\n```", "cwe": "821"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint clinospore_mesomorph = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *lineary_psalmodic = 0;\r\n int corojo_california;\r\n int sympathism_campo;\r\n char **expressly_threshingtime = 0;\r\n int *shellier_flotten = 0;\r\n int gigantoblast_medin;\r\n char **quintupled_forthink[10] = {0};\r\n char *anischuria_ureteric[28] = {0};\r\n char *cherrying_brachiopod;;\r\n if (__sync_bool_compare_and_swap(&clinospore_mesomorph,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cherrying_brachiopod = getenv(\"CHALCOSTIBITE_THAMURIA\");\r\n if (cherrying_brachiopod != 0) {;\r\n anischuria_ureteric[20] = cherrying_brachiopod;\r\n quintupled_forthink[5] = anischuria_ureteric;\r\n gigantoblast_medin = 5;\r\n shellier_flotten = &gigantoblast_medin;\r\n expressly_threshingtime = *(quintupled_forthink + *shellier_flotten);\r\n sympathism_campo = 5;\r\n while(1 == 1){\r\n sympathism_campo = sympathism_campo * 2;\r\n sympathism_campo = sympathism_campo + 2;\r\n if (sympathism_campo > 1000) {\r\n break; \r\n }\r\n }\r\n corojo_california = sympathism_campo;\r\n lineary_psalmodic = ((char *)expressly_threshingtime[20]);\r\n \r\n input = atoi(lineary_psalmodic);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n quotient = 1024 / mod;\n```", "cwe": "369"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nint politicalize_thickest = 0;\r\nint global_variable;\r\n\r\nunion cricetine_toader \r\n{\r\n char *upperco_yaka;\r\n double preludium_conciliatorily;\r\n char *fructiculture_pierrots;\r\n char thereright_pyche;\r\n int corrivalry_chamacoco;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nunion cricetine_toader inviable_simon(union cricetine_toader reedified_sciurids);\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_mutex_t mutex_0, mutex_1;\r\npthread_t t0, t1;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *replace (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *qsort_arr;\r\n int i = 0;\r\n \r\n \r\n printf(\"replace: entering function\\n\");\r\n \r\n qsort_arr = malloc(sizeof(int)*Data->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < Data->qsize; i++) {\r\n qsort_arr[i] = Data->qsize - i;\r\n }\r\n qsort(qsort_arr, Data->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(Data->file1);\r\n printf(\"replace: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n printf(\"replace: Grabbed lock 0\\n\");\r\n printf(\"replace: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1); \r\n printf(\"replace: Grabbed lock 1\\n\");\r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] == '_') {\r\n Data->data[i] = '-';\r\n }\r\n i++;\r\n }\r\n printf(\"replace: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n printf(\"replace: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n \r\n return NULL;\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n \r\n printf(\"toCap: Entering function\\n\");\r\n printf(\"toCap: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1);\r\n printf(\"toCap: Grabbed lock 1\\n\");\r\n readFile(Data->file2);\r\n \r\n \r\n printf(\"toCap: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0); \r\n printf(\"toCap: Grabbed lock 0\\n\");\r\n \r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] > 'a' && Data->data[i] < 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n i++;\r\n }\r\n printf(\"toCap: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n printf(\"toCap: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int hasUnderscores = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *feluccas_sogging = 0;\r\n int citicism_zag;\r\n int maser_damageably;\r\n union cricetine_toader afflictionless_mythologize = {0};\r\n union cricetine_toader tingle_autacoidal;\r\n int siblee_ecophene = 110;\r\n char *congratulant_calyptratae;;\r\n if (__sync_bool_compare_and_swap(&politicalize_thickest,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&congratulant_calyptratae,\"4177\",siblee_ecophene);\r\n if (congratulant_calyptratae != 0) {;\r\n tingle_autacoidal . upperco_yaka = congratulant_calyptratae;\r\n afflictionless_mythologize = inviable_simon(tingle_autacoidal);\r\n maser_damageably = 5;\r\n while(1 == 1){\r\n maser_damageably = maser_damageably * 2;\r\n maser_damageably = maser_damageably + 2;\r\n if (maser_damageably > 1000) {\r\n break; \r\n }\r\n }\r\n citicism_zag = maser_damageably;\r\n feluccas_sogging = ((char *)afflictionless_mythologize . upperco_yaka);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(feluccas_sogging) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(feluccas_sogging) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(feluccas_sogging) + 1));\r\n if (Data->data) {\r\n if ((sscanf(feluccas_sogging, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n while(Data->data[i] != '\\0') { \r\n if (Data->data[i++] == '_') { \r\n hasUnderscores = 1;\r\n }\r\n }\r\n \r\n if (pthread_create(&t0, NULL, toCap, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (hasUnderscores == 1) {\r\n \r\n if (pthread_create(&t1, NULL, replace, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n }\r\n pthread_join(t0, NULL);\r\n if (hasUnderscores == 1) {\r\n pthread_join(t1, NULL);\r\n }\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (afflictionless_mythologize . upperco_yaka != 0) \r\n free(((char *)afflictionless_mythologize . upperco_yaka));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nunion cricetine_toader inviable_simon(union cricetine_toader reedified_sciurids)\r\n{\r\n ++global_variable;\r\n return reedified_sciurids;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n printf(\"toCap: Attempting to grab lock 0\\n\");\n pthread_mutex_lock(&mutex_0); \n printf(\"toCap: Grabbed lock 0\\n\");\n```", "cwe": "833"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint epiglottides_squad = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int *arr;\r\n \r\n pthread_mutex_lock(&mutex);\r\n readFile(Data->file1);\r\n arr = malloc(sizeof(int) * Data->qsize);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n \r\n \r\n \r\n \r\n \r\n for(i = 0; i < Data->data_size; i++) {\r\n \r\n if (Data->data[i] >= 'a' &&\r\n Data->data[i] <= 'z') { \r\n Data->data[i] -= 32;\r\n }\r\n }\r\n \r\n pthread_mutex_unlock(&mutex);\r\n return NULL;\r\n}\r\nvoid *delNonAlpha (void *data) {\r\n struct data *Data = (struct data*) data;\r\n int i = 0;\r\n int j = 0;\r\n char* temp = malloc(sizeof(char) * (Data->data_size + 1));\r\n \r\n while(Data->data[i] != '\\0') {\r\n if((Data->data[i] >= 'A' && Data->data[i] <= 'Z') ||\r\n (Data->data[i] >= 'a' && Data->data[i] <= 'z')) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[j++] = '\\0';\r\n Data->data_size = j;\r\n free(Data->data);\r\n \r\n \r\n Data->data = NULL; \r\n \r\n \r\n \r\n \r\n \r\n readFile(Data->file2);\r\n Data->data = temp;\r\n \r\n \r\n \r\n \r\n return NULL;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data;\r\n char *abiology_chunked = 0;\r\n int endogastrically_superenrollment;\r\n char **solutionist_spreads = 0;\r\n char **haplessnesses_subvocally = 0;\r\n int amygdule_empiry = 0;\r\n char *misyoke_thallodal = 0;\r\n int logistics_respots = 141;\r\n char *muskego_hexactinelline;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&epiglottides_squad,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&muskego_hexactinelline,\"6398\",logistics_respots);\r\n if (muskego_hexactinelline != 0) {;\r\n amygdule_empiry = ((int )(strlen(muskego_hexactinelline)));\r\n misyoke_thallodal = ((char *)(malloc(amygdule_empiry + 1)));\r\n if (misyoke_thallodal == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(misyoke_thallodal,0,amygdule_empiry + 1);\r\n memcpy(misyoke_thallodal,muskego_hexactinelline,amygdule_empiry);\r\n if (muskego_hexactinelline != 0) \r\n free(((char *)muskego_hexactinelline));\r\n endogastrically_superenrollment = 1;\r\n solutionist_spreads = &misyoke_thallodal;\r\n haplessnesses_subvocally = ((char **)(((unsigned long )solutionist_spreads) * endogastrically_superenrollment * endogastrically_superenrollment)) + 5;\r\n abiology_chunked = ((char *)( *(haplessnesses_subvocally - 5)));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(abiology_chunked) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(abiology_chunked) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(abiology_chunked) + 1));\r\n if (Data->data && Data->file1 && Data->file2) {\r\n if ((sscanf(abiology_chunked, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n if (pthread_mutex_init(&mutex, NULL) != 0) {\r\n printf(\"Mutex failed to initilize.\");\r\n }\r\n Data->data_size = strlen(Data->data);\r\n \r\n if (pthread_create(&t0, NULL, delNonAlpha, (void *)Data) != 0) { \r\n printf(\"Error creating thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toCap, (void *)Data) != 0) {\r\n printf(\"Error creating thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n printf(\"After joins.\\n\");\r\n pthread_mutex_destroy(&mutex);\r\n } else {\r\n printf(\"Error parsing input.\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ( *(haplessnesses_subvocally - 5) != 0) \r\n free(((char *)( *(haplessnesses_subvocally - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n for(i = 0; i < Data->data_size; i++) {\n \n if (Data->data[i] >= 'a' &&\n Data->data[i] <= 'z') { \n Data->data[i] -= 32;\n }\n }\n```", "cwe": "414"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "connection_ap_handshake_rewrite_and_attach(entry_connection_t *conn,\r\r\n origin_circuit_t *circ,\r\r\n crypt_path_t *cpath)\r\r\n{\r\r\n socks_request_t *socks = conn->socks_request;\r\r\n const or_options_t *options = get_options();\r\r\n connection_t *base_conn = ENTRY_TO_CONN(conn);\r\r\n time_t now = time(NULL);\r\r\n rewrite_result_t rr;\r\r\n\r\r\n /* First we'll do the rewrite part. Let's see if we get a reasonable\r\r\n * answer.\r\r\n */\r\r\n memset(&rr, 0, sizeof(rr));\r\r\n connection_ap_handshake_rewrite(conn,&rr);\r\r\n\r\r\n if (rr.should_close) {\r\r\n /* connection_ap_handshake_rewrite told us to close the connection:\r\r\n * either because it sent back an answer, or because it sent back an\r\r\n * error */\r\r\n connection_mark_unattached_ap(conn, rr.end_reason);\r\r\n if (END_STREAM_REASON_DONE == (rr.end_reason & END_STREAM_REASON_MASK))\r\r\n return 0;\r\r\n else\r\r\n return -1;\r\r\n }\r\r\n\r\r\n const time_t map_expires = rr.map_expires;\r\r\n const int automap = rr.automap;\r\r\n const addressmap_entry_source_t exit_source = rr.exit_source;\r\r\n\r\r\n /* Now, we parse the address to see if it's an .onion or .exit or\r\r\n * other special address.\r\r\n */\r\r\n const hostname_type_t addresstype = parse_extended_hostname(socks->address);\r\r\n\r\r\n /* Now see whether the hostname is bogus. This could happen because of an\r\r\n * onion hostname whose format we don't recognize. */\r\r\n if (addresstype == BAD_HOSTNAME) {\r\r\n control_event_client_status(LOG_WARN, \"SOCKS_BAD_HOSTNAME HOSTNAME=%s\",\r\r\n escaped(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n /* If this is a .exit hostname, strip off the .name.exit part, and\r\r\n * see whether we're willing to connect there, and and otherwise handle the\r\r\n * .exit address.\r\r\n *\r\r\n * We'll set chosen_exit_name and/or close the connection as appropriate.\r\r\n */\r\r\n if (addresstype == EXIT_HOSTNAME) {\r\r\n /* If StrictNodes is not set, then .exit overrides ExcludeNodes but\r\r\n * not ExcludeExitNodes. */\r\r\n routerset_t *excludeset = options->StrictNodes ?\r\r\n options->ExcludeExitNodesUnion_ : options->ExcludeExitNodes;\r\r\n const node_t *node = NULL;\r\r\n\r\r\n /* If this .exit was added by an AUTOMAP, then it came straight from\r\r\n * a user. Make sure that options->AllowDotExit permits that! */\r\r\n if (exit_source == ADDRMAPSRC_AUTOMAP && !options->AllowDotExit) {\r\r\n /* Whoops; this one is stale. It must have gotten added earlier,\r\r\n * when AllowDotExit was on. */\r\r\n log_warn(LD_APP,\"Stale automapped address for '%s.exit', with \"\r\r\n \"AllowDotExit disabled. Refusing.\",\r\r\n safe_str_client(socks->address));\r\r\n control_event_client_status(LOG_WARN, \"SOCKS_BAD_HOSTNAME HOSTNAME=%s\",\r\r\n escaped(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n /* Double-check to make sure there are no .exits coming from\r\r\n * impossible/weird sources. */\r\r\n if (exit_source == ADDRMAPSRC_DNS ||\r\r\n (exit_source == ADDRMAPSRC_NONE && !options->AllowDotExit)) {\r\r\n /* It shouldn't be possible to get a .exit address from any of these\r\r\n * sources. */\r\r\n log_warn(LD_BUG,\"Address '%s.exit', with impossible source for the \"\r\r\n \".exit part. Refusing.\",\r\r\n safe_str_client(socks->address));\r\r\n control_event_client_status(LOG_WARN, \"SOCKS_BAD_HOSTNAME HOSTNAME=%s\",\r\r\n escaped(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n tor_assert(!automap);\r\r\n\r\r\n /* Now, find the character before the .(name) part.\r\r\n * (The \".exit\" part got stripped off by \"parse_extended_hostname\").\r\r\n *\r\r\n * We're going to put the exit name into conn->chosen_exit_name, and\r\r\n * look up a node correspondingly. */\r\r\n char *s = strrchr(socks->address,'.');\r\r\n if (s) {\r\r\n /* The address was of the form \"(stuff).(name).exit */\r\r\n if (s[1] != '\\0') {\r\r\n /* Looks like a real .exit one. */\r\r\n conn->chosen_exit_name = tor_strdup(s+1);\r\r\n node = node_get_by_nickname(conn->chosen_exit_name, 1);\r\r\n\r\r\n if (exit_source == ADDRMAPSRC_TRACKEXIT) {\r\r\n /* We 5 tries before it expires the addressmap */\r\r\n conn->chosen_exit_retries = TRACKHOSTEXITS_RETRIES;\r\r\n }\r\r\n *s = 0;\r\r\n } else {\r\r\n /* Oops, the address was (stuff)..exit. That's not okay. */\r\r\n log_warn(LD_APP,\"Malformed exit address '%s.exit'. Refusing.\",\r\r\n safe_str_client(socks->address));\r\r\n control_event_client_status(LOG_WARN, \"SOCKS_BAD_HOSTNAME HOSTNAME=%s\",\r\r\n escaped(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n } else {\r\r\n /* It looks like they just asked for \"foo.exit\". That's a special\r\r\n * form that means (foo's address).foo.exit. */\r\r\n\r\r\n conn->chosen_exit_name = tor_strdup(socks->address);\r\r\n node = node_get_by_nickname(conn->chosen_exit_name, 1);\r\r\n if (node) {\r\r\n *socks->address = 0;\r\r\n node_get_address_string(node, socks->address, sizeof(socks->address));\r\r\n }\r\r\n }\r\r\n\r\r\n /* Now make sure that the chosen exit exists... */\r\r\n if (!node) {\r\r\n log_warn(LD_APP,\r\r\n \"Unrecognized relay in exit address '%s.exit'. Refusing.\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n /* ...and make sure that it isn't excluded. */\r\r\n if (routerset_contains_node(excludeset, node)) {\r\r\n log_warn(LD_APP,\r\r\n \"Excluded relay in exit address '%s.exit'. Refusing.\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n /* XXXX-1090 Should we also allow foo.bar.exit if ExitNodes is set and\r\r\n Bar is not listed in it? I say yes, but our revised manpage branch\r\r\n implies no. */\r\r\n }\r\r\n\r\r\n /* Now, we handle everything that isn't a .onion address. */\r\r\n if (addresstype != ONION_HOSTNAME) {\r\r\n /* Not a hidden-service request. It's either a hostname or an IP,\r\r\n * possibly with a .exit that we stripped off. We're going to check\r\r\n * if we're allowed to connect/resolve there, and then launch the\r\r\n * appropriate request. */\r\r\n\r\r\n /* Check for funny characters in the address. */\r\r\n if (address_is_invalid_destination(socks->address, 1)) {\r\r\n control_event_client_status(LOG_WARN, \"SOCKS_BAD_HOSTNAME HOSTNAME=%s\",\r\r\n escaped(socks->address));\r\r\n log_warn(LD_APP,\r\r\n \"Destination '%s' seems to be an invalid hostname. Failing.\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n#ifdef ENABLE_TOR2WEB_MODE\r\r\n /* If we're running in Tor2webMode, we don't allow anything BUT .onion\r\r\n * addresses. */\r\r\n if (options->Tor2webMode) {\r\r\n log_warn(LD_APP, \"Refusing to connect to non-hidden-service hostname \"\r\r\n \"or IP address %s because tor2web mode is enabled.\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n }\r\r\n#endif\r\r\n\r\r\n /* socks->address is a non-onion hostname or IP address.\r\r\n * If we can't do any non-onion requests, refuse the connection.\r\r\n * If we have a hostname but can't do DNS, refuse the connection.\r\r\n * If we have an IP address, but we can't use that address family,\r\r\n * refuse the connection.\r\r\n *\r\r\n * If we can do DNS requests, and we can use at least one address family,\r\r\n * then we have to resolve the address first. Then we'll know if it\r\r\n * resolves to a usable address family. */\r\r\n\r\r\n /* First, check if all non-onion traffic is disabled */\r\r\n if (!conn->entry_cfg.dns_request && !conn->entry_cfg.ipv4_traffic\r\r\n && !conn->entry_cfg.ipv6_traffic) {\r\r\n log_warn(LD_APP, \"Refusing to connect to non-hidden-service hostname \"\r\r\n \"or IP address %s because Port has OnionTrafficOnly set (or \"\r\r\n \"NoDNSRequest, NoIPv4Traffic, and NoIPv6Traffic).\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n /* Then check if we have a hostname or IP address, and whether DNS or\r\r\n * the IP address family are permitted. Reject if not. */\r\r\n tor_addr_t dummy_addr;\r\r\n int socks_family = tor_addr_parse(&dummy_addr, socks->address);\r\r\n /* family will be -1 for a non-onion hostname that's not an IP */\r\r\n if (socks_family == -1) {\r\r\n if (!conn->entry_cfg.dns_request) {\r\r\n log_warn(LD_APP, \"Refusing to connect to hostname %s \"\r\r\n \"because Port has NoDNSRequest set.\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n }\r\r\n } else if (socks_family == AF_INET) {\r\r\n if (!conn->entry_cfg.ipv4_traffic) {\r\r\n log_warn(LD_APP, \"Refusing to connect to IPv4 address %s because \"\r\r\n \"Port has NoIPv4Traffic set.\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n }\r\r\n } else if (socks_family == AF_INET6) {\r\r\n if (!conn->entry_cfg.ipv6_traffic) {\r\r\n log_warn(LD_APP, \"Refusing to connect to IPv6 address %s because \"\r\r\n \"Port has NoIPv6Traffic set.\",\r\r\n safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n }\r\r\n } else {\r\r\n tor_assert_nonfatal_unreached_once();\r\r\n }\r\r\n\r\r\n /* See if this is a hostname lookup that we can answer immediately.\r\r\n * (For example, an attempt to look up the IP address for an IP address.)\r\r\n */\r\r\n if (socks->command == SOCKS_COMMAND_RESOLVE) {\r\r\n tor_addr_t answer;\r\r\n /* Reply to resolves immediately if we can. */\r\r\n if (tor_addr_parse(&answer, socks->address) >= 0) {/* is it an IP? */\r\r\n /* remember _what_ is supposed to have been resolved. */\r\r\n strlcpy(socks->address, rr.orig_address, sizeof(socks->address));\r\r\n connection_ap_handshake_socks_resolved_addr(conn, &answer, -1,\r\r\n map_expires);\r\r\n connection_mark_unattached_ap(conn,\r\r\n END_STREAM_REASON_DONE |\r\r\n END_STREAM_REASON_FLAG_ALREADY_SOCKS_REPLIED);\r\r\n return 0;\r\r\n }\r\r\n tor_assert(!automap);\r\r\n rep_hist_note_used_resolve(now); /* help predict this next time */\r\r\n } else if (socks->command == SOCKS_COMMAND_CONNECT) {\r\r\n /* Now see if this is a connect request that we can reject immediately */\r\r\n\r\r\n tor_assert(!automap);\r\r\n /* Don't allow connections to port 0. */\r\r\n if (socks->port == 0) {\r\r\n log_notice(LD_APP,\"Application asked to connect to port 0. Refusing.\");\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n /* You can't make connections to internal addresses, by default.\r\r\n * Exceptions are begindir requests (where the address is meaningless),\r\r\n * or cases where you've hand-configured a particular exit, thereby\r\r\n * making the local address meaningful. */\r\r\n if (options->ClientRejectInternalAddresses &&\r\r\n !conn->use_begindir && !conn->chosen_exit_name && !circ) {\r\r\n /* If we reach this point then we don't want to allow internal\r\r\n * addresses. Check if we got one. */\r\r\n tor_addr_t addr;\r\r\n if (tor_addr_hostname_is_local(socks->address) ||\r\r\n (tor_addr_parse(&addr, socks->address) >= 0 &&\r\r\n tor_addr_is_internal(&addr, 0))) {\r\r\n /* If this is an explicit private address with no chosen exit node,\r\r\n * then we really don't want to try to connect to it. That's\r\r\n * probably an error. */\r\r\n if (conn->is_transparent_ap) {\r\r\n#define WARN_INTRVL_LOOP 300\r\r\n static ratelim_t loop_warn_limit = RATELIM_INIT(WARN_INTRVL_LOOP);\r\r\n char *m;\r\r\n if ((m = rate_limit_log(&loop_warn_limit, approx_time()))) {\r\r\n log_warn(LD_NET,\r\r\n \"Rejecting request for anonymous connection to private \"\r\r\n \"address %s on a TransPort or NATDPort. Possible loop \"\r\r\n \"in your NAT rules?%s\", safe_str_client(socks->address),\r\r\n m);\r\r\n tor_free(m);\r\r\n }\r\r\n } else {\r\r\n#define WARN_INTRVL_PRIV 300\r\r\n static ratelim_t priv_warn_limit = RATELIM_INIT(WARN_INTRVL_PRIV);\r\r\n char *m;\r\r\n if ((m = rate_limit_log(&priv_warn_limit, approx_time()))) {\r\r\n log_warn(LD_NET,\r\r\n \"Rejecting SOCKS request for anonymous connection to \"\r\r\n \"private address %s.%s\",\r\r\n safe_str_client(socks->address),m);\r\r\n tor_free(m);\r\r\n }\r\r\n }\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_PRIVATE_ADDR);\r\r\n return -1;\r\r\n }\r\r\n } /* end \"if we should check for internal addresses\" */\r\r\n\r\r\n /* Okay. We're still doing a CONNECT, and it wasn't a private\r\r\n * address. Here we do special handling for literal IP addresses,\r\r\n * to see if we should reject this preemptively, and to set up\r\r\n * fields in conn->entry_cfg to tell the exit what AF we want. */\r\r\n {\r\r\n tor_addr_t addr;\r\r\n /* XXX Duplicate call to tor_addr_parse. */\r\r\n if (tor_addr_parse(&addr, socks->address) >= 0) {\r\r\n /* If we reach this point, it's an IPv4 or an IPv6 address. */\r\r\n sa_family_t family = tor_addr_family(&addr);\r\r\n\r\r\n if ((family == AF_INET && ! conn->entry_cfg.ipv4_traffic) ||\r\r\n (family == AF_INET6 && ! conn->entry_cfg.ipv6_traffic)) {\r\r\n /* You can't do an IPv4 address on a v6-only socks listener,\r\r\n * or vice versa. */\r\r\n log_warn(LD_NET, \"Rejecting SOCKS request for an IP address \"\r\r\n \"family that this listener does not support.\");\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n } else if (family == AF_INET6 && socks->socks_version == 4) {\r\r\n /* You can't make a socks4 request to an IPv6 address. Socks4\r\r\n * doesn't support that. */\r\r\n log_warn(LD_NET, \"Rejecting SOCKS4 request for an IPv6 address.\");\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n } else if (socks->socks_version == 4 &&\r\r\n !conn->entry_cfg.ipv4_traffic) {\r\r\n /* You can't do any kind of Socks4 request when IPv4 is forbidden.\r\r\n *\r\r\n * XXX raise this check outside the enclosing block? */\r\r\n log_warn(LD_NET, \"Rejecting SOCKS4 request on a listener with \"\r\r\n \"no IPv4 traffic supported.\");\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n } else if (family == AF_INET6) {\r\r\n /* Tell the exit: we won't accept any ipv4 connection to an IPv6\r\r\n * address. */\r\r\n conn->entry_cfg.ipv4_traffic = 0;\r\r\n } else if (family == AF_INET) {\r\r\n /* Tell the exit: we won't accept any ipv6 connection to an IPv4\r\r\n * address. */\r\r\n conn->entry_cfg.ipv6_traffic = 0;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n /* we never allow IPv6 answers on socks4. (TODO: Is this smart?) */\r\r\n if (socks->socks_version == 4)\r\r\n conn->entry_cfg.ipv6_traffic = 0;\r\r\n\r\r\n /* Still handling CONNECT. Now, check for exit enclaves. (Which we\r\r\n * don't do on BEGINDIR, or when there is a chosen exit.)\r\r\n *\r\r\n * TODO: Should we remove this? Exit enclaves are nutty and don't\r\r\n * work very well\r\r\n */\r\r\n if (!conn->use_begindir && !conn->chosen_exit_name && !circ) {\r\r\n /* see if we can find a suitable enclave exit */\r\r\n const node_t *r =\r\r\n router_find_exact_exit_enclave(socks->address, socks->port);\r\r\n if (r) {\r\r\n log_info(LD_APP,\r\r\n \"Redirecting address %s to exit at enclave router %s\",\r\r\n safe_str_client(socks->address), node_describe(r));\r\r\n /* use the hex digest, not nickname, in case there are two\r\r\n routers with this nickname */\r\r\n conn->chosen_exit_name =\r\r\n tor_strdup(hex_str(r->identity, DIGEST_LEN));\r\r\n conn->chosen_exit_optional = 1;\r\r\n }\r\r\n }\r\r\n\r\r\n /* Still handling CONNECT: warn or reject if it's using a dangerous\r\r\n * port. */\r\r\n if (!conn->use_begindir && !conn->chosen_exit_name && !circ)\r\r\n if (consider_plaintext_ports(conn, socks->port) < 0)\r\r\n return -1;\r\r\n\r\r\n /* Remember the port so that we will predict that more requests\r\r\n there will happen in the future. */\r\r\n if (!conn->use_begindir) {\r\r\n /* help predict this next time */\r\r\n rep_hist_note_used_port(now, socks->port);\r\r\n }\r\r\n } else if (socks->command == SOCKS_COMMAND_RESOLVE_PTR) {\r\r\n rep_hist_note_used_resolve(now); /* help predict this next time */\r\r\n /* no extra processing needed */\r\r\n } else {\r\r\n /* We should only be doing CONNECT, RESOLVE, or RESOLVE_PTR! */\r\r\n tor_fragile_assert();\r\r\n }\r\r\n\r\r\n /* Okay. At this point we've set chosen_exit_name if needed, rewritten the\r\r\n * address, and decided not to reject it for any number of reasons. Now\r\r\n * mark the connection as waiting for a circuit, and try to attach it!\r\r\n */\r\r\n base_conn->state = AP_CONN_STATE_CIRCUIT_WAIT;\r\r\n\r\r\n /* If we were given a circuit to attach to, try to attach. Otherwise,\r\r\n * try to find a good one and attach to that. */\r\r\n int rv;\r\r\n if (circ) {\r\r\n rv = connection_ap_handshake_attach_chosen_circuit(conn, circ, cpath);\r\r\n } else {\r\r\n /* We'll try to attach it at the next event loop, or whenever\r\r\n * we call connection_ap_attach_pending() */\r\r\n connection_ap_mark_as_pending_circuit(conn);\r\r\n rv = 0;\r\r\n }\r\r\n\r\r\n /* If the above function returned 0 then we're waiting for a circuit.\r\r\n * if it returned 1, we're attached. Both are okay. But if it returned\r\r\n * -1, there was an error, so make sure the connection is marked, and\r\r\n * return -1. */\r\r\n if (rv < 0) {\r\r\n if (!base_conn->marked_for_close)\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n return 0;\r\r\n } else {\r\r\n /* If we get here, it's a request for a .onion address! */\r\r\n tor_assert(!automap);\r\r\n\r\r\n /* If .onion address requests are disabled, refuse the request */\r\r\n if (!conn->entry_cfg.onion_traffic) {\r\r\n log_warn(LD_APP, \"Onion address %s requested from a port with .onion \"\r\r\n \"disabled\", safe_str_client(socks->address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_ENTRYPOLICY);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n /* Check whether it's RESOLVE or RESOLVE_PTR. We don't handle those\r\r\n * for hidden service addresses. */\r\r\n if (SOCKS_COMMAND_IS_RESOLVE(socks->command)) {\r\r\n /* if it's a resolve request, fail it right now, rather than\r\r\n * building all the circuits and then realizing it won't work. */\r\r\n log_warn(LD_APP,\r\r\n \"Resolve requests to hidden services not allowed. Failing.\");\r\r\n connection_ap_handshake_socks_resolved(conn,RESOLVED_TYPE_ERROR,\r\r\n 0,NULL,-1,TIME_MAX);\r\r\n connection_mark_unattached_ap(conn,\r\r\n END_STREAM_REASON_SOCKSPROTOCOL |\r\r\n END_STREAM_REASON_FLAG_ALREADY_SOCKS_REPLIED);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n /* If we were passed a circuit, then we need to fail. .onion addresses\r\r\n * only work when we launch our own circuits for now. */\r\r\n if (circ) {\r\r\n log_warn(LD_CONTROL, \"Attachstream to a circuit is not \"\r\r\n \"supported for .onion addresses currently. Failing.\");\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n }\r\r\n\r\r\n /* Look up if we have client authorization configured for this hidden\r\r\n * service. If we do, associate it with the rend_data. */\r\r\n rend_service_authorization_t *client_auth =\r\r\n rend_client_lookup_service_authorization(socks->address);\r\r\n\r\r\n const uint8_t *cookie = NULL;\r\r\n rend_auth_type_t auth_type = REND_NO_AUTH;\r\r\n if (client_auth) {\r\r\n log_info(LD_REND, \"Using previously configured client authorization \"\r\r\n \"for hidden service request.\");\r\r\n auth_type = client_auth->auth_type;\r\r\n cookie = client_auth->descriptor_cookie;\r\r\n }\r\r\n\r\r\n /* Fill in the rend_data field so we can start doing a connection to\r\r\n * a hidden service. */\r\r\n rend_data_t *rend_data = ENTRY_TO_EDGE_CONN(conn)->rend_data =\r\r\n rend_data_client_create(socks->address, NULL, (char *) cookie,\r\r\n auth_type);\r\r\n if (rend_data == NULL) {\r\r\n return -1;\r\r\n }\r\r\n const char *onion_address = rend_data_get_address(rend_data);\r\r\n log_info(LD_REND,\"Got a hidden service request for ID '%s'\",\r\r\n safe_str_client(onion_address));\r\r\n\r\r\n /* Lookup the given onion address. If invalid, stop right now.\r\r\n * Otherwise, we might have it in the cache or not. */\r\r\n unsigned int refetch_desc = 0;\r\r\n rend_cache_entry_t *entry = NULL;\r\r\n const int rend_cache_lookup_result =\r\r\n rend_cache_lookup_entry(onion_address, -1, &entry);\r\r\n if (rend_cache_lookup_result < 0) {\r\r\n switch (-rend_cache_lookup_result) {\r\r\n case EINVAL:\r\r\n /* We should already have rejected this address! */\r\r\n log_warn(LD_BUG,\"Invalid service name '%s'\",\r\r\n safe_str_client(onion_address));\r\r\n connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);\r\r\n return -1;\r\r\n case ENOENT:\r\r\n /* We didn't have this; we should look it up. */\r\r\n refetch_desc = 1;\r\r\n break;\r\r\n default:\r\r\n log_warn(LD_BUG, \"Unknown cache lookup error %d\",\r\r\n rend_cache_lookup_result);\r\r\n return -1;\r\r\n }\r\r\n }\r\r\n\r\r\n /* Help predict that we'll want to do hidden service circuits in the\r\r\n * future. We're not sure if it will need a stable circuit yet, but\r\r\n * we know we'll need *something*. */\r\r\n rep_hist_note_used_internal(now, 0, 1);\r\r\n\r\r\n /* Now we have a descriptor but is it usable or not? If not, refetch.\r\r\n * Also, a fetch could have been requested if the onion address was not\r\r\n * found in the cache previously. */\r\r\n if (refetch_desc || !rend_client_any_intro_points_usable(entry)) {\r\r\n connection_ap_mark_as_non_pending_circuit(conn);\r\r\n base_conn->state = AP_CONN_STATE_RENDDESC_WAIT;\r\r\n log_info(LD_REND, \"Unknown descriptor %s. Fetching.\",\r\r\n safe_str_client(onion_address));\r\r\n rend_client_refetch_v2_renddesc(rend_data);\r\r\n return 0;\r\r\n }\r\r\n\r\r\n /* We have the descriptor! So launch a connection to the HS. */\r\r\n base_conn->state = AP_CONN_STATE_CIRCUIT_WAIT;\r\r\n log_info(LD_REND, \"Descriptor is here. Great.\");\r\r\n\r\r\n /* We'll try to attach it at the next event loop, or whenever\r\r\n * we call connection_ap_attach_pending() */\r\r\n connection_ap_mark_as_pending_circuit(conn);\r\r\n return 0;\r\r\n }\r\r\n\r\r\n return 0; /* unreached but keeps the compiler happy */\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint idiograph_alleman = 0;\r\nint global_variable;\r\n\r\nunion adenous_satsuma \r\n{\r\n char *evendown_vicing;\r\n double teamsters_polyplastic;\r\n char *craniognosy_hierarchic;\r\n char alg_paye;\r\n int asininities_lerne;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured);\r\nint toupper(int c) {\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n#define MEDIZE_MEMORYLESS(x) zygion_assmannshausen((union adenous_satsuma *) x)\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n union adenous_satsuma *dowdy_sofa = {0};\r\n union adenous_satsuma anisotropically_orientality;\r\n char *worship_bridesman;;\r\n if (__sync_bool_compare_and_swap(&idiograph_alleman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n worship_bridesman = getenv(\"HOOL_NONCARTELIZED\");\r\n if (worship_bridesman != 0) {;\r\n anisotropically_orientality . evendown_vicing = worship_bridesman;\r\n dowdy_sofa = &anisotropically_orientality;\r\n\tMEDIZE_MEMORYLESS(dowdy_sofa);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured)\r\n{\r\n int oc_i = 0;\r\n char stack_buffer_64[64];\r\n char *hirples_vindices = 0;\r\n ++global_variable;;\r\n hirples_vindices = ((char *)( *gynecomazia_cultured) . evendown_vicing);\r\n \r\n memset(stack_buffer_64,0,64);\r\n \r\n \r\n \r\n \r\n \r\n strcpy(stack_buffer_64,hirples_vindices);\r\n \r\n \r\n \r\n for (; oc_i < 64; ++oc_i) {\r\n stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",stack_buffer_64);\r\n \r\n \r\n \r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n;\nclose_printf_context();\n```", "cwe": "120"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "int main (int argc, char **argv) {\r\r\n int c;\r\r\n bool lock_memory = false;\r\r\n bool do_daemonize = false;\r\r\n bool preallocate = false;\r\r\n int maxcore = 0;\r\r\n char *username = NULL;\r\r\n char *pid_file = NULL;\r\r\n struct passwd *pw;\r\r\n struct rlimit rlim;\r\r\n char *buf;\r\r\n char unit = '\\0';\r\r\n int size_max = 0;\r\r\n int retval = EXIT_SUCCESS;\r\r\n /* listening sockets */\r\r\n static int *l_socket = NULL;\r\r\n\r\r\n /* udp socket */\r\r\n static int *u_socket = NULL;\r\r\n bool protocol_specified = false;\r\r\n bool tcp_specified = false;\r\r\n bool udp_specified = false;\r\r\n bool start_lru_maintainer = false;\r\r\n bool start_lru_crawler = false;\r\r\n enum hashfunc_type hash_type = JENKINS_HASH;\r\r\n uint32_t tocrawl;\r\r\n uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];\r\r\n bool use_slab_sizes = false;\r\r\n char *slab_sizes_unparsed = NULL;\r\r\n bool slab_chunk_size_changed = false;\r\r\n\r\r\n char *subopts, *subopts_orig;\r\r\n char *subopts_value;\r\r\n enum {\r\r\n MAXCONNS_FAST = 0,\r\r\n HASHPOWER_INIT,\r\r\n SLAB_REASSIGN,\r\r\n SLAB_AUTOMOVE,\r\r\n TAIL_REPAIR_TIME,\r\r\n HASH_ALGORITHM,\r\r\n LRU_CRAWLER,\r\r\n LRU_CRAWLER_SLEEP,\r\r\n LRU_CRAWLER_TOCRAWL,\r\r\n LRU_MAINTAINER,\r\r\n HOT_LRU_PCT,\r\r\n WARM_LRU_PCT,\r\r\n HOT_MAX_AGE,\r\r\n WARM_MAX_FACTOR,\r\r\n TEMPORARY_TTL,\r\r\n IDLE_TIMEOUT,\r\r\n WATCHER_LOGBUF_SIZE,\r\r\n WORKER_LOGBUF_SIZE,\r\r\n SLAB_SIZES,\r\r\n SLAB_CHUNK_MAX,\r\r\n TRACK_SIZES,\r\r\n NO_INLINE_ASCII_RESP,\r\r\n MODERN\r\r\n };\r\r\n char *const subopts_tokens[] = {\r\r\n [MAXCONNS_FAST] = \"maxconns_fast\",\r\r\n [HASHPOWER_INIT] = \"hashpower\",\r\r\n [SLAB_REASSIGN] = \"slab_reassign\",\r\r\n [SLAB_AUTOMOVE] = \"slab_automove\",\r\r\n [TAIL_REPAIR_TIME] = \"tail_repair_time\",\r\r\n [HASH_ALGORITHM] = \"hash_algorithm\",\r\r\n [LRU_CRAWLER] = \"lru_crawler\",\r\r\n [LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\",\r\r\n [LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\",\r\r\n [LRU_MAINTAINER] = \"lru_maintainer\",\r\r\n [HOT_LRU_PCT] = \"hot_lru_pct\",\r\r\n [WARM_LRU_PCT] = \"warm_lru_pct\",\r\r\n [HOT_MAX_AGE] = \"hot_max_age\",\r\r\n [WARM_MAX_FACTOR] = \"warm_max_factor\",\r\r\n [TEMPORARY_TTL] = \"temporary_ttl\",\r\r\n [IDLE_TIMEOUT] = \"idle_timeout\",\r\r\n [WATCHER_LOGBUF_SIZE] = \"watcher_logbuf_size\",\r\r\n [WORKER_LOGBUF_SIZE] = \"worker_logbuf_size\",\r\r\n [SLAB_SIZES] = \"slab_sizes\",\r\r\n [SLAB_CHUNK_MAX] = \"slab_chunk_max\",\r\r\n [TRACK_SIZES] = \"track_sizes\",\r\r\n [NO_INLINE_ASCII_RESP] = \"no_inline_ascii_resp\",\r\r\n [MODERN] = \"modern\",\r\r\n NULL\r\r\n };\r\r\n\r\r\n if (!sanitycheck()) {\r\r\n return EX_OSERR;\r\r\n }\r\r\n\r\r\n /* handle SIGINT and SIGTERM */\r\r\n signal(SIGINT, sig_handler);\r\r\n signal(SIGTERM, sig_handler);\r\r\n\r\r\n /* init settings */\r\r\n settings_init();\r\r\n\r\r\n /* Run regardless of initializing it later */\r\r\n init_lru_crawler();\r\r\n init_lru_maintainer();\r\r\n\r\r\n /* set stderr non-buffering (for running under, say, daemontools) */\r\r\n setbuf(stderr, NULL);\r\r\n\r\r\n /* process arguments */\r\r\n while (-1 != (c = getopt(argc, argv,\r\r\n \"a:\" /* access mask for unix socket */\r\r\n \"A\" /* enable admin shutdown commannd */\r\r\n \"p:\" /* TCP port number to listen on */\r\r\n \"s:\" /* unix socket path to listen on */\r\r\n \"U:\" /* UDP port number to listen on */\r\r\n \"m:\" /* max memory to use for items in megabytes */\r\r\n \"M\" /* return error on memory exhausted */\r\r\n \"c:\" /* max simultaneous connections */\r\r\n \"k\" /* lock down all paged memory */\r\r\n \"hiV\" /* help, licence info, version */\r\r\n \"r\" /* maximize core file limit */\r\r\n \"v\" /* verbose */\r\r\n \"d\" /* daemon mode */\r\r\n \"l:\" /* interface to listen on */\r\r\n \"u:\" /* user identity to run as */\r\r\n \"P:\" /* save PID in file */\r\r\n \"f:\" /* factor? */\r\r\n \"n:\" /* minimum space allocated for key+value+flags */\r\r\n \"t:\" /* threads */\r\r\n \"D:\" /* prefix delimiter? */\r\r\n \"L\" /* Large memory pages */\r\r\n \"R:\" /* max requests per event */\r\r\n \"C\" /* Disable use of CAS */\r\r\n \"b:\" /* backlog queue limit */\r\r\n \"B:\" /* Binding protocol */\r\r\n \"I:\" /* Max item size */\r\r\n \"S\" /* Sasl ON */\r\r\n \"F\" /* Disable flush_all */\r\r\n \"X\" /* Disable dump commands */\r\r\n \"o:\" /* Extended generic options */\r\r\n ))) {\r\r\n switch (c) {\r\r\n case 'A':\r\r\n /* enables \"shutdown\" command */\r\r\n settings.shutdown_command = true;\r\r\n break;\r\r\n\r\r\n case 'a':\r\r\n /* access for unix domain socket, as octal mask (like chmod)*/\r\r\n settings.access= strtol(optarg,NULL,8);\r\r\n break;\r\r\n\r\r\n case 'U':\r\r\n settings.udpport = atoi(optarg);\r\r\n udp_specified = true;\r\r\n break;\r\r\n case 'p':\r\r\n settings.port = atoi(optarg);\r\r\n tcp_specified = true;\r\r\n break;\r\r\n case 's':\r\r\n settings.socketpath = optarg;\r\r\n break;\r\r\n case 'm':\r\r\n settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\r\r\n break;\r\r\n case 'M':\r\r\n settings.evict_to_free = 0;\r\r\n break;\r\r\n case 'c':\r\r\n settings.maxconns = atoi(optarg);\r\r\n if (settings.maxconns <= 0) {\r\r\n fprintf(stderr, \"Maximum connections must be greater than 0\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case 'h':\r\r\n usage();\r\r\n exit(EXIT_SUCCESS);\r\r\n case 'i':\r\r\n usage_license();\r\r\n exit(EXIT_SUCCESS);\r\r\n case 'V':\r\r\n printf(PACKAGE \" \" VERSION \"\\n\");\r\r\n exit(EXIT_SUCCESS);\r\r\n case 'k':\r\r\n lock_memory = true;\r\r\n break;\r\r\n case 'v':\r\r\n settings.verbose++;\r\r\n break;\r\r\n case 'l':\r\r\n if (settings.inter != NULL) {\r\r\n if (strstr(settings.inter, optarg) != NULL) {\r\r\n break;\r\r\n }\r\r\n size_t len = strlen(settings.inter) + strlen(optarg) + 2;\r\r\n char *p = malloc(len);\r\r\n if (p == NULL) {\r\r\n fprintf(stderr, \"Failed to allocate memory\\n\");\r\r\n return 1;\r\r\n }\r\r\n snprintf(p, len, \"%s,%s\", settings.inter, optarg);\r\r\n free(settings.inter);\r\r\n settings.inter = p;\r\r\n } else {\r\r\n settings.inter= strdup(optarg);\r\r\n }\r\r\n break;\r\r\n case 'd':\r\r\n do_daemonize = true;\r\r\n break;\r\r\n case 'r':\r\r\n maxcore = 1;\r\r\n break;\r\r\n case 'R':\r\r\n settings.reqs_per_event = atoi(optarg);\r\r\n if (settings.reqs_per_event == 0) {\r\r\n fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case 'u':\r\r\n username = optarg;\r\r\n break;\r\r\n case 'P':\r\r\n pid_file = optarg;\r\r\n break;\r\r\n case 'f':\r\r\n settings.factor = atof(optarg);\r\r\n if (settings.factor <= 1.0) {\r\r\n fprintf(stderr, \"Factor must be greater than 1\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case 'n':\r\r\n settings.chunk_size = atoi(optarg);\r\r\n if (settings.chunk_size == 0) {\r\r\n fprintf(stderr, \"Chunk size must be greater than 0\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case 't':\r\r\n settings.num_threads = atoi(optarg);\r\r\n if (settings.num_threads <= 0) {\r\r\n fprintf(stderr, \"Number of threads must be greater than 0\\n\");\r\r\n return 1;\r\r\n }\r\r\n /* There're other problems when you get above 64 threads.\r\r\n * In the future we should portably detect # of cores for the\r\r\n * default.\r\r\n */\r\r\n if (settings.num_threads > 64) {\r\r\n fprintf(stderr, \"WARNING: Setting a high number of worker\"\r\r\n \"threads is not recommended.\\n\"\r\r\n \" Set this value to the number of cores in\"\r\r\n \" your machine or less.\\n\");\r\r\n }\r\r\n break;\r\r\n case 'D':\r\r\n if (! optarg || ! optarg[0]) {\r\r\n fprintf(stderr, \"No delimiter specified\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.prefix_delimiter = optarg[0];\r\r\n settings.detail_enabled = 1;\r\r\n break;\r\r\n case 'L' :\r\r\n if (enable_large_pages() == 0) {\r\r\n preallocate = true;\r\r\n } else {\r\r\n fprintf(stderr, \"Cannot enable large pages on this system\\n\"\r\r\n \"(There is no Linux support as of this version)\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case 'C' :\r\r\n settings.use_cas = false;\r\r\n break;\r\r\n case 'b' :\r\r\n settings.backlog = atoi(optarg);\r\r\n break;\r\r\n case 'B':\r\r\n protocol_specified = true;\r\r\n if (strcmp(optarg, \"auto\") == 0) {\r\r\n settings.binding_protocol = negotiating_prot;\r\r\n } else if (strcmp(optarg, \"binary\") == 0) {\r\r\n settings.binding_protocol = binary_prot;\r\r\n } else if (strcmp(optarg, \"ascii\") == 0) {\r\r\n settings.binding_protocol = ascii_prot;\r\r\n } else {\r\r\n fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"\r\r\n \" -- should be one of auto, binary, or ascii\\n\", optarg);\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n break;\r\r\n case 'I':\r\r\n buf = strdup(optarg);\r\r\n unit = buf[strlen(buf)-1];\r\r\n if (unit == 'k' || unit == 'm' ||\r\r\n unit == 'K' || unit == 'M') {\r\r\n buf[strlen(buf)-1] = '\\0';\r\r\n size_max = atoi(buf);\r\r\n if (unit == 'k' || unit == 'K')\r\r\n size_max *= 1024;\r\r\n if (unit == 'm' || unit == 'M')\r\r\n size_max *= 1024 * 1024;\r\r\n settings.item_size_max = size_max;\r\r\n } else {\r\r\n settings.item_size_max = atoi(buf);\r\r\n }\r\r\n free(buf);\r\r\n if (settings.item_size_max < 1024) {\r\r\n fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");\r\r\n return 1;\r\r\n }\r\r\n if (settings.item_size_max > (settings.maxbytes / 4)) {\r\r\n fprintf(stderr, \"Cannot set item size limit higher than 1/4 of memory max.\\n\");\r\r\n return 1;\r\r\n }\r\r\n if (settings.item_size_max > (1024 * 1024 * 1024)) {\r\r\n fprintf(stderr, \"Cannot set item size limit higher than a gigabyte.\\n\");\r\r\n return 1;\r\r\n }\r\r\n if (settings.item_size_max > 1024 * 1024) {\r\r\n if (!slab_chunk_size_changed) {\r\r\n settings.slab_chunk_size_max = 524288;\r\r\n }\r\r\n }\r\r\n break;\r\r\n case 'S': /* set Sasl authentication to true. Default is false */\r\r\n#ifndef ENABLE_SASL\r\r\n fprintf(stderr, \"This server is not built with SASL support.\\n\");\r\r\n exit(EX_USAGE);\r\r\n#endif\r\r\n settings.sasl = true;\r\r\n break;\r\r\n case 'F' :\r\r\n settings.flush_enabled = false;\r\r\n break;\r\r\n case 'X' :\r\r\n settings.dump_enabled = false;\r\r\n break;\r\r\n case 'o': /* It's sub-opts time! */\r\r\n subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */\r\r\n\r\r\n while (*subopts != '\\0') {\r\r\n\r\r\n switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {\r\r\n case MAXCONNS_FAST:\r\r\n settings.maxconns_fast = true;\r\r\n break;\r\r\n case HASHPOWER_INIT:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing numeric argument for hashpower\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.hashpower_init = atoi(subopts_value);\r\r\n if (settings.hashpower_init < 12) {\r\r\n fprintf(stderr, \"Initial hashtable multiplier of %d is too low\\n\",\r\r\n settings.hashpower_init);\r\r\n return 1;\r\r\n } else if (settings.hashpower_init > 64) {\r\r\n fprintf(stderr, \"Initial hashtable multiplier of %d is too high\\n\"\r\r\n \"Choose a value based on \\\"STAT hash_power_level\\\" from a running instance\\n\",\r\r\n settings.hashpower_init);\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case SLAB_REASSIGN:\r\r\n settings.slab_reassign = true;\r\r\n break;\r\r\n case SLAB_AUTOMOVE:\r\r\n if (subopts_value == NULL) {\r\r\n settings.slab_automove = 1;\r\r\n break;\r\r\n }\r\r\n settings.slab_automove = atoi(subopts_value);\r\r\n if (settings.slab_automove < 0 || settings.slab_automove > 2) {\r\r\n fprintf(stderr, \"slab_automove must be between 0 and 2\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case TAIL_REPAIR_TIME:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing numeric argument for tail_repair_time\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.tail_repair_time = atoi(subopts_value);\r\r\n if (settings.tail_repair_time < 10) {\r\r\n fprintf(stderr, \"Cannot set tail_repair_time to less than 10 seconds\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case HASH_ALGORITHM:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing hash_algorithm argument\\n\");\r\r\n return 1;\r\r\n };\r\r\n if (strcmp(subopts_value, \"jenkins\") == 0) {\r\r\n hash_type = JENKINS_HASH;\r\r\n } else if (strcmp(subopts_value, \"murmur3\") == 0) {\r\r\n hash_type = MURMUR3_HASH;\r\r\n } else {\r\r\n fprintf(stderr, \"Unknown hash_algorithm option (jenkins, murmur3)\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case LRU_CRAWLER:\r\r\n start_lru_crawler = true;\r\r\n break;\r\r\n case LRU_CRAWLER_SLEEP:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing lru_crawler_sleep value\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.lru_crawler_sleep = atoi(subopts_value);\r\r\n if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {\r\r\n fprintf(stderr, \"LRU crawler sleep must be between 0 and 1 second\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case LRU_CRAWLER_TOCRAWL:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing lru_crawler_tocrawl value\\n\");\r\r\n return 1;\r\r\n }\r\r\n if (!safe_strtoul(subopts_value, &tocrawl)) {\r\r\n fprintf(stderr, \"lru_crawler_tocrawl takes a numeric 32bit value\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.lru_crawler_tocrawl = tocrawl;\r\r\n break;\r\r\n case LRU_MAINTAINER:\r\r\n start_lru_maintainer = true;\r\r\n settings.lru_segmented = true;\r\r\n break;\r\r\n case HOT_LRU_PCT:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing hot_lru_pct argument\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.hot_lru_pct = atoi(subopts_value);\r\r\n if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {\r\r\n fprintf(stderr, \"hot_lru_pct must be > 1 and < 80\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case WARM_LRU_PCT:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing warm_lru_pct argument\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.warm_lru_pct = atoi(subopts_value);\r\r\n if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {\r\r\n fprintf(stderr, \"warm_lru_pct must be > 1 and < 80\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case HOT_MAX_AGE:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing hot_max_age argument\\n\");\r\r\n return 1;\r\r\n }\r\r\n if (!safe_strtoul(subopts_value, &settings.hot_max_age)) {\r\r\n fprintf(stderr, \"invalid argument to hot_max_age\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case WARM_MAX_FACTOR:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing warm_max_factor argument\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.warm_max_factor = atof(subopts_value);\r\r\n if (settings.warm_max_factor <= 0) {\r\r\n fprintf(stderr, \"warm_max_factor must be > 0\\n\");\r\r\n return 1;\r\r\n }\r\r\n break;\r\r\n case TEMPORARY_TTL:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing temporary_ttl argument\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.temp_lru = true;\r\r\n settings.temporary_ttl = atoi(subopts_value);\r\r\n break;\r\r\n case IDLE_TIMEOUT:\r\r\n settings.idle_timeout = atoi(subopts_value);\r\r\n break;\r\r\n case WATCHER_LOGBUF_SIZE:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing watcher_logbuf_size argument\\n\");\r\r\n return 1;\r\r\n }\r\r\n if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {\r\r\n fprintf(stderr, \"could not parse argument to watcher_logbuf_size\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.logger_watcher_buf_size *= 1024; /* kilobytes */\r\r\n break;\r\r\n case WORKER_LOGBUF_SIZE:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing worker_logbuf_size argument\\n\");\r\r\n return 1;\r\r\n }\r\r\n if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {\r\r\n fprintf(stderr, \"could not parse argument to worker_logbuf_size\\n\");\r\r\n return 1;\r\r\n }\r\r\n settings.logger_buf_size *= 1024; /* kilobytes */\r\r\n case SLAB_SIZES:\r\r\n slab_sizes_unparsed = subopts_value;\r\r\n break;\r\r\n case SLAB_CHUNK_MAX:\r\r\n if (subopts_value == NULL) {\r\r\n fprintf(stderr, \"Missing slab_chunk_max argument\\n\");\r\r\n }\r\r\n if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {\r\r\n fprintf(stderr, \"could not parse argument to slab_chunk_max\\n\");\r\r\n }\r\r\n slab_chunk_size_changed = true;\r\r\n break;\r\r\n case TRACK_SIZES:\r\r\n item_stats_sizes_init();\r\r\n break;\r\r\n case NO_INLINE_ASCII_RESP:\r\r\n settings.inline_ascii_response = false;\r\r\n break;\r\r\n case MODERN:\r\r\n /* Modernized defaults. Need to add equivalent no_* flags\r\r\n * before making truly default. */\r\r\n\r\r\n if (!slab_chunk_size_changed) {\r\r\n settings.slab_chunk_size_max = 524288;\r\r\n }\r\r\n settings.slab_reassign = true;\r\r\n settings.slab_automove = 1;\r\r\n settings.maxconns_fast = true;\r\r\n settings.inline_ascii_response = false;\r\r\n settings.lru_segmented = true;\r\r\n hash_type = MURMUR3_HASH;\r\r\n start_lru_crawler = true;\r\r\n start_lru_maintainer = true;\r\r\n break;\r\r\n default:\r\r\n printf(\"Illegal suboption \\\"%s\\\"\\n\", subopts_value);\r\r\n return 1;\r\r\n }\r\r\n\r\r\n }\r\r\n free(subopts_orig);\r\r\n break;\r\r\n default:\r\r\n fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\r\r\n return 1;\r\r\n }\r\r\n }\r\r\n\r\r\n if (settings.slab_chunk_size_max > settings.item_size_max) {\r\r\n fprintf(stderr, \"slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\\n\",\r\r\n settings.slab_chunk_size_max, settings.item_size_max);\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n\r\r\n if (settings.item_size_max % settings.slab_chunk_size_max != 0) {\r\r\n fprintf(stderr, \"-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\\n\",\r\r\n settings.item_size_max, settings.slab_chunk_size_max);\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n\r\r\n if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {\r\r\n fprintf(stderr, \"slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\\n\",\r\r\n settings.slab_chunk_size_max, settings.slab_page_size);\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n\r\r\n /*if (settings.slab_chunk_size_max == 16384 && settings.factor == 1.25) {\r\r\n settings.factor = 1.08;\r\r\n }*/\r\r\n\r\r\n if (slab_sizes_unparsed != NULL) {\r\r\n if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {\r\r\n use_slab_sizes = true;\r\r\n } else {\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n }\r\r\n\r\r\n if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {\r\r\n fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n\r\r\n if (settings.temp_lru && !start_lru_maintainer) {\r\r\n fprintf(stderr, \"temporary_ttl requires lru_maintainer to be enabled\\n\");\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n\r\r\n if (hash_init(hash_type) != 0) {\r\r\n fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n\r\r\n /*\r\r\n * Use one workerthread to serve each UDP port if the user specified\r\r\n * multiple ports\r\r\n */\r\r\n if (settings.inter != NULL && strchr(settings.inter, ',')) {\r\r\n settings.num_threads_per_udp = 1;\r\r\n } else {\r\r\n settings.num_threads_per_udp = settings.num_threads;\r\r\n }\r\r\n\r\r\n if (settings.sasl) {\r\r\n if (!protocol_specified) {\r\r\n settings.binding_protocol = binary_prot;\r\r\n } else {\r\r\n if (settings.binding_protocol != binary_prot) {\r\r\n fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (tcp_specified && !udp_specified) {\r\r\n settings.udpport = settings.port;\r\r\n } else if (udp_specified && !tcp_specified) {\r\r\n settings.port = settings.udpport;\r\r\n }\r\r\n\r\r\n if (maxcore != 0) {\r\r\n struct rlimit rlim_new;\r\r\n /*\r\r\n * First try raising to infinity; if that fails, try bringing\r\r\n * the soft limit to the hard.\r\r\n */\r\r\n if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\r\r\n rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\r\r\n if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\r\r\n /* failed. try raising just to the old max */\r\r\n rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\r\r\n (void)setrlimit(RLIMIT_CORE, &rlim_new);\r\r\n }\r\r\n }\r\r\n /*\r\r\n * getrlimit again to see what we ended up with. Only fail if\r\r\n * the soft limit ends up 0, because then no core files will be\r\r\n * created at all.\r\r\n */\r\r\n\r\r\n if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\r\r\n fprintf(stderr, \"failed to ensure corefile creation\\n\");\r\r\n exit(EX_OSERR);\r\r\n }\r\r\n }\r\r\n\r\r\n /*\r\r\n * If needed, increase rlimits to allow as many connections\r\r\n * as needed.\r\r\n */\r\r\n\r\r\n if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\r\r\n fprintf(stderr, \"failed to getrlimit number of files\\n\");\r\r\n exit(EX_OSERR);\r\r\n } else {\r\r\n rlim.rlim_cur = settings.maxconns;\r\r\n rlim.rlim_max = settings.maxconns;\r\r\n if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\r\r\n fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");\r\r\n exit(EX_OSERR);\r\r\n }\r\r\n }\r\r\n\r\r\n /* lose root privileges if we have them */\r\r\n if (getuid() == 0 || geteuid() == 0) {\r\r\n if (username == 0 || *username == '\\0') {\r\r\n fprintf(stderr, \"can't run as root without the -u switch\\n\");\r\r\n exit(EX_USAGE);\r\r\n }\r\r\n if ((pw = getpwnam(username)) == 0) {\r\r\n fprintf(stderr, \"can't find the user %s to switch to\\n\", username);\r\r\n exit(EX_NOUSER);\r\r\n }\r\r\n if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\r\r\n fprintf(stderr, \"failed to assume identity of user %s\\n\", username);\r\r\n exit(EX_OSERR);\r\r\n }\r\r\n }\r\r\n\r\r\n /* Initialize Sasl if -S was specified */\r\r\n if (settings.sasl) {\r\r\n init_sasl();\r\r\n }\r\r\n\r\r\n /* daemonize if requested */\r\r\n /* if we want to ensure our ability to dump core, don't chdir to / */\r\r\n if (do_daemonize) {\r\r\n if (sigignore(SIGHUP) == -1) {\r\r\n perror(\"Failed to ignore SIGHUP\");\r\r\n }\r\r\n if (daemonize(maxcore, settings.verbose) == -1) {\r\r\n fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\r\r\n exit(EXIT_FAILURE);\r\r\n }\r\r\n }\r\r\n\r\r\n /* lock paged memory if needed */\r\r\n if (lock_memory) {\r\r\n#ifdef HAVE_MLOCKALL\r\r\n int res = mlockall(MCL_CURRENT | MCL_FUTURE);\r\r\n if (res != 0) {\r\r\n fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",\r\r\n strerror(errno));\r\r\n }\r\r\n#else\r\r\n fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform. proceeding without.\\n\");\r\r\n#endif\r\r\n }\r\r\n\r\r\n /* initialize main thread libevent instance */\r\r\n main_base = event_init();\r\r\n\r\r\n /* initialize other stuff */\r\r\n logger_init();\r\r\n stats_init();\r\r\n assoc_init(settings.hashpower_init);\r\r\n conn_init();\r\r\n slabs_init(settings.maxbytes, settings.factor, preallocate,\r\r\n use_slab_sizes ? slab_sizes : NULL);\r\r\n\r\r\n /*\r\r\n * ignore SIGPIPE signals; we can use errno == EPIPE if we\r\r\n * need that information\r\r\n */\r\r\n if (sigignore(SIGPIPE) == -1) {\r\r\n perror(\"failed to ignore SIGPIPE; sigaction\");\r\r\n exit(EX_OSERR);\r\r\n }\r\r\n /* start up worker threads if MT mode */\r\r\n memcached_thread_init(settings.num_threads);\r\r\n\r\r\n if (start_assoc_maintenance_thread() == -1) {\r\r\n exit(EXIT_FAILURE);\r\r\n }\r\r\n\r\r\n if (start_lru_crawler && start_item_crawler_thread() != 0) {\r\r\n fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");\r\r\n exit(EXIT_FAILURE);\r\r\n }\r\r\n\r\r\n if (start_lru_maintainer && start_lru_maintainer_thread() != 0) {\r\r\n fprintf(stderr, \"Failed to enable LRU maintainer thread\\n\");\r\r\n return 1;\r\r\n }\r\r\n\r\r\n if (settings.slab_reassign &&\r\r\n start_slab_maintenance_thread() == -1) {\r\r\n exit(EXIT_FAILURE);\r\r\n }\r\r\n\r\r\n if (settings.idle_timeout && start_conn_timeout_thread() == -1) {\r\r\n exit(EXIT_FAILURE);\r\r\n }\r\r\n\r\r\n /* initialise clock event */\r\r\n clock_handler(0, 0, 0);\r\r\n\r\r\n /* create unix mode sockets after dropping privileges */\r\r\n if (settings.socketpath != NULL) {\r\r\n errno = 0;\r\r\n if (server_socket_unix(settings.socketpath,settings.access)) {\r\r\n vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\r\r\n exit(EX_OSERR);\r\r\n }\r\r\n }\r\r\n\r\r\n /* create the listening socket, bind it, and init */\r\r\n if (settings.socketpath == NULL) {\r\r\n const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\r\r\n char *temp_portnumber_filename = NULL;\r\r\n size_t len;\r\r\n FILE *portnumber_file = NULL;\r\r\n\r\r\n if (portnumber_filename != NULL) {\r\r\n len = strlen(portnumber_filename)+4+1;\r\r\n temp_portnumber_filename = malloc(len);\r\r\n snprintf(temp_portnumber_filename,\r\r\n len,\r\r\n \"%s.lck\", portnumber_filename);\r\r\n\r\r\n portnumber_file = fopen(temp_portnumber_filename, \"a\");\r\r\n if (portnumber_file == NULL) {\r\r\n fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\r\r\n temp_portnumber_filename, strerror(errno));\r\r\n }\r\r\n }\r\r\n\r\r\n errno = 0;\r\r\n if (settings.port && server_sockets(settings.port, tcp_transport,\r\r\n portnumber_file)) {\r\r\n vperror(\"failed to listen on TCP port %d\", settings.port);\r\r\n exit(EX_OSERR);\r\r\n }\r\r\n\r\r\n /*\r\r\n * initialization order: first create the listening sockets\r\r\n * (may need root on low ports), then drop root if needed,\r\r\n * then daemonise if needed, then init libevent (in some cases\r\r\n * descriptors created by libevent wouldn't survive forking).\r\r\n */\r\r\n\r\r\n /* create the UDP listening socket and bind it */\r\r\n errno = 0;\r\r\n if (settings.udpport && server_sockets(settings.udpport, udp_transport,\r\r\n portnumber_file)) {\r\r\n vperror(\"failed to listen on UDP port %d\", settings.udpport);\r\r\n exit(EX_OSERR);\r\r\n }\r\r\n\r\r\n if (portnumber_file) {\r\r\n fclose(portnumber_file);\r\r\n rename(temp_portnumber_filename, portnumber_filename);\r\r\n free(temp_portnumber_filename);\r\r\n }\r\r\n }\r\r\n\r\r\n /* Give the sockets a moment to open. I know this is dumb, but the error\r\r\n * is only an advisory.\r\r\n */\r\r\n usleep(1000);\r\r\n if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {\r\r\n fprintf(stderr, \"Maxconns setting is too low, use -c to increase.\\n\");\r\r\n exit(EXIT_FAILURE);\r\r\n }\r\r\n\r\r\n if (pid_file != NULL) {\r\r\n save_pid(pid_file);\r\r\n }\r\r\n\r\r\n /* Drop privileges no longer needed */\r\r\n drop_privileges();\r\r\n\r\r\n /* Initialize the uriencode lookup table. */\r\r\n uriencode_init();\r\r\n\r\r\n /* enter the event loop */\r\r\n if (event_base_loop(main_base, 0) != 0) {\r\r\n retval = EXIT_FAILURE;\r\r\n }\r\r\n\r\r\n stop_assoc_maintenance_thread();\r\r\n\r\r\n /* remove the PID file if we're a daemon */\r\r\n if (do_daemonize)\r\r\n remove_pidfile(pid_file);\r\r\n /* Clean up strdup() call for bind() address */\r\r\n if (settings.inter)\r\r\n free(settings.inter);\r\r\n if (l_socket)\r\r\n free(l_socket);\r\r\n if (u_socket)\r\r\n free(u_socket);\r\r\n\r\r\n return retval;\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "interp(i_ctx_t **pi_ctx_p /* context for execution, updated if resched */,\r\r\n const ref * pref /* object to interpret */,\r\r\n ref * perror_object)\r\r\n{\r\r\n i_ctx_t *i_ctx_p = *pi_ctx_p;\r\r\n /*\r\r\n * Note that iref may actually be either a ref * or a ref_packed *.\r\r\n * Certain DEC compilers assume that a ref * is ref-aligned even if it\r\r\n * is cast to a short *, and generate code on this assumption, leading\r\r\n * to \"unaligned access\" errors. For this reason, we declare\r\r\n * iref_packed, and use a macro to cast it to the more aligned type\r\r\n * where necessary (which is almost everywhere it is used). This may\r\r\n * lead to compiler warnings about \"cast increases alignment\r\r\n * requirements\", but this is less harmful than expensive traps at run\r\r\n * time.\r\r\n */\r\r\n register const ref_packed *iref_packed = (const ref_packed *)pref;\r\r\n /*\r\r\n * To make matters worse, some versions of gcc/egcs have a bug that\r\r\n * leads them to assume that if iref_packed is EVER cast to a ref *,\r\r\n * it is ALWAYS ref-aligned. We detect this in stdpre.h and provide\r\r\n * the following workaround:\r\r\n */\r\r\n#ifdef ALIGNMENT_ALIASING_BUG\r\r\n const ref *iref_temp;\r\r\n# define IREF (iref_temp = (const ref *)iref_packed, iref_temp)\r\r\n#else\r\r\n# define IREF ((const ref *)iref_packed)\r\r\n#endif\r\r\n#define SET_IREF(rp) (iref_packed = (const ref_packed *)(rp))\r\r\n register int icount = 0; /* # of consecutive tokens at iref */\r\r\n register os_ptr iosp = osp; /* private copy of osp */\r\r\n register es_ptr iesp = esp; /* private copy of esp */\r\r\n int code;\r\r\n ref token; /* token read from file or string, */\r\r\n /* must be declared in this scope */\r\r\n ref *pvalue;\r\r\n ref refnull;\r\r\n uint opindex; /* needed for oparrays */\r\r\n os_ptr whichp;\r\r\n\r\r\n /*\r\r\n * We have to make the error information into a struct;\r\r\n * otherwise, the Watcom compiler will assign it to registers\r\r\n * strictly on the basis of textual frequency.\r\r\n * We also have to use ref_assign_inline everywhere, and\r\r\n * avoid direct assignments of refs, so that esi and edi\r\r\n * will remain available on Intel processors.\r\r\n */\r\r\n struct interp_error_s {\r\r\n int code;\r\r\n int line;\r\r\n const ref *obj;\r\r\n ref full;\r\r\n } ierror;\r\r\n\r\r\n /*\r\r\n * Get a pointer to the name table so that we can use the\r\r\n * inline version of name_index_ref.\r\r\n */\r\r\n const name_table *const int_nt = imemory->gs_lib_ctx->gs_name_table;\r\r\n\r\r\n#define set_error(ecode)\\\r\r\n { ierror.code = ecode; ierror.line = __LINE__; }\r\r\n#define return_with_error(ecode, objp)\\\r\r\n { set_error(ecode); ierror.obj = objp; goto rwe; }\r\r\n#define return_with_error_iref(ecode)\\\r\r\n { set_error(ecode); goto rwei; }\r\r\n#define return_with_code_iref()\\\r\r\n { ierror.line = __LINE__; goto rweci; }\r\r\n#define return_with_stackoverflow(objp)\\\r\r\n { o_stack.requested = 1; return_with_error(gs_error_stackoverflow, objp); }\r\r\n#define return_with_stackoverflow_iref()\\\r\r\n { o_stack.requested = 1; return_with_error_iref(gs_error_stackoverflow); }\r\r\n/*\r\r\n * If control reaches the special operators (x_add, etc.) as a result of\r\r\n * interpreting an executable name, iref points to the name, not the\r\r\n * operator, so the name rather than the operator becomes the error object,\r\r\n * which is wrong. We detect and handle this case explicitly when an error\r\r\n * occurs, so as not to slow down the non-error case.\r\r\n */\r\r\n#define return_with_error_tx_op(err_code)\\\r\r\n { if (r_has_type(IREF, t_name)) {\\\r\r\n return_with_error(err_code, pvalue);\\\r\r\n } else {\\\r\r\n return_with_error_iref(err_code);\\\r\r\n }\\\r\r\n }\r\r\n\r\r\n int *ticks_left = &imemory_system->gs_lib_ctx->gcsignal;\r\r\n\r\r\n#if defined(DEBUG_TRACE_PS_OPERATORS) || defined(DEBUG)\r\r\n int (*call_operator_fn)(op_proc_t, i_ctx_t *) = do_call_operator;\r\r\n\r\r\n if (gs_debug_c('!'))\r\r\n call_operator_fn = do_call_operator_verbose;\r\r\n#endif\r\r\n\r\r\n *ticks_left = i_ctx_p->time_slice_ticks;\r\r\n\r\r\n make_null(&ierror.full);\r\r\n ierror.obj = &ierror.full;\r\r\n make_null(&refnull);\r\r\n pvalue = &refnull;\r\r\n\r\r\n /*\r\r\n * If we exceed the VMThreshold, set *ticks_left to -100\r\r\n * to alert the interpreter that we need to garbage collect.\r\r\n */\r\r\n set_gc_signal(i_ctx_p, -100);\r\r\n\r\r\n esfile_clear_cache();\r\r\n /*\r\r\n * From here on, if icount > 0, iref and icount correspond\r\r\n * to the top entry on the execution stack: icount is the count\r\r\n * of sequential entries remaining AFTER the current one.\r\r\n */\r\r\n#define IREF_NEXT(ip)\\\r\r\n ((const ref_packed *)((const ref *)(ip) + 1))\r\r\n#define IREF_NEXT_EITHER(ip)\\\r\r\n ( r_is_packed(ip) ? (ip) + 1 : IREF_NEXT(ip) )\r\r\n#define store_state(ep)\\\r\r\n ( icount > 0 ? (ep->value.const_refs = IREF + 1, r_set_size(ep, icount)) : 0 )\r\r\n#define store_state_short(ep)\\\r\r\n ( icount > 0 ? (ep->value.packed = iref_packed + 1, r_set_size(ep, icount)) : 0 )\r\r\n#define store_state_either(ep)\\\r\r\n ( icount > 0 ? (ep->value.packed = IREF_NEXT_EITHER(iref_packed), r_set_size(ep, icount)) : 0 )\r\r\n#define next()\\\r\r\n if ( --icount > 0 ) { iref_packed = IREF_NEXT(iref_packed); goto top; } else goto out\r\r\n#define next_short()\\\r\r\n if ( --icount <= 0 ) { if ( icount < 0 ) goto up; iesp--; }\\\r\r\n ++iref_packed; goto top\r\r\n#define next_either()\\\r\r\n if ( --icount <= 0 ) { if ( icount < 0 ) goto up; iesp--; }\\\r\r\n iref_packed = IREF_NEXT_EITHER(iref_packed); goto top\r\r\n\r\r\n#if !PACKED_SPECIAL_OPS\r\r\n# undef next_either\r\r\n# define next_either() next()\r\r\n# undef store_state_either\r\r\n# define store_state_either(ep) store_state(ep)\r\r\n#endif\r\r\n\r\r\n /* We want to recognize executable arrays here, */\r\r\n /* so we push the argument on the estack and enter */\r\r\n /* the loop at the bottom. */\r\r\n if (iesp >= estop)\r\r\n return_with_error(gs_error_execstackoverflow, pref);\r\r\n ++iesp;\r\r\n ref_assign_inline(iesp, pref);\r\r\n goto bot;\r\r\n top:\r\r\n /*\r\r\n * This is the top of the interpreter loop.\r\r\n * iref points to the ref being interpreted.\r\r\n * Note that this might be an element of a packed array,\r\r\n * not a real ref: we carefully arranged the first 16 bits of\r\r\n * a ref and of a packed array element so they could be distinguished\r\r\n * from each other. (See ghost.h and packed.h for more detail.)\r\r\n */\r\r\n INCR(top);\r\r\n#ifdef DEBUG\r\r\n /* Do a little validation on the top o-stack entry. */\r\r\n if (iosp >= osbot &&\r\r\n (r_type(iosp) == t__invalid || r_type(iosp) >= tx_next_op)\r\r\n ) {\r\r\n mlprintf(imemory, \"Invalid value on o-stack!\\n\");\r\r\n return_with_error_iref(gs_error_Fatal);\r\r\n }\r\r\n if (gs_debug['I'] ||\r\r\n (gs_debug['i'] &&\r\r\n (r_is_packed(iref_packed) ?\r\r\n r_packed_is_name(iref_packed) :\r\r\n r_has_type(IREF, t_name)))\r\r\n ) {\r\r\n os_ptr save_osp = osp; /* avoid side-effects */\r\r\n es_ptr save_esp = esp;\r\r\n\r\r\n osp = iosp;\r\r\n esp = iesp;\r\r\n dmlprintf5(imemory, \"d%u,e%u<%u>0x%lx(%d): \",\r\r\n ref_stack_count(&d_stack), ref_stack_count(&e_stack),\r\r\n ref_stack_count(&o_stack), (ulong)IREF, icount);\r\r\n debug_print_ref(imemory, IREF);\r\r\n if (iosp >= osbot) {\r\r\n dmputs(imemory, \" // \");\r\r\n debug_print_ref(imemory, iosp);\r\r\n }\r\r\n dmputc(imemory, '\\n');\r\r\n osp = save_osp;\r\r\n esp = save_esp;\r\r\n dmflush(imemory);\r\r\n }\r\r\n#endif\r\r\n/* Objects that have attributes (arrays, dictionaries, files, and strings) */\r\r\n/* use lit and exec; other objects use plain and plain_exec. */\r\r\n#define lit(t) type_xe_value(t, a_execute)\r\r\n#define exec(t) type_xe_value(t, a_execute + a_executable)\r\r\n#define nox(t) type_xe_value(t, 0)\r\r\n#define nox_exec(t) type_xe_value(t, a_executable)\r\r\n#define plain(t) type_xe_value(t, 0)\r\r\n#define plain_exec(t) type_xe_value(t, a_executable)\r\r\n /*\r\r\n * We have to populate enough cases of the switch statement to force\r\r\n * some compilers to use a dispatch rather than a testing loop.\r\r\n * What a nuisance!\r\r\n */\r\r\n switch (r_type_xe(iref_packed)) {\r\r\n /* Access errors. */\r\r\n#define cases_invalid()\\\r\r\n case plain(t__invalid): case plain_exec(t__invalid)\r\r\n cases_invalid():\r\r\n return_with_error_iref(gs_error_Fatal);\r\r\n#define cases_nox()\\\r\r\n case nox_exec(t_array): case nox_exec(t_dictionary):\\\r\r\n case nox_exec(t_file): case nox_exec(t_string):\\\r\r\n case nox_exec(t_mixedarray): case nox_exec(t_shortarray)\r\r\n cases_nox():\r\r\n return_with_error_iref(gs_error_invalidaccess);\r\r\n /*\r\r\n * Literal objects. We have to enumerate all the types.\r\r\n * In fact, we have to include some extra plain_exec entries\r\r\n * just to populate the switch. We break them up into groups\r\r\n * to avoid overflowing some preprocessors.\r\r\n */\r\r\n#define cases_lit_1()\\\r\r\n case lit(t_array): case nox(t_array):\\\r\r\n case plain(t_boolean): case plain_exec(t_boolean):\\\r\r\n case lit(t_dictionary): case nox(t_dictionary)\r\r\n#define cases_lit_2()\\\r\r\n case lit(t_file): case nox(t_file):\\\r\r\n case plain(t_fontID): case plain_exec(t_fontID):\\\r\r\n case plain(t_integer): case plain_exec(t_integer):\\\r\r\n case plain(t_mark): case plain_exec(t_mark)\r\r\n#define cases_lit_3()\\\r\r\n case plain(t_name):\\\r\r\n case plain(t_null):\\\r\r\n case plain(t_oparray):\\\r\r\n case plain(t_operator)\r\r\n#define cases_lit_4()\\\r\r\n case plain(t_real): case plain_exec(t_real):\\\r\r\n case plain(t_save): case plain_exec(t_save):\\\r\r\n case lit(t_string): case nox(t_string)\r\r\n#define cases_lit_5()\\\r\r\n case lit(t_mixedarray): case nox(t_mixedarray):\\\r\r\n case lit(t_shortarray): case nox(t_shortarray):\\\r\r\n case plain(t_device): case plain_exec(t_device):\\\r\r\n case plain(t_struct): case plain_exec(t_struct):\\\r\r\n case plain(t_astruct): case plain_exec(t_astruct)\r\r\n /* Executable arrays are treated as literals in direct execution. */\r\r\n#define cases_lit_array()\\\r\r\n case exec(t_array): case exec(t_mixedarray): case exec(t_shortarray)\r\r\n cases_lit_1():\r\r\n cases_lit_2():\r\r\n cases_lit_3():\r\r\n cases_lit_4():\r\r\n cases_lit_5():\r\r\n INCR(lit);\r\r\n break;\r\r\n cases_lit_array():\r\r\n INCR(lit_array);\r\r\n break;\r\r\n /* Special operators. */\r\r\n case plain_exec(tx_op_add):\r\r\nx_add: INCR(x_add);\r\r\n osp = iosp; /* sync o_stack */\r\r\n if ((code = zop_add(i_ctx_p)) < 0)\r\r\n return_with_error_tx_op(code);\r\r\n iosp--;\r\r\n next_either();\r\r\n case plain_exec(tx_op_def):\r\r\nx_def: INCR(x_def);\r\r\n osp = iosp; /* sync o_stack */\r\r\n if ((code = zop_def(i_ctx_p)) < 0)\r\r\n return_with_error_tx_op(code);\r\r\n iosp -= 2;\r\r\n next_either();\r\r\n case plain_exec(tx_op_dup):\r\r\nx_dup: INCR(x_dup);\r\r\n if (iosp < osbot)\r\r\n return_with_error_tx_op(gs_error_stackunderflow);\r\r\n if (iosp >= ostop) {\r\r\n o_stack.requested = 1;\r\r\n return_with_error_tx_op(gs_error_stackoverflow);\r\r\n }\r\r\n iosp++;\r\r\n ref_assign_inline(iosp, iosp - 1);\r\r\n next_either();\r\r\n case plain_exec(tx_op_exch):\r\r\nx_exch: INCR(x_exch);\r\r\n if (iosp <= osbot)\r\r\n return_with_error_tx_op(gs_error_stackunderflow);\r\r\n ref_assign_inline(&token, iosp);\r\r\n ref_assign_inline(iosp, iosp - 1);\r\r\n ref_assign_inline(iosp - 1, &token);\r\r\n next_either();\r\r\n case plain_exec(tx_op_if):\r\r\nx_if: INCR(x_if);\r\r\n if (!r_is_proc(iosp))\r\r\n return_with_error_tx_op(check_proc_failed(iosp));\r\r\n if (!r_has_type(iosp - 1, t_boolean))\r\r\n return_with_error_tx_op((iosp <= osbot ?\r\r\n gs_error_stackunderflow : gs_error_typecheck));\r\r\n if (!iosp[-1].value.boolval) {\r\r\n iosp -= 2;\r\r\n next_either();\r\r\n }\r\r\n if (iesp >= estop)\r\r\n return_with_error_tx_op(gs_error_execstackoverflow);\r\r\n store_state_either(iesp);\r\r\n whichp = iosp;\r\r\n iosp -= 2;\r\r\n goto ifup;\r\r\n case plain_exec(tx_op_ifelse):\r\r\nx_ifelse: INCR(x_ifelse);\r\r\n if (!r_is_proc(iosp))\r\r\n return_with_error_tx_op(check_proc_failed(iosp));\r\r\n if (!r_is_proc(iosp - 1))\r\r\n return_with_error_tx_op(check_proc_failed(iosp - 1));\r\r\n if (!r_has_type(iosp - 2, t_boolean))\r\r\n return_with_error_tx_op((iosp < osbot + 2 ?\r\r\n gs_error_stackunderflow : gs_error_typecheck));\r\r\n if (iesp >= estop)\r\r\n return_with_error_tx_op(gs_error_execstackoverflow);\r\r\n store_state_either(iesp);\r\r\n whichp = (iosp[-2].value.boolval ? iosp - 1 : iosp);\r\r\n iosp -= 3;\r\r\n /* Open code \"up\" for the array case(s) */\r\r\n ifup:if ((icount = r_size(whichp) - 1) <= 0) {\r\r\n if (icount < 0)\r\r\n goto up; /* 0-element proc */\r\r\n SET_IREF(whichp->value.refs); /* 1-element proc */\r\r\n if (--(*ticks_left) > 0)\r\r\n goto top;\r\r\n }\r\r\n ++iesp;\r\r\n /* Do a ref_assign, but also set iref. */\r\r\n iesp->tas = whichp->tas;\r\r\n SET_IREF(iesp->value.refs = whichp->value.refs);\r\r\n if (--(*ticks_left) > 0)\r\r\n goto top;\r\r\n goto slice;\r\r\n case plain_exec(tx_op_index):\r\r\nx_index: INCR(x_index);\r\r\n osp = iosp; /* zindex references o_stack */\r\r\n if ((code = zindex(i_ctx_p)) < 0)\r\r\n return_with_error_tx_op(code);\r\r\n next_either();\r\r\n case plain_exec(tx_op_pop):\r\r\nx_pop: INCR(x_pop);\r\r\n if (iosp < osbot)\r\r\n return_with_error_tx_op(gs_error_stackunderflow);\r\r\n iosp--;\r\r\n next_either();\r\r\n case plain_exec(tx_op_roll):\r\r\nx_roll: INCR(x_roll);\r\r\n osp = iosp; /* zroll references o_stack */\r\r\n if ((code = zroll(i_ctx_p)) < 0)\r\r\n return_with_error_tx_op(code);\r\r\n iosp -= 2;\r\r\n next_either();\r\r\n case plain_exec(tx_op_sub):\r\r\nx_sub: INCR(x_sub);\r\r\n osp = iosp; /* sync o_stack */\r\r\n if ((code = zop_sub(i_ctx_p)) < 0)\r\r\n return_with_error_tx_op(code);\r\r\n iosp--;\r\r\n next_either();\r\r\n /* Executable types. */\r\r\n case plain_exec(t_null):\r\r\n goto bot;\r\r\n case plain_exec(t_oparray):\r\r\n /* Replace with the definition and go again. */\r\r\n INCR(exec_array);\r\r\n opindex = op_index(IREF);\r\r\n pvalue = (ref *)IREF->value.const_refs;\r\r\n opst: /* Prepare to call a t_oparray procedure in *pvalue. */\r\r\n store_state(iesp);\r\r\n oppr: /* Record the stack depths in case of failure. */\r\r\n if (iesp >= estop - 4)\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n iesp += 5;\r\r\n osp = iosp; /* ref_stack_count_inline needs this */\r\r\n make_mark_estack(iesp - 4, es_other, oparray_cleanup);\r\r\n make_int(iesp - 3, opindex); /* for .errorexec effect */\r\r\n make_int(iesp - 2, ref_stack_count_inline(&o_stack));\r\r\n make_int(iesp - 1, ref_stack_count_inline(&d_stack));\r\r\n make_op_estack(iesp, oparray_pop);\r\r\n goto pr;\r\r\n prst: /* Prepare to call the procedure (array) in *pvalue. */\r\r\n store_state(iesp);\r\r\n pr: /* Call the array in *pvalue. State has been stored. */\r\r\n /* We want to do this check before assigning icount so icount is correct\r\r\n * in the event of a gs_error_execstackoverflow\r\r\n */\r\r\n if (iesp >= estop) {\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n }\r\r\n if ((icount = r_size(pvalue) - 1) <= 0) {\r\r\n if (icount < 0)\r\r\n goto up; /* 0-element proc */\r\r\n SET_IREF(pvalue->value.refs); /* 1-element proc */\r\r\n if (--(*ticks_left) > 0)\r\r\n goto top;\r\r\n }\r\r\n ++iesp;\r\r\n /* Do a ref_assign, but also set iref. */\r\r\n iesp->tas = pvalue->tas;\r\r\n SET_IREF(iesp->value.refs = pvalue->value.refs);\r\r\n if (--(*ticks_left) > 0)\r\r\n goto top;\r\r\n goto slice;\r\r\n case plain_exec(t_operator):\r\r\n INCR(exec_operator);\r\r\n if (--(*ticks_left) <= 0) { /* The following doesn't work, */\r\r\n /* and I can't figure out why. */\r\r\n/****** goto sst; ******/\r\r\n }\r\r\n esp = iesp; /* save for operator */\r\r\n osp = iosp; /* ditto */\r\r\n /* Operator routines take osp as an argument. */\r\r\n /* This is just a convenience, since they adjust */\r\r\n /* osp themselves to reflect the results. */\r\r\n /* Operators that (net) push information on the */\r\r\n /* operand stack must check for overflow: */\r\r\n /* this normally happens automatically through */\r\r\n /* the push macro (in oper.h). */\r\r\n /* Operators that do not typecheck their operands, */\r\r\n /* or take a variable number of arguments, */\r\r\n /* must check explicitly for stack underflow. */\r\r\n /* (See oper.h for more detail.) */\r\r\n /* Note that each case must set iosp = osp: */\r\r\n /* this is so we can switch on code without having to */\r\r\n /* store it and reload it (for dumb compilers). */\r\r\n switch (code = call_operator(real_opproc(IREF), i_ctx_p)) {\r\r\n case 0: /* normal case */\r\r\n case 1: /* alternative success case */\r\r\n iosp = osp;\r\r\n next();\r\r\n case o_push_estack: /* store the state and go to up */\r\r\n store_state(iesp);\r\r\n opush:iosp = osp;\r\r\n iesp = esp;\r\r\n if (--(*ticks_left) > 0)\r\r\n goto up;\r\r\n goto slice;\r\r\n case o_pop_estack: /* just go to up */\r\r\n opop:iosp = osp;\r\r\n if (esp == iesp)\r\r\n goto bot;\r\r\n iesp = esp;\r\r\n goto up;\r\r\n case o_reschedule:\r\r\n store_state(iesp);\r\r\n goto res;\r\r\n case gs_error_Remap_Color:\r\r\noe_remap: store_state(iesp);\r\r\nremap: if (iesp + 2 >= estop) {\r\r\n esp = iesp;\r\r\n code = ref_stack_extend(&e_stack, 2);\r\r\n if (code < 0)\r\r\n return_with_error_iref(code);\r\r\n iesp = esp;\r\r\n }\r\r\n packed_get(imemory, iref_packed, iesp + 1);\r\r\n make_oper(iesp + 2, 0,\r\r\n r_ptr(&istate->remap_color_info,\r\r\n int_remap_color_info_t)->proc);\r\r\n iesp += 2;\r\r\n goto up;\r\r\n }\r\r\n iosp = osp;\r\r\n iesp = esp;\r\r\n return_with_code_iref();\r\r\n case plain_exec(t_name):\r\r\n INCR(exec_name);\r\r\n pvalue = IREF->value.pname->pvalue;\r\r\n if (!pv_valid(pvalue)) {\r\r\n uint nidx = names_index(int_nt, IREF);\r\r\n uint htemp;\r\r\n\r\r\n INCR(find_name);\r\r\n if ((pvalue = dict_find_name_by_index_inline(nidx, htemp)) == 0)\r\r\n return_with_error_iref(gs_error_undefined);\r\r\n }\r\r\n /* Dispatch on the type of the value. */\r\r\n /* Again, we have to over-populate the switch. */\r\r\n switch (r_type_xe(pvalue)) {\r\r\n cases_invalid():\r\r\n return_with_error_iref(gs_error_Fatal);\r\r\n cases_nox(): /* access errors */\r\r\n return_with_error_iref(gs_error_invalidaccess);\r\r\n cases_lit_1():\r\r\n cases_lit_2():\r\r\n cases_lit_3():\r\r\n cases_lit_4():\r\r\n cases_lit_5():\r\r\n INCR(name_lit);\r\r\n /* Just push the value */\r\r\n if (iosp >= ostop)\r\r\n return_with_stackoverflow(pvalue);\r\r\n ++iosp;\r\r\n ref_assign_inline(iosp, pvalue);\r\r\n next();\r\r\n case exec(t_array):\r\r\n case exec(t_mixedarray):\r\r\n case exec(t_shortarray):\r\r\n INCR(name_proc);\r\r\n /* This is an executable procedure, execute it. */\r\r\n goto prst;\r\r\n case plain_exec(tx_op_add):\r\r\n goto x_add;\r\r\n case plain_exec(tx_op_def):\r\r\n goto x_def;\r\r\n case plain_exec(tx_op_dup):\r\r\n goto x_dup;\r\r\n case plain_exec(tx_op_exch):\r\r\n goto x_exch;\r\r\n case plain_exec(tx_op_if):\r\r\n goto x_if;\r\r\n case plain_exec(tx_op_ifelse):\r\r\n goto x_ifelse;\r\r\n case plain_exec(tx_op_index):\r\r\n goto x_index;\r\r\n case plain_exec(tx_op_pop):\r\r\n goto x_pop;\r\r\n case plain_exec(tx_op_roll):\r\r\n goto x_roll;\r\r\n case plain_exec(tx_op_sub):\r\r\n goto x_sub;\r\r\n case plain_exec(t_null):\r\r\n goto bot;\r\r\n case plain_exec(t_oparray):\r\r\n INCR(name_oparray);\r\r\n opindex = op_index(pvalue);\r\r\n pvalue = (ref *)pvalue->value.const_refs;\r\r\n goto opst;\r\r\n case plain_exec(t_operator):\r\r\n INCR(name_operator);\r\r\n { /* Shortcut for operators. */\r\r\n /* See above for the logic. */\r\r\n if (--(*ticks_left) <= 0) { /* The following doesn't work, */\r\r\n /* and I can't figure out why. */\r\r\n/****** goto sst; ******/\r\r\n }\r\r\n esp = iesp;\r\r\n osp = iosp;\r\r\n switch (code = call_operator(real_opproc(pvalue),\r\r\n i_ctx_p)\r\r\n ) {\r\r\n case 0: /* normal case */\r\r\n case 1: /* alternative success case */\r\r\n iosp = osp;\r\r\n next();\r\r\n case o_push_estack:\r\r\n store_state(iesp);\r\r\n goto opush;\r\r\n case o_pop_estack:\r\r\n goto opop;\r\r\n case o_reschedule:\r\r\n store_state(iesp);\r\r\n goto res;\r\r\n case gs_error_Remap_Color:\r\r\n goto oe_remap;\r\r\n }\r\r\n iosp = osp;\r\r\n iesp = esp;\r\r\n return_with_error(code, pvalue);\r\r\n }\r\r\n case plain_exec(t_name):\r\r\n case exec(t_file):\r\r\n case exec(t_string):\r\r\n default:\r\r\n /* Not a procedure, reinterpret it. */\r\r\n store_state(iesp);\r\r\n icount = 0;\r\r\n SET_IREF(pvalue);\r\r\n goto top;\r\r\n }\r\r\n case exec(t_file):\r\r\n { /* Executable file. Read the next token and interpret it. */\r\r\n stream *s;\r\r\n scanner_state sstate;\r\r\n\r\r\n check_read_known_file(i_ctx_p, s, IREF, return_with_error_iref);\r\r\n rt:\r\r\n if (iosp >= ostop) /* check early */\r\r\n return_with_stackoverflow_iref();\r\r\n osp = iosp; /* gs_scan_token uses ostack */\r\r\n gs_scanner_init_options(&sstate, IREF, i_ctx_p->scanner_options);\r\r\n again:\r\r\n code = gs_scan_token(i_ctx_p, &token, &sstate);\r\r\n iosp = osp; /* ditto */\r\r\n switch (code) {\r\r\n case 0: /* read a token */\r\r\n /* It's worth checking for literals, which make up */\r\r\n /* the majority of input tokens, before storing the */\r\r\n /* state on the e-stack. Note that because of //, */\r\r\n /* the token may have *any* type and attributes. */\r\r\n /* Note also that executable arrays aren't executed */\r\r\n /* at the top level -- they're treated as literals. */\r\r\n if (!r_has_attr(&token, a_executable) ||\r\r\n r_is_array(&token)\r\r\n ) { /* If gs_scan_token used the o-stack, */\r\r\n /* we know we can do a push now; if not, */\r\r\n /* the pre-check is still valid. */\r\r\n iosp++;\r\r\n ref_assign_inline(iosp, &token);\r\r\n goto rt;\r\r\n }\r\r\n store_state(iesp);\r\r\n /* Push the file on the e-stack */\r\r\n if (iesp >= estop)\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n esfile_set_cache(++iesp);\r\r\n ref_assign_inline(iesp, IREF);\r\r\n SET_IREF(&token);\r\r\n icount = 0;\r\r\n goto top;\r\r\n case gs_error_undefined: /* //name undefined */\r\r\n gs_scanner_error_object(i_ctx_p, &sstate, &token);\r\r\n return_with_error(code, &token);\r\r\n case scan_EOF: /* end of file */\r\r\n esfile_clear_cache();\r\r\n goto bot;\r\r\n case scan_BOS:\r\r\n /* Binary object sequences */\r\r\n /* ARE executed at the top level. */\r\r\n store_state(iesp);\r\r\n /* Push the file on the e-stack */\r\r\n if (iesp >= estop)\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n esfile_set_cache(++iesp);\r\r\n ref_assign_inline(iesp, IREF);\r\r\n pvalue = &token;\r\r\n goto pr;\r\r\n case scan_Refill:\r\r\n store_state(iesp);\r\r\n /* iref may point into the exec stack; */\r\r\n /* save its referent now. */\r\r\n ref_assign_inline(&token, IREF);\r\r\n /* Push the file on the e-stack */\r\r\n if (iesp >= estop)\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n ++iesp;\r\r\n ref_assign_inline(iesp, &token);\r\r\n esp = iesp;\r\r\n osp = iosp;\r\r\n code = gs_scan_handle_refill(i_ctx_p, &sstate, true,\r\r\n ztokenexec_continue);\r\r\n scan_cont:\r\r\n iosp = osp;\r\r\n iesp = esp;\r\r\n switch (code) {\r\r\n case 0:\r\r\n iesp--; /* don't push the file */\r\r\n goto again; /* stacks are unchanged */\r\r\n case o_push_estack:\r\r\n esfile_clear_cache();\r\r\n if (--(*ticks_left) > 0)\r\r\n goto up;\r\r\n goto slice;\r\r\n }\r\r\n /* must be an error */\r\r\n iesp--; /* don't push the file */\r\r\n return_with_code_iref();\r\r\n case scan_Comment:\r\r\n case scan_DSC_Comment: {\r\r\n /* See scan_Refill above for comments. */\r\r\n ref file_token;\r\r\n\r\r\n store_state(iesp);\r\r\n ref_assign_inline(&file_token, IREF);\r\r\n if (iesp >= estop)\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n ++iesp;\r\r\n ref_assign_inline(iesp, &file_token);\r\r\n esp = iesp;\r\r\n osp = iosp;\r\r\n code = ztoken_handle_comment(i_ctx_p,\r\r\n &sstate, &token,\r\r\n code, true, true,\r\r\n ztokenexec_continue);\r\r\n }\r\r\n goto scan_cont;\r\r\n default: /* error */\r\r\n ref_assign_inline(&token, IREF);\r\r\n gs_scanner_error_object(i_ctx_p, &sstate, &token);\r\r\n return_with_error(code, &token);\r\r\n }\r\r\n }\r\r\n case exec(t_string):\r\r\n { /* Executable string. Read a token and interpret it. */\r\r\n stream ss;\r\r\n scanner_state sstate;\r\r\n\r\r\n s_init(&ss, NULL);\r\r\n sread_string(&ss, IREF->value.bytes, r_size(IREF));\r\r\n gs_scanner_init_stream_options(&sstate, &ss, SCAN_FROM_STRING);\r\r\n osp = iosp; /* gs_scan_token uses ostack */\r\r\n code = gs_scan_token(i_ctx_p, &token, &sstate);\r\r\n iosp = osp; /* ditto */\r\r\n switch (code) {\r\r\n case 0: /* read a token */\r\r\n case scan_BOS: /* binary object sequence */\r\r\n store_state(iesp);\r\r\n /* If the updated string isn't empty, push it back */\r\r\n /* on the e-stack. */\r\r\n {\r\r\n uint size = sbufavailable(&ss);\r\r\n\r\r\n if (size) {\r\r\n if (iesp >= estop)\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n ++iesp;\r\r\n iesp->tas.type_attrs = IREF->tas.type_attrs;\r\r\n iesp->value.const_bytes = sbufptr(&ss);\r\r\n r_set_size(iesp, size);\r\r\n }\r\r\n }\r\r\n if (code == 0) {\r\r\n SET_IREF(&token);\r\r\n icount = 0;\r\r\n goto top;\r\r\n }\r\r\n /* Handle BOS specially */\r\r\n pvalue = &token;\r\r\n goto pr;\r\r\n case scan_EOF: /* end of string */\r\r\n goto bot;\r\r\n case scan_Refill: /* error */\r\r\n code = gs_note_error(gs_error_syntaxerror);\r\r\n /* fall through */\r\r\n default: /* error */\r\r\n ref_assign_inline(&token, IREF);\r\r\n gs_scanner_error_object(i_ctx_p, &sstate, &token);\r\r\n return_with_error(code, &token);\r\r\n }\r\r\n }\r\r\n /* Handle packed arrays here by re-dispatching. */\r\r\n /* This also picks up some anomalous cases of non-packed arrays. */\r\r\n default:\r\r\n {\r\r\n uint index;\r\r\n\r\r\n switch (*iref_packed >> r_packed_type_shift) {\r\r\n case pt_full_ref:\r\r\n case pt_full_ref + 1:\r\r\n INCR(p_full);\r\r\n if (iosp >= ostop)\r\r\n return_with_stackoverflow_iref();\r\r\n /* We know this can't be an executable object */\r\r\n /* requiring special handling, so we just push it. */\r\r\n ++iosp;\r\r\n /* We know that refs are properly aligned: */\r\r\n /* see packed.h for details. */\r\r\n ref_assign_inline(iosp, IREF);\r\r\n next();\r\r\n case pt_executable_operator:\r\r\n index = *iref_packed & packed_value_mask;\r\r\n if (--(*ticks_left) <= 0) { /* The following doesn't work, */\r\r\n /* and I can't figure out why. */\r\r\n/****** goto sst_short; ******/\r\r\n }\r\r\n if (!op_index_is_operator(index)) {\r\r\n INCR(p_exec_oparray);\r\r\n store_state_short(iesp);\r\r\n opindex = index;\r\r\n /* Call the operator procedure. */\r\r\n index -= op_def_count;\r\r\n pvalue = (ref *)\r\r\n (index < r_size(&i_ctx_p->op_array_table_global.table) ?\r\r\n i_ctx_p->op_array_table_global.table.value.const_refs +\r\r\n index :\r\r\n i_ctx_p->op_array_table_local.table.value.const_refs +\r\r\n (index - r_size(&i_ctx_p->op_array_table_global.table)));\r\r\n goto oppr;\r\r\n }\r\r\n INCR(p_exec_operator);\r\r\n /* See the main plain_exec(t_operator) case */\r\r\n /* for details of what happens here. */\r\r\n#if PACKED_SPECIAL_OPS\r\r\n /*\r\r\n * We arranged in iinit.c that the special ops\r\r\n * have operator indices starting at 1.\r\r\n *\r\r\n * The (int) cast in the next line is required\r\r\n * because some compilers don't allow arithmetic\r\r\n * involving two different enumerated types.\r\r\n */\r\r\n# define case_xop(xop) case xop - (int)tx_op + 1\r\r\n switch (index) {\r\r\n case_xop(tx_op_add):goto x_add;\r\r\n case_xop(tx_op_def):goto x_def;\r\r\n case_xop(tx_op_dup):goto x_dup;\r\r\n case_xop(tx_op_exch):goto x_exch;\r\r\n case_xop(tx_op_if):goto x_if;\r\r\n case_xop(tx_op_ifelse):goto x_ifelse;\r\r\n case_xop(tx_op_index):goto x_index;\r\r\n case_xop(tx_op_pop):goto x_pop;\r\r\n case_xop(tx_op_roll):goto x_roll;\r\r\n case_xop(tx_op_sub):goto x_sub;\r\r\n case 0: /* for dumb compilers */\r\r\n default:\r\r\n ;\r\r\n }\r\r\n# undef case_xop\r\r\n#endif\r\r\n INCR(p_exec_non_x_operator);\r\r\n esp = iesp;\r\r\n osp = iosp;\r\r\n switch (code = call_operator(op_index_proc(index), i_ctx_p)) {\r\r\n case 0:\r\r\n case 1:\r\r\n iosp = osp;\r\r\n next_short();\r\r\n case o_push_estack:\r\r\n store_state_short(iesp);\r\r\n goto opush;\r\r\n case o_pop_estack:\r\r\n iosp = osp;\r\r\n if (esp == iesp) {\r\r\n next_short();\r\r\n }\r\r\n iesp = esp;\r\r\n goto up;\r\r\n case o_reschedule:\r\r\n store_state_short(iesp);\r\r\n goto res;\r\r\n case gs_error_Remap_Color:\r\r\n store_state_short(iesp);\r\r\n goto remap;\r\r\n }\r\r\n iosp = osp;\r\r\n iesp = esp;\r\r\n return_with_code_iref();\r\r\n case pt_integer:\r\r\n INCR(p_integer);\r\r\n if (iosp >= ostop)\r\r\n return_with_stackoverflow_iref();\r\r\n ++iosp;\r\r\n make_int(iosp,\r\r\n ((int)*iref_packed & packed_int_mask) +\r\r\n packed_min_intval);\r\r\n next_short();\r\r\n case pt_literal_name:\r\r\n INCR(p_lit_name);\r\r\n {\r\r\n uint nidx = *iref_packed & packed_value_mask;\r\r\n\r\r\n if (iosp >= ostop)\r\r\n return_with_stackoverflow_iref();\r\r\n ++iosp;\r\r\n name_index_ref_inline(int_nt, nidx, iosp);\r\r\n next_short();\r\r\n }\r\r\n case pt_executable_name:\r\r\n INCR(p_exec_name);\r\r\n {\r\r\n uint nidx = *iref_packed & packed_value_mask;\r\r\n\r\r\n pvalue = name_index_ptr_inline(int_nt, nidx)->pvalue;\r\r\n if (!pv_valid(pvalue)) {\r\r\n uint htemp;\r\r\n\r\r\n INCR(p_find_name);\r\r\n if ((pvalue = dict_find_name_by_index_inline(nidx, htemp)) == 0) {\r\r\n names_index_ref(int_nt, nidx, &token);\r\r\n return_with_error(gs_error_undefined, &token);\r\r\n }\r\r\n }\r\r\n if (r_has_masked_attrs(pvalue, a_execute, a_execute + a_executable)) { /* Literal, push it. */\r\r\n INCR(p_name_lit);\r\r\n if (iosp >= ostop)\r\r\n return_with_stackoverflow_iref();\r\r\n ++iosp;\r\r\n ref_assign_inline(iosp, pvalue);\r\r\n next_short();\r\r\n }\r\r\n if (r_is_proc(pvalue)) { /* This is an executable procedure, */\r\r\n /* execute it. */\r\r\n INCR(p_name_proc);\r\r\n store_state_short(iesp);\r\r\n goto pr;\r\r\n }\r\r\n /* Not a literal or procedure, reinterpret it. */\r\r\n store_state_short(iesp);\r\r\n icount = 0;\r\r\n SET_IREF(pvalue);\r\r\n goto top;\r\r\n }\r\r\n /* default can't happen here */\r\r\n }\r\r\n }\r\r\n }\r\r\n /* Literal type, just push it. */\r\r\n if (iosp >= ostop)\r\r\n return_with_stackoverflow_iref();\r\r\n ++iosp;\r\r\n ref_assign_inline(iosp, IREF);\r\r\n bot:next();\r\r\n out: /* At most 1 more token in the current procedure. */\r\r\n /* (We already decremented icount.) */\r\r\n if (!icount) {\r\r\n /* Pop the execution stack for tail recursion. */\r\r\n iesp--;\r\r\n iref_packed = IREF_NEXT(iref_packed);\r\r\n goto top;\r\r\n }\r\r\n up:if (--(*ticks_left) < 0)\r\r\n goto slice;\r\r\n /* See if there is anything left on the execution stack. */\r\r\n if (!r_is_proc(iesp)) {\r\r\n SET_IREF(iesp--);\r\r\n icount = 0;\r\r\n goto top;\r\r\n }\r\r\n SET_IREF(iesp->value.refs); /* next element of array */\r\r\n icount = r_size(iesp) - 1;\r\r\n if (icount <= 0) { /* <= 1 more elements */\r\r\n iesp--; /* pop, or tail recursion */\r\r\n if (icount < 0)\r\r\n goto up;\r\r\n }\r\r\n goto top;\r\r\nres:\r\r\n /* Some operator has asked for context rescheduling. */\r\r\n /* We've done a store_state. */\r\r\n *pi_ctx_p = i_ctx_p;\r\r\n code = (*i_ctx_p->reschedule_proc)(pi_ctx_p);\r\r\n i_ctx_p = *pi_ctx_p;\r\r\n sched: /* We've just called a scheduling procedure. */\r\r\n /* The interpreter state is in memory; iref is not current. */\r\r\n if (code < 0) {\r\r\n set_error(code);\r\r\n /*\r\r\n * We need a real object to return as the error object.\r\r\n * (It only has to last long enough to store in\r\r\n * *perror_object.)\r\r\n */\r\r\n make_null_proc(&ierror.full);\r\r\n SET_IREF(ierror.obj = &ierror.full);\r\r\n goto error_exit;\r\r\n }\r\r\n /* Reload state information from memory. */\r\r\n iosp = osp;\r\r\n iesp = esp;\r\r\n goto up;\r\r\n#if 0 /****** ****** ***** */\r\r\n sst: /* Time-slice, but push the current object first. */\r\r\n store_state(iesp);\r\r\n if (iesp >= estop)\r\r\n return_with_error_iref(gs_error_execstackoverflow);\r\r\n iesp++;\r\r\n ref_assign_inline(iesp, iref);\r\r\n#endif /****** ****** ***** */\r\r\n slice: /* It's time to time-slice or garbage collect. */\r\r\n /* iref is not live, so we don't need to do a store_state. */\r\r\n osp = iosp;\r\r\n esp = iesp;\r\r\n /* If *ticks_left <= -100, we need to GC now. */\r\r\n if ((*ticks_left) <= -100) { /* We need to garbage collect now. */\r\r\n *pi_ctx_p = i_ctx_p;\r\r\n code = interp_reclaim(pi_ctx_p, -1);\r\r\n i_ctx_p = *pi_ctx_p;\r\r\n } else if (i_ctx_p->time_slice_proc != NULL) {\r\r\n *pi_ctx_p = i_ctx_p;\r\r\n code = (*i_ctx_p->time_slice_proc)(pi_ctx_p);\r\r\n i_ctx_p = *pi_ctx_p;\r\r\n } else\r\r\n code = 0;\r\r\n *ticks_left = i_ctx_p->time_slice_ticks;\r\r\n set_code_on_interrupt(imemory, &code);\r\r\n goto sched;\r\r\n\r\r\n /* Error exits. */\r\r\n\r\r\n rweci:\r\r\n ierror.code = code;\r\r\n rwei:\r\r\n ierror.obj = IREF;\r\r\n rwe:\r\r\n if (!r_is_packed(iref_packed))\r\r\n store_state(iesp);\r\r\n else {\r\r\n /*\r\r\n * We need a real object to return as the error object.\r\r\n * (It only has to last long enough to store in *perror_object.)\r\r\n */\r\r\n packed_get(imemory, (const ref_packed *)ierror.obj, &ierror.full);\r\r\n store_state_short(iesp);\r\r\n if (IREF == ierror.obj)\r\r\n SET_IREF(&ierror.full);\r\r\n ierror.obj = &ierror.full;\r\r\n }\r\r\n error_exit:\r\r\n if (GS_ERROR_IS_INTERRUPT(ierror.code)) { /* We must push the current object being interpreted */\r\r\n /* back on the e-stack so it will be re-executed. */\r\r\n /* Currently, this is always an executable operator, */\r\r\n /* but it might be something else someday if we check */\r\r\n /* for interrupts in the interpreter loop itself. */\r\r\n if (iesp >= estop)\r\r\n ierror.code = gs_error_execstackoverflow;\r\r\n else {\r\r\n iesp++;\r\r\n ref_assign_inline(iesp, IREF);\r\r\n }\r\r\n }\r\r\n esp = iesp;\r\r\n osp = iosp;\r\r\n ref_assign_inline(perror_object, ierror.obj);\r\r\n#ifdef DEBUG\r\r\n if (ierror.code == gs_error_InterpreterExit) {\r\r\n /* Do not call gs_log_error to reduce the noise. */\r\r\n return gs_error_InterpreterExit;\r\r\n }\r\r\n#endif\r\r\n return gs_log_error(ierror.code, __FILE__, ierror.line);\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <unistd.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint epiphonemas_hayatake = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int fd;\r\n char *extension = \".lck\";\r\n char *thelockfile;\r\n char *anno_louisianians = 0;\r\n jmp_buf primp_sovkhoz;\r\n int carbolising_tanga;\r\n void **costain_adjument = 0;\r\n void *labyrinthitis_foresweat = 0;\r\n char *biliverdic_myriapodan;;\r\n if (__sync_bool_compare_and_swap(&epiphonemas_hayatake,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n biliverdic_myriapodan = getenv(\"DIFFRACTION_HOMOANISIC\");\r\n if (biliverdic_myriapodan != 0) {;\r\n labyrinthitis_foresweat = ((void *)biliverdic_myriapodan);\r\n costain_adjument = &labyrinthitis_foresweat;\r\n carbolising_tanga = setjmp(primp_sovkhoz);\r\n if (carbolising_tanga == 0) {\r\n longjmp(primp_sovkhoz,1);\r\n }\r\n anno_louisianians = ((char *)((char *)( *costain_adjument)));\r\n \r\n thelockfile = (char *)malloc(strlen(\"/opt//workspace/testData/\") + strlen(anno_louisianians) +\r\n strlen(extension) + 1);\r\n \r\n if (thelockfile) {\r\n \r\n \r\n strcpy(thelockfile, \"/opt//workspace/testData/\");\r\n strcat(thelockfile, anno_louisianians);\r\n strcat(thelockfile, extension);\r\n \r\n \r\n if (access(\"/opt//workspace/testData/\", R_OK && W_OK) == -1) {\r\n printf(\"Error accessing testData directory\\n\");\r\n } else {\r\n printf(\"Grabbing lock file: %s\\n\", thelockfile);\r\n \r\n \r\n \r\n while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\r\n sleep(0);\r\n }\r\n \r\n printf(\"Made it to the critical section\\n\");\r\n if (fd != -1) {\r\n close(fd);\r\n unlink(thelockfile);\r\n }\r\n free (thelockfile);\r\n }\r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\n sleep(0);\n }\n```", "cwe": "412"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint teonanacatl_interloli = 0;\r\nint global_variable;\r\nvoid handle_taint(char *trodi_pickett);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&teonanacatl_interloli,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid handle_taint(char *trodi_pickett)\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *crevassing_duvetyns = 0;\r\n jmp_buf incelebrity_neotenies;\r\n int beinked_pippy;\r\n void **smudges_pythonissa = 0;\r\n void **coursey_fernas = 0;\r\n void *appetibleness_carunculated = 0;\r\n ++global_variable;;\r\n if (trodi_pickett != 0) {;\r\n appetibleness_carunculated = ((void *)trodi_pickett);\r\n smudges_pythonissa = &appetibleness_carunculated;\r\n coursey_fernas = smudges_pythonissa + 5;\r\n beinked_pippy = setjmp(incelebrity_neotenies);\r\n if (beinked_pippy == 0) {\r\n longjmp(incelebrity_neotenies,1);\r\n }\r\n crevassing_duvetyns = ((char *)((char *)( *(coursey_fernas - 5))));\r\n \r\n taint_size = strlen(crevassing_duvetyns);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,crevassing_duvetyns,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\n if (((char *)( *(coursey_fernas - 5))) != 0) \r\n free(((char *)((char *)( *(coursey_fernas - 5)))));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n \n \n if (malloced_buff[ss_i] == 0 && errno == 12) {\n printf(\"Malloc error due to ulimit\\n\");\n if (trace_flag == 0) {\n \n```", "cwe": "401"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\r\r\n{\r\r\n /* ! */\r\r\n\r\r\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\r\r\n\r\r\n WORD32 i4_err_status = 0;\r\r\n UWORD8 *pu1_buf = NULL;\r\r\n WORD32 buflen;\r\r\n UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\r\r\n\r\r\n UWORD32 bytes_consumed = 0;\r\r\n UWORD32 cur_slice_is_nonref = 0;\r\r\n UWORD32 u4_next_is_aud;\r\r\n UWORD32 u4_first_start_code_found = 0;\r\r\n WORD32 ret = 0,api_ret_value = IV_SUCCESS;\r\r\n WORD32 header_data_left = 0,frame_data_left = 0;\r\r\n UWORD8 *pu1_bitstrm_buf;\r\r\n ivd_video_decode_ip_t *ps_dec_ip;\r\r\n ivd_video_decode_op_t *ps_dec_op;\r\r\n\r\r\n ithread_set_name((void*)\"Parse_thread\");\r\r\n\r\r\n ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\r\r\n ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\r\r\n ps_dec->pv_dec_out = ps_dec_op;\r\r\n if(ps_dec->init_done != 1)\r\r\n {\r\r\n return IV_FAIL;\r\r\n }\r\r\n\r\r\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\r\r\n DATA_SYNC();\r\r\n\r\r\n if(0 == ps_dec->u1_flushfrm)\r\r\n {\r\r\n if(ps_dec_ip->pv_stream_buffer == NULL)\r\r\n {\r\r\n ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\r\r\n ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\r\r\n return IV_FAIL;\r\r\n }\r\r\n if(ps_dec_ip->u4_num_Bytes <= 0)\r\r\n {\r\r\n ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\r\r\n ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\r\r\n return IV_FAIL;\r\r\n\r\r\n }\r\r\n }\r\r\n ps_dec->u1_pic_decode_done = 0;\r\r\n\r\r\n ps_dec_op->u4_num_bytes_consumed = 0;\r\r\n\r\r\n ps_dec->ps_out_buffer = NULL;\r\r\n\r\r\n if(ps_dec_ip->u4_size\r\r\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\r\r\n ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\r\r\n\r\r\n ps_dec->u4_fmt_conv_cur_row = 0;\r\r\n\r\r\n ps_dec->u4_output_present = 0;\r\r\n ps_dec->s_disp_op.u4_error_code = 1;\r\r\n ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\r\r\n if(0 == ps_dec->u4_share_disp_buf\r\r\n && ps_dec->i4_decode_header == 0)\r\r\n {\r\r\n UWORD32 i;\r\r\n if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\r\r\n {\r\r\n ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\r\r\n ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\r\r\n return IV_FAIL;\r\r\n }\r\r\n\r\r\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\r\r\n {\r\r\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\r\r\n {\r\r\n ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\r\r\n ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\r\r\n return IV_FAIL;\r\r\n }\r\r\n\r\r\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\r\r\n {\r\r\n ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\r\r\n ps_dec_op->u4_error_code |=\r\r\n IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\r\r\n return IV_FAIL;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\r\r\n {\r\r\n ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\r\r\n return IV_FAIL;\r\r\n }\r\r\n\r\r\n /* ! */\r\r\n ps_dec->u4_ts = ps_dec_ip->u4_ts;\r\r\n\r\r\n ps_dec_op->u4_error_code = 0;\r\r\n ps_dec_op->e_pic_type = -1;\r\r\n ps_dec_op->u4_output_present = 0;\r\r\n ps_dec_op->u4_frame_decoded_flag = 0;\r\r\n\r\r\n ps_dec->i4_frametype = -1;\r\r\n ps_dec->i4_content_type = -1;\r\r\n /*\r\r\n * For field pictures, set the bottom and top picture decoded u4_flag correctly.\r\r\n */\r\r\n {\r\r\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\r\r\n {\r\r\n ps_dec->u1_top_bottom_decoded = 0;\r\r\n }\r\r\n }\r\r\n ps_dec->u4_slice_start_code_found = 0;\r\r\n\r\r\n /* In case the deocder is not in flush mode(in shared mode),\r\r\n then decoder has to pick up a buffer to write current frame.\r\r\n Check if a frame is available in such cases */\r\r\n\r\r\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\r\r\n && ps_dec->u1_flushfrm == 0)\r\r\n {\r\r\n UWORD32 i;\r\r\n\r\r\n WORD32 disp_avail = 0, free_id;\r\r\n\r\r\n /* Check if at least one buffer is available with the codec */\r\r\n /* If not then return to application with error */\r\r\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\r\r\n {\r\r\n if(0 == ps_dec->u4_disp_buf_mapping[i]\r\r\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\r\r\n {\r\r\n disp_avail = 1;\r\r\n break;\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n if(0 == disp_avail)\r\r\n {\r\r\n /* If something is queued for display wait for that buffer to be returned */\r\r\n\r\r\n ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\r\r\n ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\r\r\n return (IV_FAIL);\r\r\n }\r\r\n\r\r\n while(1)\r\r\n {\r\r\n pic_buffer_t *ps_pic_buf;\r\r\n ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\r\r\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\r\r\n\r\r\n if(ps_pic_buf == NULL)\r\r\n {\r\r\n UWORD32 i, display_queued = 0;\r\r\n\r\r\n /* check if any buffer was given for display which is not returned yet */\r\r\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\r\r\n {\r\r\n if(0 != ps_dec->u4_disp_buf_mapping[i])\r\r\n {\r\r\n display_queued = 1;\r\r\n break;\r\r\n }\r\r\n }\r\r\n /* If some buffer is queued for display, then codec has to singal an error and wait\r\r\n for that buffer to be returned.\r\r\n If nothing is queued for display then codec has ownership of all display buffers\r\r\n and it can reuse any of the existing buffers and continue decoding */\r\r\n\r\r\n if(1 == display_queued)\r\r\n {\r\r\n /* If something is queued for display wait for that buffer to be returned */\r\r\n ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\r\r\n ps_dec_op->u4_error_code |= (1\r\r\n << IVD_UNSUPPORTEDPARAM);\r\r\n return (IV_FAIL);\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\r\r\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\r\r\n {\r\r\n ih264_buf_mgr_set_status(\r\r\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\r\r\n free_id,\r\r\n BUF_MGR_IO);\r\r\n }\r\r\n else\r\r\n {\r\r\n /**\r\r\n * Found a free buffer for present call. Release it now.\r\r\n * Will be again obtained later.\r\r\n */\r\r\n ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\r\r\n free_id,\r\r\n BUF_MGR_IO);\r\r\n break;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\r\r\n {\r\r\n\r\r\n ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\r\r\n &(ps_dec->s_disp_op));\r\r\n if(0 == ps_dec->s_disp_op.u4_error_code)\r\r\n {\r\r\n ps_dec->u4_fmt_conv_cur_row = 0;\r\r\n ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\r\r\n ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\r\r\n ps_dec->u4_fmt_conv_cur_row,\r\r\n ps_dec->u4_fmt_conv_num_rows);\r\r\n ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\r\r\n ps_dec->u4_output_present = 1;\r\r\n\r\r\n }\r\r\n ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\r\r\n\r\r\n ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\r\r\n ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\r\r\n\r\r\n ps_dec_op->u4_new_seq = 0;\r\r\n\r\r\n ps_dec_op->u4_output_present = ps_dec->u4_output_present;\r\r\n ps_dec_op->u4_progressive_frame_flag =\r\r\n ps_dec->s_disp_op.u4_progressive_frame_flag;\r\r\n ps_dec_op->e_output_format =\r\r\n ps_dec->s_disp_op.e_output_format;\r\r\n ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\r\r\n ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\r\r\n ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\r\r\n ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\r\r\n\r\r\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\r\r\n ps_dec_op->u4_is_ref_flag = -1;\r\r\n ps_dec_op->e_pic_type = IV_NA_FRAME;\r\r\n ps_dec_op->u4_frame_decoded_flag = 0;\r\r\n\r\r\n if(0 == ps_dec->s_disp_op.u4_error_code)\r\r\n {\r\r\n return (IV_SUCCESS);\r\r\n }\r\r\n else\r\r\n return (IV_FAIL);\r\r\n\r\r\n }\r\r\n if(ps_dec->u1_res_changed == 1)\r\r\n {\r\r\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\r\r\n ih264d_init_decoder(ps_dec);\r\r\n }\r\r\n\r\r\n ps_dec->u4_prev_nal_skipped = 0;\r\r\n\r\r\n ps_dec->u2_cur_mb_addr = 0;\r\r\n ps_dec->u2_total_mbs_coded = 0;\r\r\n ps_dec->u2_cur_slice_num = 0;\r\r\n ps_dec->cur_dec_mb_num = 0;\r\r\n ps_dec->cur_recon_mb_num = 0;\r\r\n ps_dec->u4_first_slice_in_pic = 2;\r\r\n ps_dec->u1_slice_header_done = 0;\r\r\n ps_dec->u1_dangling_field = 0;\r\r\n\r\r\n ps_dec->u4_dec_thread_created = 0;\r\r\n ps_dec->u4_bs_deblk_thread_created = 0;\r\r\n ps_dec->u4_cur_bs_mb_num = 0;\r\r\n\r\r\n DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\r\r\n\r\r\n\r\r\n ps_dec->u4_pic_buf_got = 0;\r\r\n\r\r\n do\r\r\n {\r\r\n WORD32 buf_size;\r\r\n\r\r\n pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\r\r\n + ps_dec_op->u4_num_bytes_consumed;\r\r\n\r\r\n u4_max_ofst = ps_dec_ip->u4_num_Bytes\r\r\n - ps_dec_op->u4_num_bytes_consumed;\r\r\n\r\r\n /* If dynamic bitstream buffer is not allocated and\r\r\n * header decode is done, then allocate dynamic bitstream buffer\r\r\n */\r\r\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\r\r\n (ps_dec->i4_header_decoded & 1))\r\r\n {\r\r\n WORD32 size;\r\r\n\r\r\n void *pv_buf;\r\r\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\r\r\n size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\r\r\n pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\r\r\n RETURN_IF((NULL == pv_buf), IV_FAIL);\r\r\n ps_dec->pu1_bits_buf_dynamic = pv_buf;\r\r\n ps_dec->u4_dynamic_bits_buf_size = size;\r\r\n }\r\r\n\r\r\n if(ps_dec->pu1_bits_buf_dynamic)\r\r\n {\r\r\n pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\r\r\n buf_size = ps_dec->u4_dynamic_bits_buf_size;\r\r\n }\r\r\n else\r\r\n {\r\r\n pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\r\r\n buf_size = ps_dec->u4_static_bits_buf_size;\r\r\n }\r\r\n\r\r\n u4_next_is_aud = 0;\r\r\n\r\r\n buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\r\r\n &u4_length_of_start_code,\r\r\n &u4_next_is_aud);\r\r\n\r\r\n if(buflen == -1)\r\r\n buflen = 0;\r\r\n /* Ignore bytes beyond the allocated size of intermediate buffer */\r\r\n buflen = MIN(buflen, buf_size);\r\r\n\r\r\n bytes_consumed = buflen + u4_length_of_start_code;\r\r\n ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\r\r\n\r\r\n {\r\r\n UWORD8 u1_firstbyte, u1_nal_ref_idc;\r\r\n\r\r\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\r\r\n {\r\r\n u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\r\r\n u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\r\r\n if(u1_nal_ref_idc == 0)\r\r\n {\r\r\n /*skip non reference frames*/\r\r\n cur_slice_is_nonref = 1;\r\r\n continue;\r\r\n }\r\r\n else\r\r\n {\r\r\n if(1 == cur_slice_is_nonref)\r\r\n {\r\r\n /*We have encountered a referenced frame,return to app*/\r\r\n ps_dec_op->u4_num_bytes_consumed -=\r\r\n bytes_consumed;\r\r\n ps_dec_op->e_pic_type = IV_B_FRAME;\r\r\n ps_dec_op->u4_error_code =\r\r\n IVD_DEC_FRM_SKIPPED;\r\r\n ps_dec_op->u4_error_code |= (1\r\r\n << IVD_UNSUPPORTEDPARAM);\r\r\n ps_dec_op->u4_frame_decoded_flag = 0;\r\r\n ps_dec_op->u4_size =\r\r\n sizeof(ivd_video_decode_op_t);\r\r\n /*signal the decode thread*/\r\r\n ih264d_signal_decode_thread(ps_dec);\r\r\n /* close deblock thread if it is not closed yet*/\r\r\n if(ps_dec->u4_num_cores == 3)\r\r\n {\r\r\n ih264d_signal_bs_deblk_thread(ps_dec);\r\r\n }\r\r\n\r\r\n return (IV_FAIL);\r\r\n }\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n\r\r\n if(buflen)\r\r\n {\r\r\n memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\r\r\n buflen);\r\r\n /* Decoder may read extra 8 bytes near end of the frame */\r\r\n if((buflen + 8) < buf_size)\r\r\n {\r\r\n memset(pu1_bitstrm_buf + buflen, 0, 8);\r\r\n }\r\r\n u4_first_start_code_found = 1;\r\r\n\r\r\n }\r\r\n else\r\r\n {\r\r\n /*start code not found*/\r\r\n\r\r\n if(u4_first_start_code_found == 0)\r\r\n {\r\r\n /*no start codes found in current process call*/\r\r\n\r\r\n ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\r\r\n ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\r\r\n\r\r\n if(ps_dec->u4_pic_buf_got == 0)\r\r\n {\r\r\n\r\r\n ih264d_fill_output_struct_from_context(ps_dec,\r\r\n ps_dec_op);\r\r\n\r\r\n ps_dec_op->u4_error_code = ps_dec->i4_error_code;\r\r\n ps_dec_op->u4_frame_decoded_flag = 0;\r\r\n\r\r\n return (IV_FAIL);\r\r\n }\r\r\n else\r\r\n {\r\r\n ps_dec->u1_pic_decode_done = 1;\r\r\n continue;\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n /* a start code has already been found earlier in the same process call*/\r\r\n frame_data_left = 0;\r\r\n continue;\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n ps_dec->u4_return_to_app = 0;\r\r\n ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\r\r\n pu1_bitstrm_buf, buflen);\r\r\n if(ret != OK)\r\r\n {\r\r\n UWORD32 error = ih264d_map_error(ret);\r\r\n ps_dec_op->u4_error_code = error | ret;\r\r\n api_ret_value = IV_FAIL;\r\r\n\r\r\n if((ret == IVD_RES_CHANGED)\r\r\n || (ret == IVD_MEM_ALLOC_FAILED)\r\r\n || (ret == ERROR_UNAVAIL_PICBUF_T)\r\r\n || (ret == ERROR_UNAVAIL_MVBUF_T))\r\r\n {\r\r\n break;\r\r\n }\r\r\n\r\r\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\r\r\n {\r\r\n ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\r\r\n api_ret_value = IV_FAIL;\r\r\n break;\r\r\n }\r\r\n\r\r\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\r\r\n {\r\r\n api_ret_value = IV_FAIL;\r\r\n break;\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n if(ps_dec->u4_return_to_app)\r\r\n {\r\r\n /*We have encountered a referenced frame,return to app*/\r\r\n ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\r\r\n ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\r\r\n ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\r\r\n ps_dec_op->u4_frame_decoded_flag = 0;\r\r\n ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\r\r\n /*signal the decode thread*/\r\r\n ih264d_signal_decode_thread(ps_dec);\r\r\n /* close deblock thread if it is not closed yet*/\r\r\n if(ps_dec->u4_num_cores == 3)\r\r\n {\r\r\n ih264d_signal_bs_deblk_thread(ps_dec);\r\r\n }\r\r\n return (IV_FAIL);\r\r\n\r\r\n }\r\r\n\r\r\n\r\r\n\r\r\n header_data_left = ((ps_dec->i4_decode_header == 1)\r\r\n && (ps_dec->i4_header_decoded != 3)\r\r\n && (ps_dec_op->u4_num_bytes_consumed\r\r\n < ps_dec_ip->u4_num_Bytes));\r\r\n frame_data_left = (((ps_dec->i4_decode_header == 0)\r\r\n && ((ps_dec->u1_pic_decode_done == 0)\r\r\n || (u4_next_is_aud == 1)))\r\r\n && (ps_dec_op->u4_num_bytes_consumed\r\r\n < ps_dec_ip->u4_num_Bytes));\r\r\n }\r\r\n while(( header_data_left == 1)||(frame_data_left == 1));\r\r\n\r\r\n if((ps_dec->u4_slice_start_code_found == 1)\r\r\n && (ret != IVD_MEM_ALLOC_FAILED)\r\r\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\r\r\n {\r\r\n WORD32 num_mb_skipped;\r\r\n WORD32 prev_slice_err;\r\r\n pocstruct_t temp_poc;\r\r\n WORD32 ret1;\r\r\n\r\r\n num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\r\r\n - ps_dec->u2_total_mbs_coded;\r\r\n\r\r\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\r\r\n prev_slice_err = 1;\r\r\n else\r\r\n prev_slice_err = 2;\r\r\n\r\r\n ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\r\r\n &temp_poc, prev_slice_err);\r\r\n\r\r\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\r\r\n {\r\r\n return IV_FAIL;\r\r\n }\r\r\n }\r\r\n\r\r\n if((ret == IVD_RES_CHANGED)\r\r\n || (ret == IVD_MEM_ALLOC_FAILED)\r\r\n || (ret == ERROR_UNAVAIL_PICBUF_T)\r\r\n || (ret == ERROR_UNAVAIL_MVBUF_T))\r\r\n {\r\r\n\r\r\n /* signal the decode thread */\r\r\n ih264d_signal_decode_thread(ps_dec);\r\r\n /* close deblock thread if it is not closed yet */\r\r\n if(ps_dec->u4_num_cores == 3)\r\r\n {\r\r\n ih264d_signal_bs_deblk_thread(ps_dec);\r\r\n }\r\r\n /* dont consume bitstream for change in resolution case */\r\r\n if(ret == IVD_RES_CHANGED)\r\r\n {\r\r\n ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\r\r\n }\r\r\n return IV_FAIL;\r\r\n }\r\r\n\r\r\n\r\r\n if(ps_dec->u1_separate_parse)\r\r\n {\r\r\n /* If Format conversion is not complete,\r\r\n complete it here */\r\r\n if(ps_dec->u4_num_cores == 2)\r\r\n {\r\r\n\r\r\n /*do deblocking of all mbs*/\r\r\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\r\r\n {\r\r\n UWORD32 u4_num_mbs,u4_max_addr;\r\r\n tfr_ctxt_t s_tfr_ctxt;\r\r\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\r\r\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\r\r\n\r\r\n /*BS is done for all mbs while parsing*/\r\r\n u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\r\r\n ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\r\r\n\r\r\n\r\r\n ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\r\r\n ps_dec->u2_frm_wd_in_mbs, 0);\r\r\n\r\r\n\r\r\n u4_num_mbs = u4_max_addr\r\r\n - ps_dec->u4_cur_deblk_mb_num + 1;\r\r\n\r\r\n DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\r\r\n\r\r\n if(u4_num_mbs != 0)\r\r\n ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\r\r\n ps_tfr_cxt,1);\r\r\n\r\r\n ps_dec->u4_start_recon_deblk = 0;\r\r\n\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n /*signal the decode thread*/\r\r\n ih264d_signal_decode_thread(ps_dec);\r\r\n /* close deblock thread if it is not closed yet*/\r\r\n if(ps_dec->u4_num_cores == 3)\r\r\n {\r\r\n ih264d_signal_bs_deblk_thread(ps_dec);\r\r\n }\r\r\n }\r\r\n\r\r\n\r\r\n DATA_SYNC();\r\r\n\r\r\n\r\r\n if((ps_dec_op->u4_error_code & 0xff)\r\r\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\r\r\n {\r\r\n ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\r\r\n ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\r\r\n }\r\r\n\r\r\n if(ps_dec->i4_header_decoded != 3)\r\r\n {\r\r\n ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\r\r\n\r\r\n }\r\r\n\r\r\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\r\r\n {\r\r\n ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\r\r\n\r\r\n }\r\r\n if(ps_dec->u4_prev_nal_skipped)\r\r\n {\r\r\n /*We have encountered a referenced frame,return to app*/\r\r\n ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\r\r\n ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\r\r\n ps_dec_op->u4_frame_decoded_flag = 0;\r\r\n ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\r\r\n /* close deblock thread if it is not closed yet*/\r\r\n if(ps_dec->u4_num_cores == 3)\r\r\n {\r\r\n ih264d_signal_bs_deblk_thread(ps_dec);\r\r\n }\r\r\n return (IV_FAIL);\r\r\n\r\r\n }\r\r\n\r\r\n if((ps_dec->u4_slice_start_code_found == 1)\r\r\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\r\r\n {\r\r\n /*\r\r\n * For field pictures, set the bottom and top picture decoded u4_flag correctly.\r\r\n */\r\r\n\r\r\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\r\r\n {\r\r\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\r\r\n {\r\r\n ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\r\r\n }\r\r\n else\r\r\n {\r\r\n ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\r\r\n }\r\r\n }\r\r\n\r\r\n /* if new frame in not found (if we are still getting slices from previous frame)\r\r\n * ih264d_deblock_display is not called. Such frames will not be added to reference /display\r\r\n */\r\r\n if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\r\r\n {\r\r\n /* Calling Function to deblock Picture and Display */\r\r\n ret = ih264d_deblock_display(ps_dec);\r\r\n if(ret != 0)\r\r\n {\r\r\n return IV_FAIL;\r\r\n }\r\r\n }\r\r\n\r\r\n\r\r\n /*set to complete ,as we dont support partial frame decode*/\r\r\n if(ps_dec->i4_header_decoded == 3)\r\r\n {\r\r\n ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\r\r\n }\r\r\n\r\r\n /*Update the i4_frametype at the end of picture*/\r\r\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\r\r\n {\r\r\n ps_dec->i4_frametype = IV_IDR_FRAME;\r\r\n }\r\r\n else if(ps_dec->i4_pic_type == B_SLICE)\r\r\n {\r\r\n ps_dec->i4_frametype = IV_B_FRAME;\r\r\n }\r\r\n else if(ps_dec->i4_pic_type == P_SLICE)\r\r\n {\r\r\n ps_dec->i4_frametype = IV_P_FRAME;\r\r\n }\r\r\n else if(ps_dec->i4_pic_type == I_SLICE)\r\r\n {\r\r\n ps_dec->i4_frametype = IV_I_FRAME;\r\r\n }\r\r\n else\r\r\n {\r\r\n H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\r\r\n }\r\r\n\r\r\n ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\r\r\n\r\r\n ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\r\r\n ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\r\r\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\r\r\n\r\r\n }\r\r\n\r\r\n /* close deblock thread if it is not closed yet*/\r\r\n if(ps_dec->u4_num_cores == 3)\r\r\n {\r\r\n ih264d_signal_bs_deblk_thread(ps_dec);\r\r\n }\r\r\n\r\r\n\r\r\n {\r\r\n /* In case the decoder is configured to run in low delay mode,\r\r\n * then get display buffer and then format convert.\r\r\n * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\r\r\n */\r\r\n\r\r\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\r\r\n && ps_dec->u1_init_dec_flag)\r\r\n {\r\r\n\r\r\n ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\r\r\n &(ps_dec->s_disp_op));\r\r\n if(0 == ps_dec->s_disp_op.u4_error_code)\r\r\n {\r\r\n ps_dec->u4_fmt_conv_cur_row = 0;\r\r\n ps_dec->u4_output_present = 1;\r\r\n }\r\r\n }\r\r\n\r\r\n ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\r\r\n\r\r\n /* If Format conversion is not complete,\r\r\n complete it here */\r\r\n if(ps_dec->u4_output_present &&\r\r\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\r\r\n {\r\r\n ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\r\r\n - ps_dec->u4_fmt_conv_cur_row;\r\r\n ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\r\r\n ps_dec->u4_fmt_conv_cur_row,\r\r\n ps_dec->u4_fmt_conv_num_rows);\r\r\n ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\r\r\n }\r\r\n\r\r\n ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\r\r\n }\r\r\n\r\r\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\r\r\n {\r\r\n ps_dec_op->u4_progressive_frame_flag = 1;\r\r\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\r\r\n {\r\r\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\r\r\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\r\r\n ps_dec_op->u4_progressive_frame_flag = 0;\r\r\n\r\r\n }\r\r\n }\r\r\n\r\r\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\r\r\n DATA_SYNC();\r\r\n\r\r\n H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\r\r\n ps_dec_op->u4_num_bytes_consumed);\r\r\n return api_ret_value;\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint suppressors_modalize = 0;\r\nint global_variable;\r\n\r\nunion ureterostomies_patrizate \r\n{\r\n char *stromal_miseries;\r\n double pomiculture_groupoids;\r\n char *yolkiest_stronghurst;\r\n char trepanning_intentively;\r\n int homoplastically_interwreathed;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid regalvanization_palisado(union ureterostomies_patrizate *chalcis_uncaptived);\r\nvoid snippily_yarnell(union ureterostomies_patrizate *trimerite_tangibleness);\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n union ureterostomies_patrizate *weaver_recitement = {0};\r\n union ureterostomies_patrizate tomtit_hexathlon;\r\n char *klarika_loudlier;;\r\n if (__sync_bool_compare_and_swap(&suppressors_modalize,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n klarika_loudlier = getenv(\"MORTORIO_UNCURB\");\r\n if (klarika_loudlier != 0) {;\r\n tomtit_hexathlon . stromal_miseries = klarika_loudlier;\r\n weaver_recitement = &tomtit_hexathlon;\r\n regalvanization_palisado(weaver_recitement);\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid regalvanization_palisado(union ureterostomies_patrizate *chalcis_uncaptived)\r\n{\r\n ++global_variable;;\r\n snippily_yarnell(chalcis_uncaptived);\r\n}\r\n\r\nvoid snippily_yarnell(union ureterostomies_patrizate *trimerite_tangibleness)\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *oculary_popeyed = 0;\r\n ++global_variable;;\r\n oculary_popeyed = ((char *)( *trimerite_tangibleness) . stromal_miseries);\r\n \r\n taint_size = strlen(oculary_popeyed);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,oculary_popeyed,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\nclose_printf_context();\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n \n \n if (malloced_buff[ss_i] == 0 && errno == 12) {\n printf(\"Malloc error due to ulimit\\n\");\n if (trace_flag == 0) {\n \n```", "cwe": "401"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\nint desktops_sesquinona = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid chocho_cumbrance(char *const islanded_lyburn);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int phthalanilic_unforbiddenness = 30;\r\n char *birdless_nemaline;;\r\n if (__sync_bool_compare_and_swap(&desktops_sesquinona,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&birdless_nemaline,\"4357\",phthalanilic_unforbiddenness);\r\n if (birdless_nemaline != 0) {;\r\n chocho_cumbrance(birdless_nemaline);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid chocho_cumbrance(char *const islanded_lyburn)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *maximins_plecotine = 0;\r\n int stringwood_histone;\r\n int supernaturalist_yawn;\r\n ++global_variable;;\r\n supernaturalist_yawn = 5;\r\n while(1 == 1){\r\n supernaturalist_yawn = supernaturalist_yawn * 2;\r\n supernaturalist_yawn = supernaturalist_yawn + 2;\r\n if (supernaturalist_yawn > 1000) {\r\n break; \r\n }\r\n }\r\n stringwood_histone = supernaturalist_yawn;\r\n maximins_plecotine = ((char *)((char *)islanded_lyburn));\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",maximins_plecotine);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (((char *)islanded_lyburn) != 0) \r\n free(((char *)((char *)islanded_lyburn)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "gethttp (const struct url *u, struct url *original_url, struct http_stat *hs,\r\r\n int *dt, struct url *proxy, struct iri *iri, int count)\r\r\n{\r\r\n struct request *req = NULL;\r\r\n\r\r\n char *type = NULL;\r\r\n char *user, *passwd;\r\r\n char *proxyauth;\r\r\n int statcode;\r\r\n int write_error;\r\r\n wgint contlen, contrange;\r\r\n const struct url *conn;\r\r\n FILE *fp;\r\r\n int err;\r\r\n uerr_t retval;\r\r\n#ifdef HAVE_HSTS\r\r\n#ifdef TESTING\r\r\n /* we don't link against main.o when we're testing */\r\r\n hsts_store_t hsts_store = NULL;\r\r\n#else\r\r\n extern hsts_store_t hsts_store;\r\r\n#endif\r\r\n const char *hsts_params;\r\r\n time_t max_age;\r\r\n bool include_subdomains;\r\r\n#endif\r\r\n\r\r\n int sock = -1;\r\r\n\r\r\n /* Set to 1 when the authorization has already been sent and should\r\r\n not be tried again. */\r\r\n bool auth_finished = false;\r\r\n\r\r\n /* Set to 1 when just globally-set Basic authorization has been sent;\r\r\n * should prevent further Basic negotiations, but not other\r\r\n * mechanisms. */\r\r\n bool basic_auth_finished = false;\r\r\n\r\r\n /* Whether NTLM authentication is used for this request. */\r\r\n bool ntlm_seen = false;\r\r\n\r\r\n /* Whether our connection to the remote host is through SSL. */\r\r\n bool using_ssl = false;\r\r\n\r\r\n /* Whether a HEAD request will be issued (as opposed to GET or\r\r\n POST). */\r\r\n bool head_only = !!(*dt & HEAD_ONLY);\r\r\n\r\r\n /* Whether conditional get request will be issued. */\r\r\n bool cond_get = !!(*dt & IF_MODIFIED_SINCE);\r\r\n\r\r\n#ifdef HAVE_METALINK\r\r\n /* Are we looking for metalink info in HTTP headers? */\r\r\n bool metalink = !!(*dt & METALINK_METADATA);\r\r\n#endif\r\r\n\r\r\n char *head = NULL;\r\r\n struct response *resp = NULL;\r\r\n char hdrval[512];\r\r\n char *message = NULL;\r\r\n\r\r\n /* Declare WARC variables. */\r\r\n bool warc_enabled = (opt.warc_filename != NULL);\r\r\n FILE *warc_tmp = NULL;\r\r\n char warc_timestamp_str [21];\r\r\n char warc_request_uuid [48];\r\r\n ip_address *warc_ip = NULL;\r\r\n off_t warc_payload_offset = -1;\r\r\n\r\r\n /* Whether this connection will be kept alive after the HTTP request\r\r\n is done. */\r\r\n bool keep_alive;\r\r\n\r\r\n /* Is the server using the chunked transfer encoding? */\r\r\n bool chunked_transfer_encoding = false;\r\r\n\r\r\n /* Whether keep-alive should be inhibited. */\r\r\n bool inhibit_keep_alive =\r\r\n !opt.http_keep_alive || opt.ignore_length;\r\r\n\r\r\n /* Headers sent when using POST. */\r\r\n wgint body_data_size = 0;\r\r\n\r\r\n#ifdef HAVE_SSL\r\r\n if (u->scheme == SCHEME_HTTPS)\r\r\n {\r\r\n /* Initialize the SSL context. After this has once been done,\r\r\n it becomes a no-op. */\r\r\n if (!ssl_init ())\r\r\n {\r\r\n scheme_disable (SCHEME_HTTPS);\r\r\n logprintf (LOG_NOTQUIET,\r\r\n _(\"Disabling SSL due to encountered errors.\\n\"));\r\r\n retval = SSLINITFAILED;\r\r\n goto cleanup;\r\r\n }\r\r\n }\r\r\n#endif /* HAVE_SSL */\r\r\n\r\r\n /* Initialize certain elements of struct http_stat. */\r\r\n hs->len = 0;\r\r\n hs->contlen = -1;\r\r\n hs->res = -1;\r\r\n hs->rderrmsg = NULL;\r\r\n hs->newloc = NULL;\r\r\n xfree (hs->remote_time);\r\r\n hs->error = NULL;\r\r\n hs->message = NULL;\r\r\n hs->local_encoding = ENC_NONE;\r\r\n hs->remote_encoding = ENC_NONE;\r\r\n\r\r\n conn = u;\r\r\n\r\r\n {\r\r\n uerr_t ret;\r\r\n req = initialize_request (u, hs, dt, proxy, inhibit_keep_alive,\r\r\n &basic_auth_finished, &body_data_size,\r\r\n &user, &passwd, &ret);\r\r\n if (req == NULL)\r\r\n {\r\r\n retval = ret;\r\r\n goto cleanup;\r\r\n }\r\r\n }\r\r\n retry_with_auth:\r\r\n /* We need to come back here when the initial attempt to retrieve\r\r\n without authorization header fails. (Expected to happen at least\r\r\n for the Digest authorization scheme.) */\r\r\n\r\r\n if (opt.cookies)\r\r\n request_set_header (req, \"Cookie\",\r\r\n cookie_header (wget_cookie_jar,\r\r\n u->host, u->port, u->path,\r\r\n#ifdef HAVE_SSL\r\r\n u->scheme == SCHEME_HTTPS\r\r\n#else\r\r\n 0\r\r\n#endif\r\r\n ),\r\r\n rel_value);\r\r\n\r\r\n /* Add the user headers. */\r\r\n if (opt.user_headers)\r\r\n {\r\r\n int i;\r\r\n for (i = 0; opt.user_headers[i]; i++)\r\r\n request_set_user_header (req, opt.user_headers[i]);\r\r\n }\r\r\n\r\r\n proxyauth = NULL;\r\r\n if (proxy)\r\r\n {\r\r\n conn = proxy;\r\r\n initialize_proxy_configuration (u, req, proxy, &proxyauth);\r\r\n }\r\r\n keep_alive = true;\r\r\n\r\r\n /* Establish the connection. */\r\r\n if (inhibit_keep_alive)\r\r\n keep_alive = false;\r\r\n\r\r\n {\r\r\n uerr_t conn_err = establish_connection (u, &conn, hs, proxy, &proxyauth, &req,\r\r\n &using_ssl, inhibit_keep_alive, &sock);\r\r\n if (conn_err != RETROK)\r\r\n {\r\r\n retval = conn_err;\r\r\n goto cleanup;\r\r\n }\r\r\n }\r\r\n\r\r\n /* Open the temporary file where we will write the request. */\r\r\n if (warc_enabled)\r\r\n {\r\r\n warc_tmp = warc_tempfile ();\r\r\n if (warc_tmp == NULL)\r\r\n {\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = WARC_TMP_FOPENERR;\r\r\n goto cleanup;\r\r\n }\r\r\n\r\r\n if (! proxy)\r\r\n {\r\r\n warc_ip = (ip_address *) alloca (sizeof (ip_address));\r\r\n socket_ip_address (sock, warc_ip, ENDPOINT_PEER);\r\r\n }\r\r\n }\r\r\n\r\r\n /* Send the request to server. */\r\r\n write_error = request_send (req, sock, warc_tmp);\r\r\n\r\r\n if (write_error >= 0)\r\r\n {\r\r\n if (opt.body_data)\r\r\n {\r\r\n DEBUGP ((\"[BODY data: %s]\\n\", opt.body_data));\r\r\n write_error = fd_write (sock, opt.body_data, body_data_size, -1);\r\r\n if (write_error >= 0 && warc_tmp != NULL)\r\r\n {\r\r\n int warc_tmp_written;\r\r\n\r\r\n /* Remember end of headers / start of payload. */\r\r\n warc_payload_offset = ftello (warc_tmp);\r\r\n\r\r\n /* Write a copy of the data to the WARC record. */\r\r\n warc_tmp_written = fwrite (opt.body_data, 1, body_data_size, warc_tmp);\r\r\n if (warc_tmp_written != body_data_size)\r\r\n write_error = -2;\r\r\n }\r\r\n }\r\r\n else if (opt.body_file && body_data_size != 0)\r\r\n {\r\r\n if (warc_tmp != NULL)\r\r\n /* Remember end of headers / start of payload */\r\r\n warc_payload_offset = ftello (warc_tmp);\r\r\n\r\r\n write_error = body_file_send (sock, opt.body_file, body_data_size, warc_tmp);\r\r\n }\r\r\n }\r\r\n\r\r\n if (write_error < 0)\r\r\n {\r\r\n CLOSE_INVALIDATE (sock);\r\r\n\r\r\n if (warc_tmp != NULL)\r\r\n fclose (warc_tmp);\r\r\n\r\r\n if (write_error == -2)\r\r\n retval = WARC_TMP_FWRITEERR;\r\r\n else\r\r\n retval = WRITEFAILED;\r\r\n goto cleanup;\r\r\n }\r\r\n logprintf (LOG_VERBOSE, _(\"%s request sent, awaiting response... \"),\r\r\n proxy ? \"Proxy\" : \"HTTP\");\r\r\n contlen = -1;\r\r\n contrange = 0;\r\r\n *dt &= ~RETROKF;\r\r\n\r\r\n\r\r\n if (warc_enabled)\r\r\n {\r\r\n bool warc_result;\r\r\n\r\r\n /* Generate a timestamp and uuid for this request. */\r\r\n warc_timestamp (warc_timestamp_str, sizeof (warc_timestamp_str));\r\r\n warc_uuid_str (warc_request_uuid);\r\r\n\r\r\n /* Create a request record and store it in the WARC file. */\r\r\n warc_result = warc_write_request_record (u->url, warc_timestamp_str,\r\r\n warc_request_uuid, warc_ip,\r\r\n warc_tmp, warc_payload_offset);\r\r\n if (! warc_result)\r\r\n {\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = WARC_ERR;\r\r\n goto cleanup;\r\r\n }\r\r\n\r\r\n /* warc_write_request_record has also closed warc_tmp. */\r\r\n }\r\r\n\r\r\n /* Repeat while we receive a 10x response code. */\r\r\n {\r\r\n bool _repeat;\r\r\n\r\r\n do\r\r\n {\r\r\n head = read_http_response_head (sock);\r\r\n if (!head)\r\r\n {\r\r\n if (errno == 0)\r\r\n {\r\r\n logputs (LOG_NOTQUIET, _(\"No data received.\\n\"));\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = HEOF;\r\r\n }\r\r\n else\r\r\n {\r\r\n logprintf (LOG_NOTQUIET, _(\"Read error (%s) in headers.\\n\"),\r\r\n fd_errstr (sock));\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = HERR;\r\r\n }\r\r\n goto cleanup;\r\r\n }\r\r\n DEBUGP ((\"\\n---response begin---\\n%s---response end---\\n\", head));\r\r\n\r\r\n resp = resp_new (head);\r\r\n\r\r\n /* Check for status line. */\r\r\n xfree (message);\r\r\n statcode = resp_status (resp, &message);\r\r\n if (statcode < 0)\r\r\n {\r\r\n char *tms = datetime_str (time (NULL));\r\r\n logprintf (LOG_VERBOSE, \"%d\\n\", statcode);\r\r\n logprintf (LOG_NOTQUIET, _(\"%s ERROR %d: %s.\\n\"), tms, statcode,\r\r\n quotearg_style (escape_quoting_style,\r\r\n _(\"Malformed status line\")));\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = HERR;\r\r\n goto cleanup;\r\r\n }\r\r\n\r\r\n if (H_10X (statcode))\r\r\n {\r\r\n xfree (head);\r\r\n resp_free (&resp);\r\r\n _repeat = true;\r\r\n DEBUGP ((\"Ignoring response\\n\"));\r\r\n }\r\r\n else\r\r\n {\r\r\n _repeat = false;\r\r\n }\r\r\n }\r\r\n while (_repeat);\r\r\n }\r\r\n\r\r\n xfree (hs->message);\r\r\n hs->message = xstrdup (message);\r\r\n if (!opt.server_response)\r\r\n logprintf (LOG_VERBOSE, \"%2d %s\\n\", statcode,\r\r\n message ? quotearg_style (escape_quoting_style, message) : \"\");\r\r\n else\r\r\n {\r\r\n logprintf (LOG_VERBOSE, \"\\n\");\r\r\n print_server_response (resp, \" \");\r\r\n }\r\r\n\r\r\n if (!opt.ignore_length\r\r\n && resp_header_copy (resp, \"Content-Length\", hdrval, sizeof (hdrval)))\r\r\n {\r\r\n wgint parsed;\r\r\n errno = 0;\r\r\n parsed = str_to_wgint (hdrval, NULL, 10);\r\r\n if (parsed == WGINT_MAX && errno == ERANGE)\r\r\n {\r\r\n /* Out of range.\r\r\n #### If Content-Length is out of range, it most likely\r\r\n means that the file is larger than 2G and that we're\r\r\n compiled without LFS. In that case we should probably\r\r\n refuse to even attempt to download the file. */\r\r\n contlen = -1;\r\r\n }\r\r\n else if (parsed < 0)\r\r\n {\r\r\n /* Negative Content-Length; nonsensical, so we can't\r\r\n assume any information about the content to receive. */\r\r\n contlen = -1;\r\r\n }\r\r\n else\r\r\n contlen = parsed;\r\r\n }\r\r\n\r\r\n /* Check for keep-alive related responses. */\r\r\n if (!inhibit_keep_alive)\r\r\n {\r\r\n if (resp_header_copy (resp, \"Connection\", hdrval, sizeof (hdrval)))\r\r\n {\r\r\n if (0 == c_strcasecmp (hdrval, \"Close\"))\r\r\n keep_alive = false;\r\r\n }\r\r\n }\r\r\n\r\r\n chunked_transfer_encoding = false;\r\r\n if (resp_header_copy (resp, \"Transfer-Encoding\", hdrval, sizeof (hdrval))\r\r\n && 0 == c_strcasecmp (hdrval, \"chunked\"))\r\r\n chunked_transfer_encoding = true;\r\r\n\r\r\n /* Handle (possibly multiple instances of) the Set-Cookie header. */\r\r\n if (opt.cookies)\r\r\n {\r\r\n int scpos;\r\r\n const char *scbeg, *scend;\r\r\n /* The jar should have been created by now. */\r\r\n assert (wget_cookie_jar != NULL);\r\r\n for (scpos = 0;\r\r\n (scpos = resp_header_locate (resp, \"Set-Cookie\", scpos,\r\r\n &scbeg, &scend)) != -1;\r\r\n ++scpos)\r\r\n {\r\r\n char *set_cookie; BOUNDED_TO_ALLOCA (scbeg, scend, set_cookie);\r\r\n cookie_handle_set_cookie (wget_cookie_jar, u->host, u->port,\r\r\n u->path, set_cookie);\r\r\n }\r\r\n }\r\r\n\r\r\n if (keep_alive)\r\r\n /* The server has promised that it will not close the connection\r\r\n when we're done. This means that we can register it. */\r\r\n register_persistent (conn->host, conn->port, sock, using_ssl);\r\r\n\r\r\n#ifdef HAVE_METALINK\r\r\n /* We need to check for the Metalink data in the very first response\r\r\n we get from the server (before redirections, authorization, etc.). */\r\r\n if (metalink)\r\r\n {\r\r\n hs->metalink = metalink_from_http (resp, hs, u);\r\r\n /* Bugfix: hs->local_file is NULL (opt.content_disposition). */\r\r\n if (!hs->local_file && hs->metalink && hs->metalink->origin)\r\r\n hs->local_file = xstrdup (hs->metalink->origin);\r\r\n xfree (hs->message);\r\r\n retval = RETR_WITH_METALINK;\r\r\n CLOSE_FINISH (sock);\r\r\n goto cleanup;\r\r\n }\r\r\n#endif\r\r\n\r\r\n if (statcode == HTTP_STATUS_UNAUTHORIZED)\r\r\n {\r\r\n /* Authorization is required. */\r\r\n uerr_t auth_err = RETROK;\r\r\n bool retry;\r\r\n /* Normally we are not interested in the response body.\r\r\n But if we are writing a WARC file we are: we like to keep everything. */\r\r\n if (warc_enabled)\r\r\n {\r\r\n int _err;\r\r\n type = resp_header_strdup (resp, \"Content-Type\");\r\r\n _err = read_response_body (hs, sock, NULL, contlen, 0,\r\r\n chunked_transfer_encoding,\r\r\n u->url, warc_timestamp_str,\r\r\n warc_request_uuid, warc_ip, type,\r\r\n statcode, head);\r\r\n xfree (type);\r\r\n\r\r\n if (_err != RETRFINISHED || hs->res < 0)\r\r\n {\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = _err;\r\r\n goto cleanup;\r\r\n }\r\r\n else\r\r\n CLOSE_FINISH (sock);\r\r\n }\r\r\n else\r\r\n {\r\r\n /* Since WARC is disabled, we are not interested in the response body. */\r\r\n if (keep_alive && !head_only\r\r\n && skip_short_body (sock, contlen, chunked_transfer_encoding))\r\r\n CLOSE_FINISH (sock);\r\r\n else\r\r\n CLOSE_INVALIDATE (sock);\r\r\n }\r\r\n\r\r\n pconn.authorized = false;\r\r\n\r\r\n {\r\r\n auth_err = check_auth (u, user, passwd, resp, req,\r\r\n &ntlm_seen, &retry,\r\r\n &basic_auth_finished,\r\r\n &auth_finished);\r\r\n if (auth_err == RETROK && retry)\r\r\n {\r\r\n xfree (hs->message);\r\r\n resp_free (&resp);\r\r\n xfree (message);\r\r\n xfree (head);\r\r\n goto retry_with_auth;\r\r\n }\r\r\n }\r\r\n if (auth_err == RETROK)\r\r\n retval = AUTHFAILED;\r\r\n else\r\r\n retval = auth_err;\r\r\n goto cleanup;\r\r\n }\r\r\n else /* statcode != HTTP_STATUS_UNAUTHORIZED */\r\r\n {\r\r\n /* Kludge: if NTLM is used, mark the TCP connection as authorized. */\r\r\n if (ntlm_seen)\r\r\n pconn.authorized = true;\r\r\n }\r\r\n\r\r\n {\r\r\n uerr_t ret = check_file_output (u, hs, resp, hdrval, sizeof hdrval);\r\r\n if (ret != RETROK)\r\r\n {\r\r\n retval = ret;\r\r\n goto cleanup;\r\r\n }\r\r\n }\r\r\n\r\r\n hs->statcode = statcode;\r\r\n if (statcode == -1)\r\r\n hs->error = xstrdup (_(\"Malformed status line\"));\r\r\n else if (!*message)\r\r\n hs->error = xstrdup (_(\"(no description)\"));\r\r\n else\r\r\n hs->error = xstrdup (message);\r\r\n\r\r\n#ifdef HAVE_HSTS\r\r\n if (opt.hsts && hsts_store)\r\r\n {\r\r\n hsts_params = resp_header_strdup (resp, \"Strict-Transport-Security\");\r\r\n if (parse_strict_transport_security (hsts_params, &max_age, &include_subdomains))\r\r\n {\r\r\n /* process strict transport security */\r\r\n if (hsts_store_entry (hsts_store, u->scheme, u->host, u->port, max_age, include_subdomains))\r\r\n DEBUGP((\"Added new HSTS host: %s:%u (max-age: %lu, includeSubdomains: %s)\\n\",\r\r\n u->host,\r\r\n (unsigned) u->port,\r\r\n (unsigned long) max_age,\r\r\n (include_subdomains ? \"true\" : \"false\")));\r\r\n else\r\r\n DEBUGP((\"Updated HSTS host: %s:%u (max-age: %lu, includeSubdomains: %s)\\n\",\r\r\n u->host,\r\r\n (unsigned) u->port,\r\r\n (unsigned long) max_age,\r\r\n (include_subdomains ? \"true\" : \"false\")));\r\r\n }\r\r\n }\r\r\n#endif\r\r\n\r\r\n type = resp_header_strdup (resp, \"Content-Type\");\r\r\n if (type)\r\r\n {\r\r\n char *tmp = strchr (type, ';');\r\r\n if (tmp)\r\r\n {\r\r\n#ifdef ENABLE_IRI\r\r\n /* sXXXav: only needed if IRI support is enabled */\r\r\n char *tmp2 = tmp + 1;\r\r\n#endif\r\r\n\r\r\n while (tmp > type && c_isspace (tmp[-1]))\r\r\n --tmp;\r\r\n *tmp = '\\0';\r\r\n\r\r\n#ifdef ENABLE_IRI\r\r\n /* Try to get remote encoding if needed */\r\r\n if (opt.enable_iri && !opt.encoding_remote)\r\r\n {\r\r\n tmp = parse_charset (tmp2);\r\r\n if (tmp)\r\r\n set_content_encoding (iri, tmp);\r\r\n xfree (tmp);\r\r\n }\r\r\n#endif\r\r\n }\r\r\n }\r\r\n hs->newloc = resp_header_strdup (resp, \"Location\");\r\r\n hs->remote_time = resp_header_strdup (resp, \"Last-Modified\");\r\r\n if (!hs->remote_time) // now look for the Wayback Machine's timestamp\r\r\n hs->remote_time = resp_header_strdup (resp, \"X-Archive-Orig-last-modified\");\r\r\n\r\r\n if (resp_header_copy (resp, \"Content-Range\", hdrval, sizeof (hdrval)))\r\r\n {\r\r\n wgint first_byte_pos, last_byte_pos, entity_length;\r\r\n if (parse_content_range (hdrval, &first_byte_pos, &last_byte_pos,\r\r\n &entity_length))\r\r\n {\r\r\n contrange = first_byte_pos;\r\r\n contlen = last_byte_pos - first_byte_pos + 1;\r\r\n }\r\r\n }\r\r\n\r\r\n if (resp_header_copy (resp, \"Content-Encoding\", hdrval, sizeof (hdrval)))\r\r\n {\r\r\n hs->local_encoding = ENC_INVALID;\r\r\n\r\r\n switch (hdrval[0])\r\r\n {\r\r\n case 'b': case 'B':\r\r\n if (0 == c_strcasecmp(hdrval, \"br\"))\r\r\n hs->local_encoding = ENC_BROTLI;\r\r\n break;\r\r\n case 'c': case 'C':\r\r\n if (0 == c_strcasecmp(hdrval, \"compress\"))\r\r\n hs->local_encoding = ENC_COMPRESS;\r\r\n break;\r\r\n case 'd': case 'D':\r\r\n if (0 == c_strcasecmp(hdrval, \"deflate\"))\r\r\n hs->local_encoding = ENC_DEFLATE;\r\r\n break;\r\r\n case 'g': case 'G':\r\r\n if (0 == c_strcasecmp(hdrval, \"gzip\"))\r\r\n hs->local_encoding = ENC_GZIP;\r\r\n break;\r\r\n case 'i': case 'I':\r\r\n if (0 == c_strcasecmp(hdrval, \"identity\"))\r\r\n hs->local_encoding = ENC_NONE;\r\r\n break;\r\r\n case 'x': case 'X':\r\r\n if (0 == c_strcasecmp(hdrval, \"x-compress\"))\r\r\n hs->local_encoding = ENC_COMPRESS;\r\r\n else if (0 == c_strcasecmp(hdrval, \"x-gzip\"))\r\r\n hs->local_encoding = ENC_GZIP;\r\r\n break;\r\r\n case '\\0':\r\r\n hs->local_encoding = ENC_NONE;\r\r\n }\r\r\n\r\r\n if (hs->local_encoding == ENC_INVALID)\r\r\n {\r\r\n DEBUGP ((\"Unrecognized Content-Encoding: %s\\n\", hdrval));\r\r\n hs->local_encoding = ENC_NONE;\r\r\n }\r\r\n#ifdef HAVE_LIBZ\r\r\n else if (hs->local_encoding == ENC_GZIP\r\r\n && opt.compression != compression_none)\r\r\n {\r\r\n const char *p;\r\r\n\r\r\n /* Make sure the Content-Type is not gzip before decompressing */\r\r\n if (type)\r\r\n {\r\r\n p = strchr (type, '/');\r\r\n if (p == NULL)\r\r\n {\r\r\n hs->remote_encoding = ENC_GZIP;\r\r\n hs->local_encoding = ENC_NONE;\r\r\n }\r\r\n else\r\r\n {\r\r\n p++;\r\r\n if (c_tolower(p[0]) == 'x' && p[1] == '-')\r\r\n p += 2;\r\r\n if (0 != c_strcasecmp (p, \"gzip\"))\r\r\n {\r\r\n hs->remote_encoding = ENC_GZIP;\r\r\n hs->local_encoding = ENC_NONE;\r\r\n }\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n hs->remote_encoding = ENC_GZIP;\r\r\n hs->local_encoding = ENC_NONE;\r\r\n }\r\r\n\r\r\n /* don't uncompress if a file ends with '.gz' or '.tgz' */\r\r\n if (hs->remote_encoding == ENC_GZIP\r\r\n && (p = strrchr(u->file, '.'))\r\r\n && (c_strcasecmp(p, \".gz\") == 0 || c_strcasecmp(p, \".tgz\") == 0))\r\r\n {\r\r\n DEBUGP ((\"Enabling broken server workaround. Will not decompress this GZip file.\\n\"));\r\r\n hs->remote_encoding = ENC_NONE;\r\r\n }\r\r\n }\r\r\n#endif\r\r\n }\r\r\n\r\r\n /* 20x responses are counted among successful by default. */\r\r\n if (H_20X (statcode))\r\r\n *dt |= RETROKF;\r\r\n\r\r\n if (statcode == HTTP_STATUS_NO_CONTENT)\r\r\n {\r\r\n /* 204 response has no body (RFC 2616, 4.3) */\r\r\n\r\r\n /* In case the caller cares to look... */\r\r\n hs->len = 0;\r\r\n hs->res = 0;\r\r\n hs->restval = 0;\r\r\n\r\r\n CLOSE_FINISH (sock);\r\r\n\r\r\n retval = RETRFINISHED;\r\r\n goto cleanup;\r\r\n }\r\r\n\r\r\n /* Return if redirected. */\r\r\n if (H_REDIRECTED (statcode) || statcode == HTTP_STATUS_MULTIPLE_CHOICES)\r\r\n {\r\r\n /* RFC2068 says that in case of the 300 (multiple choices)\r\r\n response, the server can output a preferred URL through\r\r\n `Location' header; otherwise, the request should be treated\r\r\n like GET. So, if the location is set, it will be a\r\r\n redirection; otherwise, just proceed normally. */\r\r\n if (statcode == HTTP_STATUS_MULTIPLE_CHOICES && !hs->newloc)\r\r\n *dt |= RETROKF;\r\r\n else\r\r\n {\r\r\n logprintf (LOG_VERBOSE,\r\r\n _(\"Location: %s%s\\n\"),\r\r\n hs->newloc ? escnonprint_uri (hs->newloc) : _(\"unspecified\"),\r\r\n hs->newloc ? _(\" [following]\") : \"\");\r\r\n\r\r\n /* In case the caller cares to look... */\r\r\n hs->len = 0;\r\r\n hs->res = 0;\r\r\n hs->restval = 0;\r\r\n\r\r\n /* Normally we are not interested in the response body of a redirect.\r\r\n But if we are writing a WARC file we are: we like to keep everything. */\r\r\n if (warc_enabled)\r\r\n {\r\r\n int _err = read_response_body (hs, sock, NULL, contlen, 0,\r\r\n chunked_transfer_encoding,\r\r\n u->url, warc_timestamp_str,\r\r\n warc_request_uuid, warc_ip, type,\r\r\n statcode, head);\r\r\n\r\r\n if (_err != RETRFINISHED || hs->res < 0)\r\r\n {\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = _err;\r\r\n goto cleanup;\r\r\n }\r\r\n else\r\r\n CLOSE_FINISH (sock);\r\r\n }\r\r\n else\r\r\n {\r\r\n /* Since WARC is disabled, we are not interested in the response body. */\r\r\n if (keep_alive && !head_only\r\r\n && skip_short_body (sock, contlen, chunked_transfer_encoding))\r\r\n CLOSE_FINISH (sock);\r\r\n else\r\r\n CLOSE_INVALIDATE (sock);\r\r\n }\r\r\n\r\r\n /* From RFC2616: The status codes 303 and 307 have\r\r\n been added for servers that wish to make unambiguously\r\r\n clear which kind of reaction is expected of the client.\r\r\n\r\r\n A 307 should be redirected using the same method,\r\r\n in other words, a POST should be preserved and not\r\r\n converted to a GET in that case.\r\r\n\r\r\n With strict adherence to RFC2616, POST requests are not\r\r\n converted to a GET request on 301 Permanent Redirect\r\r\n or 302 Temporary Redirect.\r\r\n\r\r\n A switch may be provided later based on the HTTPbis draft\r\r\n that allows clients to convert POST requests to GET\r\r\n requests on 301 and 302 response codes. */\r\r\n switch (statcode)\r\r\n {\r\r\n case HTTP_STATUS_TEMPORARY_REDIRECT:\r\r\n case HTTP_STATUS_PERMANENT_REDIRECT:\r\r\n retval = NEWLOCATION_KEEP_POST;\r\r\n goto cleanup;\r\r\n case HTTP_STATUS_MOVED_PERMANENTLY:\r\r\n if (opt.method && c_strcasecmp (opt.method, \"post\") != 0)\r\r\n {\r\r\n retval = NEWLOCATION_KEEP_POST;\r\r\n goto cleanup;\r\r\n }\r\r\n break;\r\r\n case HTTP_STATUS_MOVED_TEMPORARILY:\r\r\n if (opt.method && c_strcasecmp (opt.method, \"post\") != 0)\r\r\n {\r\r\n retval = NEWLOCATION_KEEP_POST;\r\r\n goto cleanup;\r\r\n }\r\r\n break;\r\r\n }\r\r\n retval = NEWLOCATION;\r\r\n goto cleanup;\r\r\n }\r\r\n }\r\r\n\r\r\n if (cond_get)\r\r\n {\r\r\n if (statcode == HTTP_STATUS_NOT_MODIFIED)\r\r\n {\r\r\n logprintf (LOG_VERBOSE,\r\r\n _ (\"File %s not modified on server. Omitting download.\\n\\n\"),\r\r\n quote (hs->local_file));\r\r\n *dt |= RETROKF;\r\r\n CLOSE_FINISH (sock);\r\r\n retval = RETRUNNEEDED;\r\r\n goto cleanup;\r\r\n }\r\r\n }\r\r\n\r\r\n set_content_type (dt, type);\r\r\n\r\r\n if (opt.adjust_extension)\r\r\n {\r\r\n const char *encoding_ext = NULL;\r\r\n switch (hs->local_encoding)\r\r\n {\r\r\n case ENC_INVALID:\r\r\n case ENC_NONE:\r\r\n break;\r\r\n case ENC_BROTLI:\r\r\n encoding_ext = \".br\";\r\r\n break;\r\r\n case ENC_COMPRESS:\r\r\n encoding_ext = \".Z\";\r\r\n break;\r\r\n case ENC_DEFLATE:\r\r\n encoding_ext = \".zlib\";\r\r\n break;\r\r\n case ENC_GZIP:\r\r\n encoding_ext = \".gz\";\r\r\n break;\r\r\n default:\r\r\n DEBUGP ((\"No extension found for encoding %d\\n\",\r\r\n hs->local_encoding));\r\r\n }\r\r\n if (encoding_ext != NULL)\r\r\n {\r\r\n char *file_ext = strrchr (hs->local_file, '.');\r\r\n /* strip Content-Encoding extension (it will be re-added later) */\r\r\n if (file_ext != NULL && 0 == strcasecmp (file_ext, encoding_ext))\r\r\n *file_ext = '\\0';\r\r\n }\r\r\n if (*dt & TEXTHTML)\r\r\n /* -E / --adjust-extension / adjust_extension = on was specified,\r\r\n and this is a text/html file. If some case-insensitive\r\r\n variation on \".htm[l]\" isn't already the file's suffix,\r\r\n tack on \".html\". */\r\r\n {\r\r\n ensure_extension (hs, \".html\", dt);\r\r\n }\r\r\n else if (*dt & TEXTCSS)\r\r\n {\r\r\n ensure_extension (hs, \".css\", dt);\r\r\n }\r\r\n if (encoding_ext != NULL)\r\r\n {\r\r\n ensure_extension (hs, encoding_ext, dt);\r\r\n }\r\r\n }\r\r\n\r\r\n if (cond_get)\r\r\n {\r\r\n /* Handle the case when server ignores If-Modified-Since header. */\r\r\n if (statcode == HTTP_STATUS_OK && hs->remote_time)\r\r\n {\r\r\n time_t tmr = http_atotm (hs->remote_time);\r\r\n\r\r\n /* Check if the local file is up-to-date based on Last-Modified header\r\r\n and content length. */\r\r\n if (tmr != (time_t) - 1 && tmr <= hs->orig_file_tstamp\r\r\n && (contlen == -1 || contlen == hs->orig_file_size))\r\r\n {\r\r\n logprintf (LOG_VERBOSE,\r\r\n _(\"Server ignored If-Modified-Since header for file %s.\\n\"\r\r\n \"You might want to add --no-if-modified-since option.\"\r\r\n \"\\n\\n\"),\r\r\n quote (hs->local_file));\r\r\n *dt |= RETROKF;\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = RETRUNNEEDED;\r\r\n goto cleanup;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (statcode == HTTP_STATUS_RANGE_NOT_SATISFIABLE\r\r\n && hs->restval < (contlen + contrange))\r\r\n {\r\r\n /* The file was not completely downloaded,\r\r\n yet the server claims the range is invalid.\r\r\n Bail out. */\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = RANGEERR;\r\r\n goto cleanup;\r\r\n }\r\r\n if (statcode == HTTP_STATUS_RANGE_NOT_SATISFIABLE\r\r\n || (!opt.timestamping && hs->restval > 0 && statcode == HTTP_STATUS_OK\r\r\n && contrange == 0 && contlen >= 0 && hs->restval >= contlen))\r\r\n {\r\r\n /* If `-c' is in use and the file has been fully downloaded (or\r\r\n the remote file has shrunk), Wget effectively requests bytes\r\r\n after the end of file and the server response with 416\r\r\n (or 200 with a <= Content-Length. */\r\r\n logputs (LOG_VERBOSE, _(\"\\\r\r\n\\n The file is already fully retrieved; nothing to do.\\n\\n\"));\r\r\n /* In case the caller inspects. */\r\r\n hs->len = contlen;\r\r\n hs->res = 0;\r\r\n /* Mark as successfully retrieved. */\r\r\n *dt |= RETROKF;\r\r\n\r\r\n /* Try to maintain the keep-alive connection. It is often cheaper to\r\r\n * consume some bytes which have already been sent than to negotiate\r\r\n * a new connection. However, if the body is too large, or we don't\r\r\n * care about keep-alive, then simply terminate the connection */\r\r\n if (keep_alive &&\r\r\n skip_short_body (sock, contlen, chunked_transfer_encoding))\r\r\n CLOSE_FINISH (sock);\r\r\n else\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = RETRUNNEEDED;\r\r\n goto cleanup;\r\r\n }\r\r\n if ((contrange != 0 && contrange != hs->restval)\r\r\n || (H_PARTIAL (statcode) && !contrange && hs->restval))\r\r\n {\r\r\n /* The Range request was somehow misunderstood by the server.\r\r\n Bail out. */\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = RANGEERR;\r\r\n goto cleanup;\r\r\n }\r\r\n if (contlen == -1)\r\r\n hs->contlen = -1;\r\r\n /* If the response is gzipped, the uncompressed size is unknown. */\r\r\n else if (hs->remote_encoding == ENC_GZIP)\r\r\n hs->contlen = -1;\r\r\n else\r\r\n hs->contlen = contlen + contrange;\r\r\n\r\r\n if (opt.verbose)\r\r\n {\r\r\n if (*dt & RETROKF)\r\r\n {\r\r\n /* No need to print this output if the body won't be\r\r\n downloaded at all, or if the original server response is\r\r\n printed. */\r\r\n logputs (LOG_VERBOSE, _(\"Length: \"));\r\r\n if (contlen != -1)\r\r\n {\r\r\n logputs (LOG_VERBOSE, number_to_static_string (contlen + contrange));\r\r\n if (contlen + contrange >= 1024)\r\r\n logprintf (LOG_VERBOSE, \" (%s)\",\r\r\n human_readable (contlen + contrange, 10, 1));\r\r\n if (contrange)\r\r\n {\r\r\n if (contlen >= 1024)\r\r\n logprintf (LOG_VERBOSE, _(\", %s (%s) remaining\"),\r\r\n number_to_static_string (contlen),\r\r\n human_readable (contlen, 10, 1));\r\r\n else\r\r\n logprintf (LOG_VERBOSE, _(\", %s remaining\"),\r\r\n number_to_static_string (contlen));\r\r\n }\r\r\n }\r\r\n else\r\r\n logputs (LOG_VERBOSE,\r\r\n opt.ignore_length ? _(\"ignored\") : _(\"unspecified\"));\r\r\n if (type)\r\r\n logprintf (LOG_VERBOSE, \" [%s]\\n\", quotearg_style (escape_quoting_style, type));\r\r\n else\r\r\n logputs (LOG_VERBOSE, \"\\n\");\r\r\n }\r\r\n }\r\r\n\r\r\n /* Return if we have no intention of further downloading. */\r\r\n if ((!(*dt & RETROKF) && !opt.content_on_error) || head_only || (opt.spider && !opt.recursive))\r\r\n {\r\r\n /* In case the caller cares to look... */\r\r\n hs->len = 0;\r\r\n hs->res = 0;\r\r\n hs->restval = 0;\r\r\n\r\r\n /* Normally we are not interested in the response body of a error responses.\r\r\n But if we are writing a WARC file we are: we like to keep everything. */\r\r\n if (warc_enabled)\r\r\n {\r\r\n int _err = read_response_body (hs, sock, NULL, contlen, 0,\r\r\n chunked_transfer_encoding,\r\r\n u->url, warc_timestamp_str,\r\r\n warc_request_uuid, warc_ip, type,\r\r\n statcode, head);\r\r\n\r\r\n if (_err != RETRFINISHED || hs->res < 0)\r\r\n {\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = _err;\r\r\n goto cleanup;\r\r\n }\r\r\n\r\r\n CLOSE_FINISH (sock);\r\r\n }\r\r\n else\r\r\n {\r\r\n /* Since WARC is disabled, we are not interested in the response body. */\r\r\n if (head_only)\r\r\n /* Pre-1.10 Wget used CLOSE_INVALIDATE here. Now we trust the\r\r\n servers not to send body in response to a HEAD request, and\r\r\n those that do will likely be caught by test_socket_open.\r\r\n If not, they can be worked around using\r\r\n `--no-http-keep-alive'. */\r\r\n CLOSE_FINISH (sock);\r\r\n else if (opt.spider && !opt.recursive)\r\r\n /* we just want to see if the page exists - no downloading required */\r\r\n CLOSE_INVALIDATE (sock);\r\r\n else if (keep_alive\r\r\n && skip_short_body (sock, contlen, chunked_transfer_encoding))\r\r\n /* Successfully skipped the body; also keep using the socket. */\r\r\n CLOSE_FINISH (sock);\r\r\n else\r\r\n CLOSE_INVALIDATE (sock);\r\r\n }\r\r\n\r\r\n if (statcode == HTTP_STATUS_GATEWAY_TIMEOUT)\r\r\n retval = GATEWAYTIMEOUT;\r\r\n else\r\r\n retval = RETRFINISHED;\r\r\n\r\r\n goto cleanup;\r\r\n }\r\r\n\r\r\n err = open_output_stream (hs, count, &fp);\r\r\n if (err != RETROK)\r\r\n {\r\r\n CLOSE_INVALIDATE (sock);\r\r\n retval = err;\r\r\n goto cleanup;\r\r\n }\r\r\n\r\r\n#ifdef ENABLE_XATTR\r\r\n if (opt.enable_xattr)\r\r\n {\r\r\n if (original_url != u)\r\r\n set_file_metadata (u->url, original_url->url, fp);\r\r\n else\r\r\n set_file_metadata (u->url, NULL, fp);\r\r\n }\r\r\n#endif\r\r\n\r\r\n err = read_response_body (hs, sock, fp, contlen, contrange,\r\r\n chunked_transfer_encoding,\r\r\n u->url, warc_timestamp_str,\r\r\n warc_request_uuid, warc_ip, type,\r\r\n statcode, head);\r\r\n\r\r\n if (hs->res >= 0)\r\r\n CLOSE_FINISH (sock);\r\r\n else\r\r\n CLOSE_INVALIDATE (sock);\r\r\n\r\r\n if (!output_stream)\r\r\n fclose (fp);\r\r\n\r\r\n retval = err;\r\r\n\r\r\n cleanup:\r\r\n xfree (head);\r\r\n xfree (type);\r\r\n xfree (message);\r\r\n resp_free (&resp);\r\r\n request_free (&req);\r\r\n\r\r\n return retval;\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <pthread.h> \r\n#include <signal.h> \r\n#include <unistd.h> \r\n#include <sys/stat.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint tetratone_windlassing = 0;\r\nint global_variable;\r\nvoid handle_taint(char *sailers_innocuously);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct data {\r\n int data_size;\r\n char *data;\r\n char *file1;\r\n};\r\nstruct data *Data;\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForSig(char* sleepFile) {\r\n int fd;\r\n char outStr[25] = {0};\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForSig\\n\");\r\n sprintf(outStr, \"%d.pid\", getpid());\r\n strcat(filename, \"/opt//workspace/testData/\");\r\n strcat(filename, outStr);\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n \r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nvoid delNonAlpha (void *data) {\r\n struct data *Data = (struct data*) data;\r\n int i = 0;\r\n int j = 0;\r\n char* temp = malloc(sizeof(char) * (Data->data_size + 1));\r\n \r\n printf(\"Grabbing lock\\n\");\r\n \r\n \r\n pthread_mutex_lock(&mutex); \r\n \r\n \r\n while(Data->data[i] != '\\0') {\r\n if((Data->data[i] >= 'A' && Data->data[i] <= 'Z') ||\r\n (Data->data[i] >= 'a' && Data->data[i] <= 'z')) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[j++] = '\\0';\r\n Data->data_size = j;\r\n free(Data->data);\r\n Data->data = temp;\r\n waitForSig(Data->file1); \r\n printf(\"Realeasing lock\\n\");\r\n pthread_mutex_unlock(&mutex);\r\n \r\n}\r\nvoid sig_handler (int sig) {\r\n \r\n \r\n if (Data != NULL) {\r\n \r\n \r\n delNonAlpha(Data); \r\n }\r\n signal(SIGUSR1, SIG_IGN);\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{;\r\n if (__sync_bool_compare_and_swap(&tetratone_windlassing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid handle_taint(char *sailers_innocuously)\r\n{\r\n char *mentor_inexplicitness = 0;\r\n char **unsternness_pulleyless = 0;\r\n char *lectureships_postliterate = 0;\r\n ++global_variable;;\r\n if (sailers_innocuously != 0) {;\r\n unsternness_pulleyless = &sailers_innocuously;\r\n mentor_inexplicitness = ((char *)( *unsternness_pulleyless));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(mentor_inexplicitness) + 1));\r\n if (Data->data && Data->file1) {\r\n if ((sscanf(mentor_inexplicitness, \"%s %s\",\r\n Data->file1,\r\n Data->data) == 2) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0))\r\n {\r\n \r\n \r\n Data->data_size = strlen(Data->data);\r\n if (pthread_mutex_init(&mutex, NULL) != 0) {\r\n printf(\"Mutex failed to initilize.\");\r\n }\r\n if (signal(SIGUSR1, sig_handler) == SIG_ERR) { \r\n \r\n printf (\"Error catching SIGUSR1!\\n\");\r\n }\r\n delNonAlpha(Data);\r\n signal(SIGUSR1, SIG_IGN); \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ( *unsternness_pulleyless != 0) \r\n free(((char *)( *unsternness_pulleyless)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n pthread_mutex_lock(&mutex); \n \n```", "cwe": "479"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <stdio.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint peshitta_endoscopically = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar *crispin_boused(char *subtransversal_hepatopexia);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *malemiut_mot = 0;\r\n jmp_buf yugoslav_ahq;\r\n int capsuligerous_trichopathic;\r\n char *organogel_contours = 0;\r\n int grimstead_foreslow = 0;\r\n char *classico_umbered = 0;\r\n int camorra_replait = 35;\r\n char *overemulate_eightling;;\r\n if (__sync_bool_compare_and_swap(&peshitta_endoscopically,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&overemulate_eightling,\"4789\",camorra_replait);\r\n if (overemulate_eightling != 0) {;\r\n grimstead_foreslow = ((int )(strlen(overemulate_eightling)));\r\n classico_umbered = ((char *)(malloc(grimstead_foreslow + 1)));\r\n if (classico_umbered == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(classico_umbered,0,grimstead_foreslow + 1);\r\n memcpy(classico_umbered,overemulate_eightling,grimstead_foreslow);\r\n if (overemulate_eightling != 0) \r\n free(((char *)overemulate_eightling));\r\n organogel_contours = crispin_boused(classico_umbered);\r\n capsuligerous_trichopathic = setjmp(yugoslav_ahq);\r\n if (capsuligerous_trichopathic == 0) {\r\n longjmp(yugoslav_ahq,1);\r\n }\r\n malemiut_mot = ((char *)organogel_contours);\r\n \r\n if (strlen(malemiut_mot) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(malemiut_mot) == 1) {\r\n parsed_input = malloc((strlen(malemiut_mot)+1) * sizeof(char));\r\n urlDecode(malemiut_mot, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (organogel_contours != 0) \r\n free(((char *)organogel_contours));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nchar *crispin_boused(char *subtransversal_hepatopexia)\r\n{\r\n ++global_variable;\r\n return subtransversal_hepatopexia;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <math.h>\r\n\r\n#include \"config.h\"\r\n#include \"compat/va_copy.h\"\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavfilter/avfilter.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libavresample/avresample.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#if CONFIG_POSTPROC\r\n#include \"libpostproc/postprocess.h\"\r\n#endif\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/eval.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"cmdutils.h\"\r\n#include \"version.h\"\r\n#if CONFIG_NETWORK\r\n#include \"libavformat/network.h\"\r\n#endif\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/resource.h>\r\n#endif\r\n#if TRACE\r\n#define TRACEPOINT_DEFINE\r\n#define TRACEPOINT_PROBE_DYNAMIC_LINKAGE\r\n#include </trace.h>\r\n#endif\r\nstatic int init_report(const char *env);\r\nstruct SwsContext *sws_opts;\r\nAVDictionary *swr_opts;\r\nAVDictionary *format_opts;\r\nAVDictionary *codec_opts;\r\nAVDictionary *resample_opts;\r\nconst int this_year = 2013;\r\nstatic FILE *report_file;\r\nint yikirgaulit_lederite = 0;\r\nint global_variable;\r\n\r\nstruct tbilisi_neckful \r\n{\r\n char *charwoman_carthamin;\r\n double peeving_dillseed;\r\n char *greathead_approach;\r\n char whipper_outdwelt;\r\n int nama_fibromata;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid nereidae_alloa(struct tbilisi_neckful unroot_verier);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nvoid init_opts()\r\n{\r\n if (1) {\r\n sws_opts = sws_getContext(16,16,AV_PIX_FMT_YUV420P,16,16,AV_PIX_FMT_YUV420P,4,((void *)0),((void *)0),((void *)0));\r\n }\r\n}\r\n\r\nvoid uninit_opts()\r\n{\r\n#if CONFIG_SWSCALE\r\n sws_freeContext(sws_opts);\r\n sws_opts = ((void *)0);\r\n#endif\r\n av_dict_free(&swr_opts);\r\n av_dict_free(&format_opts);\r\n av_dict_free(&codec_opts);\r\n av_dict_free(&resample_opts);\r\n}\r\n\r\nvoid log_callback_help(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n vfprintf(stdout,fmt,vl);\r\n}\r\n\r\nstatic void log_callback_report(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n va_list vl2;\r\n char line[1024];\r\n static int print_prefix = 1;\r\n __builtin_va_copy(vl2,vl);\r\n av_log_default_callback(ptr,level,fmt,vl);\r\n av_log_format_line(ptr,level,fmt,vl2,line,(sizeof(line)),&print_prefix);\r\n __builtin_va_end(vl2);\r\n fputs(line,report_file);\r\n fflush(report_file);\r\n}\r\n\r\ndouble parse_number_or_die(const char *context,const char *numstr,int type,double min,double max)\r\n{\r\n char *tail;\r\n const char *error;\r\n double d = av_strtod(numstr,&tail);\r\n if ( *tail) {\r\n error = \"Expected number for %s but found: %s\\n\";\r\n }\r\n else {\r\n if (d < min || d > max) {\r\n error = \"The value for %s was %s which is not within %f - %f\\n\";\r\n }\r\n else {\r\n if (type == 0x0400 && ((int64_t )d) != d) {\r\n error = \"Expected int64 for %s but found %s\\n\";\r\n }\r\n else {\r\n if (type == 0x80 && ((int )d) != d) {\r\n error = \"Expected int for %s but found %s\\n\";\r\n }\r\n else {\r\n return d;\r\n }\r\n }\r\n }\r\n }\r\n av_log(((void *)0),8,error,context,numstr,min,max);\r\n exit(1);\r\n return 0;\r\n}\r\n\r\nint64_t parse_time_or_die(const char *context,const char *timestr,int is_duration)\r\n{\r\n int64_t us;\r\n if (av_parse_time(&us,timestr,is_duration) < 0) {\r\n av_log(((void *)0),8,\"Invalid %s specification for %s: %s\\n\",(is_duration?\"duration\" : \"date\"),context,timestr);\r\n exit(1);\r\n }\r\n return us;\r\n}\r\n\r\nvoid show_help_options(const OptionDef *options,const char *msg,int req_flags,int rej_flags,int alt_flags)\r\n{\r\n const OptionDef *po;\r\n int first;\r\n first = 1;\r\n for (po = options; po -> name != ((void *)0); po++) {\r\n char buf[64];\r\n if ((po -> flags & req_flags) != req_flags || alt_flags && !(po -> flags & alt_flags) || po -> flags & rej_flags) {\r\n continue; \r\n }\r\n if (first) {\r\n printf(\"%s\\n\",msg);\r\n first = 0;\r\n }\r\n av_strlcpy(buf,po -> name,sizeof(buf));\r\n if (po -> argname) {\r\n av_strlcat(buf,\" \",sizeof(buf));\r\n av_strlcat(buf,po -> argname,sizeof(buf));\r\n }\r\n printf(\"-%-17s %s\\n\",buf,po -> help);\r\n }\r\n printf(\"\\n\");\r\n}\r\n\r\nvoid show_help_children(const AVClass *class,int flags)\r\n{\r\n const AVClass *child = ((void *)0);\r\n if (class -> option) {\r\n av_opt_show2((&class),((void *)0),flags,0);\r\n printf(\"\\n\");\r\n }\r\n while(child = av_opt_child_class_next(class,child))\r\n show_help_children(child,flags);\r\n}\r\n\r\nstatic const OptionDef *find_option(const OptionDef *po,const char *name)\r\n{\r\n const char *p = (strchr(name,':'));\r\n int len = (p?(p - name) : strlen(name));\r\n while(po -> name != ((void *)0)){\r\n if (!strncmp(name,po -> name,len) && strlen(po -> name) == len) {\r\n break; \r\n }\r\n po++;\r\n }\r\n return po;\r\n}\r\n#if HAVE_COMMANDLINETOARGVW\r\n#include <windows.h>\r\n#include <shellapi.h>\r\n\r\n\r\n\r\n#else\r\n\r\ninline static void prepare_app_arguments(int *argc_ptr,char ***argv_ptr)\r\n{\r\n\r\n}\r\n#endif \r\n\r\nstatic int write_option(void *optctx,const OptionDef *po,const char *opt,const char *arg)\r\n{\r\n\r\n void *dst = po -> flags & (0x4000 | 0x8000)?(((uint8_t *)optctx) + po -> u . off) : po -> u . dst_ptr;\r\n int *dstcount;\r\n if (po -> flags & 0x8000) {\r\n SpecifierOpt **so = dst;\r\n char *p = strchr(opt,':');\r\n dstcount = ((int *)(so + 1));\r\n *so = (grow_array(( *so),(sizeof(( *( *so)))),dstcount, *dstcount + 1));\r\n ( *so)[ *dstcount - 1] . specifier = av_strdup(((p?p + 1 : \"\")));\r\n dst = (&( *so)[ *dstcount - 1] . u);\r\n }\r\n if (po -> flags & 0x0008) {\r\n char *str;\r\n str = av_strdup(arg);\r\n\r\n *((char **)dst) = str;\r\n }\r\n else {\r\n if (po -> flags & 0x00002 || po -> flags & 0x80) {\r\n *((int *)dst) = (parse_number_or_die(opt,arg,0x0400,(- 2147483647 - 1),2147483647));\r\n }\r\n else {\r\n if (po -> flags & 0x0400) {\r\n *((int64_t *)dst) = (parse_number_or_die(opt,arg,0x0400,(- 9223372036854775807L - 1),9223372036854775807L));\r\n }\r\n else {\r\n if (po -> flags & 0x10000) {\r\n *((int64_t *)dst) = parse_time_or_die(opt,arg,1);\r\n }\r\n else {\r\n if (po -> flags & 0x00100) {\r\n *((float *)dst) = (parse_number_or_die(opt,arg,0x00100,(-__builtin_inff()),(__builtin_inff())));\r\n }\r\n else {\r\n if (po -> flags & 0x20000) {\r\n *((double *)dst) = parse_number_or_die(opt,arg,0x20000,(-__builtin_inff()),(__builtin_inff()));\r\n }\r\n else {\r\n if (po -> u . func_arg) {\r\n int ret = po -> u . func_arg(optctx,opt,arg);\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Failed to set value '%s' for option '%s'\\n\",arg,opt);\r\n return ret;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n }\r\n }\r\n }\r\n if (po -> flags & 0x0800) {\r\n exit(0);\r\n }\r\n return 0;\r\n}\r\n\r\nint parse_option(void *optctx,const char *opt,const char *arg,const OptionDef *options)\r\n{\r\n const OptionDef *po;\r\n int ret;\r\n po = find_option(options,opt);\r\n if (!po -> name && opt[0] == 'n' && opt[1] == 'o') {\r\n\r\n po = find_option(options,opt + 2);\r\n if (po -> name && po -> flags & 0x00002) {\r\n arg = \"0\";\r\n }\r\n }\r\n else {\r\n if (po -> flags & 0x00002) {\r\n arg = \"1\";\r\n }\r\n }\r\n if (!po -> name) {\r\n po = find_option(options,\"default\");\r\n }\r\n if (!po -> name) {\r\n av_log(((void *)0),16,\"Unrecognized option '%s'\\n\",opt);\r\n return - 22;\r\n }\r\n if (po -> flags & 0x0001 && !arg) {\r\n av_log(((void *)0),16,\"Missing argument for option '%s'\\n\",opt);\r\n return - 22;\r\n }\r\n ret = write_option(optctx,po,opt,arg);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n return !(!(po -> flags & 0x0001));\r\n}\r\n\r\nvoid parse_options(void *optctx,int argc,char **argv,const OptionDef *options,void (*parse_arg_function)(void *, const char *))\r\n{\r\n const char *opt;\r\n int optindex;\r\n int handleoptions = 1;\r\n int ret;\r\n\r\n prepare_app_arguments(&argc,&argv);\r\n\r\n optindex = 1;\r\n while(optindex < argc){\r\n opt = argv[optindex++];\r\n if (handleoptions && opt[0] == '-' && opt[1] != '\\0') {\r\n if (opt[1] == '-' && opt[2] == '\\0') {\r\n handleoptions = 0;\r\n continue; \r\n }\r\n opt++;\r\n if ((ret = parse_option(optctx,opt,argv[optindex],options)) < 0) {\r\n exit(1);\r\n }\r\n optindex += ret;\r\n }\r\n else {\r\n if (parse_arg_function) {\r\n parse_arg_function(optctx,opt);\r\n }\r\n }\r\n }\r\n}\r\n\r\nint parse_optgroup(void *optctx,OptionGroup *g)\r\n{\r\n int i;\r\n int ret;\r\n av_log(((void *)0),48,\"Parsing a group of options: %s %s.\\n\",g -> group_def -> name,g -> arg);\r\n for (i = 0; i < g -> nb_opts; i++) {\r\n Option *o = &g -> opts[i];\r\n av_log(((void *)0),48,\"Applying option %s (%s) with argument %s.\\n\",o -> key,o -> opt -> help,o -> val);\r\n ret = write_option(optctx,o -> opt,o -> key,o -> val);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n }\r\n av_log(((void *)0),48,\"Successfully parsed a group of options.\\n\");\r\n return 0;\r\n}\r\n\r\nint locate_option(int argc,char **argv,const OptionDef *options,const char *optname)\r\n{\r\n const OptionDef *po;\r\n int i;\r\n for (i = 1; i < argc; i++) {\r\n const char *cur_opt = argv[i];\r\n if (( *(cur_opt++)) != '-') {\r\n continue; \r\n }\r\n po = find_option(options,cur_opt);\r\n if (!po -> name && cur_opt[0] == 'n' && cur_opt[1] == 'o') {\r\n po = find_option(options,cur_opt + 2);\r\n }\r\n if (!po -> name && !strcmp(cur_opt,optname) || po -> name && !strcmp(optname,po -> name)) {\r\n return i;\r\n }\r\n if (po -> flags & 0x0001) {\r\n i++;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void dump_argument(const char *a)\r\n{\r\n const unsigned char *p;\r\n for (p = a; *p; p++) \r\n if (!(( *p) >= '+' && ( *p) <= ':' || ( *p) >= 64 && ( *p) <= 'Z' || ( *p) == '_' || ( *p) >= 'a' && ( *p) <= 'z')) {\r\n break; \r\n }\r\n if (!( *p)) {\r\n fputs(a,report_file);\r\n return ;\r\n }\r\n fputc('\"',report_file);\r\n for (p = a; *p; p++) {\r\n if (( *p) == '\\\\' || ( *p) == '\"' || ( *p) == '$' || ( *p) == '`') {\r\n fprintf(report_file,\"\\\\%c\",( *p));\r\n }\r\n else {\r\n if (( *p) < 32 || ( *p) > '~') {\r\n fprintf(report_file,\"\\\\x%02x\",( *p));\r\n }\r\n else {\r\n fputc(( *p),report_file);\r\n }\r\n }\r\n }\r\n fputc('\"',report_file);\r\n}\r\n\r\nvoid parse_loglevel(int argc,char **argv,const OptionDef *options)\r\n{\r\n int idx = locate_option(argc,argv,options,\"loglevel\");\r\n const char *env;\r\n if (!idx) {\r\n idx = locate_option(argc,argv,options,\"v\");\r\n }\r\n if (idx && argv[idx + 1]) {\r\n opt_loglevel(((void *)0),\"loglevel\",argv[idx + 1]);\r\n }\r\n idx = locate_option(argc,argv,options,\"report\");\r\n if ((env = (getenv(\"FFREPORT\"))) || idx) {\r\n init_report(env);\r\n if (report_file) {\r\n int i;\r\n fprintf(report_file,\"Command line:\\n\");\r\n for (i = 0; i < argc; i++) {\r\n dump_argument(argv[i]);\r\n fputc((i < argc - 1?32 : '\\n'),report_file);\r\n }\r\n fflush(report_file);\r\n }\r\n }\r\n}\r\n#define FLAGS (o->type == AV_OPT_TYPE_FLAGS) ? AV_DICT_APPEND : 0\r\n\r\nint opt_default(void *optctx,const char *opt,const char *arg)\r\n{\r\n const AVOption *o;\r\n int consumed = 0;\r\n char opt_stripped[128];\r\n const char *p;\r\n const AVClass *cc = avcodec_get_class();\r\n const AVClass *fc = avformat_get_class();\r\n#if CONFIG_AVRESAMPLE\r\n#endif\r\n const AVClass *sc;\r\n const AVClass *swr_class;\r\n if (!strcmp(opt,\"debug\") || !strcmp(opt,\"fdebug\")) {\r\n av_log_set_level(48);\r\n }\r\n if (!(p = (strchr(opt,':')))) {\r\n p = opt + strlen(opt);\r\n }\r\n av_strlcpy(opt_stripped,opt,(sizeof(opt_stripped) > (p - opt + 1)?(p - opt + 1) : sizeof(opt_stripped)));\r\n if ((o = av_opt_find((&cc),opt_stripped,((void *)0),0,0x0001 | 0x00002)) || (opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') && (o = av_opt_find((&cc),opt + 1,((void *)0),0,0x00002))) {\r\n av_dict_set(&codec_opts,opt,arg,((o -> type) == AV_OPT_TYPE_FLAGS?32 : 0));\r\n consumed = 1;\r\n }\r\n if (o = av_opt_find((&fc),opt,((void *)0),0,0x0001 | 0x00002)) {\r\n av_dict_set(&format_opts,opt,arg,((o -> type) == AV_OPT_TYPE_FLAGS?32 : 0));\r\n if (consumed) {\r\n av_log(((void *)0),40,\"Routing %s to codec and muxer layer\\n\",opt);\r\n }\r\n consumed = 1;\r\n }\r\n#if CONFIG_SWSCALE\r\n sc = sws_get_class();\r\n if (!consumed && av_opt_find((&sc),opt,((void *)0),0,0x0001 | 0x00002)) {\r\n\r\n int ret = av_opt_set(sws_opts,opt,arg,0);\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Error setting option %s.\\n\",opt);\r\n return ret;\r\n }\r\n consumed = 1;\r\n }\r\n#endif\r\n#if CONFIG_SWRESAMPLE\r\n swr_class = swr_get_class();\r\n if (!consumed && (o = av_opt_find((&swr_class),opt,((void *)0),0,0x0001 | 0x00002))) {\r\n struct SwrContext *swr = swr_alloc();\r\n int ret = av_opt_set(swr,opt,arg,0);\r\n swr_free(&swr);\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Error setting option %s.\\n\",opt);\r\n return ret;\r\n }\r\n av_dict_set(&swr_opts,opt,arg,((o -> type) == AV_OPT_TYPE_FLAGS?32 : 0));\r\n consumed = 1;\r\n }\r\n#endif\r\n#if CONFIG_AVRESAMPLE\r\n#endif\r\n if (consumed) {\r\n return 0;\r\n }\r\n return -((int )((0xF8 | 'O' << 8 | 'P' << 16) | ((unsigned int )'T') << 24));\r\n}\r\n\r\n\r\nstatic int match_group_separator(const OptionGroupDef *groups,int nb_groups,const char *opt)\r\n{\r\n int i;\r\n for (i = 0; i < nb_groups; i++) {\r\n const OptionGroupDef *p = &groups[i];\r\n if (p -> sep && !strcmp(p -> sep,opt)) {\r\n return i;\r\n }\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nstatic void finish_group(OptionParseContext *octx,int group_idx,const char *arg)\r\n{\r\n OptionGroupList *l = &octx -> groups[group_idx];\r\n OptionGroup *g;\r\n l -> groups = (grow_array((l -> groups),(sizeof(( *l -> groups))),&l -> nb_groups,l -> nb_groups + 1));\r\n g = &l -> groups[l -> nb_groups - 1];\r\n *g = octx -> cur_group;\r\n g -> arg = arg;\r\n g -> group_def = l -> group_def;\r\n#if CONFIG_SWSCALE\r\n g -> sws_opts = sws_opts;\r\n#endif\r\n g -> swr_opts = swr_opts;\r\n g -> codec_opts = codec_opts;\r\n g -> format_opts = format_opts;\r\n g -> resample_opts = resample_opts;\r\n codec_opts = ((void *)0);\r\n format_opts = ((void *)0);\r\n resample_opts = ((void *)0);\r\n#if CONFIG_SWSCALE\r\n sws_opts = ((void *)0);\r\n#endif\r\n swr_opts = ((void *)0);\r\n init_opts();\r\n memset((&octx -> cur_group),0,sizeof(octx -> cur_group));\r\n}\r\n\r\n\r\nstatic void add_opt(OptionParseContext *octx,const OptionDef *opt,const char *key,const char *val)\r\n{\r\n int global = !(opt -> flags & (0x2000 | 0x8000 | 0x4000));\r\n OptionGroup *g = global?&octx -> global_opts : &octx -> cur_group;\r\n g -> opts = (grow_array((g -> opts),(sizeof(( *g -> opts))),&g -> nb_opts,g -> nb_opts + 1));\r\n g -> opts[g -> nb_opts - 1] . opt = opt;\r\n g -> opts[g -> nb_opts - 1] . key = key;\r\n g -> opts[g -> nb_opts - 1] . val = val;\r\n}\r\n\r\nstatic void init_parse_context(OptionParseContext *octx,const OptionGroupDef *groups,int nb_groups)\r\n{\r\n static const OptionGroupDef global_group = {(\"global\")};\r\n int i;\r\n memset(octx,0,sizeof(( *octx)));\r\n octx -> nb_groups = nb_groups;\r\n octx -> groups = (av_mallocz(sizeof(( *octx -> groups)) * (octx -> nb_groups)));\r\n if (!octx -> groups) {\r\n exit(1);\r\n }\r\n for (i = 0; i < octx -> nb_groups; i++) \r\n octx -> groups[i] . group_def = &groups[i];\r\n octx -> global_opts . group_def = &global_group;\r\n octx -> global_opts . arg = \"\";\r\n init_opts();\r\n}\r\n\r\nvoid uninit_parse_context(OptionParseContext *octx)\r\n{\r\n int i;\r\n int j;\r\n for (i = 0; i < octx -> nb_groups; i++) {\r\n OptionGroupList *l = &octx -> groups[i];\r\n for (j = 0; j < l -> nb_groups; j++) {\r\n av_freep((&l -> groups[j] . opts));\r\n av_dict_free(&l -> groups[j] . codec_opts);\r\n av_dict_free(&l -> groups[j] . format_opts);\r\n av_dict_free(&l -> groups[j] . resample_opts);\r\n#if CONFIG_SWSCALE\r\n sws_freeContext(l -> groups[j] . sws_opts);\r\n#endif\r\n av_dict_free(&l -> groups[j] . swr_opts);\r\n }\r\n av_freep((&l -> groups));\r\n }\r\n av_freep((&octx -> groups));\r\n av_freep((&octx -> cur_group . opts));\r\n av_freep((&octx -> global_opts . opts));\r\n uninit_opts();\r\n}\r\n\r\nint split_commandline(OptionParseContext *octx,int argc,char *argv[],const OptionDef *options,const OptionGroupDef *groups,int nb_groups)\r\n{\r\n int optindex = 1;\r\n int dashdash = - 2;\r\n\r\n prepare_app_arguments(&argc,&argv);\r\n init_parse_context(octx,groups,nb_groups);\r\n av_log(((void *)0),48,\"Splitting the commandline.\\n\");\r\n while(optindex < argc){\r\n const char *opt = argv[optindex++];\r\n const char *arg;\r\n const OptionDef *po;\r\n int ret;\r\n av_log(((void *)0),48,\"Reading option '%s' ...\",opt);\r\n if (opt[0] == '-' && opt[1] == '-' && !opt[2]) {\r\n dashdash = optindex;\r\n continue; \r\n }\r\n\r\n if (opt[0] != '-' || !opt[1] || dashdash + 1 == optindex) {\r\n finish_group(octx,0,opt);\r\n av_log(((void *)0),48,\" matched as %s.\\n\",groups[0] . name);\r\n continue; \r\n }\r\n opt++;\r\n#define GET_ARG(arg) \\\r\ndo { \\\r\n arg = argv[optindex++]; \\\r\n if (!arg) { \\\r\n av_log(NULL, AV_LOG_ERROR, \"Missing argument for option '%s'.\\n\", opt);\\\r\n return AVERROR(EINVAL); \\\r\n } \\\r\n} while (0)\r\n\r\n if ((ret = match_group_separator(groups,nb_groups,opt)) >= 0) {\r\n do {\r\n arg = argv[optindex++];\r\n if (!arg) {\r\n av_log(((void *)0),16,\"Missing argument for option '%s'.\\n\",opt);\r\n return - 22;\r\n }\r\n }while (0);\r\n finish_group(octx,ret,arg);\r\n av_log(((void *)0),48,\" matched as %s with argument '%s'.\\n\",groups[ret] . name,arg);\r\n continue; \r\n }\r\n\r\n po = find_option(options,opt);\r\n if (po -> name) {\r\n if (po -> flags & 0x0800) {\r\n\r\n arg = argv[optindex++];\r\n }\r\n else {\r\n if (po -> flags & 0x0001) {\r\n do {\r\n arg = argv[optindex++];\r\n if (!arg) {\r\n av_log(((void *)0),16,\"Missing argument for option '%s'.\\n\",opt);\r\n return - 22;\r\n }\r\n }while (0);\r\n }\r\n else {\r\n arg = \"1\";\r\n }\r\n }\r\n add_opt(octx,po,opt,arg);\r\n av_log(((void *)0),48,\" matched as option '%s' (%s) with argument '%s'.\\n\",po -> name,po -> help,arg);\r\n continue; \r\n }\r\n\r\n if (argv[optindex]) {\r\n ret = opt_default(((void *)0),opt,argv[optindex]);\r\n if (ret >= 0) {\r\n av_log(((void *)0),48,\" matched as AVOption '%s' with argument '%s'.\\n\",opt,argv[optindex]);\r\n optindex++;\r\n continue; \r\n }\r\n else {\r\n if (ret != -((int )((0xF8 | 'O' << 8 | 'P' << 16) | ((unsigned int )'T') << 24))) {\r\n av_log(((void *)0),16,\"Error parsing option '%s' with argument '%s'.\\n\",opt,argv[optindex]);\r\n return ret;\r\n }\r\n }\r\n }\r\n\r\n if (opt[0] == 'n' && opt[1] == 'o' && (po = find_option(options,opt + 2)) && po -> name && po -> flags & 0x00002) {\r\n add_opt(octx,po,opt,\"0\");\r\n av_log(((void *)0),48,\" matched as option '%s' (%s) with argument 0.\\n\",po -> name,po -> help);\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Unrecognized option '%s'.\\n\",opt);\r\n return -((int )((0xF8 | 'O' << 8 | 'P' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (octx -> cur_group . nb_opts || codec_opts || format_opts || resample_opts) {\r\n av_log(((void *)0),24,\"Trailing options were found on the commandline.\\n\");\r\n }\r\n av_log(((void *)0),48,\"Finished splitting the commandline.\\n\");\r\n return 0;\r\n}\r\n\r\nint opt_loglevel(void *optctx,const char *opt,const char *arg)\r\n{\r\n const struct {\r\n const char *name;\r\n int level;}log_levels[] = {{\"quiet\", (- 8)}, {\"panic\", (0)}, {\"fatal\", (8)}, {\"error\", (16)}, {\"warning\", (24)}, {\"info\", (32)}, {\"verbose\", (40)}, {\"debug\", (48)}};\r\n char *tail;\r\n int level;\r\n int i;\r\n for (i = 0; i < sizeof(log_levels) / sizeof(log_levels[0]); i++) {\r\n if (!strcmp(log_levels[i] . name,arg)) {\r\n av_log_set_level(log_levels[i] . level);\r\n return 0;\r\n }\r\n }\r\n level = (strtol(arg,&tail,'\\n'));\r\n if ( *tail) {\r\n av_log(((void *)0),8,\"Invalid loglevel \\\"%s\\\". Possible levels are numbers or:\\n\",arg);\r\n for (i = 0; i < sizeof(log_levels) / sizeof(log_levels[0]); i++) \r\n av_log(((void *)0),8,\"\\\"%s\\\"\\n\",log_levels[i] . name);\r\n exit(1);\r\n }\r\n av_log_set_level(level);\r\n return 0;\r\n}\r\n\r\nstatic void expand_filename_template(AVBPrint *bp,const char *template,struct tm *tm)\r\n{\r\n int c;\r\n while(c = ( *(template++))){\r\n if (c == '%') {\r\n if (!(c = ( *(template++)))) {\r\n break; \r\n }\r\n switch(c){\r\n case 'p':\r\n{\r\n av_bprintf(bp,\"%s\",program_name);\r\n break; \r\n }\r\n case 't':\r\n{\r\n av_bprintf(bp,\"%04d%02d%02d-%02d%02d%02d\",tm -> tm_year + 1900,tm -> tm_mon + 1,tm -> tm_mday,tm -> tm_hour,tm -> tm_min,tm -> tm_sec);\r\n break; \r\n }\r\n case '%':\r\n{\r\n av_bprint_chars(bp,c,1);\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n av_bprint_chars(bp,c,1);\r\n }\r\n }\r\n}\r\n\r\nstatic int init_report(const char *env)\r\n{\r\n char *filename_template = ((void *)0);\r\n char *key;\r\n char *val;\r\n int ret;\r\n int count = 0;\r\n time_t now;\r\n struct tm *tm;\r\n AVBPrint filename;\r\n\r\n if (report_file) {\r\n return 0;\r\n }\r\n time(&now);\r\n tm = localtime((&now));\r\n while(env && *env){\r\n if ((ret = av_opt_get_key_value(&env,\"=\",\":\",0,&key,&val)) < 0) {\r\n if (count) {\r\n av_log(((void *)0),16,\"Failed to parse FFREPORT environment variable: %s\\n\",av_make_error_string(((char [64]){(0)}),64,ret));\r\n }\r\n break; \r\n }\r\n if ( *env) {\r\n env++;\r\n }\r\n count++;\r\n if (!strcmp(key,\"file\")) {\r\n av_free(filename_template);\r\n filename_template = val;\r\n val = ((void *)0);\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Unknown key '%s' in FFREPORT\\n\",key);\r\n }\r\n av_free(val);\r\n av_free(key);\r\n }\r\n av_bprint_init(&filename,0,1);\r\n expand_filename_template(&filename,(av_x_if_null(filename_template,\"%p-%t.log\")),tm);\r\n av_free(filename_template);\r\n if (!av_bprint_is_complete(&filename)) {\r\n av_log(((void *)0),16,\"Out of memory building report file name\\n\");\r\n return - 12;\r\n }\r\n report_file = fopen(filename . str,\"w\");\r\n if (!report_file) {\r\n av_log(((void *)0),16,\"Failed to open report \\\"%s\\\": %s\\n\",filename . str,strerror( *__errno_location()));\r\n return -( *__errno_location());\r\n }\r\n av_log_set_callback(log_callback_report);\r\n av_log(((void *)0),32,\"%s started on %04d-%02d-%02d at %02d:%02d:%02d\\nReport written to \\\"%s\\\"\\n\",program_name,tm -> tm_year + 1900,tm -> tm_mon + 1,tm -> tm_mday,tm -> tm_hour,tm -> tm_min,tm -> tm_sec,filename . str);\r\n av_log_set_level((av_log_get_level() > 40?av_log_get_level() : 40));\r\n av_bprint_finalize(&filename,((void *)0));\r\n return 0;\r\n}\r\n\r\nint opt_report(const char *opt)\r\n{\r\n return init_report(((void *)0));\r\n}\r\n\r\nint opt_max_alloc(void *optctx,const char *opt,const char *arg)\r\n{\r\n char *tail;\r\n size_t max;\r\n max = (strtol(arg,&tail,'\\n'));\r\n if ( *tail) {\r\n av_log(((void *)0),8,\"Invalid max_alloc \\\"%s\\\".\\n\",arg);\r\n exit(1);\r\n }\r\n av_max_alloc(max);\r\n return 0;\r\n}\r\n\r\nint opt_cpuflags(void *optctx,const char *opt,const char *arg)\r\n{\r\n int ret;\r\n unsigned int flags = (av_get_cpu_flags());\r\n if ((ret = av_parse_cpu_caps(&flags,arg)) < 0) {\r\n return ret;\r\n }\r\n av_force_cpu_flags(flags);\r\n return 0;\r\n}\r\n\r\nint opt_timelimit(void *optctx,const char *opt,const char *arg)\r\n{\r\n#if HAVE_SETRLIMIT\r\n int lim = (parse_number_or_die(opt,arg,0x0400,0,2147483647));\r\n struct rlimit rl = {lim, (lim + 1)};\r\n if (setrlimit(RLIMIT_CPU,(&rl))) {\r\n perror(\"setrlimit\");\r\n }\r\n#else\r\n#endif\r\n return 0;\r\n}\r\n\r\nvoid print_error(const char *filename,int err)\r\n{\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(err,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-err));\r\n }\r\n av_log(((void *)0),16,\"%s: %s\\n\",filename,errbuf_ptr);\r\n}\r\nstatic int warned_cfg = 0;\r\n#define INDENT 1\r\n#define SHOW_VERSION 2\r\n#define SHOW_CONFIG 4\r\n#define SHOW_COPYRIGHT 8\r\n#define PRINT_LIB_INFO(libname, LIBNAME, flags, level) \\\r\n if (CONFIG_##LIBNAME) { \\\r\n const char *indent = flags & INDENT? \" \" : \"\"; \\\r\n if (flags & SHOW_VERSION) { \\\r\n unsigned int version = libname##_version(); \\\r\n av_log(NULL, level, \\\r\n \"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\", \\\r\n indent, #libname, \\\r\n LIB##LIBNAME##_VERSION_MAJOR, \\\r\n LIB##LIBNAME##_VERSION_MINOR, \\\r\n LIB##LIBNAME##_VERSION_MICRO, \\\r\n version >> 16, version >> 8 & 0xff, version & 0xff); \\\r\n } \\\r\n if (flags & SHOW_CONFIG) { \\\r\n const char *cfg = libname##_configuration(); \\\r\n if (strcmp(FFMPEG_CONFIGURATION, cfg)) { \\\r\n if (!warned_cfg) { \\\r\n av_log(NULL, level, \\\r\n \"%sWARNING: library configuration mismatch\\n\", \\\r\n indent); \\\r\n warned_cfg = 1; \\\r\n } \\\r\n av_log(NULL, level, \"%s%-11s configuration: %s\\n\", \\\r\n indent, #libname, cfg); \\\r\n } \\\r\n } \\\r\n } \\\r\n\r\n\r\nstatic void print_all_libs_info(int flags,int level)\r\n{\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avutil_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avutil\",'4',18,100,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avutil_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avutil\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avcodec_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avcodec\",'6','\\\\',100,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avcodec_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avcodec\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avformat_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avformat\",'6',63,'h',version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avformat_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avformat\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avdevice_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avdevice\",'6',3,103,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avdevice_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avdevice\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = avfilter_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"avfilter\",3,42,103,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = avfilter_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"avfilter\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = swscale_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"swscale\",2,2,100,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = swscale_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"swscale\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n if (1) {\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n if (flags & 2) {\r\n unsigned int version = swresample_version();\r\n av_log(((void *)0),level,\"%slib%-11s %2d.%3d.%3d / %2d.%3d.%3d\\n\",indent,\"swresample\",0,17,102,version >> 16,version >> 8 & 0xFF,version & 0xFF);\r\n }\r\n if (flags & 4) {\r\n const char *cfg = swresample_configuration();\r\n if (strcmp(\"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\",cfg)) {\r\n if (!warned_cfg) {\r\n av_log(((void *)0),level,\"%sWARNING: library configuration mismatch\\n\",indent);\r\n warned_cfg = 1;\r\n }\r\n av_log(((void *)0),level,\"%s%-11s configuration: %s\\n\",indent,\"swresample\",cfg);\r\n }\r\n }\r\n }\r\n ;\r\n#if CONFIG_POSTPROC\r\n#endif\r\n}\r\n\r\nstatic void print_program_info(int flags,int level)\r\n{\r\n const char *indent = (flags & 1?\" \" : \"\");\r\n av_log(((void *)0),level,\"%s version 1.2.2\",program_name);\r\n if (flags & 8) {\r\n av_log(((void *)0),level,\" Copyright (c) %d-%d the FFmpeg developers\",program_birth_year,this_year);\r\n }\r\n av_log(((void *)0),level,\"\\n\");\r\n av_log(((void *)0),level,\"%sbuilt on %s %s with %s\\n\",indent,\"Nov 21 2014\",\"18:55:08\",\"gcc 4.4.7 (GCC) 20120313 (Red Hat 4.4.7-4)\");\r\n av_log(((void *)0),level,\"%sconfiguration: --prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\\n\",indent);\r\n}\r\n\r\nvoid show_banner(int argc,char **argv,const OptionDef *options)\r\n{\r\n int idx = locate_option(argc,argv,options,\"version\");\r\n if (idx) {\r\n return ;\r\n }\r\n print_program_info(1 | 8,32);\r\n print_all_libs_info(1 | 4,32);\r\n print_all_libs_info(1 | 2,32);\r\n}\r\n\r\nint show_version(void *optctx,const char *opt,const char *arg)\r\n{\r\n av_log_set_callback(log_callback_help);\r\n print_program_info(0,32);\r\n print_all_libs_info(2,32);\r\n return 0;\r\n}\r\n\r\nint show_license(void *optctx,const char *opt,const char *arg)\r\n{\r\n#if CONFIG_NONFREE\r\n#elif CONFIG_GPLV3\r\n#elif CONFIG_GPL\r\n#elif CONFIG_LGPLV3\r\n#else\r\n printf(\"%s is free software; you can redistribute it and/or\\nmodify it under the terms of the GNU Lesser General Public\\nLicense as published by the Free Software Foundation; either\\nversion 2.1 of the License, or (at your option) any later version.\\n\\n%s is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\nLesser General Public License for more details.\\n\\nYou should have received a copy of the GNU Lesser General Public\\nLicense along with %s; if not, write to the Free Software\\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",program_name,program_name,program_name);\r\n#endif\r\n return 0;\r\n}\r\n\r\nint show_formats(void *optctx,const char *opt,const char *arg)\r\n{\r\n AVInputFormat *ifmt = ((void *)0);\r\n AVOutputFormat *ofmt = ((void *)0);\r\n const char *last_name;\r\n printf(\"File formats:\\n D. = Demuxing supported\\n .E = Muxing supported\\n --\\n\");\r\n last_name = \"000\";\r\n for (; ; ) {\r\n int decode = 0;\r\n int encode = 0;\r\n const char *name = ((void *)0);\r\n const char *long_name = ((void *)0);\r\n while(ofmt = av_oformat_next(ofmt)){\r\n if ((name == ((void *)0) || strcmp(ofmt -> name,name) < 0) && strcmp(ofmt -> name,last_name) > 0) {\r\n name = ofmt -> name;\r\n long_name = ofmt -> long_name;\r\n encode = 1;\r\n }\r\n }\r\n while(ifmt = av_iformat_next(ifmt)){\r\n if ((name == ((void *)0) || strcmp(ifmt -> name,name) < 0) && strcmp(ifmt -> name,last_name) > 0) {\r\n name = ifmt -> name;\r\n long_name = ifmt -> long_name;\r\n encode = 0;\r\n }\r\n if (name && strcmp(ifmt -> name,name) == 0) {\r\n decode = 1;\r\n }\r\n }\r\n if (name == ((void *)0)) {\r\n break; \r\n }\r\n last_name = name;\r\n printf(\" %s%s %-15s %s\\n\",(decode?\"D\" : \" \"),(encode?\"E\" : \" \"),name,(long_name?long_name : \" \"));\r\n }\r\n return 0;\r\n}\r\n#define PRINT_CODEC_SUPPORTED(codec, field, type, list_name, term, get_name) \\\r\n if (codec->field) { \\\r\n const type *p = codec->field; \\\r\n \\\r\n printf(\" Supported \" list_name \":\"); \\\r\n while (*p != term) { \\\r\n get_name(*p); \\\r\n printf(\" %s\", name); \\\r\n p++; \\\r\n } \\\r\n printf(\"\\n\"); \\\r\n } \\\r\n\r\n\r\nstatic void print_codec(const AVCodec *c)\r\n{\r\n int encoder = av_codec_is_encoder(c);\r\n printf(\"%s %s [%s]:\\n\",(encoder?\"Encoder\" : \"Decoder\"),c -> name,(c -> long_name?c -> long_name : \"\"));\r\n if ((c -> type) == AVMEDIA_TYPE_VIDEO) {\r\n printf(\" Threading capabilities: \");\r\n switch(c -> capabilities & (0x1000 | 0x2000)){\r\n case 0x1000 | 0x2000:\r\n{\r\n printf(\"frame and slice\");\r\n break; \r\n }\r\n case 0x1000:\r\n{\r\n printf(\"frame\");\r\n break; \r\n }\r\n case 0x2000:\r\n{\r\n printf(\"slice\");\r\n break; \r\n }\r\n default:\r\n{\r\n printf(\"no\");\r\n break; \r\n }\r\n }\r\n printf(\"\\n\");\r\n }\r\n if (c -> supported_framerates) {\r\n const AVRational *fps = c -> supported_framerates;\r\n printf(\" Supported framerates:\");\r\n while(fps -> num){\r\n printf(\" %d/%d\",fps -> num,fps -> den);\r\n fps++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n if (c -> pix_fmts) {\r\n const enum AVPixelFormat *p = c -> pix_fmts;\r\n printf(\" Supported pixel formats:\");\r\n while(( *p) != AV_PIX_FMT_NONE){\r\n const char *name = av_get_pix_fmt_name( *p);\r\n ;\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> supported_samplerates) {\r\n const int *p = c -> supported_samplerates;\r\n printf(\" Supported sample rates:\");\r\n while( *p != 0){\r\n char name[16];\r\n snprintf(name,sizeof(name),\"%d\", *p);\r\n ;\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> sample_fmts) {\r\n const enum AVSampleFormat *p = c -> sample_fmts;\r\n printf(\" Supported sample formats:\");\r\n while(( *p) != AV_SAMPLE_FMT_NONE){\r\n const char *name = av_get_sample_fmt_name( *p);\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> channel_layouts) {\r\n const uint64_t *p = c -> channel_layouts;\r\n printf(\" Supported channel layouts:\");\r\n while( *p != 0){\r\n char name[128];\r\n av_get_channel_layout_string(name,(sizeof(name)),0, *p);\r\n ;\r\n printf(\" %s\",name);\r\n p++;\r\n }\r\n printf(\"\\n\");\r\n }\r\n ;\r\n if (c -> priv_class) {\r\n show_help_children(c -> priv_class,1 | 2);\r\n }\r\n}\r\n\r\nstatic char get_media_type_char(enum AVMediaType type)\r\n{\r\n switch(type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return 'V';\r\n case AVMEDIA_TYPE_AUDIO:\r\n return 'A';\r\n case AVMEDIA_TYPE_DATA:\r\n return 'D';\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n return 'S';\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n return 'T';\r\n default:\r\n return 63;\r\n }\r\n}\r\n\r\nstatic const AVCodec *next_codec_for_id(enum AVCodecID id,const AVCodec *prev,int encoder)\r\n{\r\n while(prev = (av_codec_next(prev))){\r\n if ((prev -> id) == id && ((encoder?av_codec_is_encoder(prev) : av_codec_is_decoder(prev)))) {\r\n return prev;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_codec_desc(const void *a,const void *b)\r\n{\r\n const AVCodecDescriptor *const *da = a;\r\n const AVCodecDescriptor *const *db = b;\r\n return (( *da) -> type) != (( *db) -> type)?(( *da) -> type) - (( *db) -> type) : strcmp(( *da) -> name,( *db) -> name);\r\n}\r\n\r\nstatic unsigned int get_codecs_sorted(const AVCodecDescriptor ***rcodecs)\r\n{\r\n const AVCodecDescriptor *desc = ((void *)0);\r\n const AVCodecDescriptor **codecs;\r\n unsigned int nb_codecs = 0;\r\n unsigned int i = 0;\r\n while(desc = avcodec_descriptor_next(desc))\r\n nb_codecs++;\r\n if (!(codecs = (av_calloc(nb_codecs,sizeof(( *codecs)))))) {\r\n av_log(((void *)0),16,\"Out of memory\\n\");\r\n exit(1);\r\n }\r\n desc = ((void *)0);\r\n while(desc = avcodec_descriptor_next(desc))\r\n codecs[i++] = desc;\r\n do {\r\n if (!(i == nb_codecs)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i == nb_codecs\",\"cmdutils.c\",1271);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(codecs,nb_codecs,sizeof(( *codecs)),compare_codec_desc);\r\n *rcodecs = codecs;\r\n return nb_codecs;\r\n}\r\n\r\nstatic void print_codecs_for_id(enum AVCodecID id,int encoder)\r\n{\r\n const AVCodec *codec = ((void *)0);\r\n printf(\" (%s: \",(encoder?\"encoders\" : \"decoders\"));\r\n while(codec = next_codec_for_id(id,codec,encoder))\r\n printf(\"%s \",codec -> name);\r\n printf(\")\");\r\n}\r\n\r\nint show_codecs(void *optctx,const char *opt,const char *arg)\r\n{\r\n const AVCodecDescriptor **codecs;\r\n unsigned int i;\r\n unsigned int nb_codecs = get_codecs_sorted(&codecs);\r\n printf(\"Codecs:\\n D..... = Decoding supported\\n .E.... = Encoding supported\\n ..V... = Video codec\\n ..A... = Audio codec\\n ..S... = Subtitle codec\\n ...I.. = Intra frame-only codec\\n ....L. = Lossy compression\\n .....S = Lossless compression\\n -------\\n\");\r\n for (i = 0; i < nb_codecs; i++) {\r\n const AVCodecDescriptor *desc = codecs[i];\r\n const AVCodec *codec = ((void *)0);\r\n printf(\" \");\r\n printf((avcodec_find_decoder(desc -> id)?\"D\" : \".\"));\r\n printf((avcodec_find_encoder(desc -> id)?\"E\" : \".\"));\r\n printf(\"%c\",(get_media_type_char(desc -> type)));\r\n printf((desc -> props & 1 << 0?\"I\" : \".\"));\r\n printf((desc -> props & 1 << 1?\"L\" : \".\"));\r\n printf((desc -> props & 1 << 2?\"S\" : \".\"));\r\n printf(\" %-20s %s\",desc -> name,(desc -> long_name?desc -> long_name : \"\"));\r\n\r\n while(codec = next_codec_for_id(desc -> id,codec,0)){\r\n if (strcmp(codec -> name,desc -> name)) {\r\n print_codecs_for_id(desc -> id,0);\r\n break; \r\n }\r\n }\r\n codec = ((void *)0);\r\n while(codec = next_codec_for_id(desc -> id,codec,1)){\r\n if (strcmp(codec -> name,desc -> name)) {\r\n print_codecs_for_id(desc -> id,1);\r\n break; \r\n }\r\n }\r\n printf(\"\\n\");\r\n }\r\n av_free(codecs);\r\n return 0;\r\n}\r\n\r\nstatic void print_codecs(int encoder)\r\n{\r\n const AVCodecDescriptor **codecs;\r\n unsigned int i;\r\n unsigned int nb_codecs = get_codecs_sorted(&codecs);\r\n printf(\"%s:\\n V..... = Video\\n A..... = Audio\\n S..... = Subtitle\\n .F.... = Frame-level multithreading\\n ..S... = Slice-level multithreading\\n ...X.. = Codec is experimental\\n ....B. = Supports draw_horiz_band\\n .....D = Supports direct rendering method 1\\n ------\\n\",(encoder?\"Encoders\" : \"Decoders\"));\r\n for (i = 0; i < nb_codecs; i++) {\r\n const AVCodecDescriptor *desc = codecs[i];\r\n const AVCodec *codec = ((void *)0);\r\n while(codec = next_codec_for_id(desc -> id,codec,encoder)){\r\n printf(\" %c\",(get_media_type_char(desc -> type)));\r\n printf((codec -> capabilities & 0x1000?\"F\" : \".\"));\r\n printf((codec -> capabilities & 0x2000?\"S\" : \".\"));\r\n printf((codec -> capabilities & 0x0200?\"X\" : \".\"));\r\n printf((codec -> capabilities & 0x0001?\"B\" : \".\"));\r\n printf((codec -> capabilities & 0x00002?\"D\" : \".\"));\r\n printf(\" %-20s %s\",codec -> name,(codec -> long_name?codec -> long_name : \"\"));\r\n if (strcmp(codec -> name,desc -> name)) {\r\n printf(\" (codec %s)\",desc -> name);\r\n }\r\n printf(\"\\n\");\r\n }\r\n }\r\n av_free(codecs);\r\n}\r\n\r\nint show_decoders(void *optctx,const char *opt,const char *arg)\r\n{\r\n print_codecs(0);\r\n return 0;\r\n}\r\n\r\nint show_encoders(void *optctx,const char *opt,const char *arg)\r\n{\r\n print_codecs(1);\r\n return 0;\r\n}\r\n\r\nint show_bsfs(void *optctx,const char *opt,const char *arg)\r\n{\r\n AVBitStreamFilter *bsf = ((void *)0);\r\n printf(\"Bitstream filters:\\n\");\r\n while(bsf = av_bitstream_filter_next(bsf))\r\n printf(\"%s\\n\",bsf -> name);\r\n printf(\"\\n\");\r\n return 0;\r\n}\r\n\r\nint show_protocols(void *optctx,const char *opt,const char *arg)\r\n{\r\n void *opaque = (void *)0;\r\n const char *name;\r\n printf(\"Supported file protocols:\\nInput:\\n\");\r\n while(name = avio_enum_protocols(&opaque,0))\r\n printf(\"%s\\n\",name);\r\n printf(\"Output:\\n\");\r\n while(name = avio_enum_protocols(&opaque,1))\r\n printf(\"%s\\n\",name);\r\n return 0;\r\n}\r\n\r\nint show_filters(void *optctx,const char *opt,const char *arg)\r\n{\r\n AVFilter **filter __attribute__((unused)) = ((void *)0);\r\n char descr[64];\r\n char *descr_cur;\r\n int i;\r\n int j;\r\n const AVFilterPad *pad;\r\n printf(\"Filters:\\n\");\r\n#if CONFIG_AVFILTER\r\n while((filter = av_filter_next(filter)) && *filter){\r\n descr_cur = descr;\r\n for (i = 0; i < 2; i++) {\r\n if (i) {\r\n *(descr_cur++) = '-';\r\n *(descr_cur++) = '>';\r\n }\r\n pad = (i?( *filter) -> outputs : ( *filter) -> inputs);\r\n for (j = 0; pad && pad[j] . name; j++) {\r\n if (descr_cur >= descr + sizeof(descr) - 4) {\r\n break; \r\n }\r\n *(descr_cur++) = get_media_type_char(pad[j] . type);\r\n }\r\n if (!j) {\r\n *(descr_cur++) = '|';\r\n }\r\n }\r\n *descr_cur = 0;\r\n printf(\"%-16s %-10s %s\\n\",( *filter) -> name,descr,( *filter) -> description);\r\n }\r\n#endif\r\n return 0;\r\n}\r\n\r\nint show_pix_fmts(void *optctx,const char *opt,const char *arg)\r\n{\r\n const AVPixFmtDescriptor *pix_desc = ((void *)0);\r\n printf(\"Pixel formats:\\nI.... = Supported Input format for conversion\\n.O... = Supported Output format for conversion\\n..H.. = Hardware accelerated format\\n...P. = Paletted format\\n....B = Bitstream format\\nFLAGS NAME NB_COMPONENTS BITS_PER_PIXEL\\n-----\\n\");\r\n#if !CONFIG_SWSCALE\r\n# define sws_isSupportedInput(x) 0\r\n# define sws_isSupportedOutput(x) 0\r\n#endif\r\n while(pix_desc = av_pix_fmt_desc_next(pix_desc)){\r\n enum AVPixelFormat pix_fmt = av_pix_fmt_desc_get_id(pix_desc);\r\n printf(\"%c%c%c%c%c %-16s %d %2d\\n\",(sws_isSupportedInput(pix_fmt)?'I' : '.'),(sws_isSupportedOutput(pix_fmt)?'O' : '.'),((pix_desc -> flags) & 8?'H' : '.'),((pix_desc -> flags) & 2?'P' : '.'),((pix_desc -> flags) & 4?'B' : '.'),pix_desc -> name,(pix_desc -> nb_components),av_get_bits_per_pixel(pix_desc));\r\n }\r\n return 0;\r\n}\r\n\r\nint show_layouts(void *optctx,const char *opt,const char *arg)\r\n{\r\n int i = 0;\r\n uint64_t layout;\r\n uint64_t j;\r\n const char *name;\r\n const char *descr;\r\n printf(\"Individual channels:\\nNAME DESCRIPTION\\n\");\r\n for (i = 0; i < 63; i++) {\r\n name = av_get_channel_name(((uint64_t )1) << i);\r\n if (!name) {\r\n continue; \r\n }\r\n descr = av_get_channel_description(((uint64_t )1) << i);\r\n printf(\"%-12s%s\\n\",name,descr);\r\n }\r\n printf(\"\\nStandard channel layouts:\\nNAME DECOMPOSITION\\n\");\r\n for (i = 0; !av_get_standard_channel_layout(i,&layout,&name); i++) {\r\n if (name) {\r\n printf(\"%-12s\",name);\r\n for (j = 1; j; j <<= 1) \r\n if (layout & j) {\r\n printf(\"%s%s\",(layout & j - 1?\"+\" : \"\"),av_get_channel_name(j));\r\n }\r\n printf(\"\\n\");\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint show_sample_fmts(void *optctx,const char *opt,const char *arg)\r\n{\r\n int i;\r\n char fmt_str[128];\r\n for (i = - 1; i < AV_SAMPLE_FMT_NB; i++) \r\n printf(\"%s\\n\",av_get_sample_fmt_string(fmt_str,(sizeof(fmt_str)),i));\r\n return 0;\r\n}\r\n\r\nstatic void show_help_codec(const char *name,int encoder)\r\n{\r\n const AVCodecDescriptor *desc;\r\n const AVCodec *codec;\r\n if (!name) {\r\n av_log(((void *)0),16,\"No codec name specified.\\n\");\r\n return ;\r\n }\r\n codec = ((encoder?avcodec_find_encoder_by_name(name) : avcodec_find_decoder_by_name(name)));\r\n if (codec) {\r\n print_codec(codec);\r\n }\r\n else {\r\n if (desc = avcodec_descriptor_get_by_name(name)) {\r\n int printed = 0;\r\n while(codec = next_codec_for_id(desc -> id,codec,encoder)){\r\n printed = 1;\r\n print_codec(codec);\r\n }\r\n if (!printed) {\r\n av_log(((void *)0),16,\"Codec '%s' is known to FFmpeg, but no %s for it are available. FFmpeg might need to be recompiled with additional external libraries.\\n\",name,(encoder?\"encoders\" : \"decoders\"));\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Codec '%s' is not recognized by FFmpeg.\\n\",name);\r\n }\r\n }\r\n}\r\n\r\nstatic void show_help_demuxer(const char *name)\r\n{\r\n const AVInputFormat *fmt = (av_find_input_format(name));\r\n if (!fmt) {\r\n av_log(((void *)0),16,\"Unknown format '%s'.\\n\",name);\r\n return ;\r\n }\r\n printf(\"Demuxer %s [%s]:\\n\",fmt -> name,fmt -> long_name);\r\n if (fmt -> extensions) {\r\n printf(\" Common extensions: %s.\\n\",fmt -> extensions);\r\n }\r\n if (fmt -> priv_class) {\r\n show_help_children(fmt -> priv_class,2);\r\n }\r\n}\r\n\r\nstatic void show_help_muxer(const char *name)\r\n{\r\n const AVCodecDescriptor *desc;\r\n const AVOutputFormat *fmt = (av_guess_format(name,((void *)0),((void *)0)));\r\n if (!fmt) {\r\n av_log(((void *)0),16,\"Unknown format '%s'.\\n\",name);\r\n return ;\r\n }\r\n printf(\"Muxer %s [%s]:\\n\",fmt -> name,fmt -> long_name);\r\n if (fmt -> extensions) {\r\n printf(\" Common extensions: %s.\\n\",fmt -> extensions);\r\n }\r\n if (fmt -> mime_type) {\r\n printf(\" Mime type: %s.\\n\",fmt -> mime_type);\r\n }\r\n if ((fmt -> video_codec) != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt -> video_codec))) {\r\n printf(\" Default video codec: %s.\\n\",desc -> name);\r\n }\r\n if ((fmt -> audio_codec) != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt -> audio_codec))) {\r\n printf(\" Default audio codec: %s.\\n\",desc -> name);\r\n }\r\n if ((fmt -> subtitle_codec) != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt -> subtitle_codec))) {\r\n printf(\" Default subtitle codec: %s.\\n\",desc -> name);\r\n }\r\n if (fmt -> priv_class) {\r\n show_help_children(fmt -> priv_class,1);\r\n }\r\n}\r\n\r\nint show_help(void *optctx,const char *opt,const char *arg)\r\n{\r\n char *topic;\r\n char *par;\r\n av_log_set_callback(log_callback_help);\r\n topic = av_strdup((arg?arg : \"\"));\r\n par = strchr(topic,'=');\r\n if (par) {\r\n *(par++) = 0;\r\n }\r\n if (!( *topic)) {\r\n show_help_default(topic,par);\r\n }\r\n else {\r\n if (!strcmp(topic,\"decoder\")) {\r\n show_help_codec(par,0);\r\n }\r\n else {\r\n if (!strcmp(topic,\"encoder\")) {\r\n show_help_codec(par,1);\r\n }\r\n else {\r\n if (!strcmp(topic,\"demuxer\")) {\r\n show_help_demuxer(par);\r\n }\r\n else {\r\n if (!strcmp(topic,\"muxer\")) {\r\n show_help_muxer(par);\r\n }\r\n else {\r\n show_help_default(topic,par);\r\n }\r\n }\r\n }\r\n }\r\n }\r\n av_freep((&topic));\r\n return 0;\r\n}\r\n\r\nint read_yesno()\r\n{\r\n int c = getchar();\r\n int yesno = av_toupper(c) == 'Y';\r\n while(c != '\\n' && c != - 1)\r\n c = getchar();\r\n return yesno;\r\n}\r\n\r\nint cmdutils_read_file(const char *filename,char **bufptr,size_t *size)\r\n{\r\n int ret;\r\n FILE *f = fopen(filename,\"rb\");\r\n if (!f) {\r\n av_log(((void *)0),16,\"Cannot read file '%s': %s\\n\",filename,strerror( *__errno_location()));\r\n return -( *__errno_location());\r\n }\r\n fseek(f,0,2);\r\n *size = (ftell(f));\r\n fseek(f,0,0);\r\n if ( *size == ((size_t )(- 1))) {\r\n av_log(((void *)0),16,\"IO error: %s\\n\",strerror( *__errno_location()));\r\n fclose(f);\r\n return -( *__errno_location());\r\n }\r\n *bufptr = (av_malloc( *size + 1));\r\n if (!( *bufptr)) {\r\n av_log(((void *)0),16,\"Could not allocate file buffer\\n\");\r\n fclose(f);\r\n return - 12;\r\n }\r\n ret = (fread(( *bufptr),1, *size,f));\r\n if (ret < *size) {\r\n av_free(( *bufptr));\r\n if (ferror(f)) {\r\n av_log(((void *)0),16,\"Error while reading file '%s': %s\\n\",filename,strerror( *__errno_location()));\r\n ret = -( *__errno_location());\r\n }\r\n else {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n ( *bufptr)[( *size)++] = '\\0';\r\n }\r\n fclose(f);\r\n return ret;\r\n}\r\n\r\nFILE *get_preset_file(char *filename,size_t filename_size,const char *preset_name,int is_path,const char *codec_name)\r\n{\r\n FILE *f = ((void *)0);\r\n int i;\r\n const char *base[3] = {(getenv(\"FFMPEG_DATADIR\")), (getenv(\"HOME\")), \"/opt//workspace/install/share/ffmpeg\"};\r\n if (is_path) {\r\n av_strlcpy(filename,preset_name,filename_size);\r\n f = fopen(filename,\"r\");\r\n }\r\n else {\r\n#ifdef _WIN32\r\n#endif\r\n for (i = 0; i < 3 && !f; i++) {\r\n if (!base[i]) {\r\n continue; \r\n }\r\n snprintf(filename,filename_size,\"%s%s/%s.ffpreset\",base[i],(i != 1?\"\" : \"/.ffmpeg\"),preset_name);\r\n f = fopen(filename,\"r\");\r\n if (!f && codec_name) {\r\n snprintf(filename,filename_size,\"%s%s/%s-%s.ffpreset\",base[i],(i != 1?\"\" : \"/.ffmpeg\"),codec_name,preset_name);\r\n f = fopen(filename,\"r\");\r\n }\r\n }\r\n }\r\n return f;\r\n}\r\n\r\nint check_stream_specifier(AVFormatContext *s,AVStream *st,const char *spec)\r\n{\r\n int ret = avformat_match_stream_specifier(s,st,spec);\r\n if (ret < 0) {\r\n av_log(s,16,\"Invalid stream specifier: %s.\\n\",spec);\r\n }\r\n return ret;\r\n}\r\n\r\nAVDictionary *filter_codec_opts(AVDictionary *opts,enum AVCodecID codec_id,AVFormatContext *s,AVStream *st,AVCodec *codec)\r\n{\r\n AVDictionary *ret = ((void *)0);\r\n AVDictionaryEntry *t = ((void *)0);\r\n int flags = s -> oformat?1 : 2;\r\n char prefix = 0;\r\n const AVClass *cc = avcodec_get_class();\r\n if (!codec) {\r\n codec = (s -> oformat?avcodec_find_encoder(codec_id) : avcodec_find_decoder(codec_id));\r\n }\r\n switch(st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n prefix = 'v';\r\n flags |= 16;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n prefix = 'a';\r\n flags |= 8;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n prefix = 's';\r\n flags |= 32;\r\n break; \r\n }\r\n }\r\n while(t = av_dict_get(opts,\"\",t,2)){\r\n char *p = strchr((t -> key),':');\r\n\r\n if (p) {\r\n switch(check_stream_specifier(s,st,(p + 1))){\r\n case 1:\r\n{\r\n *p = 0;\r\n break; \r\n }\r\n case 0:\r\n continue; \r\n default:\r\n return ((void *)0);\r\n }\r\n }\r\n if (av_opt_find((&cc),(t -> key),((void *)0),flags,0x00002) || codec && codec -> priv_class && av_opt_find((&codec -> priv_class),(t -> key),((void *)0),flags,0x00002)) {\r\n av_dict_set(&ret,(t -> key),(t -> value),0);\r\n }\r\n else {\r\n if (t -> key[0] == prefix && av_opt_find((&cc),(t -> key + 1),((void *)0),flags,0x00002)) {\r\n av_dict_set(&ret,(t -> key + 1),(t -> value),0);\r\n }\r\n }\r\n if (p) {\r\n *p = ':';\r\n }\r\n }\r\n return ret;\r\n}\r\n#define DORIA_UNTITTERING(x) nereidae_alloa((struct tbilisi_neckful) x)\r\n\r\nAVDictionary **setup_find_stream_info_opts(AVFormatContext *s,AVDictionary *codec_opts)\r\n{\r\n struct tbilisi_neckful irradiancy_turnbull = {0};\r\n int *dobbin_barragon = 0;\r\n int aposafranine_overpositively;\r\n struct tbilisi_neckful orthodiagonal_msfor[10] = {0};\r\n struct tbilisi_neckful vizardless_antaeus;\r\n char *marva_papayas;\r\n int i;\r\n AVDictionary **opts;\r\n if (__sync_bool_compare_and_swap(&yikirgaulit_lederite,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n marva_papayas = getenv(\"CHOCKLER_TAOTAI\");\r\n if (marva_papayas != 0) {;\r\n vizardless_antaeus . charwoman_carthamin = ((char *)marva_papayas);\r\n orthodiagonal_msfor[5] = vizardless_antaeus;\r\n aposafranine_overpositively = 5;\r\n dobbin_barragon = &aposafranine_overpositively;\r\n irradiancy_turnbull = *(orthodiagonal_msfor + *dobbin_barragon);\r\n\tDORIA_UNTITTERING(irradiancy_turnbull);\r\n }\r\n }\r\n }\r\n if (!s -> nb_streams) {\r\n return ((void *)0);\r\n }\r\n opts = (av_mallocz((s -> nb_streams) * sizeof(( *opts))));\r\n if (!opts) {\r\n av_log(((void *)0),16,\"Could not alloc memory for stream options.\\n\");\r\n return ((void *)0);\r\n }\r\n for (i = 0; i < s -> nb_streams; i++) \r\n opts[i] = filter_codec_opts(codec_opts,s -> streams[i] -> codec -> codec_id,s,s -> streams[i],((void *)0));\r\n return opts;\r\n}\r\n\r\nvoid *grow_array(void *array,int elem_size,int *size,int new_size)\r\n{\r\n if (new_size >= 2147483647 / elem_size) {\r\n av_log(((void *)0),16,\"Array too big.\\n\");\r\n exit(1);\r\n }\r\n if ( *size < new_size) {\r\n uint8_t *tmp = (av_realloc(array,(new_size * elem_size)));\r\n if (!tmp) {\r\n av_log(((void *)0),16,\"Could not alloc buffer.\\n\");\r\n exit(1);\r\n }\r\n memset((tmp + *size * elem_size),0,((new_size - *size) * elem_size));\r\n *size = new_size;\r\n return tmp;\r\n }\r\n return array;\r\n}\r\n\r\nstatic int alloc_buffer(FrameBuffer **pool,AVCodecContext *s,FrameBuffer **pbuf)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n FrameBuffer *buf;\r\n int i;\r\n int ret;\r\n int pixel_size;\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n\r\n int edge = 32;\r\n int w = s -> width;\r\n int h = s -> height;\r\n if (!desc) {\r\n return - 22;\r\n }\r\n pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n buf = (av_mallocz(sizeof(( *buf))));\r\n if (!buf) {\r\n return - 12;\r\n }\r\n avcodec_align_dimensions(s,&w,&h);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 2 * edge;\r\n h += 2 * edge;\r\n }\r\n if ((ret = av_image_alloc(buf -> base,buf -> linesize,w,h,s -> pix_fmt,32)) < 0) {\r\n av_freep((&buf));\r\n av_log(s,16,\"alloc_buffer: av_image_alloc() failed\\n\");\r\n return ret;\r\n }\r\n avcodec_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n for (i = 0; i < sizeof(buf -> data) / sizeof(buf -> data[0]); i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n if (s -> flags & 0x4000 || !buf -> linesize[i] || !buf -> base[i]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * edge >> v_shift) + (pixel_size * edge >> h_shift) + 32 - 1 & ~(32 - 1));\r\n }\r\n }\r\n buf -> w = s -> width;\r\n buf -> h = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n buf -> pool = pool;\r\n *pbuf = buf;\r\n return 0;\r\n}\r\n\r\nint codec_get_buffer(AVCodecContext *s,AVFrame *frame)\r\n{\r\n FrameBuffer **pool = (s -> opaque);\r\n FrameBuffer *buf;\r\n int ret;\r\n int i;\r\n if (av_image_check_size((s -> width),(s -> height),0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"codec_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!( *pool) && (ret = alloc_buffer(pool,s,pool)) < 0) {\r\n return ret;\r\n }\r\n buf = *pool;\r\n *pool = buf -> next;\r\n buf -> next = ((void *)0);\r\n if (buf -> w != s -> width || buf -> h != s -> height || (buf -> pix_fmt) != (s -> pix_fmt)) {\r\n av_freep((&buf -> base[0]));\r\n av_free(buf);\r\n if ((ret = alloc_buffer(pool,s,&buf)) < 0) {\r\n return ret;\r\n }\r\n }\r\n do {\r\n if (!(!buf -> refcount)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!buf->refcount\",\"cmdutils.c\",1915);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n frame -> opaque = buf;\r\n frame -> type = 2;\r\n frame -> extended_data = frame -> data;\r\n for (i = 0; i < sizeof(buf -> data) / sizeof(buf -> data[0]); i++) {\r\n\r\n frame -> base[i] = buf -> base[i];\r\n frame -> data[i] = buf -> data[i];\r\n frame -> linesize[i] = buf -> linesize[i];\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void unref_buffer(FrameBuffer *buf)\r\n{\r\n FrameBuffer **pool = buf -> pool;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount > 0\",\"cmdutils.c\",1935);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount--;\r\n if (!buf -> refcount) {\r\n FrameBuffer *tmp;\r\n for (tmp = *pool; tmp; tmp = tmp -> next) \r\n (void )0;\r\n buf -> next = *pool;\r\n *pool = buf;\r\n }\r\n}\r\n\r\nvoid codec_release_buffer(AVCodecContext *s,AVFrame *frame)\r\n{\r\n FrameBuffer *buf = (frame -> opaque);\r\n int i;\r\n if (frame -> type != 2) {\r\n avcodec_default_release_buffer(s,frame);\r\n return ;\r\n }\r\n for (i = 0; i < sizeof(frame -> data) / sizeof(frame -> data[0]); i++) \r\n frame -> data[i] = ((void *)0);\r\n unref_buffer(buf);\r\n}\r\n\r\nvoid filter_release_buffer(AVFilterBuffer *fb)\r\n{\r\n FrameBuffer *buf = (fb -> priv);\r\n av_free(fb);\r\n unref_buffer(buf);\r\n}\r\n\r\nvoid free_buffer_pool(FrameBuffer **pool)\r\n{\r\n FrameBuffer *buf = *pool;\r\n while(buf){\r\n *pool = buf -> next;\r\n av_freep((&buf -> base[0]));\r\n av_free(buf);\r\n buf = *pool;\r\n }\r\n}\r\n\r\nvoid nereidae_alloa(struct tbilisi_neckful unroot_verier)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *preconfirmation_beasts = 0;\r\n ++global_variable;;\r\n preconfirmation_beasts = ((char *)unroot_verier . charwoman_carthamin);\r\n \r\n buffer_value = atoi(preconfirmation_beasts);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(malloc_buffer,0,size_buffer);\n printf(\"Buffer size is %d\\n\", size_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_AES\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/aes.h>\r\n#include \"evp_locl.h\"\r\n#ifndef OPENSSL_FIPS\r\n#include \"modes_lcl.h\"\r\n#include <openssl/rand.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\ntypedef struct {\r\nAES_KEY ks;\r\nblock128_f block;\r\nunion {\r\ncbc128_f cbc;\r\nctr128_f ctr;}stream;}EVP_AES_KEY;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\nGCM128_CONTEXT gcm;\r\n\r\nunsigned char *iv;\r\n\r\nint ivlen;\r\nint taglen;\r\n\r\nint iv_gen;\r\n\r\nint tls_aad_len;\r\nctr128_f ctr;}EVP_AES_GCM_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks1;\r\nAES_KEY ks2;\r\nXTS128_CONTEXT xts;\r\nvoid (*stream)(const unsigned char *, unsigned char *, size_t , const AES_KEY *, const AES_KEY *, const unsigned char [16]);}EVP_AES_XTS_CTX;\r\ntypedef struct {\r\n\r\nAES_KEY ks;\r\n\r\nint key_set;\r\n\r\nint iv_set;\r\n\r\nint tag_set;\r\n\r\nint len_set;\r\n\r\nint L;\r\nint M;\r\nCCM128_CONTEXT ccm;\r\nccm128_f str;}EVP_AES_CCM_CTX;\r\n#define MAXBITCHUNK\t((size_t)1<<(sizeof(size_t)*8-4))\r\n#ifdef VPAES_ASM\r\nextern int vpaes_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int vpaes_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void vpaes_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void vpaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\n#endif\r\n#ifdef BSAES_ASM\r\nextern void bsaes_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char ivec[16],int enc);\r\nextern void bsaes_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t len,const AES_KEY *key,const unsigned char ivec[16]);\r\nextern void bsaes_xts_encrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void bsaes_xts_decrypt(const unsigned char *inp,unsigned char *out,size_t len,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\n#endif\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n#ifdef AES_XTS_ASM\r\n#endif\r\n#if\tdefined(AES_ASM) && !defined(I386_ONLY) &&\t( \\\r\n\t((defined(__i386)\t|| defined(__i386__)\t|| \\\r\n\t defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \\\r\n\tdefined(__x86_64)\t|| defined(__x86_64__)\t|| \\\r\n\tdefined(_M_AMD64)\t|| defined(_M_X64)\t|| \\\r\n\tdefined(__INTEL__)\t\t\t\t)\r\nextern unsigned int OPENSSL_ia32cap_P[2];\r\n#ifdef VPAES_ASM\r\n#define VPAES_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(41-32)))\r\n#endif\r\n#ifdef BSAES_ASM\r\n#define BSAES_CAPABLE\tVPAES_CAPABLE\r\n#endif\r\n\r\n#define\tAESNI_CAPABLE\t(OPENSSL_ia32cap_P[1]&(1<<(57-32)))\r\nextern int aesni_set_encrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern int aesni_set_decrypt_key(const unsigned char *userKey,int bits,AES_KEY *key);\r\nextern void aesni_encrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_decrypt(const unsigned char *in,unsigned char *out,const AES_KEY *key);\r\nextern void aesni_ecb_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,int enc);\r\nextern void aesni_cbc_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key,unsigned char *ivec,int enc);\r\nextern void aesni_ctr32_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char *ivec);\r\nextern void aesni_xts_encrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_xts_decrypt(const unsigned char *in,unsigned char *out,size_t length,const AES_KEY *key1,const AES_KEY *key2,const unsigned char iv[16]);\r\nextern void aesni_ccm64_encrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nextern void aesni_ccm64_decrypt_blocks(const unsigned char *in,unsigned char *out,size_t blocks,const void *key,const unsigned char ivec[16],unsigned char cmac[16]);\r\nint arius_citrulline = 0;\r\nint global_variable;\r\nvoid trusted_plumville(char **proliferating_superjets);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid beverages_heteromastigate(void (*rehood_unsecularised)(char **));\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n ret = aesni_set_decrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )aesni_cbc_encrypt) : ((void *)0));\r\n }\r\n else {\r\n ret = aesni_set_encrypt_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n dat -> block = ((block128_f )aesni_encrypt);\r\n if (mode == 0x2) {\r\n dat -> stream . cbc = ((cbc128_f )aesni_cbc_encrypt);\r\n }\r\n else {\r\n if (mode == 0x5) {\r\n dat -> stream . ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n dat -> stream . cbc = ((void *)0);\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,165,143,\"e_aes.c\",258);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n aesni_cbc_encrypt(in,out,len,(ctx -> cipher_data),ctx -> iv,ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n aesni_ecb_encrypt(in,out,len,(ctx -> cipher_data),ctx -> encrypt);\r\n return 1;\r\n}\r\n#define aesni_ofb_cipher aes_ofb_cipher\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb_cipher aes_cfb_cipher\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb8_cipher aes_cfb8_cipher\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_cfb1_cipher aes_cfb1_cipher\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define aesni_ctr_cipher aes_ctr_cipher\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )aesni_encrypt));\r\n gctx -> ctr = ((ctr128_f )aesni_ctr32_encrypt_blocks);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n#define aesni_gcm_cipher aes_gcm_cipher\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n\r\n if (enc) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_encrypt);\r\n xctx -> stream = aesni_xts_encrypt;\r\n }\r\n else {\r\n aesni_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )aesni_decrypt);\r\n xctx -> stream = aesni_xts_decrypt;\r\n }\r\n aesni_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )aesni_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n#define aesni_xts_cipher aes_xts_cipher\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n\r\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n aesni_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )aesni_encrypt));\r\n cctx -> str = (enc?((ccm128_f )aesni_ccm64_encrypt_blocks) : ((ccm128_f )aesni_ccm64_decrypt_blocks));\r\n cctx -> key_set = 1;\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n#define aesni_ccm_cipher aes_ccm_cipher\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len);\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_init_key,\t\t\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,\t\\\r\n\tkeylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aesni_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taesni_##mode##_init_key,\t\\\r\n\taesni_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }\r\n#else\r\n#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_init_key,\t\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\tNULL,\t\t\t\t\\\r\n\tsizeof(EVP_AES_KEY),\t\t\\\r\n\tNULL,NULL,NULL,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \\\r\nstatic const EVP_CIPHER aes_##keylen##_##mode = { \\\r\n\tnid##_##keylen##_##mode,blocksize, \\\r\n\t(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \\\r\n\tflags|EVP_CIPH_##MODE##_MODE,\t\\\r\n\taes_##mode##_init_key,\t\t\\\r\n\taes_##mode##_cipher,\t\t\\\r\n\taes_##mode##_cleanup,\t\t\\\r\n\tsizeof(EVP_AES_##MODE##_CTX),\t\\\r\n\tNULL,NULL,aes_##mode##_ctrl,NULL }; \\\r\nconst EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \\\r\n{ return &aes_##keylen##_##mode; }\r\n#endif\r\n#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)\t\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)\t\\\r\n\tBLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)\r\n\r\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n int mode;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n mode = (ctx -> cipher -> flags & 0xF0007);\r\n if ((mode == 0x1 || mode == 0x2) && !enc) {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x2) {\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = ((cbc128_f )bsaes_cbc_encrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_decrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_decrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n }\r\n }\r\n }\r\n else {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32) && mode == 0x5) {\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n ret = vpaes_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )vpaes_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )vpaes_cbc_encrypt) : ((void *)0));\r\n }\r\n else \r\n#endif\r\n{\r\n ret = AES_set_encrypt_key(key,ctx -> key_len * 8,&dat -> ks);\r\n dat -> block = ((block128_f )AES_encrypt);\r\n dat -> stream . cbc = (mode == 0x2?((cbc128_f )AES_cbc_encrypt) : ((void *)0));\r\n#ifdef AES_CTR_ASM\r\n#endif\r\n }\r\n }\r\n }\r\n if (ret < 0) {\r\n ERR_put_error(6,133,143,\"e_aes.c\",567);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . cbc) {\r\n ( *dat -> stream . cbc)(in,out,len,(&dat -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n else {\r\n CRYPTO_cbc128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,dat -> block);\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n size_t bl = (ctx -> cipher -> block_size);\r\n size_t i;\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (len < bl) {\r\n return 1;\r\n }\r\n for ((i = 0 , len -= bl); i <= len; i += bl) \r\n ( *dat -> block)(in + i,out + i,(&dat -> ks));\r\n return 1;\r\n}\r\n\r\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_ofb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n CRYPTO_cfb128_8_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n}\r\n\r\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (ctx -> flags & 0x2000) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n return 1;\r\n }\r\n while(len >= ((size_t )1) << sizeof(size_t ) * 8 - 4){\r\n CRYPTO_cfb128_1_encrypt(in,out,(((size_t )1) << sizeof(size_t ) * 8 - 4) * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n len -= ((size_t )1) << sizeof(size_t ) * 8 - 4;\r\n }\r\n if (len) {\r\n CRYPTO_cfb128_1_encrypt(in,out,len * 8,(&dat -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt,dat -> block);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n unsigned int num = (ctx -> num);\r\n EVP_AES_KEY *dat = (EVP_AES_KEY *)(ctx -> cipher_data);\r\n if (dat -> stream . ctr) {\r\n CRYPTO_ctr128_encrypt_ctr32(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> stream . ctr);\r\n }\r\n else {\r\n CRYPTO_ctr128_encrypt(in,out,len,(&dat -> ks),ctx -> iv,ctx -> buf,&num,dat -> block);\r\n }\r\n ctx -> num = ((size_t )num);\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cbc = {(419), (16), (128 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cbc : &aes_128_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ecb = {(418), (16), (128 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ecb : &aes_128_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ofb = {(420), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ofb : &aes_128_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb = {(421), (1), (128 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb : &aes_128_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb1 = {(650), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb1 : &aes_128_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_cfb8 = {(653), (1), (128 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_cfb8 : &aes_128_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ctr = {(904), (1), (128 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ctr : &aes_128_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cbc = {(423), (16), (192 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cbc : &aes_192_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ecb = {(422), (16), (192 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ecb : &aes_192_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ofb = {(424), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ofb : &aes_192_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb = {(425), (1), (192 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb : &aes_192_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb1 = {(651), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb1 : &aes_192_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_cfb8 = {(654), (1), (192 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_cfb8()\r\n{;\r\n if (__sync_bool_compare_and_swap(&arius_citrulline,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n beverages_heteromastigate(trusted_plumville);\r\n }\r\n }\r\n ;\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_cfb8 : &aes_192_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ctr = {(905), (1), (192 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ctr : &aes_192_ctr;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aesni_init_key), (aesni_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cbc = {(427), (16), (256 / 8), (16), ((0x4000 | 0x1000 | 0x2)), (aes_init_key), (aes_cbc_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cbc()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cbc : &aes_256_cbc;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aesni_init_key), (aesni_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ecb = {(426), (16), (256 / 8), (0), ((0x4000 | 0x1000 | 0x1)), (aes_init_key), (aes_ecb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ecb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ecb : &aes_256_ecb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aesni_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ofb = {(428), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x4)), (aes_init_key), (aes_ofb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ofb()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ofb : &aes_256_ofb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aesni_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb = {(429), (1), (256 / 8), (16), ((0x4000 | 0x1000 | 0x3)), (aes_init_key), (aes_cfb_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb128()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb : &aes_256_cfb;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb1 = {(652), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb1_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb1()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb1 : &aes_256_cfb1;\r\n}\r\nstatic const EVP_CIPHER aesni_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aesni_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_cfb8 = {(655), (1), (256 / 8), (16), ((0x4000 | 0x3)), (aes_init_key), (aes_cfb8_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_cfb8()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_cfb8 : &aes_256_cfb8;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aesni_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ctr = {(906), (1), (256 / 8), (16), ((0x4000 | 0x5)), (aes_init_key), (aes_ctr_cipher), (((void *)0)), ((sizeof(EVP_AES_KEY ))), (((void *)0)), (((void *)0)), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ctr()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ctr : &aes_256_ctr;\r\n}\r\n\r\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n OPENSSL_cleanse((&gctx -> gcm),sizeof(gctx -> gcm));\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic void ctr64_inc(unsigned char *counter)\r\n{\r\n int n = 8;\r\n unsigned char c;\r\n do {\r\n --n;\r\n c = counter[n];\r\n ++c;\r\n counter[n] = c;\r\n if (c) {\r\n return ;\r\n }\r\n }while (n);\r\n}\r\n\r\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n gctx -> key_set = 0;\r\n gctx -> iv_set = 0;\r\n gctx -> ivlen = c -> cipher -> iv_len;\r\n gctx -> iv = c -> iv;\r\n gctx -> taglen = - 1;\r\n gctx -> iv_gen = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return 1;\r\n }\r\n case 0x9:\r\n{\r\n if (arg <= 0) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n#endif\r\n\r\n if (arg > 16 && arg > gctx -> ivlen) {\r\n if (gctx -> iv != c -> iv) {\r\n CRYPTO_free((gctx -> iv));\r\n }\r\n gctx -> iv = (CRYPTO_malloc(((int )arg),\"e_aes.c\",728));\r\n if (!gctx -> iv) {\r\n return 0;\r\n }\r\n }\r\n gctx -> ivlen = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg <= 0 || arg > 16 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> taglen = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (arg <= 0 || arg > 16 || !c -> encrypt || gctx -> taglen < 0) {\r\n return 0;\r\n }\r\n memcpy(ptr,(c -> buf),arg);\r\n return 1;\r\n }\r\n case 0x12:\r\n{\r\n\r\n if (arg == - 1) {\r\n memcpy((gctx -> iv),ptr,(gctx -> ivlen));\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n\r\n if (arg < 4 || gctx -> ivlen - arg < 8) {\r\n return 0;\r\n }\r\n if (arg) {\r\n memcpy((gctx -> iv),ptr,arg);\r\n }\r\n if (c -> encrypt && RAND_bytes(gctx -> iv + arg,gctx -> ivlen - arg) <= 0) {\r\n return 0;\r\n }\r\n gctx -> iv_gen = 1;\r\n return 1;\r\n }\r\n case 0x13:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0) {\r\n return 0;\r\n }\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n if (arg <= 0 || arg > gctx -> ivlen) {\r\n arg = gctx -> ivlen;\r\n }\r\n memcpy(ptr,(gctx -> iv + gctx -> ivlen - arg),arg);\r\n\r\n ctr64_inc(gctx -> iv + gctx -> ivlen - 8);\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x18:\r\n{\r\n if (gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt) {\r\n return 0;\r\n }\r\n memcpy((gctx -> iv + gctx -> ivlen - arg),ptr,arg);\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,(gctx -> iv),(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n return 1;\r\n }\r\n case 0x16:\r\n{\r\n\r\n if (arg != 13) {\r\n return 0;\r\n }\r\n memcpy((c -> buf),ptr,arg);\r\n gctx -> tls_aad_len = arg;\r\n{\r\n unsigned int len = (c -> buf[arg - 2] << 8 | c -> buf[arg - 1]);\r\n\r\n len -= 8;\r\n\r\n if (!c -> encrypt) {\r\n len -= 16;\r\n }\r\n c -> buf[arg - 2] = (len >> 8);\r\n c -> buf[arg - 1] = (len & 0xff);\r\n }\r\n\r\n return 16;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n gctx -> ctr = ((ctr128_f )bsaes_ctr32_encrypt_blocks);\r\n break; \r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )vpaes_encrypt));\r\n gctx -> ctr = ((void *)0);\r\n break; \r\n }\r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&gctx -> ks);\r\n CRYPTO_gcm128_init(&gctx -> gcm,(&gctx -> ks),((block128_f )AES_encrypt));\r\n#ifdef AES_CTR_ASM\r\n#else\r\n gctx -> ctr = ((void *)0);\r\n#endif\r\n }while (0);\r\n\r\n if (iv == ((void *)0) && gctx -> iv_set) {\r\n iv = (gctx -> iv);\r\n }\r\n if (iv) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n gctx -> iv_set = 1;\r\n }\r\n gctx -> key_set = 1;\r\n }\r\n else {\r\n\r\n if (gctx -> key_set) {\r\n CRYPTO_gcm128_setiv(&gctx -> gcm,iv,(gctx -> ivlen));\r\n }\r\n else {\r\n memcpy((gctx -> iv),iv,(gctx -> ivlen));\r\n }\r\n gctx -> iv_set = 1;\r\n gctx -> iv_gen = 0;\r\n }\r\n return 1;\r\n}\r\n\r\n\r\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n int rv = - 1;\r\n\r\n if (out != in || len < (8 + 16)) {\r\n return - 1;\r\n }\r\n\r\n if (EVP_CIPHER_CTX_ctrl(ctx,(ctx -> encrypt?0x13 : 0x18),8,out) <= 0) {\r\n goto err;\r\n }\r\n\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,(ctx -> buf),(gctx -> tls_aad_len))) {\r\n goto err;\r\n }\r\n\r\n in += 8;\r\n out += 8;\r\n len -= (8 + 16);\r\n if (ctx -> encrypt) {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n out += len;\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,out,16);\r\n rv = (len + 8 + 16);\r\n }\r\n else {\r\n\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n goto err;\r\n }\r\n }\r\n\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n\r\n if (memcmp((ctx -> buf),(in + len),16)) {\r\n OPENSSL_cleanse(out,len);\r\n goto err;\r\n }\r\n rv = len;\r\n }\r\n err:\r\n gctx -> iv_set = 0;\r\n gctx -> tls_aad_len = - 1;\r\n return rv;\r\n}\r\n\r\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_GCM_CTX *gctx = (ctx -> cipher_data);\r\n\r\n if (!gctx -> key_set) {\r\n return - 1;\r\n }\r\n if (gctx -> tls_aad_len >= 0) {\r\n return aes_gcm_tls_cipher(ctx,out,in,len);\r\n }\r\n if (!gctx -> iv_set) {\r\n return - 1;\r\n }\r\n if (in) {\r\n if (out == ((void *)0)) {\r\n if (CRYPTO_gcm128_aad(&gctx -> gcm,in,len)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (ctx -> encrypt) {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_encrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_encrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n else {\r\n if (gctx -> ctr) {\r\n if (CRYPTO_gcm128_decrypt_ctr32(&gctx -> gcm,in,out,len,gctx -> ctr)) {\r\n return - 1;\r\n }\r\n }\r\n else {\r\n if (CRYPTO_gcm128_decrypt(&gctx -> gcm,in,out,len)) {\r\n return - 1;\r\n }\r\n }\r\n }\r\n }\r\n return len;\r\n }\r\n else {\r\n if (!ctx -> encrypt) {\r\n if (gctx -> taglen < 0) {\r\n return - 1;\r\n }\r\n if (CRYPTO_gcm128_finish(&gctx -> gcm,(ctx -> buf),(gctx -> taglen)) != 0) {\r\n return - 1;\r\n }\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n CRYPTO_gcm128_tag(&gctx -> gcm,ctx -> buf,16);\r\n gctx -> taglen = 16;\r\n\r\n gctx -> iv_set = 0;\r\n return 0;\r\n }\r\n}\r\n#define CUSTOM_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 \\\r\n\t\t| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\\r\n\t\t| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_gcm = {(895), (1), (((0x6 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_gcm : &aes_128_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_gcm = {(898), (1), (((0x6 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_gcm : &aes_192_gcm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aesni_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_gcm = {(901), (1), (((0x6 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | 0x200000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x6)), (aes_gcm_init_key), (aes_gcm_cipher), (aes_gcm_cleanup), ((sizeof(EVP_AES_GCM_CTX ))), (((void *)0)), (((void *)0)), (aes_gcm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_gcm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_gcm : &aes_256_gcm;\r\n}\r\n\r\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (c -> cipher_data);\r\n if (type != 0) {\r\n return - 1;\r\n }\r\n\r\n xctx -> xts . key1 = ((void *)0);\r\n xctx -> xts . key2 = ((void *)0);\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef AES_XTS_ASM\r\n#else\r\n xctx -> stream = ((void *)0);\r\n#endif\r\n\r\n#ifdef BSAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n xctx -> stream = (enc?bsaes_xts_encrypt : bsaes_xts_decrypt);\r\n }\r\n else {\r\n#endif\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n if (enc) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_encrypt);\r\n }\r\n else {\r\n vpaes_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )vpaes_decrypt);\r\n }\r\n vpaes_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )vpaes_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n break; \r\n }\r\n }\r\n#endif\r\n if (enc) {\r\n AES_set_encrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_encrypt);\r\n }\r\n else {\r\n AES_set_decrypt_key(key,ctx -> key_len * 4,&xctx -> ks1);\r\n xctx -> xts . block1 = ((block128_f )AES_decrypt);\r\n }\r\n AES_set_encrypt_key(key + ctx -> key_len / 2,ctx -> key_len * 4,&xctx -> ks2);\r\n xctx -> xts . block2 = ((block128_f )AES_encrypt);\r\n xctx -> xts . key1 = (&xctx -> ks1);\r\n }while (0);\r\n }\r\n if (iv) {\r\n xctx -> xts . key2 = (&xctx -> ks2);\r\n memcpy((ctx -> iv),iv,16);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_XTS_CTX *xctx = (ctx -> cipher_data);\r\n if (!xctx -> xts . key1 || !xctx -> xts . key2) {\r\n return 0;\r\n }\r\n if (!out || !in || len < 16) {\r\n return 0;\r\n }\r\n#ifdef OPENSSL_FIPS\r\n\r\n#endif\r\n if (xctx -> stream) {\r\n ( *xctx -> stream)(in,out,len,xctx -> xts . key1,xctx -> xts . key2,(ctx -> iv));\r\n }\r\n else {\r\n if (CRYPTO_xts128_encrypt((&xctx -> xts),(ctx -> iv),in,out,len,ctx -> encrypt)) {\r\n return 0;\r\n }\r\n }\r\n return 1;\r\n}\r\n#define aes_xts_cleanup NULL\r\n#define XTS_FLAGS\t(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\\r\n\t\t\t | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)\r\nstatic const EVP_CIPHER aesni_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_xts = {(913), (1), (((0x10001 == 0x10001?2 : 1)) * 128 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_xts : &aes_128_xts;\r\n}\r\nstatic const EVP_CIPHER aesni_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aesni_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_xts = {(914), (1), (((0x10001 == 0x10001?2 : 1)) * 256 / 8), (16), ((0x4000 | (0x1000 | 0x10 | 0x20 | 0x40) | 0x10001)), (aes_xts_init_key), (aes_xts_cipher), (((void *)0)), ((sizeof(EVP_AES_XTS_CTX ))), (((void *)0)), (((void *)0)), (aes_xts_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_xts()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_xts : &aes_256_xts;\r\n}\r\n\r\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (c -> cipher_data);\r\n switch(type){\r\n case 0x0:\r\n{\r\n cctx -> key_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> L = 8;\r\n cctx -> M = 12;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n case 0x9:\r\n arg = 15 - arg;\r\n case 0x14:\r\n{\r\n if (arg < 2 || arg > 8) {\r\n return 0;\r\n }\r\n cctx -> L = arg;\r\n return 1;\r\n }\r\n case 0x11:\r\n{\r\n if (arg & 1 || arg < 4 || arg > 16) {\r\n return 0;\r\n }\r\n if (c -> encrypt && ptr || !c -> encrypt && !ptr) {\r\n return 0;\r\n }\r\n if (ptr) {\r\n cctx -> tag_set = 1;\r\n memcpy((c -> buf),ptr,arg);\r\n }\r\n cctx -> M = arg;\r\n return 1;\r\n }\r\n case 0x10:\r\n{\r\n if (!c -> encrypt || !cctx -> tag_set) {\r\n return 0;\r\n }\r\n if (!CRYPTO_ccm128_tag(&cctx -> ccm,ptr,((size_t )arg))) {\r\n return 0;\r\n }\r\n cctx -> tag_set = 0;\r\n cctx -> iv_set = 0;\r\n cctx -> len_set = 0;\r\n return 1;\r\n }\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n if (!iv && !key) {\r\n return 1;\r\n }\r\n if (key) {\r\n do {\r\n#ifdef VPAES_CAPABLE\r\n if (OPENSSL_ia32cap_P[1] & (1 << 41 - 32)) {\r\n vpaes_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )vpaes_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n break; \r\n }\r\n#endif\r\n AES_set_encrypt_key(key,ctx -> key_len * 8,&cctx -> ks);\r\n CRYPTO_ccm128_init(&cctx -> ccm,(cctx -> M),(cctx -> L),(&cctx -> ks),((block128_f )AES_encrypt));\r\n cctx -> str = ((void *)0);\r\n cctx -> key_set = 1;\r\n }while (0);\r\n }\r\n if (iv) {\r\n memcpy((ctx -> iv),iv,(15 - cctx -> L));\r\n cctx -> iv_set = 1;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t len)\r\n{\r\n EVP_AES_CCM_CTX *cctx = (ctx -> cipher_data);\r\n CCM128_CONTEXT *ccm = &cctx -> ccm;\r\n\r\n if (!cctx -> iv_set && !cctx -> key_set) {\r\n return - 1;\r\n }\r\n if (!ctx -> encrypt && !cctx -> tag_set) {\r\n return - 1;\r\n }\r\n if (!out) {\r\n if (!in) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n return len;\r\n }\r\n\r\n if (!cctx -> len_set && len) {\r\n return - 1;\r\n }\r\n CRYPTO_ccm128_aad(ccm,in,len);\r\n return len;\r\n }\r\n\r\n if (!in) {\r\n return 0;\r\n }\r\n\r\n if (!cctx -> len_set) {\r\n if (CRYPTO_ccm128_setiv(ccm,(ctx -> iv),(15 - cctx -> L),len)) {\r\n return - 1;\r\n }\r\n cctx -> len_set = 1;\r\n }\r\n if (ctx -> encrypt) {\r\n if (cctx -> str?CRYPTO_ccm128_encrypt_ccm64(ccm,in,out,len,cctx -> str) : CRYPTO_ccm128_encrypt(ccm,in,out,len)) {\r\n return - 1;\r\n }\r\n cctx -> tag_set = 1;\r\n return len;\r\n }\r\n else {\r\n int rv = - 1;\r\n if (cctx -> str?!CRYPTO_ccm128_decrypt_ccm64(ccm,in,out,len,cctx -> str) : !CRYPTO_ccm128_decrypt(ccm,in,out,len)) {\r\n unsigned char tag[16];\r\n if (CRYPTO_ccm128_tag(ccm,tag,(cctx -> M))) {\r\n if (!memcmp(tag,(ctx -> buf),(cctx -> M))) {\r\n rv = len;\r\n }\r\n }\r\n }\r\n if (rv == - 1) {\r\n OPENSSL_cleanse(out,len);\r\n }\r\n cctx -> iv_set = 0;\r\n cctx -> tag_set = 0;\r\n cctx -> len_set = 0;\r\n return rv;\r\n }\r\n}\r\n#define aes_ccm_cleanup NULL\r\nstatic const EVP_CIPHER aesni_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_128_ccm = {(896), (1), (((0x7 == 0x10001?2 : 1)) * 128 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_128_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_128_ccm : &aes_128_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_192_ccm = {(899), (1), (((0x7 == 0x10001?2 : 1)) * 192 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_192_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_192_ccm : &aes_192_ccm;\r\n}\r\nstatic const EVP_CIPHER aesni_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aesni_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\nstatic const EVP_CIPHER aes_256_ccm = {(902), (1), (((0x7 == 0x10001?2 : 1)) * 256 / 8), (12), ((0x4000 | (0x1000 | 0x10 | 0x100000 | 0x20 | 0x40) | 0x7)), (aes_ccm_init_key), (aes_ccm_cipher), (((void *)0)), ((sizeof(EVP_AES_CCM_CTX ))), (((void *)0)), (((void *)0)), (aes_ccm_ctrl), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_aes_256_ccm()\r\n{\r\n return OPENSSL_ia32cap_P[1] & (1 << 57 - 32)?&aesni_256_ccm : &aes_256_ccm;\r\n}\r\n\r\nvoid trusted_plumville(char **proliferating_superjets)\r\n{\r\n int petasus_calabasas = 35;\r\n char *omnividence_iverson;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&omnividence_iverson,\"7847\",petasus_calabasas);\r\n if (omnividence_iverson != 0) {;\r\n *proliferating_superjets = omnividence_iverson;\r\n }\r\n}\r\n\r\nvoid beverages_heteromastigate(void (*rehood_unsecularised)(char **))\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *excusative_spicehouse = 0;\r\n char **aftercomer_viviparities = 0;\r\n char **falls_vizirial = 0;\r\n ++global_variable;\r\n char *rechose_marissa = 0;\r\n rehood_unsecularised(&rechose_marissa);\r\n if (rechose_marissa != 0) {;\r\n aftercomer_viviparities = &rechose_marissa;\r\n falls_vizirial = aftercomer_viviparities + 5;\r\n excusative_spicehouse = ((char *)( *(falls_vizirial - 5)));\r\n \r\n if (strlen(excusative_spicehouse) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(excusative_spicehouse) == 1) {\r\n parsed_input = malloc((strlen(excusative_spicehouse)+1) * sizeof(char));\r\n urlDecode(excusative_spicehouse, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if ( *(falls_vizirial - 5) != 0) \r\n free(((char *)( *(falls_vizirial - 5))));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <setjmp.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <time.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint kutaisi_gotos = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid wariest_knurliest(void *const pulers_capelline);\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n void *fbv_burgh = 0;\r\n int sitters_toolings = 73;\r\n char *redon_revaluates;;\r\n if (__sync_bool_compare_and_swap(&kutaisi_gotos,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&redon_revaluates,\"6934\",sitters_toolings);\r\n if (redon_revaluates != 0) {;\r\n fbv_burgh = ((void *)redon_revaluates);\r\n wariest_knurliest(fbv_burgh);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid wariest_knurliest(void *const pulers_capelline)\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n char *result = 0;\r\n int random_int = 0;\r\n char *superrefine_dabchicks = 0;\r\n jmp_buf camphanyl_irvingism;\r\n int geranials_multipointed;\r\n ++global_variable;;\r\n geranials_multipointed = setjmp(camphanyl_irvingism);\r\n if (geranials_multipointed == 0) {\r\n longjmp(camphanyl_irvingism,1);\r\n }\r\n superrefine_dabchicks = ((char *)((char *)((void *)pulers_capelline)));\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, superrefine_dabchicks);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\r\n \r\n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n result = PQcmdTuples(res);\r\n printf(\"Query OK, %s rows affected\\n\",result);\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\n if (((char *)((void *)pulers_capelline)) != 0) \r\n free(((char *)((char *)((void *)pulers_capelline))));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n res = PQexec(conn,query);\n if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n \n printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n PQclear(res);\n PQfinish(conn);\n exit(1);\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "static int balance_nonroot(\r\r\n MemPage *pParent, /* Parent page of siblings being balanced */\r\r\n int iParentIdx, /* Index of \"the page\" in pParent */\r\r\n u8 *aOvflSpace, /* page-size bytes of space for parent ovfl */\r\r\n int isRoot, /* True if pParent is a root-page */\r\r\n int bBulk /* True if this call is part of a bulk load */\r\r\n){\r\r\n BtShared *pBt; /* The whole database */\r\r\n int nMaxCells = 0; /* Allocated size of apCell, szCell, aFrom. */\r\r\n int nNew = 0; /* Number of pages in apNew[] */\r\r\n int nOld; /* Number of pages in apOld[] */\r\r\n int i, j, k; /* Loop counters */\r\r\n int nxDiv; /* Next divider slot in pParent->aCell[] */\r\r\n int rc = SQLITE_OK; /* The return code */\r\r\n u16 leafCorrection; /* 4 if pPage is a leaf. 0 if not */\r\r\n int leafData; /* True if pPage is a leaf of a LEAFDATA tree */\r\r\n int usableSpace; /* Bytes in pPage beyond the header */\r\r\n int pageFlags; /* Value of pPage->aData[0] */\r\r\n int iSpace1 = 0; /* First unused byte of aSpace1[] */\r\r\n int iOvflSpace = 0; /* First unused byte of aOvflSpace[] */\r\r\n int szScratch; /* Size of scratch memory requested */\r\r\n MemPage *apOld[NB]; /* pPage and up to two siblings */\r\r\n MemPage *apNew[NB+2]; /* pPage and up to NB siblings after balancing */\r\r\n u8 *pRight; /* Location in parent of right-sibling pointer */\r\r\n u8 *apDiv[NB-1]; /* Divider cells in pParent */\r\r\n int cntNew[NB+2]; /* Index in b.paCell[] of cell after i-th page */\r\r\n int cntOld[NB+2]; /* Old index in b.apCell[] */\r\r\n int szNew[NB+2]; /* Combined size of cells placed on i-th page */\r\r\n u8 *aSpace1; /* Space for copies of dividers cells */\r\r\n Pgno pgno; /* Temp var to store a page number in */\r\r\n u8 abDone[NB+2]; /* True after i'th new page is populated */\r\r\n Pgno aPgno[NB+2]; /* Page numbers of new pages before shuffling */\r\r\n Pgno aPgOrder[NB+2]; /* Copy of aPgno[] used for sorting pages */\r\r\n u16 aPgFlags[NB+2]; /* flags field of new pages before shuffling */\r\r\n CellArray b; /* Parsed information on cells being balanced */\r\r\n\r\r\n memset(abDone, 0, sizeof(abDone));\r\r\n b.nCell = 0;\r\r\n b.apCell = 0;\r\r\n pBt = pParent->pBt;\r\r\n assert( sqlite3_mutex_held(pBt->mutex) );\r\r\n assert( sqlite3PagerIswriteable(pParent->pDbPage) );\r\r\n\r\r\n /* At this point pParent may have at most one overflow cell. And if\r\r\n ** this overflow cell is present, it must be the cell with\r\r\n ** index iParentIdx. This scenario comes about when this function\r\r\n ** is called (indirectly) from sqlite3BtreeDelete().\r\r\n */\r\r\n assert( pParent->nOverflow==0 || pParent->nOverflow==1 );\r\r\n assert( pParent->nOverflow==0 || pParent->aiOvfl[0]==iParentIdx );\r\r\n\r\r\n if( !aOvflSpace ){\r\r\n return SQLITE_NOMEM_BKPT;\r\r\n }\r\r\n\r\r\n /* Find the sibling pages to balance. Also locate the cells in pParent\r\r\n ** that divide the siblings. An attempt is made to find NN siblings on\r\r\n ** either side of pPage. More siblings are taken from one side, however,\r\r\n ** if there are fewer than NN siblings on the other side. If pParent\r\r\n ** has NB or fewer children then all children of pParent are taken.\r\r\n **\r\r\n ** This loop also drops the divider cells from the parent page. This\r\r\n ** way, the remainder of the function does not have to deal with any\r\r\n ** overflow cells in the parent page, since if any existed they will\r\r\n ** have already been removed.\r\r\n */\r\r\n i = pParent->nOverflow + pParent->nCell;\r\r\n if( i<2 ){\r\r\n nxDiv = 0;\r\r\n }else{\r\r\n assert( bBulk==0 || bBulk==1 );\r\r\n if( iParentIdx==0 ){\r\r\n nxDiv = 0;\r\r\n }else if( iParentIdx==i ){\r\r\n nxDiv = i-2+bBulk;\r\r\n }else{\r\r\n nxDiv = iParentIdx-1;\r\r\n }\r\r\n i = 2-bBulk;\r\r\n }\r\r\n nOld = i+1;\r\r\n if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){\r\r\n pRight = &pParent->aData[pParent->hdrOffset+8];\r\r\n }else{\r\r\n pRight = findCell(pParent, i+nxDiv-pParent->nOverflow);\r\r\n }\r\r\n pgno = get4byte(pRight);\r\r\n while( 1 ){\r\r\n rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);\r\r\n if( rc ){\r\r\n memset(apOld, 0, (i+1)*sizeof(MemPage*));\r\r\n goto balance_cleanup;\r\r\n }\r\r\n nMaxCells += 1+apOld[i]->nCell+apOld[i]->nOverflow;\r\r\n if( (i--)==0 ) break;\r\r\n\r\r\n if( pParent->nOverflow && i+nxDiv==pParent->aiOvfl[0] ){\r\r\n apDiv[i] = pParent->apOvfl[0];\r\r\n pgno = get4byte(apDiv[i]);\r\r\n szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\r\r\n pParent->nOverflow = 0;\r\r\n }else{\r\r\n apDiv[i] = findCell(pParent, i+nxDiv-pParent->nOverflow);\r\r\n pgno = get4byte(apDiv[i]);\r\r\n szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\r\r\n\r\r\n /* Drop the cell from the parent page. apDiv[i] still points to\r\r\n ** the cell within the parent, even though it has been dropped.\r\r\n ** This is safe because dropping a cell only overwrites the first\r\r\n ** four bytes of it, and this function does not need the first\r\r\n ** four bytes of the divider cell. So the pointer is safe to use\r\r\n ** later on.\r\r\n **\r\r\n ** But not if we are in secure-delete mode. In secure-delete mode,\r\r\n ** the dropCell() routine will overwrite the entire cell with zeroes.\r\r\n ** In this case, temporarily copy the cell into the aOvflSpace[]\r\r\n ** buffer. It will be copied out again as soon as the aSpace[] buffer\r\r\n ** is allocated. */\r\r\n if( pBt->btsFlags & BTS_FAST_SECURE ){\r\r\n int iOff;\r\r\n\r\r\n iOff = SQLITE_PTR_TO_INT(apDiv[i]) - SQLITE_PTR_TO_INT(pParent->aData);\r\r\n if( (iOff+szNew[i])>(int)pBt->usableSize ){\r\r\n rc = SQLITE_CORRUPT_BKPT;\r\r\n memset(apOld, 0, (i+1)*sizeof(MemPage*));\r\r\n goto balance_cleanup;\r\r\n }else{\r\r\n memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);\r\r\n apDiv[i] = &aOvflSpace[apDiv[i]-pParent->aData];\r\r\n }\r\r\n }\r\r\n dropCell(pParent, i+nxDiv-pParent->nOverflow, szNew[i], &rc);\r\r\n }\r\r\n }\r\r\n\r\r\n /* Make nMaxCells a multiple of 4 in order to preserve 8-byte\r\r\n ** alignment */\r\r\n nMaxCells = (nMaxCells + 3)&~3;\r\r\n\r\r\n /*\r\r\n ** Allocate space for memory structures\r\r\n */\r\r\n szScratch =\r\r\n nMaxCells*sizeof(u8*) /* b.apCell */\r\r\n + nMaxCells*sizeof(u16) /* b.szCell */\r\r\n + pBt->pageSize; /* aSpace1 */\r\r\n\r\r\n assert( szScratch<=6*(int)pBt->pageSize );\r\r\n b.apCell = sqlite3StackAllocRaw(0, szScratch );\r\r\n if( b.apCell==0 ){\r\r\n rc = SQLITE_NOMEM_BKPT;\r\r\n goto balance_cleanup;\r\r\n }\r\r\n b.szCell = (u16*)&b.apCell[nMaxCells];\r\r\n aSpace1 = (u8*)&b.szCell[nMaxCells];\r\r\n assert( EIGHT_BYTE_ALIGNMENT(aSpace1) );\r\r\n\r\r\n /*\r\r\n ** Load pointers to all cells on sibling pages and the divider cells\r\r\n ** into the local b.apCell[] array. Make copies of the divider cells\r\r\n ** into space obtained from aSpace1[]. The divider cells have already\r\r\n ** been removed from pParent.\r\r\n **\r\r\n ** If the siblings are on leaf pages, then the child pointers of the\r\r\n ** divider cells are stripped from the cells before they are copied\r\r\n ** into aSpace1[]. In this way, all cells in b.apCell[] are without\r\r\n ** child pointers. If siblings are not leaves, then all cell in\r\r\n ** b.apCell[] include child pointers. Either way, all cells in b.apCell[]\r\r\n ** are alike.\r\r\n **\r\r\n ** leafCorrection: 4 if pPage is a leaf. 0 if pPage is not a leaf.\r\r\n ** leafData: 1 if pPage holds key+data and pParent holds only keys.\r\r\n */\r\r\n b.pRef = apOld[0];\r\r\n leafCorrection = b.pRef->leaf*4;\r\r\n leafData = b.pRef->intKeyLeaf;\r\r\n for(i=0; i<nOld; i++){\r\r\n MemPage *pOld = apOld[i];\r\r\n int limit = pOld->nCell;\r\r\n u8 *aData = pOld->aData;\r\r\n u16 maskPage = pOld->maskPage;\r\r\n u8 *piCell = aData + pOld->cellOffset;\r\r\n u8 *piEnd;\r\r\n\r\r\n /* Verify that all sibling pages are of the same \"type\" (table-leaf,\r\r\n ** table-interior, index-leaf, or index-interior).\r\r\n */\r\r\n if( pOld->aData[0]!=apOld[0]->aData[0] ){\r\r\n rc = SQLITE_CORRUPT_BKPT;\r\r\n goto balance_cleanup;\r\r\n }\r\r\n\r\r\n /* Load b.apCell[] with pointers to all cells in pOld. If pOld\r\r\n ** contains overflow cells, include them in the b.apCell[] array\r\r\n ** in the correct spot.\r\r\n **\r\r\n ** Note that when there are multiple overflow cells, it is always the\r\r\n ** case that they are sequential and adjacent. This invariant arises\r\r\n ** because multiple overflows can only occurs when inserting divider\r\r\n ** cells into a parent on a prior balance, and divider cells are always\r\r\n ** adjacent and are inserted in order. There is an assert() tagged\r\r\n ** with \"NOTE 1\" in the overflow cell insertion loop to prove this\r\r\n ** invariant.\r\r\n **\r\r\n ** This must be done in advance. Once the balance starts, the cell\r\r\n ** offset section of the btree page will be overwritten and we will no\r\r\n ** long be able to find the cells if a pointer to each cell is not saved\r\r\n ** first.\r\r\n */\r\r\n memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));\r\r\n if( pOld->nOverflow>0 ){\r\r\n limit = pOld->aiOvfl[0];\r\r\n for(j=0; j<limit; j++){\r\r\n b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));\r\r\n piCell += 2;\r\r\n b.nCell++;\r\r\n }\r\r\n for(k=0; k<pOld->nOverflow; k++){\r\r\n assert( k==0 || pOld->aiOvfl[k-1]+1==pOld->aiOvfl[k] );/* NOTE 1 */\r\r\n b.apCell[b.nCell] = pOld->apOvfl[k];\r\r\n b.nCell++;\r\r\n }\r\r\n }\r\r\n piEnd = aData + pOld->cellOffset + 2*pOld->nCell;\r\r\n while( piCell<piEnd ){\r\r\n assert( b.nCell<nMaxCells );\r\r\n b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));\r\r\n piCell += 2;\r\r\n b.nCell++;\r\r\n }\r\r\n\r\r\n cntOld[i] = b.nCell;\r\r\n if( i<nOld-1 && !leafData){\r\r\n u16 sz = (u16)szNew[i];\r\r\n u8 *pTemp;\r\r\n assert( b.nCell<nMaxCells );\r\r\n b.szCell[b.nCell] = sz;\r\r\n pTemp = &aSpace1[iSpace1];\r\r\n iSpace1 += sz;\r\r\n assert( sz<=pBt->maxLocal+23 );\r\r\n assert( iSpace1 <= (int)pBt->pageSize );\r\r\n memcpy(pTemp, apDiv[i], sz);\r\r\n b.apCell[b.nCell] = pTemp+leafCorrection;\r\r\n assert( leafCorrection==0 || leafCorrection==4 );\r\r\n b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;\r\r\n if( !pOld->leaf ){\r\r\n assert( leafCorrection==0 );\r\r\n assert( pOld->hdrOffset==0 );\r\r\n /* The right pointer of the child page pOld becomes the left\r\r\n ** pointer of the divider cell */\r\r\n memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);\r\r\n }else{\r\r\n assert( leafCorrection==4 );\r\r\n while( b.szCell[b.nCell]<4 ){\r\r\n /* Do not allow any cells smaller than 4 bytes. If a smaller cell\r\r\n ** does exist, pad it with 0x00 bytes. */\r\r\n assert( b.szCell[b.nCell]==3 || CORRUPT_DB );\r\r\n assert( b.apCell[b.nCell]==&aSpace1[iSpace1-3] || CORRUPT_DB );\r\r\n aSpace1[iSpace1++] = 0x00;\r\r\n b.szCell[b.nCell]++;\r\r\n }\r\r\n }\r\r\n b.nCell++;\r\r\n }\r\r\n }\r\r\n\r\r\n /*\r\r\n ** Figure out the number of pages needed to hold all b.nCell cells.\r\r\n ** Store this number in \"k\". Also compute szNew[] which is the total\r\r\n ** size of all cells on the i-th page and cntNew[] which is the index\r\r\n ** in b.apCell[] of the cell that divides page i from page i+1.\r\r\n ** cntNew[k] should equal b.nCell.\r\r\n **\r\r\n ** Values computed by this block:\r\r\n **\r\r\n ** k: The total number of sibling pages\r\r\n ** szNew[i]: Spaced used on the i-th sibling page.\r\r\n ** cntNew[i]: Index in b.apCell[] and b.szCell[] for the first cell to\r\r\n ** the right of the i-th sibling page.\r\r\n ** usableSpace: Number of bytes of space available on each sibling.\r\r\n **\r\r\n */\r\r\n usableSpace = pBt->usableSize - 12 + leafCorrection;\r\r\n for(i=k=0; i<nOld; i++, k++){\r\r\n MemPage *p = apOld[i];\r\r\n b.apEnd[k] = p->aDataEnd;\r\r\n b.ixNx[k] = cntOld[i];\r\r\n if( !leafData ){\r\r\n k++;\r\r\n b.apEnd[k] = pParent->aDataEnd;\r\r\n b.ixNx[k] = cntOld[i]+1;\r\r\n }\r\r\n szNew[i] = usableSpace - p->nFree;\r\r\n for(j=0; j<p->nOverflow; j++){\r\r\n szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);\r\r\n }\r\r\n cntNew[i] = cntOld[i];\r\r\n }\r\r\n k = nOld;\r\r\n for(i=0; i<k; i++){\r\r\n int sz;\r\r\n while( szNew[i]>usableSpace ){\r\r\n if( i+1>=k ){\r\r\n k = i+2;\r\r\n if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }\r\r\n szNew[k-1] = 0;\r\r\n cntNew[k-1] = b.nCell;\r\r\n }\r\r\n sz = 2 + cachedCellSize(&b, cntNew[i]-1);\r\r\n szNew[i] -= sz;\r\r\n if( !leafData ){\r\r\n if( cntNew[i]<b.nCell ){\r\r\n sz = 2 + cachedCellSize(&b, cntNew[i]);\r\r\n }else{\r\r\n sz = 0;\r\r\n }\r\r\n }\r\r\n szNew[i+1] += sz;\r\r\n cntNew[i]--;\r\r\n }\r\r\n while( cntNew[i]<b.nCell ){\r\r\n sz = 2 + cachedCellSize(&b, cntNew[i]);\r\r\n if( szNew[i]+sz>usableSpace ) break;\r\r\n szNew[i] += sz;\r\r\n cntNew[i]++;\r\r\n if( !leafData ){\r\r\n if( cntNew[i]<b.nCell ){\r\r\n sz = 2 + cachedCellSize(&b, cntNew[i]);\r\r\n }else{\r\r\n sz = 0;\r\r\n }\r\r\n }\r\r\n szNew[i+1] -= sz;\r\r\n }\r\r\n if( cntNew[i]>=b.nCell ){\r\r\n k = i+1;\r\r\n }else if( cntNew[i] <= (i>0 ? cntNew[i-1] : 0) ){\r\r\n rc = SQLITE_CORRUPT_BKPT;\r\r\n goto balance_cleanup;\r\r\n }\r\r\n }\r\r\n\r\r\n /*\r\r\n ** The packing computed by the previous block is biased toward the siblings\r\r\n ** on the left side (siblings with smaller keys). The left siblings are\r\r\n ** always nearly full, while the right-most sibling might be nearly empty.\r\r\n ** The next block of code attempts to adjust the packing of siblings to\r\r\n ** get a better balance.\r\r\n **\r\r\n ** This adjustment is more than an optimization. The packing above might\r\r\n ** be so out of balance as to be illegal. For example, the right-most\r\r\n ** sibling might be completely empty. This adjustment is not optional.\r\r\n */\r\r\n for(i=k-1; i>0; i--){\r\r\n int szRight = szNew[i]; /* Size of sibling on the right */\r\r\n int szLeft = szNew[i-1]; /* Size of sibling on the left */\r\r\n int r; /* Index of right-most cell in left sibling */\r\r\n int d; /* Index of first cell to the left of right sibling */\r\r\n\r\r\n r = cntNew[i-1] - 1;\r\r\n d = r + 1 - leafData;\r\r\n (void)cachedCellSize(&b, d);\r\r\n do{\r\r\n assert( d<nMaxCells );\r\r\n assert( r<nMaxCells );\r\r\n (void)cachedCellSize(&b, r);\r\r\n if( szRight!=0\r\r\n && (bBulk || szRight+b.szCell[d]+2 > szLeft-(b.szCell[r]+(i==k-1?0:2)))){\r\r\n break;\r\r\n }\r\r\n szRight += b.szCell[d] + 2;\r\r\n szLeft -= b.szCell[r] + 2;\r\r\n cntNew[i-1] = r;\r\r\n r--;\r\r\n d--;\r\r\n }while( r>=0 );\r\r\n szNew[i] = szRight;\r\r\n szNew[i-1] = szLeft;\r\r\n if( cntNew[i-1] <= (i>1 ? cntNew[i-2] : 0) ){\r\r\n rc = SQLITE_CORRUPT_BKPT;\r\r\n goto balance_cleanup;\r\r\n }\r\r\n }\r\r\n\r\r\n /* Sanity check: For a non-corrupt database file one of the follwing\r\r\n ** must be true:\r\r\n ** (1) We found one or more cells (cntNew[0])>0), or\r\r\n ** (2) pPage is a virtual root page. A virtual root page is when\r\r\n ** the real root page is page 1 and we are the only child of\r\r\n ** that page.\r\r\n */\r\r\n assert( cntNew[0]>0 || (pParent->pgno==1 && pParent->nCell==0) || CORRUPT_DB);\r\r\n TRACE((\"BALANCE: old: %d(nc=%d) %d(nc=%d) %d(nc=%d)\\n\",\r\r\n apOld[0]->pgno, apOld[0]->nCell,\r\r\n nOld>=2 ? apOld[1]->pgno : 0, nOld>=2 ? apOld[1]->nCell : 0,\r\r\n nOld>=3 ? apOld[2]->pgno : 0, nOld>=3 ? apOld[2]->nCell : 0\r\r\n ));\r\r\n\r\r\n /*\r\r\n ** Allocate k new pages. Reuse old pages where possible.\r\r\n */\r\r\n pageFlags = apOld[0]->aData[0];\r\r\n for(i=0; i<k; i++){\r\r\n MemPage *pNew;\r\r\n if( i<nOld ){\r\r\n pNew = apNew[i] = apOld[i];\r\r\n apOld[i] = 0;\r\r\n rc = sqlite3PagerWrite(pNew->pDbPage);\r\r\n nNew++;\r\r\n if( rc ) goto balance_cleanup;\r\r\n }else{\r\r\n assert( i>0 );\r\r\n rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);\r\r\n if( rc ) goto balance_cleanup;\r\r\n zeroPage(pNew, pageFlags);\r\r\n apNew[i] = pNew;\r\r\n nNew++;\r\r\n cntOld[i] = b.nCell;\r\r\n\r\r\n /* Set the pointer-map entry for the new sibling page. */\r\r\n if( ISAUTOVACUUM ){\r\r\n ptrmapPut(pBt, pNew->pgno, PTRMAP_BTREE, pParent->pgno, &rc);\r\r\n if( rc!=SQLITE_OK ){\r\r\n goto balance_cleanup;\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n /*\r\r\n ** Reassign page numbers so that the new pages are in ascending order.\r\r\n ** This helps to keep entries in the disk file in order so that a scan\r\r\n ** of the table is closer to a linear scan through the file. That in turn\r\r\n ** helps the operating system to deliver pages from the disk more rapidly.\r\r\n **\r\r\n ** An O(n^2) insertion sort algorithm is used, but since n is never more\r\r\n ** than (NB+2) (a small constant), that should not be a problem.\r\r\n **\r\r\n ** When NB==3, this one optimization makes the database about 25% faster\r\r\n ** for large insertions and deletions.\r\r\n */\r\r\n for(i=0; i<nNew; i++){\r\r\n aPgOrder[i] = aPgno[i] = apNew[i]->pgno;\r\r\n aPgFlags[i] = apNew[i]->pDbPage->flags;\r\r\n for(j=0; j<i; j++){\r\r\n if( aPgno[j]==aPgno[i] ){\r\r\n /* This branch is taken if the set of sibling pages somehow contains\r\r\n ** duplicate entries. This can happen if the database is corrupt.\r\r\n ** It would be simpler to detect this as part of the loop below, but\r\r\n ** we do the detection here in order to avoid populating the pager\r\r\n ** cache with two separate objects associated with the same\r\r\n ** page number. */\r\r\n assert( CORRUPT_DB );\r\r\n rc = SQLITE_CORRUPT_BKPT;\r\r\n goto balance_cleanup;\r\r\n }\r\r\n }\r\r\n }\r\r\n for(i=0; i<nNew; i++){\r\r\n int iBest = 0; /* aPgno[] index of page number to use */\r\r\n for(j=1; j<nNew; j++){\r\r\n if( aPgOrder[j]<aPgOrder[iBest] ) iBest = j;\r\r\n }\r\r\n pgno = aPgOrder[iBest];\r\r\n aPgOrder[iBest] = 0xffffffff;\r\r\n if( iBest!=i ){\r\r\n if( iBest>i ){\r\r\n sqlite3PagerRekey(apNew[iBest]->pDbPage, pBt->nPage+iBest+1, 0);\r\r\n }\r\r\n sqlite3PagerRekey(apNew[i]->pDbPage, pgno, aPgFlags[iBest]);\r\r\n apNew[i]->pgno = pgno;\r\r\n }\r\r\n }\r\r\n\r\r\n TRACE((\"BALANCE: new: %d(%d nc=%d) %d(%d nc=%d) %d(%d nc=%d) \"\r\r\n \"%d(%d nc=%d) %d(%d nc=%d)\\n\",\r\r\n apNew[0]->pgno, szNew[0], cntNew[0],\r\r\n nNew>=2 ? apNew[1]->pgno : 0, nNew>=2 ? szNew[1] : 0,\r\r\n nNew>=2 ? cntNew[1] - cntNew[0] - !leafData : 0,\r\r\n nNew>=3 ? apNew[2]->pgno : 0, nNew>=3 ? szNew[2] : 0,\r\r\n nNew>=3 ? cntNew[2] - cntNew[1] - !leafData : 0,\r\r\n nNew>=4 ? apNew[3]->pgno : 0, nNew>=4 ? szNew[3] : 0,\r\r\n nNew>=4 ? cntNew[3] - cntNew[2] - !leafData : 0,\r\r\n nNew>=5 ? apNew[4]->pgno : 0, nNew>=5 ? szNew[4] : 0,\r\r\n nNew>=5 ? cntNew[4] - cntNew[3] - !leafData : 0\r\r\n ));\r\r\n\r\r\n assert( sqlite3PagerIswriteable(pParent->pDbPage) );\r\r\n put4byte(pRight, apNew[nNew-1]->pgno);\r\r\n\r\r\n /* If the sibling pages are not leaves, ensure that the right-child pointer\r\r\n ** of the right-most new sibling page is set to the value that was\r\r\n ** originally in the same field of the right-most old sibling page. */\r\r\n if( (pageFlags & PTF_LEAF)==0 && nOld!=nNew ){\r\r\n MemPage *pOld = (nNew>nOld ? apNew : apOld)[nOld-1];\r\r\n memcpy(&apNew[nNew-1]->aData[8], &pOld->aData[8], 4);\r\r\n }\r\r\n\r\r\n /* Make any required updates to pointer map entries associated with\r\r\n ** cells stored on sibling pages following the balance operation. Pointer\r\r\n ** map entries associated with divider cells are set by the insertCell()\r\r\n ** routine. The associated pointer map entries are:\r\r\n **\r\r\n ** a) if the cell contains a reference to an overflow chain, the\r\r\n ** entry associated with the first page in the overflow chain, and\r\r\n **\r\r\n ** b) if the sibling pages are not leaves, the child page associated\r\r\n ** with the cell.\r\r\n **\r\r\n ** If the sibling pages are not leaves, then the pointer map entry\r\r\n ** associated with the right-child of each sibling may also need to be\r\r\n ** updated. This happens below, after the sibling pages have been\r\r\n ** populated, not here.\r\r\n */\r\r\n if( ISAUTOVACUUM ){\r\r\n MemPage *pOld;\r\r\n MemPage *pNew = pOld = apNew[0];\r\r\n u8 *aOld = pNew->aData;\r\r\n int cntOldNext = pNew->nCell + pNew->nOverflow;\r\r\n int usableSize = pBt->usableSize;\r\r\n int iNew = 0;\r\r\n int iOld = 0;\r\r\n\r\r\n for(i=0; i<b.nCell; i++){\r\r\n u8 *pCell = b.apCell[i];\r\r\n if( i==cntOldNext ){\r\r\n pOld = (++iOld)<nNew ? apNew[iOld] : apOld[iOld];\r\r\n cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;\r\r\n aOld = pOld->aData;\r\r\n }\r\r\n if( i==cntNew[iNew] ){\r\r\n pNew = apNew[++iNew];\r\r\n if( !leafData ) continue;\r\r\n }\r\r\n\r\r\n /* Cell pCell is destined for new sibling page pNew. Originally, it\r\r\n ** was either part of sibling page iOld (possibly an overflow cell),\r\r\n ** or else the divider cell to the left of sibling page iOld. So,\r\r\n ** if sibling page iOld had the same page number as pNew, and if\r\r\n ** pCell really was a part of sibling page iOld (not a divider or\r\r\n ** overflow cell), we can skip updating the pointer map entries. */\r\r\n if( iOld>=nNew\r\r\n || pNew->pgno!=aPgno[iOld]\r\r\n || !SQLITE_WITHIN(pCell,aOld,&aOld[usableSize])\r\r\n ){\r\r\n if( !leafCorrection ){\r\r\n ptrmapPut(pBt, get4byte(pCell), PTRMAP_BTREE, pNew->pgno, &rc);\r\r\n }\r\r\n if( cachedCellSize(&b,i)>pNew->minLocal ){\r\r\n ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);\r\r\n }\r\r\n if( rc ) goto balance_cleanup;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n /* Insert new divider cells into pParent. */\r\r\n for(i=0; i<nNew-1; i++){\r\r\n u8 *pCell;\r\r\n u8 *pTemp;\r\r\n int sz;\r\r\n MemPage *pNew = apNew[i];\r\r\n j = cntNew[i];\r\r\n\r\r\n assert( j<nMaxCells );\r\r\n assert( b.apCell[j]!=0 );\r\r\n pCell = b.apCell[j];\r\r\n sz = b.szCell[j] + leafCorrection;\r\r\n pTemp = &aOvflSpace[iOvflSpace];\r\r\n if( !pNew->leaf ){\r\r\n memcpy(&pNew->aData[8], pCell, 4);\r\r\n }else if( leafData ){\r\r\n /* If the tree is a leaf-data tree, and the siblings are leaves,\r\r\n ** then there is no divider cell in b.apCell[]. Instead, the divider\r\r\n ** cell consists of the integer key for the right-most cell of\r\r\n ** the sibling-page assembled above only.\r\r\n */\r\r\n CellInfo info;\r\r\n j--;\r\r\n pNew->xParseCell(pNew, b.apCell[j], &info);\r\r\n pCell = pTemp;\r\r\n sz = 4 + putVarint(&pCell[4], info.nKey);\r\r\n pTemp = 0;\r\r\n }else{\r\r\n pCell -= 4;\r\r\n /* Obscure case for non-leaf-data trees: If the cell at pCell was\r\r\n ** previously stored on a leaf node, and its reported size was 4\r\r\n ** bytes, then it may actually be smaller than this\r\r\n ** (see btreeParseCellPtr(), 4 bytes is the minimum size of\r\r\n ** any cell). But it is important to pass the correct size to\r\r\n ** insertCell(), so reparse the cell now.\r\r\n **\r\r\n ** This can only happen for b-trees used to evaluate \"IN (SELECT ...)\"\r\r\n ** and WITHOUT ROWID tables with exactly one column which is the\r\r\n ** primary key.\r\r\n */\r\r\n if( b.szCell[j]==4 ){\r\r\n assert(leafCorrection==4);\r\r\n sz = pParent->xCellSize(pParent, pCell);\r\r\n }\r\r\n }\r\r\n iOvflSpace += sz;\r\r\n assert( sz<=pBt->maxLocal+23 );\r\r\n assert( iOvflSpace <= (int)pBt->pageSize );\r\r\n insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew->pgno, &rc);\r\r\n if( rc!=SQLITE_OK ) goto balance_cleanup;\r\r\n assert( sqlite3PagerIswriteable(pParent->pDbPage) );\r\r\n }\r\r\n\r\r\n /* Now update the actual sibling pages. The order in which they are updated\r\r\n ** is important, as this code needs to avoid disrupting any page from which\r\r\n ** cells may still to be read. In practice, this means:\r\r\n **\r\r\n ** (1) If cells are moving left (from apNew[iPg] to apNew[iPg-1])\r\r\n ** then it is not safe to update page apNew[iPg] until after\r\r\n ** the left-hand sibling apNew[iPg-1] has been updated.\r\r\n **\r\r\n ** (2) If cells are moving right (from apNew[iPg] to apNew[iPg+1])\r\r\n ** then it is not safe to update page apNew[iPg] until after\r\r\n ** the right-hand sibling apNew[iPg+1] has been updated.\r\r\n **\r\r\n ** If neither of the above apply, the page is safe to update.\r\r\n **\r\r\n ** The iPg value in the following loop starts at nNew-1 goes down\r\r\n ** to 0, then back up to nNew-1 again, thus making two passes over\r\r\n ** the pages. On the initial downward pass, only condition (1) above\r\r\n ** needs to be tested because (2) will always be true from the previous\r\r\n ** step. On the upward pass, both conditions are always true, so the\r\r\n ** upwards pass simply processes pages that were missed on the downward\r\r\n ** pass.\r\r\n */\r\r\n for(i=1-nNew; i<nNew; i++){\r\r\n int iPg = i<0 ? -i : i;\r\r\n assert( iPg>=0 && iPg<nNew );\r\r\n if( abDone[iPg] ) continue; /* Skip pages already processed */\r\r\n if( i>=0 /* On the upwards pass, or... */\r\r\n || cntOld[iPg-1]>=cntNew[iPg-1] /* Condition (1) is true */\r\r\n ){\r\r\n int iNew;\r\r\n int iOld;\r\r\n int nNewCell;\r\r\n\r\r\n /* Verify condition (1): If cells are moving left, update iPg\r\r\n ** only after iPg-1 has already been updated. */\r\r\n assert( iPg==0 || cntOld[iPg-1]>=cntNew[iPg-1] || abDone[iPg-1] );\r\r\n\r\r\n /* Verify condition (2): If cells are moving right, update iPg\r\r\n ** only after iPg+1 has already been updated. */\r\r\n assert( cntNew[iPg]>=cntOld[iPg] || abDone[iPg+1] );\r\r\n\r\r\n if( iPg==0 ){\r\r\n iNew = iOld = 0;\r\r\n nNewCell = cntNew[0];\r\r\n }else{\r\r\n iOld = iPg<nOld ? (cntOld[iPg-1] + !leafData) : b.nCell;\r\r\n iNew = cntNew[iPg-1] + !leafData;\r\r\n nNewCell = cntNew[iPg] - iNew;\r\r\n }\r\r\n\r\r\n rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);\r\r\n if( rc ) goto balance_cleanup;\r\r\n abDone[iPg]++;\r\r\n apNew[iPg]->nFree = usableSpace-szNew[iPg];\r\r\n assert( apNew[iPg]->nOverflow==0 );\r\r\n assert( apNew[iPg]->nCell==nNewCell );\r\r\n }\r\r\n }\r\r\n\r\r\n /* All pages have been processed exactly once */\r\r\n assert( memcmp(abDone, \"\\01\\01\\01\\01\\01\", nNew)==0 );\r\r\n\r\r\n assert( nOld>0 );\r\r\n assert( nNew>0 );\r\r\n\r\r\n if( isRoot && pParent->nCell==0 && pParent->hdrOffset<=apNew[0]->nFree ){\r\r\n /* The root page of the b-tree now contains no cells. The only sibling\r\r\n ** page is the right-child of the parent. Copy the contents of the\r\r\n ** child page into the parent, decreasing the overall height of the\r\r\n ** b-tree structure by one. This is described as the \"balance-shallower\"\r\r\n ** sub-algorithm in some documentation.\r\r\n **\r\r\n ** If this is an auto-vacuum database, the call to copyNodeContent()\r\r\n ** sets all pointer-map entries corresponding to database image pages\r\r\n ** for which the pointer is stored within the content being copied.\r\r\n **\r\r\n ** It is critical that the child page be defragmented before being\r\r\n ** copied into the parent, because if the parent is page 1 then it will\r\r\n ** by smaller than the child due to the database header, and so all the\r\r\n ** free space needs to be up front.\r\r\n */\r\r\n assert( nNew==1 || CORRUPT_DB );\r\r\n rc = defragmentPage(apNew[0], -1);\r\r\n testcase( rc!=SQLITE_OK );\r\r\n assert( apNew[0]->nFree ==\r\r\n (get2byteNotZero(&apNew[0]->aData[5]) - apNew[0]->cellOffset\r\r\n - apNew[0]->nCell*2)\r\r\n || rc!=SQLITE_OK\r\r\n );\r\r\n copyNodeContent(apNew[0], pParent, &rc);\r\r\n freePage(apNew[0], &rc);\r\r\n }else if( ISAUTOVACUUM && !leafCorrection ){\r\r\n /* Fix the pointer map entries associated with the right-child of each\r\r\n ** sibling page. All other pointer map entries have already been taken\r\r\n ** care of. */\r\r\n for(i=0; i<nNew; i++){\r\r\n u32 key = get4byte(&apNew[i]->aData[8]);\r\r\n ptrmapPut(pBt, key, PTRMAP_BTREE, apNew[i]->pgno, &rc);\r\r\n }\r\r\n }\r\r\n\r\r\n assert( pParent->isInit );\r\r\n TRACE((\"BALANCE: finished: old=%d new=%d cells=%d\\n\",\r\r\n nOld, nNew, b.nCell));\r\r\n\r\r\n /* Free any old pages that were not reused as new pages.\r\r\n */\r\r\n for(i=nNew; i<nOld; i++){\r\r\n freePage(apOld[i], &rc);\r\r\n }\r\r\n\r\r\n#if 0\r\r\n if( ISAUTOVACUUM && rc==SQLITE_OK && apNew[0]->isInit ){\r\r\n /* The ptrmapCheckPages() contains assert() statements that verify that\r\r\n ** all pointer map pages are set correctly. This is helpful while\r\r\n ** debugging. This is usually disabled because a corrupt database may\r\r\n ** cause an assert() statement to fail. */\r\r\n ptrmapCheckPages(apNew, nNew);\r\r\n ptrmapCheckPages(&pParent, 1);\r\r\n }\r\r\n#endif\r\r\n\r\r\n /*\r\r\n ** Cleanup before returning.\r\r\n */\r\r\nbalance_cleanup:\r\r\n sqlite3StackFree(0, b.apCell);\r\r\n for(i=0; i<nOld; i++){\r\r\n releasePage(apOld[i]);\r\r\n }\r\r\n for(i=0; i<nNew; i++){\r\r\n releasePage(apNew[i]);\r\r\n }\r\r\n\r\r\n return rc;\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint salzhauer_nitwitted = 0;\r\nint global_variable;\r\nvoid woa_harped(char **compathy_cinemelodrama);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid ellington_electing(void (*subindicating_possesses)(char **));\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_t t0, t1;\r\npthread_mutex_t mutex_0, mutex_1;\r\nint dev_amount = 1;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcDevamount(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int qsize;\r\n \r\n printf(\"Inside calcDevAmount\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n \r\n \r\n dev_amount = Data->data[0] - 'A'; \r\n qsize = Data->qsize;\r\n if (dev_amount < 0) { \r\n dev_amount *= -1; \r\n }\r\n \r\n readFile(Data->file2);\r\n if (dev_amount == 0) { \r\n dev_amount += 1; \r\n }\r\n \r\n \r\n pthread_mutex_unlock(&mutex_0);\r\n return NULL;\r\n}\r\nvoid *devChar(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int i;\r\n int *arr = NULL;\r\n \r\n printf(\"Inside devChar\\n\");\r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n pthread_mutex_lock(&mutex_1);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n \r\n \r\n \r\n for (i = 0; i < strlen(Data->data); i++) { \r\n Data->data[i] /= dev_amount; \r\n }\r\n \r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&salzhauer_nitwitted,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n ellington_electing(woa_harped);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid woa_harped(char **compathy_cinemelodrama)\r\n{\r\n char *analepses_glenellyn;\r\n ++global_variable;;\r\n setup_printf_context();\r\n analepses_glenellyn = getenv(\"UNAPPERCEPTIVE_SHERR\");\r\n if (analepses_glenellyn != 0) {;\r\n *compathy_cinemelodrama = analepses_glenellyn;\r\n }\r\n}\r\n\r\nvoid ellington_electing(void (*subindicating_possesses)(char **))\r\n{\r\n struct data* Data;\r\n char *scrams_unbishop = 0;\r\n char **leavittsburg_miscompute[3] = {0};\r\n int smethwick_haulmier;\r\n char **catholicise_blockholer = 0;\r\n char **ignitive_disorder = 0;\r\n ++global_variable;\r\n char *farmership_rebalanced = 0;\r\n subindicating_possesses(&farmership_rebalanced);\r\n if (farmership_rebalanced != 0) {;\r\n smethwick_haulmier = 1;\r\n catholicise_blockholer = &farmership_rebalanced;\r\n ignitive_disorder = ((char **)(((unsigned long )catholicise_blockholer) * smethwick_haulmier * smethwick_haulmier)) + 5;\r\n leavittsburg_miscompute[0] = ignitive_disorder;\r\n scrams_unbishop = ((char *)( *(leavittsburg_miscompute[0] - 5)));\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(scrams_unbishop) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(scrams_unbishop) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(scrams_unbishop) + 1));\r\n if (Data->data) {\r\n if ((sscanf(scrams_unbishop, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n \r\n \r\n \r\n \r\n \r\n if (strlen(Data->data) > 50) { \r\n \r\n if (pthread_create(&t0, NULL, calcDevamount, Data) != 0) { \r\n printf(\"Error initializing thread 0.\");\r\n }\r\n }\r\n if (pthread_create(&t1, NULL, devChar, Data) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n if (strlen(Data->data) > 50) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n for (i = 0; i < strlen(Data->data); i++) { \n Data->data[i] /= dev_amount; \n }\n```", "cwe": "821"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint melithaemia_openable = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint 191_global_var = 0;\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n FILE * random_data = 0;\r\n char * buff = 0;\r\n unsigned long long num = 0;\r\n unsigned long long i = 0;\r\n char *shiroma_skeed = 0;\r\n int protoblattoidea_conlen;\r\n char **shebang_guttus = 0;\r\n char **swatheable_lespedeza = 0;\r\n char *anchorhold_hartshorne[18] = {0};\r\n char *perioesophageal_antiodont;;\r\n if (__sync_bool_compare_and_swap(&melithaemia_openable,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n perioesophageal_antiodont = getenv(\"CYMLING_UNEVASIVENESS\");\r\n if (perioesophageal_antiodont != 0) {;\r\n anchorhold_hartshorne[6] = perioesophageal_antiodont;\r\n protoblattoidea_conlen = 1;\r\n shebang_guttus = anchorhold_hartshorne;\r\n swatheable_lespedeza = ((char **)(((unsigned long )shebang_guttus) * protoblattoidea_conlen * protoblattoidea_conlen)) + 5;\r\n shiroma_skeed = ((char *)(swatheable_lespedeza - 5)[6]);\r\n \r\n random_data = fopen(\"/dev/urandom\", \"r\");\r\n if(random_data != NULL){\r\n num = strtoull(shiroma_skeed, NULL, 10);\r\n if(num > (unsigned long long) 0 ){\r\n if(num > (unsigned long long) 100 ){\r\n num = (unsigned long long) 100;\r\n }\r\n \r\n \r\n \r\n \r\n \r\n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\r\n for(i = 0; i < num - (unsigned long long) 10; i++){\r\n buff[i] = fgetc(random_data);\r\n }\r\n \r\n \r\n }\r\n printf(\"data is: %s\", buff);\r\n fclose(random_data);\r\n if(buff != NULL){\r\n free(buff);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n for(i = 0; i < num - (unsigned long long) 10; i++){\n buff[i] = fgetc(random_data);\n }\n```", "cwe": "191"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint scriver_canstick = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid glycyl_undeludedly(char *apepsy_preindemnifying);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n void (*bescourge_mids)(char *) = glycyl_undeludedly;\r\n char *assam_gorhen;;\r\n if (__sync_bool_compare_and_swap(&scriver_canstick,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n assam_gorhen = getenv(\"LYCANTHROPOUS_CARBOLXYLOL\");\r\n if (assam_gorhen != 0) {;\r\n bescourge_mids(assam_gorhen);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid glycyl_undeludedly(char *apepsy_preindemnifying)\r\n{\r\n int oc_i = 0;\r\n char buff[64];\r\n char source[1024];\r\n char *octometer_saucemen = 0;\r\n ++global_variable;;\r\n octometer_saucemen = ((char *)apepsy_preindemnifying);\r\n \r\n memset(buff, 65, 64);\r\n buff[63] = '\\0';\r\n memset(source,0,1024);\r\n strncpy(source,octometer_saucemen,sizeof(source));\r\n source[1023] = 0;\r\n if (strlen(source) + 1 <= sizeof(buff)) {\r\n \r\n \r\n \r\n \r\n \r\n \r\n strncpy(buff,source,sizeof(source));\r\n \r\n \r\n }\r\n for (; oc_i < strlen(buff); ++oc_i) {\r\n buff[oc_i] = toupper(buff[oc_i]);\r\n }\r\n printf(\"%s\\n\",buff);\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n \n strncpy(buff,source,sizeof(source));\n```", "cwe": "806"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint clubionidae_chrysidella = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid laft_amphore(int scissible_chromoplasm,char **upset_geniture);\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n int inconstancy_capacious = 7;\r\n int shanna_uses;\r\n char **pleonastic_botocudo = 0;\r\n char **bipyramidal_soothest = 0;\r\n char *hemicyclic_exacerbescence[84] = {0};\r\n char *spunkily_molopo;\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&clubionidae_chrysidella,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n spunkily_molopo = getenv(\"DYSPROSIUM_BIOFOG\");\r\n if (spunkily_molopo != 0) {;\r\n hemicyclic_exacerbescence[6] = spunkily_molopo;\r\n shanna_uses = 1;\r\n pleonastic_botocudo = hemicyclic_exacerbescence;\r\n bipyramidal_soothest = ((char **)(((unsigned long )pleonastic_botocudo) * shanna_uses * shanna_uses)) + 5;\r\n laft_amphore(inconstancy_capacious,bipyramidal_soothest);\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nvoid laft_amphore(int scissible_chromoplasm,char **upset_geniture)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *duramens_counterfleury = 0;\r\n ++global_variable;\r\n scissible_chromoplasm--;\r\n if (scissible_chromoplasm > 0) {\r\n laft_amphore(scissible_chromoplasm,upset_geniture);\r\n return ;\r\n }\r\n duramens_counterfleury = ((char *)(upset_geniture - 5)[6]);\r\n \r\n if (strlen(duramens_counterfleury) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,duramens_counterfleury);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\r\r\n ExceptionInfo *exception)\r\r\n{\r\r\n char\r\r\n page_geometry[MaxTextExtent];\r\r\n\r\r\n Image\r\r\n *image;\r\r\n\r\r\n MagickBooleanType\r\r\n logging;\r\r\n\r\r\n volatile int\r\r\n first_mng_object,\r\r\n object_id,\r\r\n term_chunk_found,\r\r\n skip_to_iend;\r\r\n\r\r\n volatile ssize_t\r\r\n image_count=0;\r\r\n\r\r\n MagickBooleanType\r\r\n status;\r\r\n\r\r\n MagickOffsetType\r\r\n offset;\r\r\n\r\r\n MngBox\r\r\n default_fb,\r\r\n fb,\r\r\n previous_fb;\r\r\n\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n PixelPacket\r\r\n mng_background_color;\r\r\n#endif\r\r\n\r\r\n register unsigned char\r\r\n *p;\r\r\n\r\r\n register ssize_t\r\r\n i;\r\r\n\r\r\n size_t\r\r\n count;\r\r\n\r\r\n ssize_t\r\r\n loop_level;\r\r\n\r\r\n volatile short\r\r\n skipping_loop;\r\r\n\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n unsigned int\r\r\n mandatory_back=0;\r\r\n#endif\r\r\n\r\r\n volatile unsigned int\r\r\n#ifdef MNG_OBJECT_BUFFERS\r\r\n mng_background_object=0,\r\r\n#endif\r\r\n mng_type=0; /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\r\r\n\r\r\n size_t\r\r\n default_frame_timeout,\r\r\n frame_timeout,\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n image_height,\r\r\n image_width,\r\r\n#endif\r\r\n length;\r\r\n\r\r\n /* These delays are all measured in image ticks_per_second,\r\r\n * not in MNG ticks_per_second\r\r\n */\r\r\n volatile size_t\r\r\n default_frame_delay,\r\r\n final_delay,\r\r\n final_image_delay,\r\r\n frame_delay,\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n insert_layers,\r\r\n#endif\r\r\n mng_iterations=1,\r\r\n simplicity=0,\r\r\n subframe_height=0,\r\r\n subframe_width=0;\r\r\n\r\r\n previous_fb.top=0;\r\r\n previous_fb.bottom=0;\r\r\n previous_fb.left=0;\r\r\n previous_fb.right=0;\r\r\n default_fb.top=0;\r\r\n default_fb.bottom=0;\r\r\n default_fb.left=0;\r\r\n default_fb.right=0;\r\r\n\r\r\n logging=LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Enter ReadOneMNGImage()\");\r\r\n\r\r\n image=mng_info->image;\r\r\n\r\r\n if (LocaleCompare(image_info->magick,\"MNG\") == 0)\r\r\n {\r\r\n char\r\r\n magic_number[MaxTextExtent];\r\r\n\r\r\n /* Verify MNG signature. */\r\r\n count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\r\r\n if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\r\r\n ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\r\r\n\r\r\n /* Initialize some nonzero members of the MngInfo structure. */\r\r\n for (i=0; i < MNG_MAX_OBJECTS; i++)\r\r\n {\r\r\n mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\r\r\n mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\r\r\n }\r\r\n mng_info->exists[0]=MagickTrue;\r\r\n }\r\r\n\r\r\n skipping_loop=(-1);\r\r\n first_mng_object=MagickTrue;\r\r\n mng_type=0;\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n insert_layers=MagickFalse; /* should be False when converting or mogrifying */\r\r\n#endif\r\r\n default_frame_delay=0;\r\r\n default_frame_timeout=0;\r\r\n frame_delay=0;\r\r\n final_delay=1;\r\r\n mng_info->ticks_per_second=1UL*image->ticks_per_second;\r\r\n object_id=0;\r\r\n skip_to_iend=MagickFalse;\r\r\n term_chunk_found=MagickFalse;\r\r\n mng_info->framing_mode=1;\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n mandatory_back=MagickFalse;\r\r\n#endif\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n mng_background_color=image->background_color;\r\r\n#endif\r\r\n default_fb=mng_info->frame;\r\r\n previous_fb=mng_info->frame;\r\r\n do\r\r\n {\r\r\n char\r\r\n type[MaxTextExtent];\r\r\n\r\r\n if (LocaleCompare(image_info->magick,\"MNG\") == 0)\r\r\n {\r\r\n unsigned char\r\r\n *chunk;\r\r\n\r\r\n /*\r\r\n Read a new chunk.\r\r\n */\r\r\n type[0]='\\0';\r\r\n (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\r\r\n length=ReadBlobMSBLong(image);\r\r\n count=(size_t) ReadBlob(image,4,(unsigned char *) type);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Reading MNG chunk type %c%c%c%c, length: %.20g\",\r\r\n type[0],type[1],type[2],type[3],(double) length);\r\r\n\r\r\n if (length > PNG_UINT_31_MAX)\r\r\n {\r\r\n status=MagickFalse;\r\r\n break;\r\r\n }\r\r\n\r\r\n if (count == 0)\r\r\n ThrowReaderException(CorruptImageError,\"CorruptImage\");\r\r\n\r\r\n p=NULL;\r\r\n chunk=(unsigned char *) NULL;\r\r\n\r\r\n if (length != 0)\r\r\n {\r\r\n chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\r\r\n\r\r\n if (chunk == (unsigned char *) NULL)\r\r\n ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n\r\r\n for (i=0; i < (ssize_t) length; i++)\r\r\n {\r\r\n int\r\r\n c;\r\r\n\r\r\n c=ReadBlobByte(image);\r\r\n if (c == EOF)\r\r\n break;\r\r\n chunk[i]=(unsigned char) c;\r\r\n }\r\r\n\r\r\n p=chunk;\r\r\n }\r\r\n\r\r\n (void) ReadBlobMSBLong(image); /* read crc word */\r\r\n\r\r\n#if !defined(JNG_SUPPORTED)\r\r\n if (memcmp(type,mng_JHDR,4) == 0)\r\r\n {\r\r\n skip_to_iend=MagickTrue;\r\r\n\r\r\n if (mng_info->jhdr_warning == 0)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\r\r\n\r\r\n mng_info->jhdr_warning++;\r\r\n }\r\r\n#endif\r\r\n if (memcmp(type,mng_DHDR,4) == 0)\r\r\n {\r\r\n skip_to_iend=MagickTrue;\r\r\n\r\r\n if (mng_info->dhdr_warning == 0)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\r\r\n\r\r\n mng_info->dhdr_warning++;\r\r\n }\r\r\n if (memcmp(type,mng_MEND,4) == 0)\r\r\n break;\r\r\n\r\r\n if (skip_to_iend)\r\r\n {\r\r\n if (memcmp(type,mng_IEND,4) == 0)\r\r\n skip_to_iend=MagickFalse;\r\r\n\r\r\n if (length != 0)\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Skip to IEND.\");\r\r\n\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_MHDR,4) == 0)\r\r\n {\r\r\n if (length != 28)\r\r\n {\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n ThrowReaderException(CorruptImageError,\"CorruptImage\");\r\r\n }\r\r\n\r\r\n mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\r\r\n (p[2] << 8) | p[3]);\r\r\n\r\r\n mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\r\r\n (p[6] << 8) | p[7]);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" MNG width: %.20g\",(double) mng_info->mng_width);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" MNG height: %.20g\",(double) mng_info->mng_height);\r\r\n }\r\r\n\r\r\n p+=8;\r\r\n mng_info->ticks_per_second=(size_t) mng_get_long(p);\r\r\n\r\r\n if (mng_info->ticks_per_second == 0)\r\r\n default_frame_delay=0;\r\r\n\r\r\n else\r\r\n default_frame_delay=1UL*image->ticks_per_second/\r\r\n mng_info->ticks_per_second;\r\r\n\r\r\n frame_delay=default_frame_delay;\r\r\n simplicity=0;\r\r\n\r\r\n /* Skip nominal layer count, frame count, and play time */\r\r\n p+=16;\r\r\n simplicity=(size_t) mng_get_long(p);\r\r\n\r\r\n mng_type=1; /* Full MNG */\r\r\n\r\r\n if ((simplicity != 0) && ((simplicity | 11) == 11))\r\r\n mng_type=2; /* LC */\r\r\n\r\r\n if ((simplicity != 0) && ((simplicity | 9) == 9))\r\r\n mng_type=3; /* VLC */\r\r\n\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n if (mng_type != 3)\r\r\n insert_layers=MagickTrue;\r\r\n#endif\r\r\n if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\r\r\n {\r\r\n /* Allocate next image structure. */\r\r\n AcquireNextImage(image_info,image);\r\r\n\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n return(DestroyImageList(image));\r\r\n\r\r\n image=SyncNextImageInList(image);\r\r\n mng_info->image=image;\r\r\n }\r\r\n\r\r\n if ((mng_info->mng_width > 65535L) ||\r\r\n (mng_info->mng_height > 65535L))\r\r\n {\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\r\r\n }\r\r\n\r\r\n (void) FormatLocaleString(page_geometry,MaxTextExtent,\r\r\n \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\r\r\n mng_info->mng_height);\r\r\n\r\r\n mng_info->frame.left=0;\r\r\n mng_info->frame.right=(ssize_t) mng_info->mng_width;\r\r\n mng_info->frame.top=0;\r\r\n mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\r\r\n mng_info->clip=default_fb=previous_fb=mng_info->frame;\r\r\n\r\r\n for (i=0; i < MNG_MAX_OBJECTS; i++)\r\r\n mng_info->object_clip[i]=mng_info->frame;\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_TERM,4) == 0)\r\r\n {\r\r\n int\r\r\n repeat=0;\r\r\n\r\r\n if (length != 0)\r\r\n repeat=p[0];\r\r\n\r\r\n if (repeat == 3 && length > 8)\r\r\n {\r\r\n final_delay=(png_uint_32) mng_get_long(&p[2]);\r\r\n mng_iterations=(png_uint_32) mng_get_long(&p[6]);\r\r\n\r\r\n if (mng_iterations == PNG_UINT_31_MAX)\r\r\n mng_iterations=0;\r\r\n\r\r\n image->iterations=mng_iterations;\r\r\n term_chunk_found=MagickTrue;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" repeat=%d, final_delay=%.20g, iterations=%.20g\",\r\r\n repeat,(double) final_delay, (double) image->iterations);\r\r\n }\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n if (memcmp(type,mng_DEFI,4) == 0)\r\r\n {\r\r\n if (mng_type == 3)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\r\r\n image->filename);\r\r\n\r\r\n if (length > 1)\r\r\n {\r\r\n object_id=(p[0] << 8) | p[1];\r\r\n\r\r\n if (mng_type == 2 && object_id != 0)\r\r\n (void) ThrowMagickException(&image->exception,\r\r\n GetMagickModule(),\r\r\n CoderError,\"Nonzero object_id in MNG-LC datastream\",\r\r\n \"`%s'\", image->filename);\r\r\n\r\r\n if (object_id > MNG_MAX_OBJECTS)\r\r\n {\r\r\n /*\r\r\n Instead of using a warning we should allocate a larger\r\r\n MngInfo structure and continue.\r\r\n */\r\r\n (void) ThrowMagickException(&image->exception,\r\r\n GetMagickModule(), CoderError,\r\r\n \"object id too large\",\"`%s'\",image->filename);\r\r\n object_id=MNG_MAX_OBJECTS;\r\r\n }\r\r\n\r\r\n if (mng_info->exists[object_id])\r\r\n if (mng_info->frozen[object_id])\r\r\n {\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n (void) ThrowMagickException(&image->exception,\r\r\n GetMagickModule(),CoderError,\r\r\n \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\r\r\n image->filename);\r\r\n continue;\r\r\n }\r\r\n\r\r\n mng_info->exists[object_id]=MagickTrue;\r\r\n\r\r\n if (length > 2)\r\r\n mng_info->invisible[object_id]=p[2];\r\r\n\r\r\n /*\r\r\n Extract object offset info.\r\r\n */\r\r\n if (length > 11)\r\r\n {\r\r\n mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\r\r\n (p[5] << 16) | (p[6] << 8) | p[7]);\r\r\n\r\r\n mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\r\r\n (p[9] << 16) | (p[10] << 8) | p[11]);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" x_off[%d]: %.20g, y_off[%d]: %.20g\",\r\r\n object_id,(double) mng_info->x_off[object_id],\r\r\n object_id,(double) mng_info->y_off[object_id]);\r\r\n }\r\r\n }\r\r\n\r\r\n /*\r\r\n Extract object clipping info.\r\r\n */\r\r\n \r\r\n if (length > 27)\r\r\n mng_info->object_clip[object_id]=\r\r\n mng_read_box(mng_info->frame,0, &p[12]);\r\r\n }\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n if (memcmp(type,mng_bKGD,4) == 0)\r\r\n {\r\r\n mng_info->have_global_bkgd=MagickFalse;\r\r\n\r\r\n if (length > 5)\r\r\n {\r\r\n mng_info->mng_global_bkgd.red=\r\r\n ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\r\r\n\r\r\n mng_info->mng_global_bkgd.green=\r\r\n ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\r\r\n\r\r\n mng_info->mng_global_bkgd.blue=\r\r\n ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\r\r\n\r\r\n mng_info->have_global_bkgd=MagickTrue;\r\r\n }\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n if (memcmp(type,mng_BACK,4) == 0)\r\r\n {\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n if (length > 6)\r\r\n mandatory_back=p[6];\r\r\n\r\r\n else\r\r\n mandatory_back=0;\r\r\n\r\r\n if (mandatory_back && length > 5)\r\r\n {\r\r\n mng_background_color.red=\r\r\n ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\r\r\n\r\r\n mng_background_color.green=\r\r\n ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\r\r\n\r\r\n mng_background_color.blue=\r\r\n ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\r\r\n\r\r\n mng_background_color.opacity=OpaqueOpacity;\r\r\n }\r\r\n\r\r\n#ifdef MNG_OBJECT_BUFFERS\r\r\n if (length > 8)\r\r\n mng_background_object=(p[7] << 8) | p[8];\r\r\n#endif\r\r\n#endif\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_PLTE,4) == 0)\r\r\n {\r\r\n /* Read global PLTE. */\r\r\n\r\r\n if (length && (length < 769))\r\r\n {\r\r\n if (mng_info->global_plte == (png_colorp) NULL)\r\r\n mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\r\r\n sizeof(*mng_info->global_plte));\r\r\n\r\r\n for (i=0; i < (ssize_t) (length/3); i++)\r\r\n {\r\r\n mng_info->global_plte[i].red=p[3*i];\r\r\n mng_info->global_plte[i].green=p[3*i+1];\r\r\n mng_info->global_plte[i].blue=p[3*i+2];\r\r\n }\r\r\n\r\r\n mng_info->global_plte_length=(unsigned int) (length/3);\r\r\n }\r\r\n#ifdef MNG_LOOSE\r\r\n for ( ; i < 256; i++)\r\r\n {\r\r\n mng_info->global_plte[i].red=i;\r\r\n mng_info->global_plte[i].green=i;\r\r\n mng_info->global_plte[i].blue=i;\r\r\n }\r\r\n\r\r\n if (length != 0)\r\r\n mng_info->global_plte_length=256;\r\r\n#endif\r\r\n else\r\r\n mng_info->global_plte_length=0;\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_tRNS,4) == 0)\r\r\n {\r\r\n /* read global tRNS */\r\r\n\r\r\n if (length > 0 && length < 257)\r\r\n for (i=0; i < (ssize_t) length; i++)\r\r\n mng_info->global_trns[i]=p[i];\r\r\n\r\r\n#ifdef MNG_LOOSE\r\r\n for ( ; i < 256; i++)\r\r\n mng_info->global_trns[i]=255;\r\r\n#endif\r\r\n mng_info->global_trns_length=(unsigned int) length;\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n if (memcmp(type,mng_gAMA,4) == 0)\r\r\n {\r\r\n if (length == 4)\r\r\n {\r\r\n ssize_t\r\r\n igamma;\r\r\n\r\r\n igamma=mng_get_long(p);\r\r\n mng_info->global_gamma=((float) igamma)*0.00001;\r\r\n mng_info->have_global_gama=MagickTrue;\r\r\n }\r\r\n\r\r\n else\r\r\n mng_info->have_global_gama=MagickFalse;\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_cHRM,4) == 0)\r\r\n {\r\r\n /* Read global cHRM */\r\r\n\r\r\n if (length == 32)\r\r\n {\r\r\n mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\r\r\n mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\r\r\n mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\r\r\n mng_info->global_chrm.red_primary.y=0.00001*\r\r\n mng_get_long(&p[12]);\r\r\n mng_info->global_chrm.green_primary.x=0.00001*\r\r\n mng_get_long(&p[16]);\r\r\n mng_info->global_chrm.green_primary.y=0.00001*\r\r\n mng_get_long(&p[20]);\r\r\n mng_info->global_chrm.blue_primary.x=0.00001*\r\r\n mng_get_long(&p[24]);\r\r\n mng_info->global_chrm.blue_primary.y=0.00001*\r\r\n mng_get_long(&p[28]);\r\r\n mng_info->have_global_chrm=MagickTrue;\r\r\n }\r\r\n else\r\r\n mng_info->have_global_chrm=MagickFalse;\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_sRGB,4) == 0)\r\r\n {\r\r\n /*\r\r\n Read global sRGB.\r\r\n */\r\r\n if (length != 0)\r\r\n {\r\r\n mng_info->global_srgb_intent=\r\r\n Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\r\r\n mng_info->have_global_srgb=MagickTrue;\r\r\n }\r\r\n else\r\r\n mng_info->have_global_srgb=MagickFalse;\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_iCCP,4) == 0)\r\r\n {\r\r\n /* To do: */\r\r\n\r\r\n /*\r\r\n Read global iCCP.\r\r\n */\r\r\n if (length != 0)\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_FRAM,4) == 0)\r\r\n {\r\r\n if (mng_type == 3)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\r\r\n image->filename);\r\r\n\r\r\n if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\r\r\n image->delay=frame_delay;\r\r\n\r\r\n frame_delay=default_frame_delay;\r\r\n frame_timeout=default_frame_timeout;\r\r\n fb=default_fb;\r\r\n\r\r\n if (length > 0)\r\r\n if (p[0])\r\r\n mng_info->framing_mode=p[0];\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Framing_mode=%d\",mng_info->framing_mode);\r\r\n\r\r\n if (length > 6)\r\r\n {\r\r\n /* Note the delay and frame clipping boundaries. */\r\r\n\r\r\n p++; /* framing mode */\r\r\n\r\r\n while (*p && ((p-chunk) < (ssize_t) length))\r\r\n p++; /* frame name */\r\r\n\r\r\n p++; /* frame name terminator */\r\r\n\r\r\n if ((p-chunk) < (ssize_t) (length-4))\r\r\n {\r\r\n int\r\r\n change_delay,\r\r\n change_timeout,\r\r\n change_clipping;\r\r\n\r\r\n change_delay=(*p++);\r\r\n change_timeout=(*p++);\r\r\n change_clipping=(*p++);\r\r\n p++; /* change_sync */\r\r\n\r\r\n if (change_delay && (p-chunk) < (ssize_t) (length-4))\r\r\n {\r\r\n frame_delay=1UL*image->ticks_per_second*\r\r\n mng_get_long(p);\r\r\n\r\r\n if (mng_info->ticks_per_second != 0)\r\r\n frame_delay/=mng_info->ticks_per_second;\r\r\n\r\r\n else\r\r\n frame_delay=PNG_UINT_31_MAX;\r\r\n\r\r\n if (change_delay == 2)\r\r\n default_frame_delay=frame_delay;\r\r\n\r\r\n p+=4;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Framing_delay=%.20g\",(double) frame_delay);\r\r\n }\r\r\n\r\r\n if (change_timeout && (p-chunk) < (ssize_t) (length-4))\r\r\n {\r\r\n frame_timeout=1UL*image->ticks_per_second*\r\r\n mng_get_long(p);\r\r\n\r\r\n if (mng_info->ticks_per_second != 0)\r\r\n frame_timeout/=mng_info->ticks_per_second;\r\r\n\r\r\n else\r\r\n frame_timeout=PNG_UINT_31_MAX;\r\r\n\r\r\n if (change_timeout == 2)\r\r\n default_frame_timeout=frame_timeout;\r\r\n\r\r\n p+=4;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Framing_timeout=%.20g\",(double) frame_timeout);\r\r\n }\r\r\n\r\r\n if (change_clipping && (p-chunk) < (ssize_t) (length-17))\r\r\n {\r\r\n fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\r\r\n p+=17;\r\r\n previous_fb=fb;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\r\r\n (double) fb.left,(double) fb.right,(double) fb.top,\r\r\n (double) fb.bottom);\r\r\n\r\r\n if (change_clipping == 2)\r\r\n default_fb=fb;\r\r\n }\r\r\n }\r\r\n }\r\r\n mng_info->clip=fb;\r\r\n mng_info->clip=mng_minimum_box(fb,mng_info->frame);\r\r\n\r\r\n subframe_width=(size_t) (mng_info->clip.right\r\r\n -mng_info->clip.left);\r\r\n\r\r\n subframe_height=(size_t) (mng_info->clip.bottom\r\r\n -mng_info->clip.top);\r\r\n /*\r\r\n Insert a background layer behind the frame if framing_mode is 4.\r\r\n */\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" subframe_width=%.20g, subframe_height=%.20g\",(double)\r\r\n subframe_width,(double) subframe_height);\r\r\n\r\r\n if (insert_layers && (mng_info->framing_mode == 4) &&\r\r\n (subframe_width) && (subframe_height))\r\r\n {\r\r\n /* Allocate next image structure. */\r\r\n if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\r\r\n {\r\r\n AcquireNextImage(image_info,image);\r\r\n\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n return(DestroyImageList(image));\r\r\n\r\r\n image=SyncNextImageInList(image);\r\r\n }\r\r\n\r\r\n mng_info->image=image;\r\r\n\r\r\n if (term_chunk_found)\r\r\n {\r\r\n image->start_loop=MagickTrue;\r\r\n image->iterations=mng_iterations;\r\r\n term_chunk_found=MagickFalse;\r\r\n }\r\r\n\r\r\n else\r\r\n image->start_loop=MagickFalse;\r\r\n\r\r\n image->columns=subframe_width;\r\r\n image->rows=subframe_height;\r\r\n image->page.width=subframe_width;\r\r\n image->page.height=subframe_height;\r\r\n image->page.x=mng_info->clip.left;\r\r\n image->page.y=mng_info->clip.top;\r\r\n image->background_color=mng_background_color;\r\r\n image->matte=MagickFalse;\r\r\n image->delay=0;\r\r\n (void) SetImageBackgroundColor(image);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\r\r\n (double) mng_info->clip.left,(double) mng_info->clip.right,\r\r\n (double) mng_info->clip.top,(double) mng_info->clip.bottom);\r\r\n }\r\r\n#endif\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n if (memcmp(type,mng_CLIP,4) == 0)\r\r\n {\r\r\n unsigned int\r\r\n first_object,\r\r\n last_object;\r\r\n\r\r\n /*\r\r\n Read CLIP.\r\r\n */\r\r\n if (length > 3)\r\r\n {\r\r\n first_object=(p[0] << 8) | p[1];\r\r\n last_object=(p[2] << 8) | p[3];\r\r\n p+=4;\r\r\n\r\r\n for (i=(int) first_object; i <= (int) last_object; i++)\r\r\n {\r\r\n if (mng_info->exists[i] && !mng_info->frozen[i])\r\r\n {\r\r\n MngBox\r\r\n box;\r\r\n\r\r\n box=mng_info->object_clip[i];\r\r\n if ((p-chunk) < (ssize_t) (length-17))\r\r\n mng_info->object_clip[i]=\r\r\n mng_read_box(box,(char) p[0],&p[1]);\r\r\n }\r\r\n }\r\r\n\r\r\n }\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n if (memcmp(type,mng_SAVE,4) == 0)\r\r\n {\r\r\n for (i=1; i < MNG_MAX_OBJECTS; i++)\r\r\n if (mng_info->exists[i])\r\r\n {\r\r\n mng_info->frozen[i]=MagickTrue;\r\r\n#ifdef MNG_OBJECT_BUFFERS\r\r\n if (mng_info->ob[i] != (MngBuffer *) NULL)\r\r\n mng_info->ob[i]->frozen=MagickTrue;\r\r\n#endif\r\r\n }\r\r\n\r\r\n if (length != 0)\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n\r\r\n continue;\r\r\n }\r\r\n\r\r\n if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\r\r\n {\r\r\n /* Read DISC or SEEK. */\r\r\n\r\r\n if ((length == 0) || !memcmp(type,mng_SEEK,4))\r\r\n {\r\r\n for (i=1; i < MNG_MAX_OBJECTS; i++)\r\r\n MngInfoDiscardObject(mng_info,i);\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n register ssize_t\r\r\n j;\r\r\n\r\r\n for (j=1; j < (ssize_t) length; j+=2)\r\r\n {\r\r\n i=p[j-1] << 8 | p[j];\r\r\n MngInfoDiscardObject(mng_info,i);\r\r\n }\r\r\n }\r\r\n\r\r\n if (length != 0)\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_MOVE,4) == 0)\r\r\n {\r\r\n size_t\r\r\n first_object,\r\r\n last_object;\r\r\n\r\r\n /* read MOVE */\r\r\n\r\r\n if (length > 3)\r\r\n {\r\r\n first_object=(p[0] << 8) | p[1];\r\r\n last_object=(p[2] << 8) | p[3];\r\r\n p+=4;\r\r\n\r\r\n for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\r\r\n {\r\r\n if (mng_info->exists[i] && !mng_info->frozen[i] &&\r\r\n (p-chunk) < (ssize_t) (length-8))\r\r\n {\r\r\n MngPair\r\r\n new_pair;\r\r\n\r\r\n MngPair\r\r\n old_pair;\r\r\n\r\r\n old_pair.a=mng_info->x_off[i];\r\r\n old_pair.b=mng_info->y_off[i];\r\r\n new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\r\r\n mng_info->x_off[i]=new_pair.a;\r\r\n mng_info->y_off[i]=new_pair.b;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_LOOP,4) == 0)\r\r\n {\r\r\n ssize_t loop_iters=1;\r\r\n if (length > 4)\r\r\n {\r\r\n loop_level=chunk[0];\r\r\n mng_info->loop_active[loop_level]=1; /* mark loop active */\r\r\n\r\r\n /* Record starting point. */\r\r\n loop_iters=mng_get_long(&chunk[1]);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" LOOP level %.20g has %.20g iterations \",\r\r\n (double) loop_level, (double) loop_iters);\r\r\n\r\r\n if (loop_iters == 0)\r\r\n skipping_loop=loop_level;\r\r\n\r\r\n else\r\r\n {\r\r\n mng_info->loop_jump[loop_level]=TellBlob(image);\r\r\n mng_info->loop_count[loop_level]=loop_iters;\r\r\n }\r\r\n\r\r\n mng_info->loop_iteration[loop_level]=0;\r\r\n }\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_ENDL,4) == 0)\r\r\n {\r\r\n if (length > 0)\r\r\n {\r\r\n loop_level=chunk[0];\r\r\n\r\r\n if (skipping_loop > 0)\r\r\n {\r\r\n if (skipping_loop == loop_level)\r\r\n {\r\r\n /*\r\r\n Found end of zero-iteration loop.\r\r\n */\r\r\n skipping_loop=(-1);\r\r\n mng_info->loop_active[loop_level]=0;\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n if (mng_info->loop_active[loop_level] == 1)\r\r\n {\r\r\n mng_info->loop_count[loop_level]--;\r\r\n mng_info->loop_iteration[loop_level]++;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" ENDL: LOOP level %.20g has %.20g remaining iters \",\r\r\n (double) loop_level,(double)\r\r\n mng_info->loop_count[loop_level]);\r\r\n\r\r\n if (mng_info->loop_count[loop_level] != 0)\r\r\n {\r\r\n offset=SeekBlob(image,\r\r\n mng_info->loop_jump[loop_level], SEEK_SET);\r\r\n\r\r\n if (offset < 0)\r\r\n {\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(\r\r\n chunk);\r\r\n ThrowReaderException(CorruptImageError,\r\r\n \"ImproperImageHeader\");\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n short\r\r\n last_level;\r\r\n\r\r\n /*\r\r\n Finished loop.\r\r\n */\r\r\n mng_info->loop_active[loop_level]=0;\r\r\n last_level=(-1);\r\r\n for (i=0; i < loop_level; i++)\r\r\n if (mng_info->loop_active[i] == 1)\r\r\n last_level=(short) i;\r\r\n loop_level=last_level;\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_CLON,4) == 0)\r\r\n {\r\r\n if (mng_info->clon_warning == 0)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"CLON is not implemented yet\",\"`%s'\",\r\r\n image->filename);\r\r\n\r\r\n mng_info->clon_warning++;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_MAGN,4) == 0)\r\r\n {\r\r\n png_uint_16\r\r\n magn_first,\r\r\n magn_last,\r\r\n magn_mb,\r\r\n magn_ml,\r\r\n magn_mr,\r\r\n magn_mt,\r\r\n magn_mx,\r\r\n magn_my,\r\r\n magn_methx,\r\r\n magn_methy;\r\r\n\r\r\n if (length > 1)\r\r\n magn_first=(p[0] << 8) | p[1];\r\r\n\r\r\n else\r\r\n magn_first=0;\r\r\n\r\r\n if (length > 3)\r\r\n magn_last=(p[2] << 8) | p[3];\r\r\n\r\r\n else\r\r\n magn_last=magn_first;\r\r\n#ifndef MNG_OBJECT_BUFFERS\r\r\n if (magn_first || magn_last)\r\r\n if (mng_info->magn_warning == 0)\r\r\n {\r\r\n (void) ThrowMagickException(&image->exception,\r\r\n GetMagickModule(),CoderError,\r\r\n \"MAGN is not implemented yet for nonzero objects\",\r\r\n \"`%s'\",image->filename);\r\r\n\r\r\n mng_info->magn_warning++;\r\r\n }\r\r\n#endif\r\r\n if (length > 4)\r\r\n magn_methx=p[4];\r\r\n\r\r\n else\r\r\n magn_methx=0;\r\r\n\r\r\n if (length > 6)\r\r\n magn_mx=(p[5] << 8) | p[6];\r\r\n\r\r\n else\r\r\n magn_mx=1;\r\r\n\r\r\n if (magn_mx == 0)\r\r\n magn_mx=1;\r\r\n\r\r\n if (length > 8)\r\r\n magn_my=(p[7] << 8) | p[8];\r\r\n\r\r\n else\r\r\n magn_my=magn_mx;\r\r\n\r\r\n if (magn_my == 0)\r\r\n magn_my=1;\r\r\n\r\r\n if (length > 10)\r\r\n magn_ml=(p[9] << 8) | p[10];\r\r\n\r\r\n else\r\r\n magn_ml=magn_mx;\r\r\n\r\r\n if (magn_ml == 0)\r\r\n magn_ml=1;\r\r\n\r\r\n if (length > 12)\r\r\n magn_mr=(p[11] << 8) | p[12];\r\r\n\r\r\n else\r\r\n magn_mr=magn_mx;\r\r\n\r\r\n if (magn_mr == 0)\r\r\n magn_mr=1;\r\r\n\r\r\n if (length > 14)\r\r\n magn_mt=(p[13] << 8) | p[14];\r\r\n\r\r\n else\r\r\n magn_mt=magn_my;\r\r\n\r\r\n if (magn_mt == 0)\r\r\n magn_mt=1;\r\r\n\r\r\n if (length > 16)\r\r\n magn_mb=(p[15] << 8) | p[16];\r\r\n\r\r\n else\r\r\n magn_mb=magn_my;\r\r\n\r\r\n if (magn_mb == 0)\r\r\n magn_mb=1;\r\r\n\r\r\n if (length > 17)\r\r\n magn_methy=p[17];\r\r\n\r\r\n else\r\r\n magn_methy=magn_methx;\r\r\n\r\r\n\r\r\n if (magn_methx > 5 || magn_methy > 5)\r\r\n if (mng_info->magn_warning == 0)\r\r\n {\r\r\n (void) ThrowMagickException(&image->exception,\r\r\n GetMagickModule(),CoderError,\r\r\n \"Unknown MAGN method in MNG datastream\",\"`%s'\",\r\r\n image->filename);\r\r\n\r\r\n mng_info->magn_warning++;\r\r\n }\r\r\n#ifdef MNG_OBJECT_BUFFERS\r\r\n /* Magnify existing objects in the range magn_first to magn_last */\r\r\n#endif\r\r\n if (magn_first == 0 || magn_last == 0)\r\r\n {\r\r\n /* Save the magnification factors for object 0 */\r\r\n mng_info->magn_mb=magn_mb;\r\r\n mng_info->magn_ml=magn_ml;\r\r\n mng_info->magn_mr=magn_mr;\r\r\n mng_info->magn_mt=magn_mt;\r\r\n mng_info->magn_mx=magn_mx;\r\r\n mng_info->magn_my=magn_my;\r\r\n mng_info->magn_methx=magn_methx;\r\r\n mng_info->magn_methy=magn_methy;\r\r\n }\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_PAST,4) == 0)\r\r\n {\r\r\n if (mng_info->past_warning == 0)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"PAST is not implemented yet\",\"`%s'\",\r\r\n image->filename);\r\r\n\r\r\n mng_info->past_warning++;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_SHOW,4) == 0)\r\r\n {\r\r\n if (mng_info->show_warning == 0)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"SHOW is not implemented yet\",\"`%s'\",\r\r\n image->filename);\r\r\n\r\r\n mng_info->show_warning++;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_sBIT,4) == 0)\r\r\n {\r\r\n if (length < 4)\r\r\n mng_info->have_global_sbit=MagickFalse;\r\r\n\r\r\n else\r\r\n {\r\r\n mng_info->global_sbit.gray=p[0];\r\r\n mng_info->global_sbit.red=p[0];\r\r\n mng_info->global_sbit.green=p[1];\r\r\n mng_info->global_sbit.blue=p[2];\r\r\n mng_info->global_sbit.alpha=p[3];\r\r\n mng_info->have_global_sbit=MagickTrue;\r\r\n }\r\r\n }\r\r\n if (memcmp(type,mng_pHYs,4) == 0)\r\r\n {\r\r\n if (length > 8)\r\r\n {\r\r\n mng_info->global_x_pixels_per_unit=\r\r\n (size_t) mng_get_long(p);\r\r\n mng_info->global_y_pixels_per_unit=\r\r\n (size_t) mng_get_long(&p[4]);\r\r\n mng_info->global_phys_unit_type=p[8];\r\r\n mng_info->have_global_phys=MagickTrue;\r\r\n }\r\r\n\r\r\n else\r\r\n mng_info->have_global_phys=MagickFalse;\r\r\n }\r\r\n if (memcmp(type,mng_pHYg,4) == 0)\r\r\n {\r\r\n if (mng_info->phyg_warning == 0)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\r\r\n\r\r\n mng_info->phyg_warning++;\r\r\n }\r\r\n if (memcmp(type,mng_BASI,4) == 0)\r\r\n {\r\r\n skip_to_iend=MagickTrue;\r\r\n\r\r\n if (mng_info->basi_warning == 0)\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"BASI is not implemented yet\",\"`%s'\",\r\r\n image->filename);\r\r\n\r\r\n mng_info->basi_warning++;\r\r\n#ifdef MNG_BASI_SUPPORTED\r\r\n if (length > 11)\r\r\n {\r\r\n basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\r\r\n (p[2] << 8) | p[3]);\r\r\n basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\r\r\n (p[6] << 8) | p[7]);\r\r\n basi_color_type=p[8];\r\r\n basi_compression_method=p[9];\r\r\n basi_filter_type=p[10];\r\r\n basi_interlace_method=p[11];\r\r\n }\r\r\n if (length > 13)\r\r\n basi_red=(p[12] << 8) & p[13];\r\r\n\r\r\n else\r\r\n basi_red=0;\r\r\n\r\r\n if (length > 15)\r\r\n basi_green=(p[14] << 8) & p[15];\r\r\n\r\r\n else\r\r\n basi_green=0;\r\r\n\r\r\n if (length > 17)\r\r\n basi_blue=(p[16] << 8) & p[17];\r\r\n\r\r\n else\r\r\n basi_blue=0;\r\r\n\r\r\n if (length > 19)\r\r\n basi_alpha=(p[18] << 8) & p[19];\r\r\n\r\r\n else\r\r\n {\r\r\n if (basi_sample_depth == 16)\r\r\n basi_alpha=65535L;\r\r\n else\r\r\n basi_alpha=255;\r\r\n }\r\r\n\r\r\n if (length > 20)\r\r\n basi_viewable=p[20];\r\r\n\r\r\n else\r\r\n basi_viewable=0;\r\r\n\r\r\n#endif\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (memcmp(type,mng_IHDR,4)\r\r\n#if defined(JNG_SUPPORTED)\r\r\n && memcmp(type,mng_JHDR,4)\r\r\n#endif\r\r\n )\r\r\n {\r\r\n /* Not an IHDR or JHDR chunk */\r\r\n if (length != 0)\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n\r\r\n continue;\r\r\n }\r\r\n/* Process IHDR */\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\r\r\n\r\r\n mng_info->exists[object_id]=MagickTrue;\r\r\n mng_info->viewable[object_id]=MagickTrue;\r\r\n\r\r\n if (mng_info->invisible[object_id])\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Skipping invisible object\");\r\r\n\r\r\n skip_to_iend=MagickTrue;\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n continue;\r\r\n }\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n if (length < 8)\r\r\n {\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\r\r\n }\r\r\n\r\r\n image_width=(size_t) mng_get_long(p);\r\r\n image_height=(size_t) mng_get_long(&p[4]);\r\r\n#endif\r\r\n chunk=(unsigned char *) RelinquishMagickMemory(chunk);\r\r\n\r\r\n /*\r\r\n Insert a transparent background layer behind the entire animation\r\r\n if it is not full screen.\r\r\n */\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n if (insert_layers && mng_type && first_mng_object)\r\r\n {\r\r\n if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\r\r\n (image_width < mng_info->mng_width) ||\r\r\n (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\r\r\n (image_height < mng_info->mng_height) ||\r\r\n (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\r\r\n {\r\r\n if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\r\r\n {\r\r\n /*\r\r\n Allocate next image structure.\r\r\n */\r\r\n AcquireNextImage(image_info,image);\r\r\n\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n return(DestroyImageList(image));\r\r\n\r\r\n image=SyncNextImageInList(image);\r\r\n }\r\r\n mng_info->image=image;\r\r\n\r\r\n if (term_chunk_found)\r\r\n {\r\r\n image->start_loop=MagickTrue;\r\r\n image->iterations=mng_iterations;\r\r\n term_chunk_found=MagickFalse;\r\r\n }\r\r\n\r\r\n else\r\r\n image->start_loop=MagickFalse;\r\r\n\r\r\n /* Make a background rectangle. */\r\r\n\r\r\n image->delay=0;\r\r\n image->columns=mng_info->mng_width;\r\r\n image->rows=mng_info->mng_height;\r\r\n image->page.width=mng_info->mng_width;\r\r\n image->page.height=mng_info->mng_height;\r\r\n image->page.x=0;\r\r\n image->page.y=0;\r\r\n image->background_color=mng_background_color;\r\r\n (void) SetImageBackgroundColor(image);\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Inserted transparent background layer, W=%.20g, H=%.20g\",\r\r\n (double) mng_info->mng_width,(double) mng_info->mng_height);\r\r\n }\r\r\n }\r\r\n /*\r\r\n Insert a background layer behind the upcoming image if\r\r\n framing_mode is 3, and we haven't already inserted one.\r\r\n */\r\r\n if (insert_layers && (mng_info->framing_mode == 3) &&\r\r\n (subframe_width) && (subframe_height) && (simplicity == 0 ||\r\r\n (simplicity & 0x08)))\r\r\n {\r\r\n if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\r\r\n {\r\r\n /*\r\r\n Allocate next image structure.\r\r\n */\r\r\n AcquireNextImage(image_info,image);\r\r\n\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n return(DestroyImageList(image));\r\r\n\r\r\n image=SyncNextImageInList(image);\r\r\n }\r\r\n\r\r\n mng_info->image=image;\r\r\n\r\r\n if (term_chunk_found)\r\r\n {\r\r\n image->start_loop=MagickTrue;\r\r\n image->iterations=mng_iterations;\r\r\n term_chunk_found=MagickFalse;\r\r\n }\r\r\n\r\r\n else\r\r\n image->start_loop=MagickFalse;\r\r\n\r\r\n image->delay=0;\r\r\n image->columns=subframe_width;\r\r\n image->rows=subframe_height;\r\r\n image->page.width=subframe_width;\r\r\n image->page.height=subframe_height;\r\r\n image->page.x=mng_info->clip.left;\r\r\n image->page.y=mng_info->clip.top;\r\r\n image->background_color=mng_background_color;\r\r\n image->matte=MagickFalse;\r\r\n (void) SetImageBackgroundColor(image);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\r\r\n (double) mng_info->clip.left,(double) mng_info->clip.right,\r\r\n (double) mng_info->clip.top,(double) mng_info->clip.bottom);\r\r\n }\r\r\n#endif /* MNG_INSERT_LAYERS */\r\r\n first_mng_object=MagickFalse;\r\r\n\r\r\n if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\r\r\n {\r\r\n /*\r\r\n Allocate next image structure.\r\r\n */\r\r\n AcquireNextImage(image_info,image);\r\r\n\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n return(DestroyImageList(image));\r\r\n\r\r\n image=SyncNextImageInList(image);\r\r\n }\r\r\n mng_info->image=image;\r\r\n status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\r\r\n GetBlobSize(image));\r\r\n\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n\r\r\n if (term_chunk_found)\r\r\n {\r\r\n image->start_loop=MagickTrue;\r\r\n term_chunk_found=MagickFalse;\r\r\n }\r\r\n\r\r\n else\r\r\n image->start_loop=MagickFalse;\r\r\n\r\r\n if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\r\r\n {\r\r\n image->delay=frame_delay;\r\r\n frame_delay=default_frame_delay;\r\r\n }\r\r\n\r\r\n else\r\r\n image->delay=0;\r\r\n\r\r\n image->page.width=mng_info->mng_width;\r\r\n image->page.height=mng_info->mng_height;\r\r\n image->page.x=mng_info->x_off[object_id];\r\r\n image->page.y=mng_info->y_off[object_id];\r\r\n image->iterations=mng_iterations;\r\r\n\r\r\n /*\r\r\n Seek back to the beginning of the IHDR or JHDR chunk's length field.\r\r\n */\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\r\r\n type[2],type[3]);\r\r\n\r\r\n offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\r\r\n\r\r\n if (offset < 0)\r\r\n ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\r\r\n }\r\r\n\r\r\n mng_info->image=image;\r\r\n mng_info->mng_type=mng_type;\r\r\n mng_info->object_id=object_id;\r\r\n\r\r\n if (memcmp(type,mng_IHDR,4) == 0)\r\r\n image=ReadOnePNGImage(mng_info,image_info,exception);\r\r\n\r\r\n#if defined(JNG_SUPPORTED)\r\r\n else\r\r\n image=ReadOneJNGImage(mng_info,image_info,exception);\r\r\n#endif\r\r\n\r\r\n if (image == (Image *) NULL)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \"exit ReadJNGImage() with error\");\r\r\n\r\r\n return((Image *) NULL);\r\r\n }\r\r\n\r\r\n if (image->columns == 0 || image->rows == 0)\r\r\n {\r\r\n (void) CloseBlob(image);\r\r\n return(DestroyImageList(image));\r\r\n }\r\r\n\r\r\n mng_info->image=image;\r\r\n\r\r\n if (mng_type)\r\r\n {\r\r\n MngBox\r\r\n crop_box;\r\r\n\r\r\n if (mng_info->magn_methx || mng_info->magn_methy)\r\r\n {\r\r\n png_uint_32\r\r\n magnified_height,\r\r\n magnified_width;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Processing MNG MAGN chunk\");\r\r\n\r\r\n if (mng_info->magn_methx == 1)\r\r\n {\r\r\n magnified_width=mng_info->magn_ml;\r\r\n\r\r\n if (image->columns > 1)\r\r\n magnified_width += mng_info->magn_mr;\r\r\n\r\r\n if (image->columns > 2)\r\r\n magnified_width += (png_uint_32)\r\r\n ((image->columns-2)*(mng_info->magn_mx));\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n magnified_width=(png_uint_32) image->columns;\r\r\n\r\r\n if (image->columns > 1)\r\r\n magnified_width += mng_info->magn_ml-1;\r\r\n\r\r\n if (image->columns > 2)\r\r\n magnified_width += mng_info->magn_mr-1;\r\r\n\r\r\n if (image->columns > 3)\r\r\n magnified_width += (png_uint_32)\r\r\n ((image->columns-3)*(mng_info->magn_mx-1));\r\r\n }\r\r\n\r\r\n if (mng_info->magn_methy == 1)\r\r\n {\r\r\n magnified_height=mng_info->magn_mt;\r\r\n\r\r\n if (image->rows > 1)\r\r\n magnified_height += mng_info->magn_mb;\r\r\n\r\r\n if (image->rows > 2)\r\r\n magnified_height += (png_uint_32)\r\r\n ((image->rows-2)*(mng_info->magn_my));\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n magnified_height=(png_uint_32) image->rows;\r\r\n\r\r\n if (image->rows > 1)\r\r\n magnified_height += mng_info->magn_mt-1;\r\r\n\r\r\n if (image->rows > 2)\r\r\n magnified_height += mng_info->magn_mb-1;\r\r\n\r\r\n if (image->rows > 3)\r\r\n magnified_height += (png_uint_32)\r\r\n ((image->rows-3)*(mng_info->magn_my-1));\r\r\n }\r\r\n\r\r\n if (magnified_height > image->rows ||\r\r\n magnified_width > image->columns)\r\r\n {\r\r\n Image\r\r\n *large_image;\r\r\n\r\r\n int\r\r\n yy;\r\r\n\r\r\n ssize_t\r\r\n m,\r\r\n y;\r\r\n\r\r\n register ssize_t\r\r\n x;\r\r\n\r\r\n register PixelPacket\r\r\n *n,\r\r\n *q;\r\r\n\r\r\n PixelPacket\r\r\n *next,\r\r\n *prev;\r\r\n\r\r\n png_uint_16\r\r\n magn_methx,\r\r\n magn_methy;\r\r\n\r\r\n /* Allocate next image structure. */\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Allocate magnified image\");\r\r\n\r\r\n AcquireNextImage(image_info,image);\r\r\n\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n return(DestroyImageList(image));\r\r\n\r\r\n large_image=SyncNextImageInList(image);\r\r\n\r\r\n large_image->columns=magnified_width;\r\r\n large_image->rows=magnified_height;\r\r\n\r\r\n magn_methx=mng_info->magn_methx;\r\r\n magn_methy=mng_info->magn_methy;\r\r\n\r\r\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\r\r\n#define QM unsigned short\r\r\n if (magn_methx != 1 || magn_methy != 1)\r\r\n {\r\r\n /*\r\r\n Scale pixels to unsigned shorts to prevent\r\r\n overflow of intermediate values of interpolations\r\r\n */\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n q=GetAuthenticPixels(image,0,y,image->columns,1,\r\r\n exception);\r\r\n\r\r\n for (x=(ssize_t) image->columns-1; x >= 0; x--)\r\r\n {\r\r\n SetPixelRed(q,ScaleQuantumToShort(\r\r\n GetPixelRed(q)));\r\r\n SetPixelGreen(q,ScaleQuantumToShort(\r\r\n GetPixelGreen(q)));\r\r\n SetPixelBlue(q,ScaleQuantumToShort(\r\r\n GetPixelBlue(q)));\r\r\n SetPixelOpacity(q,ScaleQuantumToShort(\r\r\n GetPixelOpacity(q)));\r\r\n q++;\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n#else\r\r\n#define QM Quantum\r\r\n#endif\r\r\n\r\r\n if (image->matte != MagickFalse)\r\r\n (void) SetImageBackgroundColor(large_image);\r\r\n\r\r\n else\r\r\n {\r\r\n large_image->background_color.opacity=OpaqueOpacity;\r\r\n (void) SetImageBackgroundColor(large_image);\r\r\n\r\r\n if (magn_methx == 4)\r\r\n magn_methx=2;\r\r\n\r\r\n if (magn_methx == 5)\r\r\n magn_methx=3;\r\r\n\r\r\n if (magn_methy == 4)\r\r\n magn_methy=2;\r\r\n\r\r\n if (magn_methy == 5)\r\r\n magn_methy=3;\r\r\n }\r\r\n\r\r\n /* magnify the rows into the right side of the large image */\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Magnify the rows to %.20g\",(double) large_image->rows);\r\r\n m=(ssize_t) mng_info->magn_mt;\r\r\n yy=0;\r\r\n length=(size_t) image->columns;\r\r\n next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next));\r\r\n prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev));\r\r\n\r\r\n if ((prev == (PixelPacket *) NULL) ||\r\r\n (next == (PixelPacket *) NULL))\r\r\n {\r\r\n image=DestroyImageList(image);\r\r\n ThrowReaderException(ResourceLimitError,\r\r\n \"MemoryAllocationFailed\");\r\r\n }\r\r\n\r\r\n n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\r\r\n (void) CopyMagickMemory(next,n,length);\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n if (y == 0)\r\r\n m=(ssize_t) mng_info->magn_mt;\r\r\n\r\r\n else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\r\r\n m=(ssize_t) mng_info->magn_mb;\r\r\n\r\r\n else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\r\r\n m=(ssize_t) mng_info->magn_mb;\r\r\n\r\r\n else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\r\r\n m=1;\r\r\n\r\r\n else\r\r\n m=(ssize_t) mng_info->magn_my;\r\r\n\r\r\n n=prev;\r\r\n prev=next;\r\r\n next=n;\r\r\n\r\r\n if (y < (ssize_t) image->rows-1)\r\r\n {\r\r\n n=GetAuthenticPixels(image,0,y+1,image->columns,1,\r\r\n exception);\r\r\n (void) CopyMagickMemory(next,n,length);\r\r\n }\r\r\n\r\r\n for (i=0; i < m; i++, yy++)\r\r\n {\r\r\n register PixelPacket\r\r\n *pixels;\r\r\n\r\r\n assert(yy < (ssize_t) large_image->rows);\r\r\n pixels=prev;\r\r\n n=next;\r\r\n q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\r\r\n 1,exception);\r\r\n q+=(large_image->columns-image->columns);\r\r\n\r\r\n for (x=(ssize_t) image->columns-1; x >= 0; x--)\r\r\n {\r\r\n /* To do: get color as function of indexes[x] */\r\r\n /*\r\r\n if (image->storage_class == PseudoClass)\r\r\n {\r\r\n }\r\r\n */\r\r\n\r\r\n if (magn_methy <= 1)\r\r\n {\r\r\n /* replicate previous */\r\r\n SetPixelRGBO(q,(pixels));\r\r\n }\r\r\n\r\r\n else if (magn_methy == 2 || magn_methy == 4)\r\r\n {\r\r\n if (i == 0)\r\r\n {\r\r\n SetPixelRGBO(q,(pixels));\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n /* Interpolate */\r\r\n SetPixelRed(q,\r\r\n ((QM) (((ssize_t)\r\r\n (2*i*(GetPixelRed(n)\r\r\n -GetPixelRed(pixels)+m))/\r\r\n ((ssize_t) (m*2))\r\r\n +GetPixelRed(pixels)))));\r\r\n SetPixelGreen(q,\r\r\n ((QM) (((ssize_t)\r\r\n (2*i*(GetPixelGreen(n)\r\r\n -GetPixelGreen(pixels)+m))/\r\r\n ((ssize_t) (m*2))\r\r\n +GetPixelGreen(pixels)))));\r\r\n SetPixelBlue(q,\r\r\n ((QM) (((ssize_t)\r\r\n (2*i*(GetPixelBlue(n)\r\r\n -GetPixelBlue(pixels)+m))/\r\r\n ((ssize_t) (m*2))\r\r\n +GetPixelBlue(pixels)))));\r\r\n\r\r\n if (image->matte != MagickFalse)\r\r\n SetPixelOpacity(q,\r\r\n ((QM) (((ssize_t)\r\r\n (2*i*(GetPixelOpacity(n)\r\r\n -GetPixelOpacity(pixels)+m))\r\r\n /((ssize_t) (m*2))+\r\r\n GetPixelOpacity(pixels)))));\r\r\n }\r\r\n\r\r\n if (magn_methy == 4)\r\r\n {\r\r\n /* Replicate nearest */\r\r\n if (i <= ((m+1) << 1))\r\r\n SetPixelOpacity(q,\r\r\n (*pixels).opacity+0);\r\r\n else\r\r\n SetPixelOpacity(q,\r\r\n (*n).opacity+0);\r\r\n }\r\r\n }\r\r\n\r\r\n else /* if (magn_methy == 3 || magn_methy == 5) */\r\r\n {\r\r\n /* Replicate nearest */\r\r\n if (i <= ((m+1) << 1))\r\r\n {\r\r\n SetPixelRGBO(q,(pixels));\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n SetPixelRGBO(q,(n));\r\r\n }\r\r\n\r\r\n if (magn_methy == 5)\r\r\n {\r\r\n SetPixelOpacity(q,\r\r\n (QM) (((ssize_t) (2*i*\r\r\n (GetPixelOpacity(n)\r\r\n -GetPixelOpacity(pixels))\r\r\n +m))/((ssize_t) (m*2))\r\r\n +GetPixelOpacity(pixels)));\r\r\n }\r\r\n }\r\r\n n++;\r\r\n q++;\r\r\n pixels++;\r\r\n } /* x */\r\r\n\r\r\n if (SyncAuthenticPixels(large_image,exception) == 0)\r\r\n break;\r\r\n\r\r\n } /* i */\r\r\n } /* y */\r\r\n\r\r\n prev=(PixelPacket *) RelinquishMagickMemory(prev);\r\r\n next=(PixelPacket *) RelinquishMagickMemory(next);\r\r\n\r\r\n length=image->columns;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Delete original image\");\r\r\n\r\r\n DeleteImageFromList(&image);\r\r\n\r\r\n image=large_image;\r\r\n\r\r\n mng_info->image=image;\r\r\n\r\r\n /* magnify the columns */\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Magnify the columns to %.20g\",(double) image->columns);\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n register PixelPacket\r\r\n *pixels;\r\r\n\r\r\n q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n pixels=q+(image->columns-length);\r\r\n n=pixels+1;\r\r\n\r\r\n for (x=(ssize_t) (image->columns-length);\r\r\n x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n /* To do: Rewrite using Get/Set***PixelComponent() */\r\r\n\r\r\n if (x == (ssize_t) (image->columns-length))\r\r\n m=(ssize_t) mng_info->magn_ml;\r\r\n\r\r\n else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\r\r\n m=(ssize_t) mng_info->magn_mr;\r\r\n\r\r\n else if (magn_methx <= 1 && x == (ssize_t) image->columns-1)\r\r\n m=(ssize_t) mng_info->magn_mr;\r\r\n\r\r\n else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\r\r\n m=1;\r\r\n\r\r\n else\r\r\n m=(ssize_t) mng_info->magn_mx;\r\r\n\r\r\n for (i=0; i < m; i++)\r\r\n {\r\r\n if (magn_methx <= 1)\r\r\n {\r\r\n /* replicate previous */\r\r\n SetPixelRGBO(q,(pixels));\r\r\n }\r\r\n\r\r\n else if (magn_methx == 2 || magn_methx == 4)\r\r\n {\r\r\n if (i == 0)\r\r\n {\r\r\n SetPixelRGBO(q,(pixels));\r\r\n }\r\r\n\r\r\n /* To do: Rewrite using Get/Set***PixelComponent() */\r\r\n else\r\r\n {\r\r\n /* Interpolate */\r\r\n SetPixelRed(q,\r\r\n (QM) ((2*i*(\r\r\n GetPixelRed(n)\r\r\n -GetPixelRed(pixels))+m)\r\r\n /((ssize_t) (m*2))+\r\r\n GetPixelRed(pixels)));\r\r\n\r\r\n SetPixelGreen(q,\r\r\n (QM) ((2*i*(\r\r\n GetPixelGreen(n)\r\r\n -GetPixelGreen(pixels))+m)\r\r\n /((ssize_t) (m*2))+\r\r\n GetPixelGreen(pixels)));\r\r\n\r\r\n SetPixelBlue(q,\r\r\n (QM) ((2*i*(\r\r\n GetPixelBlue(n)\r\r\n -GetPixelBlue(pixels))+m)\r\r\n /((ssize_t) (m*2))+\r\r\n GetPixelBlue(pixels)));\r\r\n if (image->matte != MagickFalse)\r\r\n SetPixelOpacity(q,\r\r\n (QM) ((2*i*(\r\r\n GetPixelOpacity(n)\r\r\n -GetPixelOpacity(pixels))+m)\r\r\n /((ssize_t) (m*2))+\r\r\n GetPixelOpacity(pixels)));\r\r\n }\r\r\n\r\r\n if (magn_methx == 4)\r\r\n {\r\r\n /* Replicate nearest */\r\r\n if (i <= ((m+1) << 1))\r\r\n {\r\r\n SetPixelOpacity(q,\r\r\n GetPixelOpacity(pixels)+0);\r\r\n }\r\r\n else\r\r\n {\r\r\n SetPixelOpacity(q,\r\r\n GetPixelOpacity(n)+0);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n else /* if (magn_methx == 3 || magn_methx == 5) */\r\r\n {\r\r\n /* Replicate nearest */\r\r\n if (i <= ((m+1) << 1))\r\r\n {\r\r\n SetPixelRGBO(q,(pixels));\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n SetPixelRGBO(q,(n));\r\r\n }\r\r\n\r\r\n if (magn_methx == 5)\r\r\n {\r\r\n /* Interpolate */\r\r\n SetPixelOpacity(q,\r\r\n (QM) ((2*i*( GetPixelOpacity(n)\r\r\n -GetPixelOpacity(pixels))+m)/\r\r\n ((ssize_t) (m*2))\r\r\n +GetPixelOpacity(pixels)));\r\r\n }\r\r\n }\r\r\n q++;\r\r\n }\r\r\n n++;\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\r\r\n if (magn_methx != 1 || magn_methy != 1)\r\r\n {\r\r\n /*\r\r\n Rescale pixels to Quantum\r\r\n */\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n for (x=(ssize_t) image->columns-1; x >= 0; x--)\r\r\n {\r\r\n SetPixelRed(q,ScaleShortToQuantum(\r\r\n GetPixelRed(q)));\r\r\n SetPixelGreen(q,ScaleShortToQuantum(\r\r\n GetPixelGreen(q)));\r\r\n SetPixelBlue(q,ScaleShortToQuantum(\r\r\n GetPixelBlue(q)));\r\r\n SetPixelOpacity(q,ScaleShortToQuantum(\r\r\n GetPixelOpacity(q)));\r\r\n q++;\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n#endif\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Finished MAGN processing\");\r\r\n }\r\r\n }\r\r\n\r\r\n /*\r\r\n Crop_box is with respect to the upper left corner of the MNG.\r\r\n */\r\r\n crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\r\r\n crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\r\r\n crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\r\r\n crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\r\r\n crop_box=mng_minimum_box(crop_box,mng_info->clip);\r\r\n crop_box=mng_minimum_box(crop_box,mng_info->frame);\r\r\n crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\r\r\n if ((crop_box.left != (mng_info->image_box.left\r\r\n +mng_info->x_off[object_id])) ||\r\r\n (crop_box.right != (mng_info->image_box.right\r\r\n +mng_info->x_off[object_id])) ||\r\r\n (crop_box.top != (mng_info->image_box.top\r\r\n +mng_info->y_off[object_id])) ||\r\r\n (crop_box.bottom != (mng_info->image_box.bottom\r\r\n +mng_info->y_off[object_id])))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Crop the PNG image\");\r\r\n\r\r\n if ((crop_box.left < crop_box.right) &&\r\r\n (crop_box.top < crop_box.bottom))\r\r\n {\r\r\n Image\r\r\n *im;\r\r\n\r\r\n RectangleInfo\r\r\n crop_info;\r\r\n\r\r\n /*\r\r\n Crop_info is with respect to the upper left corner of\r\r\n the image.\r\r\n */\r\r\n crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\r\r\n crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\r\r\n crop_info.width=(size_t) (crop_box.right-crop_box.left);\r\r\n crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\r\r\n image->page.width=image->columns;\r\r\n image->page.height=image->rows;\r\r\n image->page.x=0;\r\r\n image->page.y=0;\r\r\n im=CropImage(image,&crop_info,exception);\r\r\n\r\r\n if (im != (Image *) NULL)\r\r\n {\r\r\n image->columns=im->columns;\r\r\n image->rows=im->rows;\r\r\n im=DestroyImage(im);\r\r\n image->page.width=image->columns;\r\r\n image->page.height=image->rows;\r\r\n image->page.x=crop_box.left;\r\r\n image->page.y=crop_box.top;\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n /*\r\r\n No pixels in crop area. The MNG spec still requires\r\r\n a layer, though, so make a single transparent pixel in\r\r\n the top left corner.\r\r\n */\r\r\n image->columns=1;\r\r\n image->rows=1;\r\r\n image->colors=2;\r\r\n (void) SetImageBackgroundColor(image);\r\r\n image->page.width=1;\r\r\n image->page.height=1;\r\r\n image->page.x=0;\r\r\n image->page.y=0;\r\r\n }\r\r\n }\r\r\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\r\r\n image=mng_info->image;\r\r\n#endif\r\r\n }\r\r\n\r\r\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\r\r\n /* PNG does not handle depths greater than 16 so reduce it even\r\r\n * if lossy, and promote any depths > 8 to 16.\r\r\n */\r\r\n if (image->depth > 16)\r\r\n image->depth=16;\r\r\n#endif\r\r\n\r\r\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\r\r\n if (image->depth > 8)\r\r\n {\r\r\n /* To do: fill low byte properly */\r\r\n image->depth=16;\r\r\n }\r\r\n\r\r\n if (LosslessReduceDepthOK(image) != MagickFalse)\r\r\n image->depth = 8;\r\r\n#endif\r\r\n\r\r\n GetImageException(image,exception);\r\r\n\r\r\n if (image_info->number_scenes != 0)\r\r\n {\r\r\n if (mng_info->scenes_found >\r\r\n (ssize_t) (image_info->first_scene+image_info->number_scenes))\r\r\n break;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Finished reading image datastream.\");\r\r\n\r\r\n } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\r\r\n\r\r\n (void) CloseBlob(image);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Finished reading all image datastreams.\");\r\r\n\r\r\n#if defined(MNG_INSERT_LAYERS)\r\r\n if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\r\r\n (mng_info->mng_height))\r\r\n {\r\r\n /*\r\r\n Insert a background layer if nothing else was found.\r\r\n */\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" No images found. Inserting a background layer.\");\r\r\n\r\r\n if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\r\r\n {\r\r\n /*\r\r\n Allocate next image structure.\r\r\n */\r\r\n AcquireNextImage(image_info,image);\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Allocation failed, returning NULL.\");\r\r\n\r\r\n return(DestroyImageList(image));\r\r\n }\r\r\n image=SyncNextImageInList(image);\r\r\n }\r\r\n image->columns=mng_info->mng_width;\r\r\n image->rows=mng_info->mng_height;\r\r\n image->page.width=mng_info->mng_width;\r\r\n image->page.height=mng_info->mng_height;\r\r\n image->page.x=0;\r\r\n image->page.y=0;\r\r\n image->background_color=mng_background_color;\r\r\n image->matte=MagickFalse;\r\r\n\r\r\n if (image_info->ping == MagickFalse)\r\r\n (void) SetImageBackgroundColor(image);\r\r\n\r\r\n mng_info->image_found++;\r\r\n }\r\r\n#endif\r\r\n image->iterations=mng_iterations;\r\r\n\r\r\n if (mng_iterations == 1)\r\r\n image->start_loop=MagickTrue;\r\r\n\r\r\n while (GetPreviousImageInList(image) != (Image *) NULL)\r\r\n {\r\r\n image_count++;\r\r\n if (image_count > 10*mng_info->image_found)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\" No beginning\");\r\r\n\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"Linked list is corrupted, beginning of list not found\",\r\r\n \"`%s'\",image_info->filename);\r\r\n\r\r\n return(DestroyImageList(image));\r\r\n }\r\r\n\r\r\n image=GetPreviousImageInList(image);\r\r\n\r\r\n if (GetNextImageInList(image) == (Image *) NULL)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\" Corrupt list\");\r\r\n\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\r\r\n image_info->filename);\r\r\n }\r\r\n }\r\r\n\r\r\n if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\r\r\n GetNextImageInList(image) ==\r\r\n (Image *) NULL)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" First image null\");\r\r\n\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"image->next for first image is NULL but shouldn't be.\",\r\r\n \"`%s'\",image_info->filename);\r\r\n }\r\r\n\r\r\n if (mng_info->image_found == 0)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" No visible images found.\");\r\r\n\r\r\n (void) ThrowMagickException(&image->exception,GetMagickModule(),\r\r\n CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\r\r\n\r\r\n return(DestroyImageList(image));\r\r\n }\r\r\n\r\r\n if (mng_info->ticks_per_second)\r\r\n final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\r\r\n final_delay/mng_info->ticks_per_second;\r\r\n\r\r\n else\r\r\n image->start_loop=MagickTrue;\r\r\n\r\r\n /* Find final nonzero image delay */\r\r\n final_image_delay=0;\r\r\n\r\r\n while (GetNextImageInList(image) != (Image *) NULL)\r\r\n {\r\r\n if (image->delay)\r\r\n final_image_delay=image->delay;\r\r\n\r\r\n image=GetNextImageInList(image);\r\r\n }\r\r\n\r\r\n if (final_delay < final_image_delay)\r\r\n final_delay=final_image_delay;\r\r\n\r\r\n image->delay=final_delay;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\r\r\n (double) final_delay);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n int\r\r\n scene;\r\r\n\r\r\n scene=0;\r\r\n image=GetFirstImageInList(image);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Before coalesce:\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" scene 0 delay=%.20g\",(double) image->delay);\r\r\n\r\r\n while (GetNextImageInList(image) != (Image *) NULL)\r\r\n {\r\r\n image=GetNextImageInList(image);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" scene %.20g delay=%.20g\",(double) scene++,(double) image->delay);\r\r\n }\r\r\n }\r\r\n\r\r\n image=GetFirstImageInList(image);\r\r\n#ifdef MNG_COALESCE_LAYERS\r\r\n if (insert_layers)\r\r\n {\r\r\n Image\r\r\n *next_image,\r\r\n *next;\r\r\n\r\r\n size_t\r\r\n scene;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\" Coalesce Images\");\r\r\n\r\r\n scene=image->scene;\r\r\n next_image=CoalesceImages(image,&image->exception);\r\r\n\r\r\n if (next_image == (Image *) NULL)\r\r\n ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n\r\r\n image=DestroyImageList(image);\r\r\n image=next_image;\r\r\n\r\r\n for (next=image; next != (Image *) NULL; next=next_image)\r\r\n {\r\r\n next->page.width=mng_info->mng_width;\r\r\n next->page.height=mng_info->mng_height;\r\r\n next->page.x=0;\r\r\n next->page.y=0;\r\r\n next->scene=scene++;\r\r\n next_image=GetNextImageInList(next);\r\r\n\r\r\n if (next_image == (Image *) NULL)\r\r\n break;\r\r\n\r\r\n if (next->delay == 0)\r\r\n {\r\r\n scene--;\r\r\n next_image->previous=GetPreviousImageInList(next);\r\r\n if (GetPreviousImageInList(next) == (Image *) NULL)\r\r\n image=next_image;\r\r\n else\r\r\n next->previous->next=next_image;\r\r\n next=DestroyImage(next);\r\r\n }\r\r\n }\r\r\n }\r\r\n#endif\r\r\n\r\r\n while (GetNextImageInList(image) != (Image *) NULL)\r\r\n image=GetNextImageInList(image);\r\r\n\r\r\n image->dispose=BackgroundDispose;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n int\r\r\n scene;\r\r\n\r\r\n scene=0;\r\r\n image=GetFirstImageInList(image);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" After coalesce:\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\r\r\n (double) image->dispose);\r\r\n\r\r\n while (GetNextImageInList(image) != (Image *) NULL)\r\r\n {\r\r\n image=GetNextImageInList(image);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\r\r\n (double) image->delay,(double) image->dispose);\r\r\n }\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" exit ReadOneJNGImage();\");\r\r\n\r\r\n return(image);\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint armbruster_bisaxillary = 0;\r\nint global_variable;\r\ntypedef char *repreparing_boshbok;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nrepreparing_boshbok ketipate_enrolling(repreparing_boshbok agreat_coatimundi);\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n int ss_i = 0;\r\n char *subtaxon_exhaustions = 0;\r\n repreparing_boshbok recaution_yorick = 0;\r\n repreparing_boshbok uncaroled_foredoor = 0;\r\n char *organelles_dalhousie;\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&armbruster_bisaxillary,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&organelles_dalhousie,\"UNCONTEMPTIBLE_PLURISY\");\r\n if (organelles_dalhousie != 0) {;\r\n uncaroled_foredoor = organelles_dalhousie;\r\n recaution_yorick = ketipate_enrolling(uncaroled_foredoor);\r\n if (recaution_yorick != 0) {\r\n goto durax_unauthorized;\r\n }\r\n ++global_variable;\r\n durax_unauthorized:;\r\n subtaxon_exhaustions = ((char *)recaution_yorick);\r\n \r\n printf(\"checking input\\n\");\r\n \r\n \r\n \r\n while(ss_i < strlen(subtaxon_exhaustions)){\r\n \r\n if (subtaxon_exhaustions[ss_i] >= 48) {\r\n \r\n ++ss_i;\r\n }\r\n }\r\n \r\n \r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if (recaution_yorick != 0) \r\n free(((char *)recaution_yorick));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nrepreparing_boshbok ketipate_enrolling(repreparing_boshbok agreat_coatimundi)\r\n{\r\n ++global_variable;\r\n return agreat_coatimundi;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while(ss_i < strlen(subtaxon_exhaustions)){\n \n if (subtaxon_exhaustions[ss_i] >= 48) {\n \n ++ss_i;\n }\n }\n```", "cwe": "835"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint nonreasonably_poticary = 0;\r\nint global_variable;\r\n\r\nstruct hungriest_antisplitting \r\n{\r\n char *coarb_tridynamous;\r\n double orthocarbonic_axiate;\r\n char *duplation_reptiliousness;\r\n char mismarks_spinder;\r\n int bai_upshifts;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid intimate_gadsman(const struct hungriest_antisplitting detailism_witchingly);\r\ntypedef int (*fptr)();\r\nint modulus_function1 (char *modulus_param_str) {\r\n \r\n return modulus_param_str[0] % 2;\r\n}\r\nint modulus_function2 (char *modulus_param_str) {\r\n \r\n return modulus_param_str[1] % 2;\r\n}\r\nvoid get_function(int len, fptr * modulus_function) {\r\n \r\n \r\n if (len > 10) {\r\n *modulus_function = modulus_function1;\r\n \r\n }\r\n if (len < 10) {\r\n *modulus_function = modulus_function2;\r\n \r\n }\r\n \r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n struct hungriest_antisplitting trench_sulfonating;\r\n char *californians_cellarmen;\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&nonreasonably_poticary,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n californians_cellarmen = getenv(\"TRIDUUM_UNREPREHENDED\");\r\n if (californians_cellarmen != 0) {;\r\n trench_sulfonating . coarb_tridynamous = ((char *)californians_cellarmen);\r\n intimate_gadsman(trench_sulfonating);\r\n }\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid intimate_gadsman(const struct hungriest_antisplitting detailism_witchingly)\r\n{\r\n int input_len = 0;\r\n int result = 0;\r\n fptr* function_ptr = 0;\r\n char *locum_babelish = 0;\r\n jmp_buf durneder_vendean;\r\n int bevilled_trollop;\r\n ++global_variable;;\r\n bevilled_trollop = setjmp(durneder_vendean);\r\n if (bevilled_trollop == 0) {\r\n longjmp(durneder_vendean,1);\r\n }\r\n locum_babelish = ((char *)((struct hungriest_antisplitting )detailism_witchingly) . coarb_tridynamous);\r\n \r\n input_len = strlen(locum_babelish);\r\n if (input_len < 2) {\r\n printf(\"String is too short to test\\n\");\r\n } else {\r\n function_ptr = malloc(sizeof(void *));\r\n if (function_ptr == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n \r\n get_function(input_len, function_ptr);\r\n \r\n \r\n result = ( *function_ptr)(locum_babelish);\r\n \r\n if (result == 0)\r\n printf(\"mod is true\\n\");\r\n else\r\n printf(\"mod is false\\n\");\r\n if (function_ptr != 0) {\r\n free(function_ptr);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n result = ( *function_ptr)(locum_babelish);\n```", "cwe": "824"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint bout_goneoclinic = 0;\r\nint global_variable;\r\n\r\nstruct plushlike_fatigated \r\n{\r\n char *riving_alshain;\r\n double rpo_borings;\r\n char *spatting_rolandson;\r\n char stonebow_nanny;\r\n int uninvestigable_prepurpose;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid trinitration_conspissate(const struct plushlike_fatigated look_overpay);\r\nvoid featured_ostentous(int stifledly_tanta,struct plushlike_fatigated mingie_clyman);\r\nvoid gwynfa_colonizable(int taliage_rachelle,struct plushlike_fatigated neckyoke_that);\r\nint search(char *str_param,char c_param)\r\n{\r\n if ( *str_param == c_param) {\r\n return 1;\r\n } else if ( *str_param == 0) {\r\n \r\n \r\n return search(&str_param[0],c_param);\r\n } else {\r\n return search(&str_param[1],c_param);\r\n }\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n struct plushlike_fatigated repulverize_admissible;\r\n int wallpiece_decorability = 31;\r\n char *palmerdale_semiproselyte;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&bout_goneoclinic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&palmerdale_semiproselyte,\"6971\",wallpiece_decorability);\r\n if (palmerdale_semiproselyte != 0) {;\r\n repulverize_admissible . riving_alshain = ((char *)palmerdale_semiproselyte);\r\n trinitration_conspissate(repulverize_admissible);\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid trinitration_conspissate(const struct plushlike_fatigated look_overpay)\r\n{\r\n int heterotricha_waine = 7;\r\n ++global_variable;;\r\n featured_ostentous(heterotricha_waine,look_overpay);\r\n}\r\n\r\nvoid featured_ostentous(int stifledly_tanta,struct plushlike_fatigated mingie_clyman)\r\n{\r\n int found;\r\n char *conundrum_burna = 0;\r\n ++global_variable;\r\n stifledly_tanta--;\r\n if (stifledly_tanta > 0) {\r\n gwynfa_colonizable(stifledly_tanta,mingie_clyman);\r\n return ;\r\n }\r\n conundrum_burna = ((char *)((struct plushlike_fatigated )mingie_clyman) . riving_alshain);\r\n \r\n \r\n \r\n found = search(&conundrum_burna[1],conundrum_burna[0]);\r\n \r\n \r\n \r\n;\r\n if (((struct plushlike_fatigated )mingie_clyman) . riving_alshain != 0) \r\n free(((char *)((struct plushlike_fatigated )mingie_clyman) . riving_alshain));\r\nclose_printf_context();\r\n}\r\n\r\nvoid gwynfa_colonizable(int taliage_rachelle,struct plushlike_fatigated neckyoke_that)\r\n{\r\n ++global_variable;\r\n featured_ostentous(taliage_rachelle,neckyoke_that);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` found = search(&conundrum_burna[1],conundrum_burna[0]);\n```", "cwe": "674"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint stranglement_piecings = 0;\r\nint global_variable;\r\nvoid handle_taint(char *calmed_phillada);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&stranglement_piecings,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *calmed_phillada)\r\n{\r\n long long check_val = 2LL;\r\n long long in_val;\r\n int prime = 1;\r\n char *webworn_sectarianism = 0;\r\n int divorcible_threadle;\r\n int contractional_taxgathering;\r\n char **laders_paquito = 0;\r\n long tintinnabulous_certifications[10];\r\n char **gauffer_thruway[10] = {0};\r\n char *gos_cursoriness[87] = {0};\r\n ++global_variable;;\r\n if (calmed_phillada != 0) {;\r\n gos_cursoriness[5] = calmed_phillada;\r\n gauffer_thruway[5] = gos_cursoriness;\r\n tintinnabulous_certifications[1] = 5;\r\n laders_paquito = *(gauffer_thruway + tintinnabulous_certifications[1]);\r\n contractional_taxgathering = 5;\r\n while(1 == 1){\r\n contractional_taxgathering = contractional_taxgathering * 2;\r\n contractional_taxgathering = contractional_taxgathering + 2;\r\n if (contractional_taxgathering > 1000) {\r\n break; \r\n }\r\n }\r\n divorcible_threadle = contractional_taxgathering;\r\n webworn_sectarianism = ((char *)laders_paquito[5]);\r\n \r\n in_val = atoll(webworn_sectarianism);\r\n if (in_val > 1) {\r\n printf(\"Checking for primality\\n\");\r\n \r\n \r\n \r\n for (; check_val <= in_val - 1; ++check_val){\r\n \r\n \r\n if (in_val % check_val == 0) {\r\n prime = 0;\r\n break;\r\n }\r\n }\r\n \r\n \r\n if (prime) {\r\n printf(\"%lld is prime\\n\", in_val);\r\n } else {\r\n printf(\"%lld is composite\\n\", in_val);\r\n }\r\n } else {\r\n printf(\"Input value is less than or equal to 1\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\n if (laders_paquito[5] != 0) \r\n free(((char *)laders_paquito[5]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n for (; check_val <= in_val - 1; ++check_val){\n \n \n if (in_val % check_val == 0) {\n prime = 0;\n break;\n }\n }\n```", "cwe": "834"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <unistd.h> \r\nint poplesie_below = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid acquests_teratomatous(char *const contriturate_paralgesia);\r\nvoid witwall_tsinghai(char *trigonometry_smoulder);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int humorless_iroko = 0;\r\n char *enouncement_ambaris = 0;\r\n int predifferent_unroll = 20;\r\n char *overnumerously_accoutres;;\r\n if (__sync_bool_compare_and_swap(&poplesie_below,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&overnumerously_accoutres,\"5475\",predifferent_unroll);\r\n if (overnumerously_accoutres != 0) {;\r\n humorless_iroko = ((int )(strlen(overnumerously_accoutres)));\r\n enouncement_ambaris = ((char *)(malloc(humorless_iroko + 1)));\r\n if (enouncement_ambaris == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(enouncement_ambaris,0,humorless_iroko + 1);\r\n memcpy(enouncement_ambaris,overnumerously_accoutres,humorless_iroko);\r\n if (overnumerously_accoutres != 0) \r\n free(((char *)overnumerously_accoutres));\r\n acquests_teratomatous(enouncement_ambaris);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n#define BEMIRED_EPIPHYSITIS(x) witwall_tsinghai((char *) x)\r\n\r\nvoid acquests_teratomatous(char *const contriturate_paralgesia)\r\n{\r\n ++global_variable;;\r\n\tBEMIRED_EPIPHYSITIS(contriturate_paralgesia);\r\n}\r\n\r\nvoid witwall_tsinghai(char *trigonometry_smoulder)\r\n{\r\n int oc_i = 0;\r\n int opt_var;\r\n char *acetabuliferous_altropathy = 0;\r\n ++global_variable;;\r\n acetabuliferous_altropathy = ((char *)((char *)trigonometry_smoulder));\r\n \r\n size_t (*canary_pointer[1])(const char *);\r\n char base_path[20];\r\n if (strlen(acetabuliferous_altropathy) < 20) {\r\n canary_pointer[0] = strlen;\r\n memset(base_path,0,20);\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n realpath(acetabuliferous_altropathy,base_path);\r\n opt_var = canary_pointer[0](base_path);\r\n \r\n for (; oc_i < opt_var; ++oc_i) {\r\n base_path[oc_i] = toupper(base_path[oc_i]);\r\n }\r\n printf(\"%s\\n\",base_path);\r\n \r\n \r\n }\r\n \r\n;\r\n if (((char *)trigonometry_smoulder) != 0) \r\n free(((char *)((char *)trigonometry_smoulder)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n realpath(acetabuliferous_altropathy,base_path);\n opt_var = canary_pointer[0](base_path);\n \n for (; oc_i < opt_var; ++oc_i) {\n base_path[oc_i] = toupper(base_path[oc_i]);\n }\n printf(\"%s\\n\",base_path);\n```", "cwe": "785"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nint gymnospore_aldoketene = 0;\r\nint global_variable;\r\n\r\nstruct planimetric_metaphyte \r\n{\r\n char *hardstand_hissy;\r\n double surest_rappelled;\r\n char *dredger_indeciduate;\r\n char superfiniteness_sweetkins;\r\n int appareled_unshuffled;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid deskman_nonobviousness(struct planimetric_metaphyte **************************************************boffa_cornerways);\r\nint 191_global_var = 0;\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n#define EEHO_MAXILLIPEDARY(x) deskman_nonobviousness((struct planimetric_metaphyte **************************************************) x)\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n struct planimetric_metaphyte **************************************************tse_nonamenable = 0;\r\n struct planimetric_metaphyte *************************************************nonspinning_christmastide = 0;\r\n struct planimetric_metaphyte ************************************************increeping_nonassignably = 0;\r\n struct planimetric_metaphyte ***********************************************unregressive_intercranial = 0;\r\n struct planimetric_metaphyte **********************************************hookshop_soapless = 0;\r\n struct planimetric_metaphyte *********************************************unruminatingly_tennessean = 0;\r\n struct planimetric_metaphyte ********************************************replowed_shalako = 0;\r\n struct planimetric_metaphyte *******************************************disassembled_volitational = 0;\r\n struct planimetric_metaphyte ******************************************hypnosporic_nonconformable = 0;\r\n struct planimetric_metaphyte *****************************************flings_godly = 0;\r\n struct planimetric_metaphyte ****************************************undebating_puttees = 0;\r\n struct planimetric_metaphyte ***************************************pridefully_sits = 0;\r\n struct planimetric_metaphyte **************************************nonrecalcitrant_chopped = 0;\r\n struct planimetric_metaphyte *************************************intermission_ticca = 0;\r\n struct planimetric_metaphyte ************************************remotions_gwenni = 0;\r\n struct planimetric_metaphyte ***********************************saitic_ovariorrhexis = 0;\r\n struct planimetric_metaphyte **********************************herse_gessen = 0;\r\n struct planimetric_metaphyte *********************************commodation_colonelcies = 0;\r\n struct planimetric_metaphyte ********************************planimetric_quinols = 0;\r\n struct planimetric_metaphyte *******************************waste_belugas = 0;\r\n struct planimetric_metaphyte ******************************rheotropism_noncogency = 0;\r\n struct planimetric_metaphyte *****************************mappable_homerville = 0;\r\n struct planimetric_metaphyte ****************************susurration_cymaphen = 0;\r\n struct planimetric_metaphyte ***************************duodenostomy_supersets = 0;\r\n struct planimetric_metaphyte **************************anticking_haff = 0;\r\n struct planimetric_metaphyte *************************dpac_megalohepatia = 0;\r\n struct planimetric_metaphyte ************************newcastle_mastigopod = 0;\r\n struct planimetric_metaphyte ***********************diminutal_prorata = 0;\r\n struct planimetric_metaphyte **********************bink_goodeniaceous = 0;\r\n struct planimetric_metaphyte *********************stereomonoscope_tonsillitis = 0;\r\n struct planimetric_metaphyte ********************sesser_ampelitic = 0;\r\n struct planimetric_metaphyte *******************perioecic_soothers = 0;\r\n struct planimetric_metaphyte ******************filiation_overviolent = 0;\r\n struct planimetric_metaphyte *****************diuresis_overthwartness = 0;\r\n struct planimetric_metaphyte ****************piratical_nonfatal = 0;\r\n struct planimetric_metaphyte ***************mumetal_pretyranny = 0;\r\n struct planimetric_metaphyte **************bioscope_unbrined = 0;\r\n struct planimetric_metaphyte *************racahout_utilising = 0;\r\n struct planimetric_metaphyte ************gloryingly_muscicolous = 0;\r\n struct planimetric_metaphyte ***********lubeck_bigram = 0;\r\n struct planimetric_metaphyte **********petitioner_parge = 0;\r\n struct planimetric_metaphyte *********talipat_stockmen = 0;\r\n struct planimetric_metaphyte ********humpiness_boeke = 0;\r\n struct planimetric_metaphyte *******phantasiast_revved = 0;\r\n struct planimetric_metaphyte ******wive_habdalahs = 0;\r\n struct planimetric_metaphyte *****episplenitis_esquimau = 0;\r\n struct planimetric_metaphyte ****taels_untheatric = 0;\r\n struct planimetric_metaphyte ***kaumakani_undangerously = 0;\r\n struct planimetric_metaphyte **coercions_racegoing = 0;\r\n struct planimetric_metaphyte *jillana_arboreally = 0;\r\n struct planimetric_metaphyte confectory_tortillions = {0};\r\n struct planimetric_metaphyte overwetness_wallowed;\r\n int marajuana_decalage = 45;\r\n char *margarethe_underground;;\r\n if (__sync_bool_compare_and_swap(&gymnospore_aldoketene,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&margarethe_underground,\"8228\",marajuana_decalage);\r\n if (margarethe_underground != 0) {;\r\n overwetness_wallowed . hardstand_hissy = ((char *)margarethe_underground);\r\n jillana_arboreally = &overwetness_wallowed;\r\n coercions_racegoing = &jillana_arboreally;\r\n kaumakani_undangerously = &coercions_racegoing;\r\n taels_untheatric = &kaumakani_undangerously;\r\n episplenitis_esquimau = &taels_untheatric;\r\n wive_habdalahs = &episplenitis_esquimau;\r\n phantasiast_revved = &wive_habdalahs;\r\n humpiness_boeke = &phantasiast_revved;\r\n talipat_stockmen = &humpiness_boeke;\r\n petitioner_parge = &talipat_stockmen;\r\n lubeck_bigram = &petitioner_parge;\r\n gloryingly_muscicolous = &lubeck_bigram;\r\n racahout_utilising = &gloryingly_muscicolous;\r\n bioscope_unbrined = &racahout_utilising;\r\n mumetal_pretyranny = &bioscope_unbrined;\r\n piratical_nonfatal = &mumetal_pretyranny;\r\n diuresis_overthwartness = &piratical_nonfatal;\r\n filiation_overviolent = &diuresis_overthwartness;\r\n perioecic_soothers = &filiation_overviolent;\r\n sesser_ampelitic = &perioecic_soothers;\r\n stereomonoscope_tonsillitis = &sesser_ampelitic;\r\n bink_goodeniaceous = &stereomonoscope_tonsillitis;\r\n diminutal_prorata = &bink_goodeniaceous;\r\n newcastle_mastigopod = &diminutal_prorata;\r\n dpac_megalohepatia = &newcastle_mastigopod;\r\n anticking_haff = &dpac_megalohepatia;\r\n duodenostomy_supersets = &anticking_haff;\r\n susurration_cymaphen = &duodenostomy_supersets;\r\n mappable_homerville = &susurration_cymaphen;\r\n rheotropism_noncogency = &mappable_homerville;\r\n waste_belugas = &rheotropism_noncogency;\r\n planimetric_quinols = &waste_belugas;\r\n commodation_colonelcies = &planimetric_quinols;\r\n herse_gessen = &commodation_colonelcies;\r\n saitic_ovariorrhexis = &herse_gessen;\r\n remotions_gwenni = &saitic_ovariorrhexis;\r\n intermission_ticca = &remotions_gwenni;\r\n nonrecalcitrant_chopped = &intermission_ticca;\r\n pridefully_sits = &nonrecalcitrant_chopped;\r\n undebating_puttees = &pridefully_sits;\r\n flings_godly = &undebating_puttees;\r\n hypnosporic_nonconformable = &flings_godly;\r\n disassembled_volitational = &hypnosporic_nonconformable;\r\n replowed_shalako = &disassembled_volitational;\r\n unruminatingly_tennessean = &replowed_shalako;\r\n hookshop_soapless = &unruminatingly_tennessean;\r\n unregressive_intercranial = &hookshop_soapless;\r\n increeping_nonassignably = &unregressive_intercranial;\r\n nonspinning_christmastide = &increeping_nonassignably;\r\n tse_nonamenable = &nonspinning_christmastide;\r\n\tEEHO_MAXILLIPEDARY(tse_nonamenable);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid deskman_nonobviousness(struct planimetric_metaphyte **************************************************boffa_cornerways)\r\n{\r\n char buff[128];\r\n short max_size = 128;\r\n short remaining_space = 0;\r\n int size = 0;\r\n FILE * file = 0;\r\n char *psilotum_sweven = 0;\r\n ++global_variable;;\r\n psilotum_sweven = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy);\r\n \r\n file = fopen(psilotum_sweven, \"r\");\r\n if(file != NULL){\r\n fseek(file, 0, SEEK_END);\r\n size = ftell(file);\r\n fseek(file, 0, SEEK_SET);\r\n \r\n \r\n remaining_space = max_size - size;\r\n \r\n \r\n \r\n \r\n if(remaining_space > 0){\r\n fscanf(file, \"%s\", buff);\r\n printf(\"Contents of file: %s\\n\", buff);\r\n }\r\n \r\n fclose(file);\r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *boffa_cornerways)))))))))))))))))))))))))))))))))))))))))))))))))) . hardstand_hissy));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n if(remaining_space > 0){\n fscanf(file, \"%s\", buff);\n printf(\"Contents of file: %s\\n\", buff);\n }\n```", "cwe": "191"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <time.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint stumor_crimpier = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nchar *meeter_escalator(char *acervate_lurdans);\r\nvoid palpicornia_woodcockize(char *dermestes_melchite);\r\n\r\nvoid ERR_load_BIO_strings()\r\n{\r\n void (*tachyauxetic_florette)(char *) = palpicornia_woodcockize;\r\n char *yucaipa_facetiousness = 0;\r\n char *bastile_otoscopies;;\r\n if (__sync_bool_compare_and_swap(&stumor_crimpier,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n bastile_otoscopies = getenv(\"OUTVICTOR_CLERKDOM\");\r\n if (bastile_otoscopies != 0) {;\r\n yucaipa_facetiousness = meeter_escalator(bastile_otoscopies);\r\n tachyauxetic_florette(yucaipa_facetiousness);\r\n }\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nchar *meeter_escalator(char *acervate_lurdans)\r\n{\r\n ++global_variable;\r\n return acervate_lurdans;\r\n}\r\n\r\nvoid palpicornia_woodcockize(char *dermestes_melchite)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *thurgood_wimpling = 0;\r\n ++global_variable;;\r\n thurgood_wimpling = ((char *)dermestes_melchite);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, thurgood_wimpling);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer)) {\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n } else {\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/log.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avformat.h\"\r\n#include \"avio.h\"\r\n#include \"avio_internal.h\"\r\n#include \"internal.h\"\r\n#include \"url.h\"\r\n#include <stdarg.h>\r\n#define IO_BUFFER_SIZE 32768\r\n\r\n#define SHORT_SEEK_THRESHOLD 4096\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint unbolts_huntington = 0;\r\n\r\nstruct quadrigae_lindsley \r\n{\r\n char *kilter_anisodactyl;\r\n double uncoordinated_kallitype;\r\n char *braggiest_satable;\r\n char addibility_flayers;\r\n int acromion_nonscarcities;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *barmecidal_mantle);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nunsigned int get_size(char *ss_tainted)\r\n{\r\n \r\n unsigned long uns_int = 0UL;\r\n uns_int = strtoul(ss_tainted,0,0);\r\n if (uns_int > ((unsigned long )4294967295U) ||\r\n uns_int == 0)\r\n uns_int = 1U;\r\n return (unsigned int )uns_int;\r\n}\r\n\r\nstatic void *ffio_url_child_next(void *obj,void *prev)\r\n{\r\n AVIOContext *s = obj;\r\n return prev?((void *)0) : s -> opaque;\r\n}\r\n\r\nstatic const AVClass *ffio_url_child_class_next(const AVClass *prev)\r\n{\r\n return prev?((void *)0) : &ffurl_context_class;\r\n}\r\nstatic const AVOption ffio_url_options[] = {{(((void *)0))}};\r\nconst AVClass ffio_url_class = {.class_name = \"AVIOContext\", .item_name = av_default_item_name, .version = '4' << 16 | 18 << 8 | 100, .option = ffio_url_options, .child_next = ffio_url_child_next, .child_class_next = ffio_url_child_class_next};\r\nstatic void fill_buffer(AVIOContext *s);\r\nstatic int url_resetbuf(AVIOContext *s,int flags);\r\n\r\nint ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n s -> buffer = buffer;\r\n s -> buffer_size = buffer_size;\r\n s -> buf_ptr = buffer;\r\n s -> opaque = opaque;\r\n s -> direct = 0;\r\n url_resetbuf(s,(write_flag?2 : 1));\r\n s -> write_packet = write_packet;\r\n s -> read_packet = read_packet;\r\n s -> seek = seek;\r\n s -> pos = 0;\r\n s -> must_flush = 0;\r\n s -> eof_reached = 0;\r\n s -> error = 0;\r\n s -> seekable = 0x1;\r\n s -> max_packet_size = 0;\r\n s -> update_checksum = ((void *)0);\r\n if (!read_packet && !write_flag) {\r\n s -> pos = buffer_size;\r\n s -> buf_end = s -> buffer + buffer_size;\r\n }\r\n s -> read_pause = ((void *)0);\r\n s -> read_seek = ((void *)0);\r\n return 0;\r\n}\r\n\r\nAVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))\r\n{\r\n AVIOContext *s = (av_mallocz(sizeof(AVIOContext )));\r\n if (!s) {\r\n return ((void *)0);\r\n }\r\n ffio_init_context(s,buffer,buffer_size,write_flag,opaque,read_packet,write_packet,seek);\r\n return s;\r\n}\r\n\r\nstatic void writeout(AVIOContext *s,const uint8_t *data,int len)\r\n{\r\n if (s -> write_packet && !s -> error) {\r\n int ret = (s -> write_packet)(s -> opaque,((uint8_t *)data),len);\r\n if (ret < 0) {\r\n s -> error = ret;\r\n }\r\n }\r\n s -> pos += len;\r\n}\r\n\r\nstatic void flush_buffer(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr > s -> buffer) {\r\n writeout(s,(s -> buffer),(s -> buf_ptr - s -> buffer));\r\n if (s -> update_checksum) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n}\r\n\r\nvoid avio_w8(AVIOContext *s,int b)\r\n{\r\n (void )0;\r\n *(s -> buf_ptr++) = b;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n}\r\n\r\nvoid ffio_fill(AVIOContext *s,int b,int count)\r\n{\r\n while(count > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > count?count : s -> buf_end - s -> buf_ptr);\r\n memset((s -> buf_ptr),b,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n count -= len;\r\n }\r\n}\r\n\r\nvoid avio_write(AVIOContext *s,const unsigned char *buf,int size)\r\n{\r\n if (s -> direct && !s -> update_checksum) {\r\n avio_flush(s);\r\n writeout(s,buf,size);\r\n return ;\r\n }\r\n while(size > 0){\r\n int len = (s -> buf_end - s -> buf_ptr > size?size : s -> buf_end - s -> buf_ptr);\r\n memcpy((s -> buf_ptr),buf,len);\r\n s -> buf_ptr += len;\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n flush_buffer(s);\r\n }\r\n buf += len;\r\n size -= len;\r\n }\r\n}\r\n\r\nvoid avio_flush(AVIOContext *s)\r\n{\r\n flush_buffer(s);\r\n s -> must_flush = 0;\r\n}\r\n\r\nint64_t avio_seek(AVIOContext *s,int64_t offset,int whence)\r\n{\r\n int64_t offset1;\r\n int64_t pos;\r\n int force = whence & 0x20000;\r\n whence &= ~0x20000;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n pos = s -> pos - ((s -> write_flag?0 : s -> buf_end - s -> buffer));\r\n if (whence != 1 && whence != 0) {\r\n return (- 22);\r\n }\r\n if (whence == 1) {\r\n offset1 = pos + (s -> buf_ptr - s -> buffer);\r\n if (offset == 0) {\r\n return offset1;\r\n }\r\n offset += offset1;\r\n }\r\n offset1 = offset - pos;\r\n if (!s -> must_flush && (!s -> direct || !s -> seek) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer) {\r\n\r\n s -> buf_ptr = s -> buffer + offset1;\r\n }\r\n else {\r\n if ((!s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer) && !s -> write_flag && offset1 >= 0 && (!s -> direct || !s -> seek) && (whence != 2 || force)) {\r\n while(s -> pos < offset && !s -> eof_reached)\r\n fill_buffer(s);\r\n if (s -> eof_reached) {\r\n return (-((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)));\r\n }\r\n s -> buf_ptr = s -> buf_end + offset - s -> pos;\r\n }\r\n else {\r\n int64_t res;\r\n if (s -> write_flag) {\r\n flush_buffer(s);\r\n s -> must_flush = 1;\r\n }\r\n if (!s -> seek) {\r\n return (- 32);\r\n }\r\n if ((res = ((s -> seek)(s -> opaque,offset,0))) < 0) {\r\n return res;\r\n }\r\n s -> seek_count++;\r\n if (!s -> write_flag) {\r\n s -> buf_end = s -> buffer;\r\n }\r\n s -> buf_ptr = s -> buffer;\r\n s -> pos = offset;\r\n }\r\n }\r\n s -> eof_reached = 0;\r\n return offset;\r\n}\r\n\r\nint64_t avio_skip(AVIOContext *s,int64_t offset)\r\n{\r\n return avio_seek(s,offset,1);\r\n}\r\n\r\nint64_t avio_size(AVIOContext *s)\r\n{\r\n int64_t size;\r\n if (!s) {\r\n return (- 22);\r\n }\r\n if (!s -> seek) {\r\n return (- 38);\r\n }\r\n size = ((s -> seek)(s -> opaque,0,0x10000));\r\n if (size < 0) {\r\n if ((size = ((s -> seek)(s -> opaque,(- 1),2))) < 0) {\r\n return size;\r\n }\r\n size++;\r\n (s -> seek)(s -> opaque,s -> pos,0);\r\n }\r\n return size;\r\n}\r\n\r\nint url_feof(AVIOContext *s)\r\n{\r\n if (!s) {\r\n return 0;\r\n }\r\n if (s -> eof_reached) {\r\n s -> eof_reached = 0;\r\n fill_buffer(s);\r\n }\r\n return s -> eof_reached;\r\n}\r\n\r\nvoid avio_wl32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,(val >> 24));\r\n}\r\n\r\nvoid avio_wb32(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,(val >> 24));\r\n avio_w8(s,((uint8_t )(val >> 16)));\r\n avio_w8(s,((uint8_t )(val >> 8)));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nint avio_put_str(AVIOContext *s,const char *str)\r\n{\r\n int len = 1;\r\n if (str) {\r\n len += strlen(str);\r\n avio_write(s,((const unsigned char *)str),len);\r\n }\r\n else {\r\n avio_w8(s,0);\r\n }\r\n return len;\r\n}\r\n\r\nint avio_put_str16le(AVIOContext *s,const char *str)\r\n{\r\n const uint8_t *q = str;\r\n int ret = 0;\r\n while( *q){\r\n uint32_t ch;\r\n uint16_t tmp;\r\n ch = ( *(q++));\r\n{\r\n uint32_t top = (ch & 128) >> 1;\r\n if ((ch & 0xc0) == 0x80) {\r\n break; \r\n }\r\n while(ch & top){\r\n int tmp = ( *(q++)) - 128;\r\n if (tmp >> 6) {\r\n break; \r\n }\r\n ch = (ch << 6) + tmp;\r\n top <<= 5;\r\n }\r\n ch &= (top << 1) - 1;\r\n }\r\n{\r\n uint32_t in = ch;\r\n if (in < 0x10000) {\r\n tmp = in;\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n else {\r\n tmp = (0xD800 | in - 0x10000 >> 10);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n tmp = (0xDC00 | in - 0x10000 & 0x3FF);\r\n avio_wl16(s,tmp);\r\n ret += 2;\r\n }\r\n }\r\n }\r\n avio_wl16(s,0);\r\n ret += 2;\r\n return ret;\r\n}\r\n\r\nint ff_get_v_length(uint64_t val)\r\n{\r\n int i = 1;\r\n while(val >>= 7)\r\n i++;\r\n return i;\r\n}\r\n\r\nvoid ff_put_v(AVIOContext *bc,uint64_t val)\r\n{\r\n int i = ff_get_v_length(val);\r\n while(--i > 0)\r\n avio_w8(bc,128 | ((uint8_t )(val >> 7 * i)));\r\n avio_w8(bc,(val & 127));\r\n}\r\n\r\nvoid avio_wl64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wl32(s,((uint32_t )(val & 0xffffffff)));\r\n avio_wl32(s,((uint32_t )(val >> 32)));\r\n}\r\n\r\nvoid avio_wb64(AVIOContext *s,uint64_t val)\r\n{\r\n avio_wb32(s,((uint32_t )(val >> 32)));\r\n avio_wb32(s,((uint32_t )(val & 0xffffffff)));\r\n}\r\n\r\nvoid avio_wl16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((uint8_t )val));\r\n avio_w8(s,((int )val) >> 8);\r\n}\r\n\r\nvoid avio_wb16(AVIOContext *s,unsigned int val)\r\n{\r\n avio_w8(s,((int )val) >> 8);\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\nvoid avio_wl24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wl16(s,val & 0xffff);\r\n avio_w8(s,((int )val) >> 16);\r\n}\r\n\r\nvoid avio_wb24(AVIOContext *s,unsigned int val)\r\n{\r\n avio_wb16(s,(((int )val) >> 8));\r\n avio_w8(s,((uint8_t )val));\r\n}\r\n\r\n\r\nstatic void fill_buffer(AVIOContext *s)\r\n{\r\n uint8_t *dst = !s -> max_packet_size && s -> buf_end - s -> buffer < (s -> buffer_size)?s -> buf_end : s -> buffer;\r\n int len = ((s -> buffer_size) - (dst - s -> buffer));\r\n int max_buffer_size = s -> max_packet_size?s -> max_packet_size : 32768;\r\n\r\n if (!s -> read_packet && s -> buf_ptr >= s -> buf_end) {\r\n s -> eof_reached = 1;\r\n }\r\n\r\n if (s -> eof_reached) {\r\n return ;\r\n }\r\n if (s -> update_checksum && dst == s -> buffer) {\r\n if (s -> buf_end > s -> checksum_ptr) {\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_end - s -> checksum_ptr)));\r\n }\r\n s -> checksum_ptr = s -> buffer;\r\n }\r\n\r\n if (s -> read_packet && s -> buffer_size > max_buffer_size) {\r\n ffio_set_buf_size(s,max_buffer_size);\r\n s -> checksum_ptr = dst = s -> buffer;\r\n len = s -> buffer_size;\r\n }\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,dst,len));\r\n }\r\n else {\r\n len = 0;\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n }\r\n else {\r\n s -> pos += len;\r\n s -> buf_ptr = dst;\r\n s -> buf_end = dst + len;\r\n s -> bytes_read += len;\r\n }\r\n}\r\n\r\nunsigned long ff_crc04C11DB7_update(unsigned long checksum,const uint8_t *buf,unsigned int len)\r\n{\r\n return (av_crc(av_crc_get_table(AV_CRC_32_IEEE),checksum,buf,len));\r\n}\r\n\r\nunsigned long ffio_get_checksum(AVIOContext *s)\r\n{\r\n s -> checksum = ((s -> update_checksum)(s -> checksum,(s -> checksum_ptr),(s -> buf_ptr - s -> checksum_ptr)));\r\n s -> update_checksum = ((void *)0);\r\n return s -> checksum;\r\n}\r\n\r\nvoid ffio_init_checksum(AVIOContext *s,unsigned long (*update_checksum)(unsigned long , const uint8_t *, unsigned int ),unsigned long checksum)\r\n{\r\n s -> update_checksum = update_checksum;\r\n if (s -> update_checksum) {\r\n s -> checksum = checksum;\r\n s -> checksum_ptr = s -> buf_ptr;\r\n }\r\n}\r\n\r\n\r\nint avio_r8(AVIOContext *s)\r\n{\r\n if (s -> buf_ptr >= s -> buf_end) {\r\n fill_buffer(s);\r\n }\r\n if (s -> buf_ptr < s -> buf_end) {\r\n return ( *(s -> buf_ptr++));\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_read(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n int size1;\r\n size1 = size;\r\n while(size > 0){\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len > size) {\r\n len = size;\r\n }\r\n if (len == 0 || s -> write_flag) {\r\n if ((s -> direct || size > s -> buffer_size) && !s -> update_checksum) {\r\n if (s -> read_packet) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n }\r\n if (len <= 0) {\r\n\r\n s -> eof_reached = 1;\r\n if (len < 0) {\r\n s -> error = len;\r\n }\r\n break; \r\n }\r\n else {\r\n s -> pos += len;\r\n s -> bytes_read += len;\r\n size -= len;\r\n buf += len;\r\n s -> buf_ptr = s -> buffer;\r\n\r\n s -> buf_end = s -> buffer;\r\n }\r\n }\r\n else {\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n break; \r\n }\r\n }\r\n }\r\n else {\r\n memcpy(buf,(s -> buf_ptr),len);\r\n buf += len;\r\n s -> buf_ptr += len;\r\n size -= len;\r\n }\r\n }\r\n if (size1 == size) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return size1 - size;\r\n}\r\n\r\nint ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)\r\n{\r\n int len;\r\n if (size < 0) {\r\n return - 1;\r\n }\r\n if (s -> read_packet && s -> write_flag) {\r\n len = ((s -> read_packet)(s -> opaque,buf,size));\r\n if (len > 0) {\r\n s -> pos += len;\r\n }\r\n return len;\r\n }\r\n len = (s -> buf_end - s -> buf_ptr);\r\n if (len == 0) {\r\n\r\n s -> buf_end = s -> buf_ptr = s -> buffer;\r\n fill_buffer(s);\r\n len = (s -> buf_end - s -> buf_ptr);\r\n }\r\n if (len > size) {\r\n len = size;\r\n }\r\n memcpy(buf,(s -> buf_ptr),len);\r\n s -> buf_ptr += len;\r\n if (!len) {\r\n if (s -> error) {\r\n return s -> error;\r\n }\r\n if (url_feof(s)) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n }\r\n return len;\r\n}\r\n\r\nunsigned int avio_rl16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s));\r\n val |= (avio_r8(s) << 8);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= (avio_r8(s) << 16);\r\n return val;\r\n}\r\n\r\nunsigned int avio_rl32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rl16(s);\r\n val |= avio_rl16(s) << 16;\r\n return val;\r\n}\r\n\r\nuint64_t avio_rl64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rl32(s)));\r\n val |= ((uint64_t )(avio_rl32(s))) << 32;\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb16(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = (avio_r8(s) << 8);\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb24(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 8;\r\n val |= (avio_r8(s));\r\n return val;\r\n}\r\n\r\nunsigned int avio_rb32(AVIOContext *s)\r\n{\r\n unsigned int val;\r\n val = avio_rb16(s) << 16;\r\n val |= avio_rb16(s);\r\n return val;\r\n}\r\n\r\nint ff_get_line(AVIOContext *s,char *buf,int maxlen)\r\n{\r\n int i = 0;\r\n char c;\r\n do {\r\n c = (avio_r8(s));\r\n if (c && i < maxlen - 1) {\r\n buf[i++] = c;\r\n }\r\n }while (c != 10 && c);\r\n buf[i] = 0;\r\n return i;\r\n}\r\n\r\nint avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)\r\n{\r\n int i;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n\r\n buflen = (buflen - 1 > maxlen?maxlen : buflen - 1);\r\n for (i = 0; i < buflen; i++) \r\n if (!(buf[i] = (avio_r8(s)))) {\r\n return i + 1;\r\n }\r\n buf[i] = 0;\r\n for (; i < maxlen; i++) \r\n if (!avio_r8(s)) {\r\n return i + 1;\r\n }\r\n return maxlen;\r\n}\r\n#define GET_STR16(type, read) \\\r\n int avio_get_str16 ##type(AVIOContext *pb, int maxlen, char *buf, int buflen)\\\r\n{\\\r\n char* q = buf;\\\r\n int ret = 0;\\\r\n if (buflen <= 0) \\\r\n return AVERROR(EINVAL); \\\r\n while (ret + 1 < maxlen) {\\\r\n uint8_t tmp;\\\r\n uint32_t ch;\\\r\n GET_UTF16(ch, (ret += 2) <= maxlen ? read(pb) : 0, break;)\\\r\n if (!ch)\\\r\n break;\\\r\n PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\\\r\n }\\\r\n *q = 0;\\\r\n return ret;\\\r\n}\\\r\n\r\n\r\nint avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rl16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n\r\nint avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)\r\n{\r\n char *q = buf;\r\n int ret = 0;\r\n if (buflen <= 0) {\r\n return - 22;\r\n }\r\n while(ret + 1 < maxlen){\r\n uint8_t tmp;\r\n uint32_t ch;\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : 0);\r\n{\r\n unsigned int hi = ch - 0xD800;\r\n if (hi < 0x800) {\r\n ch = ((ret += 2) <= maxlen?avio_rb16(pb) : (0 - 0xDC00));\r\n if (ch > 0x3FFU || hi > 0x3FFU) {\r\n break; \r\n }\r\n ch += (hi << 10) + 0x10000;\r\n }\r\n }\r\n if (!ch) {\r\n break; \r\n }\r\n{\r\n int bytes;\r\n int shift;\r\n uint32_t in = ch;\r\n if (in < 0x80) {\r\n tmp = in;\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n else {\r\n bytes = (ff_log2_c(in) + 4) / 5;\r\n shift = (bytes - 1) * 6;\r\n tmp = ((256 - (256 >> bytes)) | in >> shift);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n while(shift >= 6){\r\n shift -= 6;\r\n tmp = (0x80 | in >> shift & 0x3F);\r\n if (q - buf < (buflen - 1)) {\r\n *(q++) = tmp;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n *q = 0;\r\n return ret;\r\n}\r\n#undef GET_STR16\r\n\r\nuint64_t avio_rb64(AVIOContext *s)\r\n{\r\n uint64_t val;\r\n val = ((uint64_t )(avio_rb32(s))) << 32;\r\n val |= ((uint64_t )(avio_rb32(s)));\r\n return val;\r\n}\r\n\r\nuint64_t ffio_read_varlen(AVIOContext *bc)\r\n{\r\n uint64_t val = 0;\r\n int tmp;\r\n do {\r\n tmp = avio_r8(bc);\r\n val = (val << 7) + (tmp & 127);\r\n }while (tmp & 128);\r\n return val;\r\n}\r\n\r\nint ffio_fdopen(AVIOContext **s,URLContext *h)\r\n{\r\n uint8_t *buffer;\r\n int buffer_size;\r\n int max_packet_size;\r\n max_packet_size = h -> max_packet_size;\r\n if (max_packet_size) {\r\n\r\n buffer_size = max_packet_size;\r\n }\r\n else {\r\n buffer_size = 32768;\r\n }\r\n buffer = (av_malloc(buffer_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n *s = avio_alloc_context(buffer,buffer_size,h -> flags & 2,h,((void *)ffurl_read),((void *)ffurl_write),((void *)ffurl_seek));\r\n if (!( *s)) {\r\n av_free(buffer);\r\n return - 12;\r\n }\r\n ( *s) -> direct = h -> flags & 0x8000;\r\n ( *s) -> seekable = (h -> is_streamed?0 : 0x1);\r\n ( *s) -> max_packet_size = max_packet_size;\r\n if (h -> prot) {\r\n ( *s) -> read_pause = ((int (*)(void *, int ))(h -> prot -> url_read_pause));\r\n ( *s) -> read_seek = ((int64_t (*)(void *, int , int64_t , int ))(h -> prot -> url_read_seek));\r\n }\r\n ( *s) -> av_class = &ffio_url_class;\r\n return 0;\r\n}\r\n\r\nint ffio_set_buf_size(AVIOContext *s,int buf_size)\r\n{\r\n uint8_t *buffer;\r\n buffer = (av_malloc(buf_size));\r\n if (!buffer) {\r\n return - 12;\r\n }\r\n av_free((s -> buffer));\r\n s -> buffer = buffer;\r\n s -> buffer_size = buf_size;\r\n s -> buf_ptr = buffer;\r\n url_resetbuf(s,(s -> write_flag?2 : 1));\r\n return 0;\r\n}\r\n\r\nstatic int url_resetbuf(AVIOContext *s,int flags)\r\n{\r\n (void )0;\r\n if (flags & 2) {\r\n s -> buf_end = s -> buffer + s -> buffer_size;\r\n s -> write_flag = 1;\r\n }\r\n else {\r\n s -> buf_end = s -> buffer;\r\n s -> write_flag = 0;\r\n }\r\n return 0;\r\n}\r\n\r\nint ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)\r\n{\r\n int64_t buffer_start;\r\n int buffer_size;\r\n int overlap;\r\n int new_size;\r\n int alloc_size;\r\n uint8_t *buf = *bufp;\r\n if (s -> write_flag) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n buffer_size = (s -> buf_end - s -> buffer);\r\n\r\n if ((buffer_start = s -> pos - buffer_size) > buf_size) {\r\n av_freep(bufp);\r\n return - 22;\r\n }\r\n overlap = (buf_size - buffer_start);\r\n new_size = buf_size + buffer_size - overlap;\r\n alloc_size = (s -> buffer_size > new_size?s -> buffer_size : new_size);\r\n if (alloc_size > buf_size) {\r\n if (!(buf = *bufp = (av_realloc_f(buf,1,alloc_size)))) {\r\n return - 12;\r\n }\r\n }\r\n if (new_size > buf_size) {\r\n memcpy((buf + buf_size),(s -> buffer + overlap),(buffer_size - overlap));\r\n buf_size = new_size;\r\n }\r\n av_free((s -> buffer));\r\n s -> buf_ptr = s -> buffer = buf;\r\n s -> buffer_size = alloc_size;\r\n s -> pos = buf_size;\r\n s -> buf_end = s -> buf_ptr + buf_size;\r\n s -> eof_reached = 0;\r\n s -> must_flush = 0;\r\n return 0;\r\n}\r\n\r\nint avio_open(AVIOContext **s,const char *filename,int flags)\r\n{\r\n return avio_open2(s,filename,flags,((void *)0),((void *)0));\r\n}\r\n\r\nint avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)\r\n{\r\n URLContext *h;\r\n int err;\r\n if (__sync_bool_compare_and_swap(&unbolts_huntington,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n err = ffurl_open(&h,filename,flags,int_cb,options);\r\n if (err < 0) {\r\n return err;\r\n }\r\n err = ffio_fdopen(s,h);\r\n if (err < 0) {\r\n ffurl_close(h);\r\n return err;\r\n }\r\n return 0;\r\n}\r\n\r\nint avio_close(AVIOContext *s)\r\n{\r\n URLContext *h;\r\n if (!s) {\r\n return 0;\r\n }\r\n avio_flush(s);\r\n h = (s -> opaque);\r\n av_freep((&s -> buffer));\r\n if (!s -> write_flag) {\r\n av_log(s,48,\"Statistics: %ld bytes read, %d seeks\\n\",s -> bytes_read,s -> seek_count);\r\n }\r\n av_free(s);\r\n return ffurl_close(h);\r\n}\r\n\r\nint avio_closep(AVIOContext **s)\r\n{\r\n int ret = avio_close( *s);\r\n *s = ((void *)0);\r\n return ret;\r\n}\r\n\r\nint avio_printf(AVIOContext *s,const char *fmt,... )\r\n{\r\n va_list ap;\r\n char buf[4096];\r\n int ret;\r\n __builtin_va_start(ap,fmt);\r\n ret = vsnprintf(buf,sizeof(buf),fmt,ap);\r\n __builtin_va_end(ap);\r\n avio_write(s,buf,(strlen(buf)));\r\n return ret;\r\n}\r\n\r\nint avio_pause(AVIOContext *s,int pause)\r\n{\r\n if (!s -> read_pause) {\r\n return - 38;\r\n }\r\n return (s -> read_pause)(s -> opaque,pause);\r\n}\r\n\r\nint64_t avio_seek_time(AVIOContext *s,int stream_index,int64_t timestamp,int flags)\r\n{\r\n URLContext *h = (s -> opaque);\r\n int64_t ret;\r\n if (!s -> read_seek) {\r\n return (- 38);\r\n }\r\n ret = ((s -> read_seek)(h,stream_index,timestamp,flags));\r\n if (ret >= 0) {\r\n int64_t pos;\r\n\r\n s -> buf_ptr = s -> buf_end;\r\n pos = ((s -> seek)(h,0,1));\r\n if (pos >= 0) {\r\n s -> pos = pos;\r\n }\r\n else {\r\n if (pos != (- 38)) {\r\n ret = pos;\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\ntypedef struct DynBuffer {\r\nint pos;\r\nint size;\r\nint allocated_size;\r\nuint8_t *buffer;\r\nint io_buffer_size;\r\nuint8_t io_buffer[1];}DynBuffer;\r\n\r\nstatic int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n DynBuffer *d = opaque;\r\n unsigned int new_size;\r\n unsigned int new_allocated_size;\r\n\r\n new_size = (d -> pos + buf_size);\r\n new_allocated_size = (d -> allocated_size);\r\n if (new_size < (d -> pos) || new_size > (2147483647 / 2)) {\r\n return - 1;\r\n }\r\n while(new_size > new_allocated_size){\r\n if (!new_allocated_size) {\r\n new_allocated_size = new_size;\r\n }\r\n else {\r\n new_allocated_size += new_allocated_size / 2 + 1;\r\n }\r\n }\r\n if (new_allocated_size > (d -> allocated_size)) {\r\n d -> buffer = (av_realloc_f((d -> buffer),1,new_allocated_size));\r\n if (d -> buffer == ((void *)0)) {\r\n return - 12;\r\n }\r\n d -> allocated_size = new_allocated_size;\r\n }\r\n memcpy((d -> buffer + d -> pos),buf,buf_size);\r\n d -> pos = new_size;\r\n if (d -> pos > d -> size) {\r\n d -> size = d -> pos;\r\n }\r\n return buf_size;\r\n}\r\n\r\nstatic int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)\r\n{\r\n unsigned char buf1[4];\r\n int ret;\r\n\r\n ((union unaligned_32 *)buf1) -> l = av_bswap32(buf_size);\r\n ret = dyn_buf_write(opaque,buf1,4);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n\r\n return dyn_buf_write(opaque,buf,buf_size);\r\n}\r\n\r\nstatic int64_t dyn_buf_seek(void *opaque,int64_t offset,int whence)\r\n{\r\n DynBuffer *d = opaque;\r\n if (whence == 1) {\r\n offset += (d -> pos);\r\n }\r\n else {\r\n if (whence == 2) {\r\n offset += (d -> size);\r\n }\r\n }\r\n if (offset < 0 || offset > 0x7fffffffLL) {\r\n return (- 1);\r\n }\r\n d -> pos = offset;\r\n return 0;\r\n}\r\n\r\nstatic int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)\r\n{\r\n DynBuffer *d;\r\n unsigned int io_buffer_size = (max_packet_size?max_packet_size : 1024);\r\n if (sizeof(DynBuffer ) + io_buffer_size < io_buffer_size) {\r\n return - 1;\r\n }\r\n d = (av_mallocz(sizeof(DynBuffer ) + io_buffer_size));\r\n if (!d) {\r\n return - 12;\r\n }\r\n d -> io_buffer_size = io_buffer_size;\r\n *s = avio_alloc_context(d -> io_buffer,d -> io_buffer_size,1,d,((void *)0),(max_packet_size?dyn_packet_buf_write : dyn_buf_write),(max_packet_size?((void *)0) : dyn_buf_seek));\r\n if (!( *s)) {\r\n av_free(d);\r\n return - 12;\r\n }\r\n ( *s) -> max_packet_size = max_packet_size;\r\n return 0;\r\n}\r\n\r\nint avio_open_dyn_buf(AVIOContext **s)\r\n{\r\n return url_open_dyn_buf_internal(s,0);\r\n}\r\n\r\nint ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)\r\n{\r\n if (max_packet_size <= 0) {\r\n return - 1;\r\n }\r\n return url_open_dyn_buf_internal(s,max_packet_size);\r\n}\r\n\r\nint avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)\r\n{\r\n DynBuffer *d = (s -> opaque);\r\n int size;\r\n static const char padbuf[16] = {(0)};\r\n int padding = 0;\r\n\r\n if (!s -> max_packet_size) {\r\n avio_write(s,padbuf,(sizeof(padbuf)));\r\n padding = 16;\r\n }\r\n avio_flush(s);\r\n *pbuffer = d -> buffer;\r\n size = d -> size;\r\n av_free(d);\r\n av_free(s);\r\n return size - padding;\r\n}\r\n\r\nvoid handle_taint(char *barmecidal_mantle)\r\n{\r\n char *other_buff = 0;\r\n int size = 0;\r\n int num = 0;\r\n char buff[200] = {0};\r\n int output_counter = 0;\r\n char *vinegarer_binominated = 0;\r\n struct quadrigae_lindsley *idism_cerebriformly = {0};\r\n struct quadrigae_lindsley raynold_gravers;\r\n ++global_variable;;\r\n if (barmecidal_mantle != 0) {;\r\n raynold_gravers . kilter_anisodactyl = ((char *)barmecidal_mantle);\r\n idism_cerebriformly = &raynold_gravers;\r\n vinegarer_binominated = ((char *)( *idism_cerebriformly) . kilter_anisodactyl);\r\n \r\n if (strlen(vinegarer_binominated) > 0 &&\r\n vinegarer_binominated[0] == '-') {\r\n printf(\"Negative number given as input\\n\");\r\n } else {\r\n \r\n \r\n num = get_size(vinegarer_binominated);\r\n other_buff = getenv(\"SS_BUFF\");\r\n \r\n \r\n \r\n if (other_buff != 0) {\r\n strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\r\n size = ((int )(strlen(buff)));\r\n \r\n \r\n while (num < size) {\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n if (num > 0)\r\n ++num;\r\n }\r\n \r\n } else {\r\n printf(\"Missing value for other_buff\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n }\r\n \r\n;\r\n if (( *idism_cerebriformly) . kilter_anisodactyl != 0) \r\n free(((char *)( *idism_cerebriformly) . kilter_anisodactyl));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (num < size) {\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n if (num > 0)\n ++num;\n }\n```", "cwe": "196"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint fayre_laicizing = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid marelya_owlish(char *ethylin_polymerically);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n void (*octoid_plotting)(char *) = marelya_owlish;\r\n char *potentilla_souderton = 0;\r\n long noropianic_gairfowl[10];\r\n char *cockermeg_mesoscapula[10] = {0};\r\n char *unfloored_protovum;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&fayre_laicizing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unfloored_protovum,\"DEMIHAKE_LUTAYO\");\r\n if (unfloored_protovum != 0) {;\r\n cockermeg_mesoscapula[5] = unfloored_protovum;\r\n noropianic_gairfowl[1] = 5;\r\n potentilla_souderton = *(cockermeg_mesoscapula + noropianic_gairfowl[1]);\r\n octoid_plotting(potentilla_souderton);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid marelya_owlish(char *ethylin_polymerically)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *siricoidea_geotaxis = 0;\r\n ++global_variable;;\r\n siricoidea_geotaxis = ((char *)ethylin_polymerically);\r\n \r\n if (strlen(siricoidea_geotaxis) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(siricoidea_geotaxis) == 1) {\r\n parsed_input = malloc((strlen(siricoidea_geotaxis)+1) * sizeof(char));\r\n urlDecode(siricoidea_geotaxis, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (ethylin_polymerically != 0) \r\n free(((char *)ethylin_polymerically));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint lesli_endangered = 0;\r\n\r\nunion mucocellulosic_seated \r\n{\r\n char *classicalities_perioesophageal;\r\n double coxiest_conductive;\r\n char *tinamidae_diastatically;\r\n char urartic_defalcator;\r\n int macrobius_acephalina;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar process_buffer(char *buffer_param)\r\n{\r\n \r\n char first_char;\r\n first_char = buffer_param[0] - 97;\r\n free(buffer_param);\r\n return first_char;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n char *buffer = 0;\r\n char *pruss_bibliopolic = 0;\r\n jmp_buf situationally_alexanders;\r\n int haithal_nobel;\r\n union mucocellulosic_seated tweedles_quomodos = {0};\r\n int **********cheirotherium_carbin = 0;\r\n int *********proscolex_sensitivenesses = 0;\r\n int ********eyewinks_nonnational = 0;\r\n int *******bondland_pua = 0;\r\n int ******subofficer_diffusive = 0;\r\n int *****pterographic_aglisten = 0;\r\n int ****palmiped_stercorean = 0;\r\n int ***kairotic_inblow = 0;\r\n int **decomposure_roseville = 0;\r\n int *transhuman_highted = 0;\r\n int lobuli_entremess;\r\n union mucocellulosic_seated majestical_overmuches[10] = {0};\r\n union mucocellulosic_seated tires_yaakov;\r\n int zeugobranchia_overbar = 44;\r\n char *axiolite_scumboard;;\r\n if (__sync_bool_compare_and_swap(&lesli_endangered,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&axiolite_scumboard,\"2674\",zeugobranchia_overbar);\r\n if (axiolite_scumboard != 0) {;\r\n tires_yaakov . classicalities_perioesophageal = axiolite_scumboard;\r\n lobuli_entremess = 5;\r\n transhuman_highted = &lobuli_entremess;\r\n decomposure_roseville = &transhuman_highted;\r\n kairotic_inblow = &decomposure_roseville;\r\n palmiped_stercorean = &kairotic_inblow;\r\n pterographic_aglisten = &palmiped_stercorean;\r\n subofficer_diffusive = &pterographic_aglisten;\r\n bondland_pua = &subofficer_diffusive;\r\n eyewinks_nonnational = &bondland_pua;\r\n proscolex_sensitivenesses = &eyewinks_nonnational;\r\n cheirotherium_carbin = &proscolex_sensitivenesses;\r\n majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))] = tires_yaakov;\r\n tweedles_quomodos = majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))];\r\n haithal_nobel = setjmp(situationally_alexanders);\r\n if (haithal_nobel == 0) {\r\n longjmp(situationally_alexanders,1);\r\n }\r\n pruss_bibliopolic = ((char *)tweedles_quomodos . classicalities_perioesophageal);\r\n \r\n buffer = malloc((strlen(pruss_bibliopolic) + 1) * sizeof(char ));\r\n if (buffer == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n strcpy(buffer,pruss_bibliopolic);\r\n \r\n \r\n if (buffer[0] >= 97) {\r\n printf(\"Index of first char: %i\\n\",process_buffer(buffer));\r\n }\r\n \r\n if (buffer != 0) {\r\n \r\n \r\n free(buffer);\r\n \r\n }\r\n \r\n;\r\n if (tweedles_quomodos . classicalities_perioesophageal != 0) \r\n free(((char *)tweedles_quomodos . classicalities_perioesophageal));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n free(buffer);\n```", "cwe": "415"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <openssl/opensslconf.h>\r\n#ifndef OPENSSL_NO_CAMELLIA\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <openssl/camellia.h>\r\n#include \"evp_locl.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\n\r\ntypedef struct {\r\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\r\n\r\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\r\nint unpraying_norton = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid *avenida_tarnopol(void *monkeys_pegboards);\r\nstruct struct_data {\r\n char *buffer_member;\r\n unsigned short size_member;\r\n};\r\nstruct struct_data *init_data(long number_param)\r\n{\r\n \r\n struct struct_data *init_data_ptr = 0;\r\n init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\r\n if (init_data_ptr == 0)\r\n return 0;\r\n init_data_ptr -> size_member = 0;\r\n \r\n\r\n init_data_ptr -> size_member = number_param;\r\n init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\r\n \r\n \r\n \r\n if (init_data_ptr -> buffer_member == 0) {\r\n free(init_data_ptr);\r\n return 0;\r\n }\r\n memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\r\n init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\r\n return init_data_ptr;\r\n}\r\n\r\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cbc()\r\n{\r\n return &camellia_128_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\r\n{\r\n return &camellia_128_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ofb()\r\n{\r\n return &camellia_128_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_ecb()\r\n{\r\n return &camellia_128_ecb;\r\n}\r\n\r\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cbc()\r\n{\r\n long number;\r\n struct struct_data *data = 0;\r\n char *fossils_somatotonic = 0;\r\n void *beerish_eulogium = 0;\r\n void *barber_terrestrially = 0;\r\n int cinereal_signal = 7;\r\n char *lactonizing_corpn;;\r\n if (__sync_bool_compare_and_swap(&unpraying_norton,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&lactonizing_corpn,\"8516\",cinereal_signal);\r\n if (lactonizing_corpn != 0) {;\r\n barber_terrestrially = ((void *)lactonizing_corpn);\r\n beerish_eulogium = avenida_tarnopol(barber_terrestrially);\r\n if (((char *)beerish_eulogium) != 0) {\r\n goto ier_intrepidities;\r\n }\r\n ++global_variable;\r\n ier_intrepidities:;\r\n fossils_somatotonic = ((char *)((char *)beerish_eulogium));\r\n \r\n number = strtol(fossils_somatotonic,0U,10);\r\n if (number > 0) {\r\n data = init_data(number);\r\n if (data != 0) {\r\n \r\n\r\n memset(data -> buffer_member, 98, number);\r\n \r\n data -> buffer_member[number - 1] = 0;\r\n printf(\"%s\\n\", data -> buffer_member);\r\n if (data -> buffer_member != 0U)\r\n free(data -> buffer_member);\r\n if (data != 0U)\r\n free(data);\r\n }\r\n } else {\r\n printf(\"Input is less than or equal to 0\\n\");\r\n }\r\n \r\n;\r\n if (((char *)beerish_eulogium) != 0) \r\n free(((char *)((char *)beerish_eulogium)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &camellia_192_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\r\n{\r\n return &camellia_192_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ofb()\r\n{\r\n return &camellia_192_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_ecb()\r\n{\r\n return &camellia_192_ecb;\r\n}\r\n\r\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (128 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cbc()\r\n{\r\n return &camellia_256_cbc;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\r\n{\r\n return &camellia_256_cfb128;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ofb()\r\n{\r\n return &camellia_256_ofb;\r\n}\r\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_ecb()\r\n{\r\n return &camellia_256_ecb;\r\n}\r\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\r\n\r\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\r\n{\r\n return &camellia_128_cfb1;\r\n}\r\n\r\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\r\n{\r\n return &camellia_192_cfb1;\r\n}\r\n\r\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (1 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\r\n{\r\n return &camellia_256_cfb1;\r\n}\r\n\r\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\r\n{\r\n return &camellia_128_cfb8;\r\n}\r\n\r\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\r\n{\r\n return &camellia_192_cfb8;\r\n}\r\n\r\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (8 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\r\n{\r\n return &camellia_256_cfb8;\r\n}\r\n\r\n\r\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n int ret;\r\n ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\r\n if (ret < 0) {\r\n ERR_put_error(6,159,157,\"e_camellia.c\",118);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nvoid *avenida_tarnopol(void *monkeys_pegboards)\r\n{\r\n ++global_variable;\r\n return monkeys_pegboards;\r\n}\r\n#else\r\n# ifdef PEDANTIC\r\n# endif\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "```\n memset(data -> buffer_member, 98, number);\n```", "cwe": "197"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint musit_pairmasts = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid tenoning_sarina(char **spaceward_darnedest);\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",'P');\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n void (*conli_sententiousness)(char **) = tenoning_sarina;\r\n int cornix_overcommit;\r\n char **unreadier_countertrades = 0;\r\n char **pholad_connectant = 0;\r\n char *engirdles_blow[31] = {0};\r\n char *subglumaceous_dogedoms;;\r\n if (__sync_bool_compare_and_swap(&musit_pairmasts,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&subglumaceous_dogedoms,\"UNILLUSTRATIVE_STEMSON\");\r\n if (subglumaceous_dogedoms != 0) {;\r\n engirdles_blow[24] = subglumaceous_dogedoms;\r\n cornix_overcommit = 1;\r\n unreadier_countertrades = engirdles_blow;\r\n pholad_connectant = ((char **)(((unsigned long )unreadier_countertrades) * cornix_overcommit * cornix_overcommit)) + 5;\r\n conli_sententiousness(pholad_connectant);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid tenoning_sarina(char **spaceward_darnedest)\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n int nFields;\r\n int i;\r\n int j = 0;\r\n char *secam_epididymitis = 0;\r\n ++global_variable;;\r\n secam_epididymitis = ((char *)(spaceward_darnedest - 5)[24]);\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", secam_epididymitis);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != 2) {\r\n \r\n printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n nFields = PQnfields(res);\r\n for (i = 0; i < nFields; i++)\r\n printf(\"%-15s\", PQfname(res, i));\r\n printf(\"\\n\\n\");\r\n \r\n for (i = 0; i < PQntuples(res); i++)\r\n {\r\n for (j = 0; j < nFields; j++)\r\n printf(\"%-15s\", PQgetvalue(res, i, j));\r\n printf(\"\\n\");\r\n }\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\n if ((spaceward_darnedest - 5)[24] != 0) \r\n free(((char *)(spaceward_darnedest - 5)[24]));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n res = PQexec(conn,query);\n if (PQresultStatus(res) != 2) {\n \n printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n PQclear(res);\n PQfinish(conn);\n exit(1);\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint bunyah_nuda = 0;\r\nint global_variable;\r\ntypedef char *deterministic_woolfells;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid misbelieve_diplosphenal(deterministic_woolfells folles_idealize);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n#define UNSUBMERSIBLE_KALIL(x) misbelieve_diplosphenal((deterministic_woolfells) x)\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n deterministic_woolfells domino_humidifies = 0;\r\n long superficial_triandria[10];\r\n deterministic_woolfells intercommuner_familial[10] = {0};\r\n deterministic_woolfells proslaveryism_demanganization = 0;\r\n char *animalculae_airmailed;;\r\n if (__sync_bool_compare_and_swap(&bunyah_nuda,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&animalculae_airmailed,\"TOLLER_POXVIRUSES\");\r\n if (animalculae_airmailed != 0) {;\r\n proslaveryism_demanganization = animalculae_airmailed;\r\n intercommuner_familial[5] = proslaveryism_demanganization;\r\n superficial_triandria[1] = 5;\r\n domino_humidifies = *(intercommuner_familial + superficial_triandria[1]);\r\n\tUNSUBMERSIBLE_KALIL(domino_humidifies);\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid misbelieve_diplosphenal(deterministic_woolfells folles_idealize)\r\n{\r\n char *buffer = 0U;\r\n int len;\r\n char *lenger_kerin = 0;\r\n ++global_variable;;\r\n lenger_kerin = ((char *)folles_idealize);\r\n \r\n len = atoi(lenger_kerin);\r\n \r\n\r\n if (len < 4096) {\r\n buffer = ((char *)(malloc(4096 * sizeof(char ))));\r\n if (buffer != 0) {\r\n memset(buffer,'a',4096);\r\n \r\n \r\n\r\n memset(&buffer[len],'b',4096 - len);\r\n \r\n buffer[4095] = 0;\r\n printf(\"%s\\n\",buffer);\r\n free(buffer);\r\n }\r\n } else {\r\n printf(\"Number is too large to use\\n\");\r\n }\r\n \r\n \r\n;\r\n if (folles_idealize != 0) \r\n free(((char *)folles_idealize));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(&buffer[len],'b',4096 - len);\n```", "cwe": "839"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint lalopathy_tollgatherer = 0;\r\nint global_variable;\r\nvoid handle_taint(char *counterbend_greenbackism);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&lalopathy_tollgatherer,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nvoid handle_taint(char *counterbend_greenbackism)\r\n{\r\n char buffer_stack[128] = {0};\r\n char *regeneracy_preregal = 0;\r\n jmp_buf bissextus_spumier;\r\n int firers_purloins;\r\n char **dispend_rehabilitative = 0;\r\n int **********undemolished_transylvanian = 0;\r\n int *********amroc_globetrotters = 0;\r\n int ********fluxweed_shechina = 0;\r\n int *******substantify_invincibility = 0;\r\n int ******probationerhood_sulphuretting = 0;\r\n int *****chilostome_basic = 0;\r\n int ****cichocki_marshalsea = 0;\r\n int ***archpriesthood_australianism = 0;\r\n int **oppositiflorous_cycling = 0;\r\n int *servette_physicomorphic = 0;\r\n int cautionary_triturated;\r\n char **deutscher_george[10] = {0};\r\n char *olathe_polychromy[70] = {0};\r\n ++global_variable;;\r\n if (counterbend_greenbackism != 0) {;\r\n olathe_polychromy[61] = counterbend_greenbackism;\r\n cautionary_triturated = 5;\r\n servette_physicomorphic = &cautionary_triturated;\r\n oppositiflorous_cycling = &servette_physicomorphic;\r\n archpriesthood_australianism = &oppositiflorous_cycling;\r\n cichocki_marshalsea = &archpriesthood_australianism;\r\n chilostome_basic = &cichocki_marshalsea;\r\n probationerhood_sulphuretting = &chilostome_basic;\r\n substantify_invincibility = &probationerhood_sulphuretting;\r\n fluxweed_shechina = &substantify_invincibility;\r\n amroc_globetrotters = &fluxweed_shechina;\r\n undemolished_transylvanian = &amroc_globetrotters;\r\n deutscher_george[ *( *( *( *( *( *( *( *( *( *undemolished_transylvanian)))))))))] = olathe_polychromy;\r\n dispend_rehabilitative = deutscher_george[ *( *( *( *( *( *( *( *( *( *undemolished_transylvanian)))))))))];\r\n firers_purloins = setjmp(bissextus_spumier);\r\n if (firers_purloins == 0) {\r\n longjmp(bissextus_spumier,1);\r\n }\r\n regeneracy_preregal = ((char *)dispend_rehabilitative[61]);\r\n \r\n \r\n \r\n \r\n \r\n sprintf(buffer_stack,regeneracy_preregal);\r\n \r\n printf(\"%s\\n\",buffer_stack);\r\n \r\n \r\n;\r\n if (dispend_rehabilitative[61] != 0) \r\n free(((char *)dispend_rehabilitative[61]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n sprintf(buffer_stack,regeneracy_preregal);\n \n printf(\"%s\\n\",buffer_stack);\n```", "cwe": "134"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint phonetic_irresolvable = 0;\r\ntypedef char *tuyeres_portfolios;\r\nint global_variable;\r\nvoid handle_taint(char *goldurn_realizing);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid antinovelist_principal(tuyeres_portfolios teretipronator_diastasis);\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&phonetic_irresolvable,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid handle_taint(char *goldurn_realizing)\r\n{\r\n void (*gomulka_acclamator)(tuyeres_portfolios ) = antinovelist_principal;\r\n tuyeres_portfolios roploch_antispirochetic = 0;\r\n long macule_tackify[10];\r\n tuyeres_portfolios tacketed_tyrannisingly[10] = {0};\r\n tuyeres_portfolios agrostography_antiopiumist = 0;\r\n ++global_variable;;\r\n if (goldurn_realizing != 0) {;\r\n agrostography_antiopiumist = goldurn_realizing;\r\n tacketed_tyrannisingly[5] = agrostography_antiopiumist;\r\n macule_tackify[1] = 5;\r\n roploch_antispirochetic = *(tacketed_tyrannisingly + macule_tackify[1]);\r\n gomulka_acclamator(roploch_antispirochetic);\r\n }\r\n}\r\n\r\nvoid antinovelist_principal(tuyeres_portfolios teretipronator_diastasis)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *rassled_receptible = 0;\r\n ++global_variable;;\r\n rassled_receptible = ((char *)teretipronator_diastasis);\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(rassled_receptible); ++i) {\r\n if (rassled_receptible[i] == ';') {\r\n if (i == 0 || rassled_receptible[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,rassled_receptible);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (teretipronator_diastasis != 0) \r\n free(((char *)teretipronator_diastasis));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "hook_add_to_infolist_type (struct t_infolist *infolist, int type,\r\r\n const char *arguments)\r\r\n{\r\r\n struct t_hook *ptr_hook;\r\r\n struct t_infolist_item *ptr_item;\r\r\n char value[64];\r\r\n int match;\r\r\n\r\r\n for (ptr_hook = weechat_hooks[type]; ptr_hook;\r\r\n ptr_hook = ptr_hook->next_hook)\r\r\n {\r\r\n match = 1;\r\r\n if (arguments && !ptr_hook->deleted)\r\r\n {\r\r\n switch (ptr_hook->type)\r\r\n {\r\r\n case HOOK_TYPE_COMMAND:\r\r\n match = string_match (HOOK_COMMAND(ptr_hook, command), arguments, 0);\r\r\n break;\r\r\n default:\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n if (!match)\r\r\n continue;\r\r\n\r\r\n ptr_item = infolist_new_item (infolist);\r\r\n if (!ptr_item)\r\r\n return 0;\r\r\n\r\r\n if (!infolist_new_var_pointer (ptr_item, \"pointer\", ptr_hook))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"plugin\", ptr_hook->plugin))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"plugin_name\",\r\r\n (ptr_hook->plugin) ?\r\r\n ptr_hook->plugin->name : NULL))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"subplugin\", ptr_hook->subplugin))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"type\", hook_type_string[ptr_hook->type]))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"deleted\", ptr_hook->deleted))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"running\", ptr_hook->running))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"priority\", ptr_hook->priority))\r\r\n return 0;\r\r\n switch (ptr_hook->type)\r\r\n {\r\r\n case HOOK_TYPE_COMMAND:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_COMMAND(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"command\", HOOK_COMMAND(ptr_hook, command)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description\",\r\r\n HOOK_COMMAND(ptr_hook, description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description_nls\",\r\r\n (HOOK_COMMAND(ptr_hook, description)\r\r\n && HOOK_COMMAND(ptr_hook, description)[0]) ?\r\r\n _(HOOK_COMMAND(ptr_hook, description)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args\",\r\r\n HOOK_COMMAND(ptr_hook, args)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_nls\",\r\r\n (HOOK_COMMAND(ptr_hook, args)\r\r\n && HOOK_COMMAND(ptr_hook, args)[0]) ?\r\r\n _(HOOK_COMMAND(ptr_hook, args)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description\",\r\r\n HOOK_COMMAND(ptr_hook, args_description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description_nls\",\r\r\n (HOOK_COMMAND(ptr_hook, args_description)\r\r\n && HOOK_COMMAND(ptr_hook, args_description)[0]) ?\r\r\n _(HOOK_COMMAND(ptr_hook, args_description)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"completion\", HOOK_COMMAND(ptr_hook, completion)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_COMMAND_RUN:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_COMMAND_RUN(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"command\", HOOK_COMMAND_RUN(ptr_hook, command)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_TIMER:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_TIMER(ptr_hook, callback)))\r\r\n return 0;\r\r\n snprintf (value, sizeof (value), \"%ld\", HOOK_TIMER(ptr_hook, interval));\r\r\n if (!infolist_new_var_string (ptr_item, \"interval\", value))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"align_second\", HOOK_TIMER(ptr_hook, align_second)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"remaining_calls\", HOOK_TIMER(ptr_hook, remaining_calls)))\r\r\n return 0;\r\r\n if (!infolist_new_var_buffer (ptr_item, \"last_exec\",\r\r\n &(HOOK_TIMER(ptr_hook, last_exec)),\r\r\n sizeof (HOOK_TIMER(ptr_hook, last_exec))))\r\r\n return 0;\r\r\n if (!infolist_new_var_buffer (ptr_item, \"next_exec\",\r\r\n &(HOOK_TIMER(ptr_hook, next_exec)),\r\r\n sizeof (HOOK_TIMER(ptr_hook, next_exec))))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_FD:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_FD(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"fd\", HOOK_FD(ptr_hook, fd)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"flags\", HOOK_FD(ptr_hook, flags)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"error\", HOOK_FD(ptr_hook, error)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_PROCESS:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_PROCESS(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"command\", HOOK_PROCESS(ptr_hook, command)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"options\", hashtable_get_string (HOOK_PROCESS(ptr_hook, options), \"keys_values\")))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"timeout\", HOOK_PROCESS(ptr_hook, timeout)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_read_stdout\", HOOK_PROCESS(ptr_hook, child_read[HOOK_PROCESS_STDOUT])))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_write_stdout\", HOOK_PROCESS(ptr_hook, child_write[HOOK_PROCESS_STDOUT])))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_read_stderr\", HOOK_PROCESS(ptr_hook, child_read[HOOK_PROCESS_STDERR])))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_write_stderr\", HOOK_PROCESS(ptr_hook, child_write[HOOK_PROCESS_STDERR])))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_pid\", HOOK_PROCESS(ptr_hook, child_pid)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"hook_fd_stdout\", HOOK_PROCESS(ptr_hook, hook_fd[HOOK_PROCESS_STDOUT])))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"hook_fd_stderr\", HOOK_PROCESS(ptr_hook, hook_fd[HOOK_PROCESS_STDERR])))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"hook_timer\", HOOK_PROCESS(ptr_hook, hook_timer)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_CONNECT:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_CONNECT(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"address\", HOOK_CONNECT(ptr_hook, address)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"port\", HOOK_CONNECT(ptr_hook, port)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"sock\", HOOK_CONNECT(ptr_hook, sock)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"ipv6\", HOOK_CONNECT(ptr_hook, ipv6)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"retry\", HOOK_CONNECT(ptr_hook, retry)))\r\r\n return 0;\r\r\n#ifdef HAVE_GNUTLS\r\r\n if (!infolist_new_var_pointer (ptr_item, \"gnutls_sess\", HOOK_CONNECT(ptr_hook, gnutls_sess)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"gnutls_cb\", HOOK_CONNECT(ptr_hook, gnutls_cb)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"gnutls_dhkey_size\", HOOK_CONNECT(ptr_hook, gnutls_dhkey_size)))\r\r\n return 0;\r\r\n#endif\r\r\n if (!infolist_new_var_string (ptr_item, \"local_hostname\", HOOK_CONNECT(ptr_hook, local_hostname)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_read\", HOOK_CONNECT(ptr_hook, child_read)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_write\", HOOK_CONNECT(ptr_hook, child_write)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_recv\", HOOK_CONNECT(ptr_hook, child_recv)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_send\", HOOK_CONNECT(ptr_hook, child_send)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"child_pid\", HOOK_CONNECT(ptr_hook, child_pid)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"hook_child_timer\", HOOK_CONNECT(ptr_hook, hook_child_timer)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"hook_fd\", HOOK_CONNECT(ptr_hook, hook_fd)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"handshake_hook_fd\", HOOK_CONNECT(ptr_hook, handshake_hook_fd)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"handshake_hook_timer\", HOOK_CONNECT(ptr_hook, handshake_hook_timer)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"handshake_fd_flags\", HOOK_CONNECT(ptr_hook, handshake_fd_flags)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"handshake_ip_address\", HOOK_CONNECT(ptr_hook, handshake_ip_address)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_PRINT:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_PRINT(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"buffer\", HOOK_PRINT(ptr_hook, buffer)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"tags_count\", HOOK_PRINT(ptr_hook, tags_count)))\r\r\n return 0;\r\r\n if (!infolist_new_var_pointer (ptr_item, \"tags_array\", HOOK_PRINT(ptr_hook, tags_array)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"message\", HOOK_PRINT(ptr_hook, message)))\r\r\n return 0;\r\r\n if (!infolist_new_var_integer (ptr_item, \"strip_colors\", HOOK_PRINT(ptr_hook, strip_colors)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_SIGNAL:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_SIGNAL(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"signal\", HOOK_SIGNAL(ptr_hook, signal)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_HSIGNAL:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_HSIGNAL(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"signal\", HOOK_HSIGNAL(ptr_hook, signal)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_CONFIG:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_CONFIG(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"option\", HOOK_CONFIG(ptr_hook, option)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_COMPLETION:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_COMPLETION(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"completion_item\", HOOK_COMPLETION(ptr_hook, completion_item)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description\", HOOK_COMPLETION(ptr_hook, description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description_nls\",\r\r\n (HOOK_COMPLETION(ptr_hook, description)\r\r\n && HOOK_COMPLETION(ptr_hook, description)[0]) ?\r\r\n _(HOOK_COMPLETION(ptr_hook, description)) : \"\"))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_MODIFIER:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_MODIFIER(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"modifier\", HOOK_MODIFIER(ptr_hook, modifier)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_INFO:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_INFO(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"info_name\", HOOK_INFO(ptr_hook, info_name)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description\", HOOK_INFO(ptr_hook, description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description_nls\",\r\r\n (HOOK_INFO(ptr_hook, description)\r\r\n && HOOK_INFO(ptr_hook, description)[0]) ?\r\r\n _(HOOK_INFO(ptr_hook, description)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description\", HOOK_INFO(ptr_hook, args_description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description_nls\",\r\r\n (HOOK_INFO(ptr_hook, args_description)\r\r\n && HOOK_INFO(ptr_hook, args_description)[0]) ?\r\r\n _(HOOK_INFO(ptr_hook, args_description)) : \"\"))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_INFO_HASHTABLE:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_INFO_HASHTABLE(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"info_name\", HOOK_INFO_HASHTABLE(ptr_hook, info_name)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description\", HOOK_INFO_HASHTABLE(ptr_hook, description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description_nls\",\r\r\n (HOOK_INFO_HASHTABLE(ptr_hook, description)\r\r\n && HOOK_INFO_HASHTABLE(ptr_hook, description)[0]) ?\r\r\n _(HOOK_INFO_HASHTABLE(ptr_hook, description)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description\", HOOK_INFO_HASHTABLE(ptr_hook, args_description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description_nls\",\r\r\n (HOOK_INFO_HASHTABLE(ptr_hook, args_description)\r\r\n && HOOK_INFO_HASHTABLE(ptr_hook, args_description)[0]) ?\r\r\n _(HOOK_INFO_HASHTABLE(ptr_hook, args_description)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"output_description\", HOOK_INFO_HASHTABLE(ptr_hook, output_description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"output_description_nls\",\r\r\n (HOOK_INFO_HASHTABLE(ptr_hook, output_description)\r\r\n && HOOK_INFO_HASHTABLE(ptr_hook, output_description)[0]) ?\r\r\n _(HOOK_INFO_HASHTABLE(ptr_hook, output_description)) : \"\"))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_INFOLIST:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_INFOLIST(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"infolist_name\", HOOK_INFOLIST(ptr_hook, infolist_name)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description\", HOOK_INFOLIST(ptr_hook, description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description_nls\",\r\r\n (HOOK_INFOLIST(ptr_hook, description)\r\r\n && HOOK_INFOLIST(ptr_hook, description)[0]) ?\r\r\n _(HOOK_INFOLIST(ptr_hook, description)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"pointer_description\", HOOK_INFOLIST(ptr_hook, pointer_description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"pointer_description_nls\",\r\r\n (HOOK_INFOLIST(ptr_hook, pointer_description)\r\r\n && HOOK_INFOLIST(ptr_hook, pointer_description)[0]) ?\r\r\n _(HOOK_INFOLIST(ptr_hook, pointer_description)) : \"\"))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description\", HOOK_INFOLIST(ptr_hook, args_description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"args_description_nls\",\r\r\n (HOOK_INFOLIST(ptr_hook, args_description)\r\r\n && HOOK_INFOLIST(ptr_hook, args_description)[0]) ?\r\r\n _(HOOK_INFOLIST(ptr_hook, args_description)) : \"\"))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_HDATA:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_HDATA(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"hdata_name\", HOOK_HDATA(ptr_hook, hdata_name)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description\", HOOK_HDATA(ptr_hook, description)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"description_nls\",\r\r\n (HOOK_HDATA(ptr_hook, description)\r\r\n && HOOK_HDATA(ptr_hook, description)[0]) ?\r\r\n _(HOOK_HDATA(ptr_hook, description)) : \"\"))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_TYPE_FOCUS:\r\r\n if (!ptr_hook->deleted)\r\r\n {\r\r\n if (!infolist_new_var_pointer (ptr_item, \"callback\", HOOK_FOCUS(ptr_hook, callback)))\r\r\n return 0;\r\r\n if (!infolist_new_var_string (ptr_item, \"area\", HOOK_FOCUS(ptr_hook, area)))\r\r\n return 0;\r\r\n }\r\r\n break;\r\r\n case HOOK_NUM_TYPES:\r\r\n /*\r\r\n * this constant is used to count types only,\r\r\n * it is never used as type\r\r\n */\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n return 1;\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint medjidieh_kechuans = 0;\r\nint global_variable;\r\n\r\nunion depickle_keeseville \r\n{\r\n char *jokul_chuvash;\r\n double radnorshire_sciarinae;\r\n char *orate_moonset;\r\n char nonseparative_goemot;\r\n int inexpungeable_fotched;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid underbuilder_appositely(union depickle_keeseville *frigga_egerton);\r\nvoid ichthyosaurus_pollutedly(union depickle_keeseville *sassanid_ephemeroptera);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n union depickle_keeseville *metropolitanize_atticize = {0};\r\n union depickle_keeseville idotheidae_beguileful;\r\n int samkhya_cruth = 35;\r\n char *gard_junior;\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&medjidieh_kechuans,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&gard_junior,\"3858\",samkhya_cruth);\r\n if (gard_junior != 0) {;\r\n idotheidae_beguileful . jokul_chuvash = gard_junior;\r\n metropolitanize_atticize = &idotheidae_beguileful;\r\n underbuilder_appositely(metropolitanize_atticize);\r\n }\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid underbuilder_appositely(union depickle_keeseville *frigga_egerton)\r\n{\r\n ++global_variable;;\r\n ichthyosaurus_pollutedly(frigga_egerton);\r\n}\r\n\r\nvoid ichthyosaurus_pollutedly(union depickle_keeseville *sassanid_ephemeroptera)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *ambulatoria_anginous = 0;\r\n ++global_variable;;\r\n ambulatoria_anginous = ((char *)( *sassanid_ephemeroptera) . jokul_chuvash);\r\n \r\n if (strlen(ambulatoria_anginous) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(ambulatoria_anginous) == 1) {\r\n parsed_input = malloc((strlen(ambulatoria_anginous)+1) * sizeof(char));\r\n urlDecode(ambulatoria_anginous, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (( *sassanid_ephemeroptera) . jokul_chuvash != 0) \r\n free(((char *)( *sassanid_ephemeroptera) . jokul_chuvash));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": " TT_RunIns( TT_ExecContext exc )\r\r\n {\r\r\n FT_ULong ins_counter = 0; /* executed instructions counter */\r\r\n FT_ULong num_twilight_points;\r\r\n FT_UShort i;\r\r\n\r\r\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\r\r\n FT_Byte opcode_pattern[1][2] = {\r\r\n /* #8 TypeMan Talk Align */\r\r\n {\r\r\n 0x06, /* SPVTL */\r\r\n 0x7D, /* RDTG */\r\r\n },\r\r\n };\r\r\n FT_UShort opcode_patterns = 1;\r\r\n FT_UShort opcode_pointer[1] = { 0 };\r\r\n FT_UShort opcode_size[1] = { 1 };\r\r\n#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */\r\r\n\r\r\n\r\r\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\r\r\n exc->iup_called = FALSE;\r\r\n#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */\r\r\n\r\r\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\r\r\n /*\r\r\n * Toggle backward compatibility according to what font wants, except\r\r\n * when\r\r\n *\r\r\n * 1) we have a `tricky' font that heavily relies on the interpreter to\r\r\n * render glyphs correctly, for example DFKai-SB, or\r\r\n * 2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.\r\r\n *\r\r\n * In those cases, backward compatibility needs to be turned off to get\r\r\n * correct rendering. The rendering is then completely up to the\r\r\n * font's programming.\r\r\n *\r\r\n */\r\r\n if ( SUBPIXEL_HINTING_MINIMAL &&\r\r\n exc->subpixel_hinting_lean &&\r\r\n !FT_IS_TRICKY( &exc->face->root ) )\r\r\n exc->backward_compatibility = !( exc->GS.instruct_control & 4 );\r\r\n else\r\r\n exc->backward_compatibility = FALSE;\r\r\n\r\r\n exc->iupx_called = FALSE;\r\r\n exc->iupy_called = FALSE;\r\r\n#endif\r\r\n\r\r\n /* We restrict the number of twilight points to a reasonable, */\r\r\n /* heuristic value to avoid slow execution of malformed bytecode. */\r\r\n num_twilight_points = FT_MAX( 30,\r\r\n 2 * ( exc->pts.n_points + exc->cvtSize ) );\r\r\n if ( exc->twilight.n_points > num_twilight_points )\r\r\n {\r\r\n if ( num_twilight_points > 0xFFFFU )\r\r\n num_twilight_points = 0xFFFFU;\r\r\n\r\r\n FT_TRACE5(( \"TT_RunIns: Resetting number of twilight points\\n\"\r\r\n \" from %d to the more reasonable value %d\\n\",\r\r\n exc->twilight.n_points,\r\r\n num_twilight_points ));\r\r\n exc->twilight.n_points = (FT_UShort)num_twilight_points;\r\r\n }\r\r\n\r\r\n /* Set up loop detectors. We restrict the number of LOOPCALL loops */\r\r\n /* and the number of JMPR, JROT, and JROF calls with a negative */\r\r\n /* argument to values that depend on various parameters like the */\r\r\n /* size of the CVT table or the number of points in the current */\r\r\n /* glyph (if applicable). */\r\r\n /* */\r\r\n /* The idea is that in real-world bytecode you either iterate over */\r\r\n /* all CVT entries (in the `prep' table), or over all points (or */\r\r\n /* contours, in the `glyf' table) of a glyph, and such iterations */\r\r\n /* don't happen very often. */\r\r\n exc->loopcall_counter = 0;\r\r\n exc->neg_jump_counter = 0;\r\r\n\r\r\n /* The maximum values are heuristic. */\r\r\n if ( exc->pts.n_points )\r\r\n exc->loopcall_counter_max = FT_MAX( 50,\r\r\n 10 * exc->pts.n_points ) +\r\r\n FT_MAX( 50,\r\r\n exc->cvtSize / 10 );\r\r\n else\r\r\n exc->loopcall_counter_max = 300 + 8 * exc->cvtSize;\r\r\n\r\r\n /* as a protection against an unreasonable number of CVT entries */\r\r\n /* we assume at most 100 control values per glyph for the counter */\r\r\n if ( exc->loopcall_counter_max >\r\r\n 100 * (FT_ULong)exc->face->root.num_glyphs )\r\r\n exc->loopcall_counter_max = 100 * (FT_ULong)exc->face->root.num_glyphs;\r\r\n\r\r\n FT_TRACE5(( \"TT_RunIns: Limiting total number of loops in LOOPCALL\"\r\r\n \" to %d\\n\", exc->loopcall_counter_max ));\r\r\n\r\r\n exc->neg_jump_counter_max = exc->loopcall_counter_max;\r\r\n FT_TRACE5(( \"TT_RunIns: Limiting total number of backward jumps\"\r\r\n \" to %d\\n\", exc->neg_jump_counter_max ));\r\r\n\r\r\n /* set PPEM and CVT functions */\r\r\n exc->tt_metrics.ratio = 0;\r\r\n if ( exc->metrics.x_ppem != exc->metrics.y_ppem )\r\r\n {\r\r\n /* non-square pixels, use the stretched routines */\r\r\n exc->func_cur_ppem = Current_Ppem_Stretched;\r\r\n exc->func_read_cvt = Read_CVT_Stretched;\r\r\n exc->func_write_cvt = Write_CVT_Stretched;\r\r\n exc->func_move_cvt = Move_CVT_Stretched;\r\r\n }\r\r\n else\r\r\n {\r\r\n /* square pixels, use normal routines */\r\r\n exc->func_cur_ppem = Current_Ppem;\r\r\n exc->func_read_cvt = Read_CVT;\r\r\n exc->func_write_cvt = Write_CVT;\r\r\n exc->func_move_cvt = Move_CVT;\r\r\n }\r\r\n\r\r\n Compute_Funcs( exc );\r\r\n Compute_Round( exc, (FT_Byte)exc->GS.round_state );\r\r\n\r\r\n do\r\r\n {\r\r\n exc->opcode = exc->code[exc->IP];\r\r\n\r\r\n#ifdef FT_DEBUG_LEVEL_TRACE\r\r\n {\r\r\n FT_Long cnt = FT_MIN( 8, exc->top );\r\r\n FT_Long n;\r\r\n\r\r\n\r\r\n /* if tracing level is 7, show current code position */\r\r\n /* and the first few stack elements also */\r\r\n FT_TRACE6(( \" \" ));\r\r\n FT_TRACE7(( \"%06d \", exc->IP ));\r\r\n FT_TRACE6(( opcode_name[exc->opcode] + 2 ));\r\r\n FT_TRACE7(( \"%*s\", *opcode_name[exc->opcode] == 'A'\r\r\n ? 2\r\r\n : 12 - ( *opcode_name[exc->opcode] - '0' ),\r\r\n \"#\" ));\r\r\n for ( n = 1; n <= cnt; n++ )\r\r\n FT_TRACE7(( \" %d\", exc->stack[exc->top - n] ));\r\r\n FT_TRACE6(( \"\\n\" ));\r\r\n }\r\r\n#endif /* FT_DEBUG_LEVEL_TRACE */\r\r\n\r\r\n if ( ( exc->length = opcode_length[exc->opcode] ) < 0 )\r\r\n {\r\r\n if ( exc->IP + 1 >= exc->codeSize )\r\r\n goto LErrorCodeOverflow_;\r\r\n\r\r\n exc->length = 2 - exc->length * exc->code[exc->IP + 1];\r\r\n }\r\r\n\r\r\n if ( exc->IP + exc->length > exc->codeSize )\r\r\n goto LErrorCodeOverflow_;\r\r\n\r\r\n /* First, let's check for empty stack and overflow */\r\r\n exc->args = exc->top - ( Pop_Push_Count[exc->opcode] >> 4 );\r\r\n\r\r\n /* `args' is the top of the stack once arguments have been popped. */\r\r\n /* One can also interpret it as the index of the last argument. */\r\r\n if ( exc->args < 0 )\r\r\n {\r\r\n if ( exc->pedantic_hinting )\r\r\n {\r\r\n exc->error = FT_THROW( Too_Few_Arguments );\r\r\n goto LErrorLabel_;\r\r\n }\r\r\n\r\r\n /* push zeroes onto the stack */\r\r\n for ( i = 0; i < Pop_Push_Count[exc->opcode] >> 4; i++ )\r\r\n exc->stack[i] = 0;\r\r\n exc->args = 0;\r\r\n }\r\r\n\r\r\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\r\r\n if ( exc->opcode == 0x91 )\r\r\n {\r\r\n /* this is very special: GETVARIATION returns */\r\r\n /* a variable number of arguments */\r\r\n\r\r\n /* it is the job of the application to `activate' GX handling, */\r\r\n /* this is, calling any of the GX API functions on the current */\r\r\n /* font to select a variation instance */\r\r\n if ( exc->face->blend )\r\r\n exc->new_top = exc->args + exc->face->blend->num_axis;\r\r\n }\r\r\n else\r\r\n#endif\r\r\n exc->new_top = exc->args + ( Pop_Push_Count[exc->opcode] & 15 );\r\r\n\r\r\n /* `new_top' is the new top of the stack, after the instruction's */\r\r\n /* execution. `top' will be set to `new_top' after the `switch' */\r\r\n /* statement. */\r\r\n if ( exc->new_top > exc->stackSize )\r\r\n {\r\r\n exc->error = FT_THROW( Stack_Overflow );\r\r\n goto LErrorLabel_;\r\r\n }\r\r\n\r\r\n exc->step_ins = TRUE;\r\r\n exc->error = FT_Err_Ok;\r\r\n\r\r\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\r\r\n\r\r\n if ( SUBPIXEL_HINTING_INFINALITY )\r\r\n {\r\r\n for ( i = 0; i < opcode_patterns; i++ )\r\r\n {\r\r\n if ( opcode_pointer[i] < opcode_size[i] &&\r\r\n exc->opcode == opcode_pattern[i][opcode_pointer[i]] )\r\r\n {\r\r\n opcode_pointer[i] += 1;\r\r\n\r\r\n if ( opcode_pointer[i] == opcode_size[i] )\r\r\n {\r\r\n FT_TRACE6(( \"sph: opcode ptrn: %d, %s %s\\n\",\r\r\n i,\r\r\n exc->face->root.family_name,\r\r\n exc->face->root.style_name ));\r\r\n\r\r\n switch ( i )\r\r\n {\r\r\n case 0:\r\r\n break;\r\r\n }\r\r\n opcode_pointer[i] = 0;\r\r\n }\r\r\n }\r\r\n else\r\r\n opcode_pointer[i] = 0;\r\r\n }\r\r\n }\r\r\n\r\r\n#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */\r\r\n\r\r\n {\r\r\n FT_Long* args = exc->stack + exc->args;\r\r\n FT_Byte opcode = exc->opcode;\r\r\n\r\r\n\r\r\n switch ( opcode )\r\r\n {\r\r\n case 0x00: /* SVTCA y */\r\r\n case 0x01: /* SVTCA x */\r\r\n case 0x02: /* SPvTCA y */\r\r\n case 0x03: /* SPvTCA x */\r\r\n case 0x04: /* SFvTCA y */\r\r\n case 0x05: /* SFvTCA x */\r\r\n Ins_SxyTCA( exc );\r\r\n break;\r\r\n\r\r\n case 0x06: /* SPvTL // */\r\r\n case 0x07: /* SPvTL + */\r\r\n Ins_SPVTL( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x08: /* SFvTL // */\r\r\n case 0x09: /* SFvTL + */\r\r\n Ins_SFVTL( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x0A: /* SPvFS */\r\r\n Ins_SPVFS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x0B: /* SFvFS */\r\r\n Ins_SFVFS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x0C: /* GPv */\r\r\n Ins_GPV( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x0D: /* GFv */\r\r\n Ins_GFV( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x0E: /* SFvTPv */\r\r\n Ins_SFVTPV( exc );\r\r\n break;\r\r\n\r\r\n case 0x0F: /* ISECT */\r\r\n Ins_ISECT( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x10: /* SRP0 */\r\r\n Ins_SRP0( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x11: /* SRP1 */\r\r\n Ins_SRP1( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x12: /* SRP2 */\r\r\n Ins_SRP2( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x13: /* SZP0 */\r\r\n Ins_SZP0( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x14: /* SZP1 */\r\r\n Ins_SZP1( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x15: /* SZP2 */\r\r\n Ins_SZP2( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x16: /* SZPS */\r\r\n Ins_SZPS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x17: /* SLOOP */\r\r\n Ins_SLOOP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x18: /* RTG */\r\r\n Ins_RTG( exc );\r\r\n break;\r\r\n\r\r\n case 0x19: /* RTHG */\r\r\n Ins_RTHG( exc );\r\r\n break;\r\r\n\r\r\n case 0x1A: /* SMD */\r\r\n Ins_SMD( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x1B: /* ELSE */\r\r\n Ins_ELSE( exc );\r\r\n break;\r\r\n\r\r\n case 0x1C: /* JMPR */\r\r\n Ins_JMPR( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x1D: /* SCVTCI */\r\r\n Ins_SCVTCI( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x1E: /* SSWCI */\r\r\n Ins_SSWCI( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x1F: /* SSW */\r\r\n Ins_SSW( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x20: /* DUP */\r\r\n Ins_DUP( args );\r\r\n break;\r\r\n\r\r\n case 0x21: /* POP */\r\r\n Ins_POP();\r\r\n break;\r\r\n\r\r\n case 0x22: /* CLEAR */\r\r\n Ins_CLEAR( exc );\r\r\n break;\r\r\n\r\r\n case 0x23: /* SWAP */\r\r\n Ins_SWAP( args );\r\r\n break;\r\r\n\r\r\n case 0x24: /* DEPTH */\r\r\n Ins_DEPTH( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x25: /* CINDEX */\r\r\n Ins_CINDEX( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x26: /* MINDEX */\r\r\n Ins_MINDEX( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x27: /* ALIGNPTS */\r\r\n Ins_ALIGNPTS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x28: /* RAW */\r\r\n Ins_UNKNOWN( exc );\r\r\n break;\r\r\n\r\r\n case 0x29: /* UTP */\r\r\n Ins_UTP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x2A: /* LOOPCALL */\r\r\n Ins_LOOPCALL( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x2B: /* CALL */\r\r\n Ins_CALL( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x2C: /* FDEF */\r\r\n Ins_FDEF( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x2D: /* ENDF */\r\r\n Ins_ENDF( exc );\r\r\n break;\r\r\n\r\r\n case 0x2E: /* MDAP */\r\r\n case 0x2F: /* MDAP */\r\r\n Ins_MDAP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x30: /* IUP */\r\r\n case 0x31: /* IUP */\r\r\n Ins_IUP( exc );\r\r\n break;\r\r\n\r\r\n case 0x32: /* SHP */\r\r\n case 0x33: /* SHP */\r\r\n Ins_SHP( exc );\r\r\n break;\r\r\n\r\r\n case 0x34: /* SHC */\r\r\n case 0x35: /* SHC */\r\r\n Ins_SHC( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x36: /* SHZ */\r\r\n case 0x37: /* SHZ */\r\r\n Ins_SHZ( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x38: /* SHPIX */\r\r\n Ins_SHPIX( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x39: /* IP */\r\r\n Ins_IP( exc );\r\r\n break;\r\r\n\r\r\n case 0x3A: /* MSIRP */\r\r\n case 0x3B: /* MSIRP */\r\r\n Ins_MSIRP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x3C: /* AlignRP */\r\r\n Ins_ALIGNRP( exc );\r\r\n break;\r\r\n\r\r\n case 0x3D: /* RTDG */\r\r\n Ins_RTDG( exc );\r\r\n break;\r\r\n\r\r\n case 0x3E: /* MIAP */\r\r\n case 0x3F: /* MIAP */\r\r\n Ins_MIAP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x40: /* NPUSHB */\r\r\n Ins_NPUSHB( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x41: /* NPUSHW */\r\r\n Ins_NPUSHW( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x42: /* WS */\r\r\n Ins_WS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x43: /* RS */\r\r\n Ins_RS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x44: /* WCVTP */\r\r\n Ins_WCVTP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x45: /* RCVT */\r\r\n Ins_RCVT( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x46: /* GC */\r\r\n case 0x47: /* GC */\r\r\n Ins_GC( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x48: /* SCFS */\r\r\n Ins_SCFS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x49: /* MD */\r\r\n case 0x4A: /* MD */\r\r\n Ins_MD( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x4B: /* MPPEM */\r\r\n Ins_MPPEM( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x4C: /* MPS */\r\r\n Ins_MPS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x4D: /* FLIPON */\r\r\n Ins_FLIPON( exc );\r\r\n break;\r\r\n\r\r\n case 0x4E: /* FLIPOFF */\r\r\n Ins_FLIPOFF( exc );\r\r\n break;\r\r\n\r\r\n case 0x4F: /* DEBUG */\r\r\n Ins_DEBUG( exc );\r\r\n break;\r\r\n\r\r\n case 0x50: /* LT */\r\r\n Ins_LT( args );\r\r\n break;\r\r\n\r\r\n case 0x51: /* LTEQ */\r\r\n Ins_LTEQ( args );\r\r\n break;\r\r\n\r\r\n case 0x52: /* GT */\r\r\n Ins_GT( args );\r\r\n break;\r\r\n\r\r\n case 0x53: /* GTEQ */\r\r\n Ins_GTEQ( args );\r\r\n break;\r\r\n\r\r\n case 0x54: /* EQ */\r\r\n Ins_EQ( args );\r\r\n break;\r\r\n\r\r\n case 0x55: /* NEQ */\r\r\n Ins_NEQ( args );\r\r\n break;\r\r\n\r\r\n case 0x56: /* ODD */\r\r\n Ins_ODD( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x57: /* EVEN */\r\r\n Ins_EVEN( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x58: /* IF */\r\r\n Ins_IF( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x59: /* EIF */\r\r\n Ins_EIF();\r\r\n break;\r\r\n\r\r\n case 0x5A: /* AND */\r\r\n Ins_AND( args );\r\r\n break;\r\r\n\r\r\n case 0x5B: /* OR */\r\r\n Ins_OR( args );\r\r\n break;\r\r\n\r\r\n case 0x5C: /* NOT */\r\r\n Ins_NOT( args );\r\r\n break;\r\r\n\r\r\n case 0x5D: /* DELTAP1 */\r\r\n Ins_DELTAP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x5E: /* SDB */\r\r\n Ins_SDB( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x5F: /* SDS */\r\r\n Ins_SDS( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x60: /* ADD */\r\r\n Ins_ADD( args );\r\r\n break;\r\r\n\r\r\n case 0x61: /* SUB */\r\r\n Ins_SUB( args );\r\r\n break;\r\r\n\r\r\n case 0x62: /* DIV */\r\r\n Ins_DIV( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x63: /* MUL */\r\r\n Ins_MUL( args );\r\r\n break;\r\r\n\r\r\n case 0x64: /* ABS */\r\r\n Ins_ABS( args );\r\r\n break;\r\r\n\r\r\n case 0x65: /* NEG */\r\r\n Ins_NEG( args );\r\r\n break;\r\r\n\r\r\n case 0x66: /* FLOOR */\r\r\n Ins_FLOOR( args );\r\r\n break;\r\r\n\r\r\n case 0x67: /* CEILING */\r\r\n Ins_CEILING( args );\r\r\n break;\r\r\n\r\r\n case 0x68: /* ROUND */\r\r\n case 0x69: /* ROUND */\r\r\n case 0x6A: /* ROUND */\r\r\n case 0x6B: /* ROUND */\r\r\n Ins_ROUND( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x6C: /* NROUND */\r\r\n case 0x6D: /* NROUND */\r\r\n case 0x6E: /* NRRUND */\r\r\n case 0x6F: /* NROUND */\r\r\n Ins_NROUND( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x70: /* WCVTF */\r\r\n Ins_WCVTF( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x71: /* DELTAP2 */\r\r\n case 0x72: /* DELTAP3 */\r\r\n Ins_DELTAP( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x73: /* DELTAC0 */\r\r\n case 0x74: /* DELTAC1 */\r\r\n case 0x75: /* DELTAC2 */\r\r\n Ins_DELTAC( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x76: /* SROUND */\r\r\n Ins_SROUND( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x77: /* S45Round */\r\r\n Ins_S45ROUND( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x78: /* JROT */\r\r\n Ins_JROT( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x79: /* JROF */\r\r\n Ins_JROF( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x7A: /* ROFF */\r\r\n Ins_ROFF( exc );\r\r\n break;\r\r\n\r\r\n case 0x7B: /* ???? */\r\r\n Ins_UNKNOWN( exc );\r\r\n break;\r\r\n\r\r\n case 0x7C: /* RUTG */\r\r\n Ins_RUTG( exc );\r\r\n break;\r\r\n\r\r\n case 0x7D: /* RDTG */\r\r\n Ins_RDTG( exc );\r\r\n break;\r\r\n\r\r\n case 0x7E: /* SANGW */\r\r\n Ins_SANGW();\r\r\n break;\r\r\n\r\r\n case 0x7F: /* AA */\r\r\n Ins_AA();\r\r\n break;\r\r\n\r\r\n case 0x80: /* FLIPPT */\r\r\n Ins_FLIPPT( exc );\r\r\n break;\r\r\n\r\r\n case 0x81: /* FLIPRGON */\r\r\n Ins_FLIPRGON( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x82: /* FLIPRGOFF */\r\r\n Ins_FLIPRGOFF( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x83: /* UNKNOWN */\r\r\n case 0x84: /* UNKNOWN */\r\r\n Ins_UNKNOWN( exc );\r\r\n break;\r\r\n\r\r\n case 0x85: /* SCANCTRL */\r\r\n Ins_SCANCTRL( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x86: /* SDPvTL */\r\r\n case 0x87: /* SDPvTL */\r\r\n Ins_SDPVTL( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x88: /* GETINFO */\r\r\n Ins_GETINFO( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x89: /* IDEF */\r\r\n Ins_IDEF( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x8A: /* ROLL */\r\r\n Ins_ROLL( args );\r\r\n break;\r\r\n\r\r\n case 0x8B: /* MAX */\r\r\n Ins_MAX( args );\r\r\n break;\r\r\n\r\r\n case 0x8C: /* MIN */\r\r\n Ins_MIN( args );\r\r\n break;\r\r\n\r\r\n case 0x8D: /* SCANTYPE */\r\r\n Ins_SCANTYPE( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x8E: /* INSTCTRL */\r\r\n Ins_INSTCTRL( exc, args );\r\r\n break;\r\r\n\r\r\n case 0x8F: /* ADJUST */\r\r\n case 0x90: /* ADJUST */\r\r\n Ins_UNKNOWN( exc );\r\r\n break;\r\r\n\r\r\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\r\r\n case 0x91:\r\r\n /* it is the job of the application to `activate' GX handling, */\r\r\n /* this is, calling any of the GX API functions on the current */\r\r\n /* font to select a variation instance */\r\r\n if ( exc->face->blend )\r\r\n Ins_GETVARIATION( exc, args );\r\r\n else\r\r\n Ins_UNKNOWN( exc );\r\r\n break;\r\r\n\r\r\n case 0x92:\r\r\n /* there is at least one MS font (LaoUI.ttf version 5.01) that */\r\r\n /* uses IDEFs for 0x91 and 0x92; for this reason we activate */\r\r\n /* GETDATA for GX fonts only, similar to GETVARIATION */\r\r\n if ( exc->face->blend )\r\r\n Ins_GETDATA( args );\r\r\n else\r\r\n Ins_UNKNOWN( exc );\r\r\n break;\r\r\n#endif\r\r\n\r\r\n default:\r\r\n if ( opcode >= 0xE0 )\r\r\n Ins_MIRP( exc, args );\r\r\n else if ( opcode >= 0xC0 )\r\r\n Ins_MDRP( exc, args );\r\r\n else if ( opcode >= 0xB8 )\r\r\n Ins_PUSHW( exc, args );\r\r\n else if ( opcode >= 0xB0 )\r\r\n Ins_PUSHB( exc, args );\r\r\n else\r\r\n Ins_UNKNOWN( exc );\r\r\n }\r\r\n }\r\r\n\r\r\n if ( exc->error )\r\r\n {\r\r\n switch ( exc->error )\r\r\n {\r\r\n /* looking for redefined instructions */\r\r\n case FT_ERR( Invalid_Opcode ):\r\r\n {\r\r\n TT_DefRecord* def = exc->IDefs;\r\r\n TT_DefRecord* limit = def + exc->numIDefs;\r\r\n\r\r\n\r\r\n for ( ; def < limit; def++ )\r\r\n {\r\r\n if ( def->active && exc->opcode == (FT_Byte)def->opc )\r\r\n {\r\r\n TT_CallRec* callrec;\r\r\n\r\r\n\r\r\n if ( exc->callTop >= exc->callSize )\r\r\n {\r\r\n exc->error = FT_THROW( Invalid_Reference );\r\r\n goto LErrorLabel_;\r\r\n }\r\r\n\r\r\n callrec = &exc->callStack[exc->callTop];\r\r\n\r\r\n callrec->Caller_Range = exc->curRange;\r\r\n callrec->Caller_IP = exc->IP + 1;\r\r\n callrec->Cur_Count = 1;\r\r\n callrec->Def = def;\r\r\n\r\r\n if ( Ins_Goto_CodeRange( exc,\r\r\n def->range,\r\r\n def->start ) == FAILURE )\r\r\n goto LErrorLabel_;\r\r\n\r\r\n goto LSuiteLabel_;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n exc->error = FT_THROW( Invalid_Opcode );\r\r\n goto LErrorLabel_;\r\r\n\r\r\n#if 0\r\r\n break; /* Unreachable code warning suppression. */\r\r\n /* Leave to remind in case a later change the editor */\r\r\n /* to consider break; */\r\r\n#endif\r\r\n\r\r\n default:\r\r\n goto LErrorLabel_;\r\r\n\r\r\n#if 0\r\r\n break;\r\r\n#endif\r\r\n }\r\r\n }\r\r\n\r\r\n exc->top = exc->new_top;\r\r\n\r\r\n if ( exc->step_ins )\r\r\n exc->IP += exc->length;\r\r\n\r\r\n /* increment instruction counter and check if we didn't */\r\r\n /* run this program for too long (e.g. infinite loops). */\r\r\n if ( ++ins_counter > TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES )\r\r\n return FT_THROW( Execution_Too_Long );\r\r\n\r\r\n LSuiteLabel_:\r\r\n if ( exc->IP >= exc->codeSize )\r\r\n {\r\r\n if ( exc->callTop > 0 )\r\r\n {\r\r\n exc->error = FT_THROW( Code_Overflow );\r\r\n goto LErrorLabel_;\r\r\n }\r\r\n else\r\r\n goto LNo_Error_;\r\r\n }\r\r\n } while ( !exc->instruction_trap );\r\r\n\r\r\n LNo_Error_:\r\r\n FT_TRACE4(( \" %d instruction%s executed\\n\",\r\r\n ins_counter == 1 ? \"\" : \"s\",\r\r\n ins_counter ));\r\r\n return FT_Err_Ok;\r\r\n\r\r\n LErrorCodeOverflow_:\r\r\n exc->error = FT_THROW( Code_Overflow );\r\r\n\r\r\n LErrorLabel_:\r\r\n if ( exc->error && !exc->instruction_trap )\r\r\n FT_TRACE1(( \" The interpreter returned error 0x%x\\n\", exc->error ));\r\r\n\r\r\n return exc->error;\r\r\n }\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\r\r\n const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\r\r\n{\r\r\n char\r\r\n im_vers[32],\r\r\n libpng_runv[32],\r\r\n libpng_vers[32],\r\r\n zlib_runv[32],\r\r\n zlib_vers[32];\r\r\n\r\r\n Image\r\r\n *image;\r\r\n\r\r\n ImageInfo\r\r\n *image_info;\r\r\n\r\r\n char\r\r\n s[2];\r\r\n\r\r\n const char\r\r\n *name,\r\r\n *property,\r\r\n *value;\r\r\n\r\r\n const StringInfo\r\r\n *profile;\r\r\n\r\r\n int\r\r\n num_passes,\r\r\n pass,\r\r\n ping_wrote_caNv;\r\r\n\r\r\n png_byte\r\r\n ping_trans_alpha[256];\r\r\n\r\r\n png_color\r\r\n palette[257];\r\r\n\r\r\n png_color_16\r\r\n ping_background,\r\r\n ping_trans_color;\r\r\n\r\r\n png_info\r\r\n *ping_info;\r\r\n\r\r\n png_struct\r\r\n *ping;\r\r\n\r\r\n png_uint_32\r\r\n ping_height,\r\r\n ping_width;\r\r\n\r\r\n ssize_t\r\r\n y;\r\r\n\r\r\n MagickBooleanType\r\r\n image_matte,\r\r\n logging,\r\r\n matte,\r\r\n\r\r\n ping_have_blob,\r\r\n ping_have_cheap_transparency,\r\r\n ping_have_color,\r\r\n ping_have_non_bw,\r\r\n ping_have_PLTE,\r\r\n ping_have_bKGD,\r\r\n ping_have_eXIf,\r\r\n ping_have_iCCP,\r\r\n ping_have_pHYs,\r\r\n ping_have_sRGB,\r\r\n ping_have_tRNS,\r\r\n\r\r\n ping_exclude_bKGD,\r\r\n ping_exclude_cHRM,\r\r\n ping_exclude_date,\r\r\n /* ping_exclude_EXIF, */\r\r\n ping_exclude_eXIf,\r\r\n ping_exclude_gAMA,\r\r\n ping_exclude_iCCP,\r\r\n /* ping_exclude_iTXt, */\r\r\n ping_exclude_oFFs,\r\r\n ping_exclude_pHYs,\r\r\n ping_exclude_sRGB,\r\r\n ping_exclude_tEXt,\r\r\n ping_exclude_tIME,\r\r\n /* ping_exclude_tRNS, */\r\r\n ping_exclude_caNv,\r\r\n ping_exclude_zCCP, /* hex-encoded iCCP */\r\r\n ping_exclude_zTXt,\r\r\n\r\r\n ping_preserve_colormap,\r\r\n ping_preserve_iCCP,\r\r\n ping_need_colortype_warning,\r\r\n\r\r\n status,\r\r\n tried_332,\r\r\n tried_333,\r\r\n tried_444;\r\r\n\r\r\n MemoryInfo\r\r\n *volatile pixel_info;\r\r\n\r\r\n QuantumInfo\r\r\n *quantum_info;\r\r\n\r\r\n PNGErrorInfo\r\r\n error_info;\r\r\n\r\r\n register ssize_t\r\r\n i,\r\r\n x;\r\r\n\r\r\n unsigned char\r\r\n *ping_pixels;\r\r\n\r\r\n volatile int\r\r\n image_colors,\r\r\n ping_bit_depth,\r\r\n ping_color_type,\r\r\n ping_interlace_method,\r\r\n ping_compression_method,\r\r\n ping_filter_method,\r\r\n ping_num_trans;\r\r\n\r\r\n volatile size_t\r\r\n image_depth,\r\r\n old_bit_depth;\r\r\n\r\r\n size_t\r\r\n quality,\r\r\n rowbytes,\r\r\n save_image_depth;\r\r\n\r\r\n int\r\r\n j,\r\r\n number_colors,\r\r\n number_opaque,\r\r\n number_semitransparent,\r\r\n number_transparent,\r\r\n ping_pHYs_unit_type;\r\r\n\r\r\n png_uint_32\r\r\n ping_pHYs_x_resolution,\r\r\n ping_pHYs_y_resolution;\r\r\n\r\r\n logging=LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Enter WriteOnePNGImage()\");\r\r\n\r\r\n image = CloneImage(IMimage,0,0,MagickFalse,exception);\r\r\n if (image == (Image *) NULL)\r\r\n return(MagickFalse);\r\r\n image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\r\r\n\r\r\n /* Define these outside of the following \"if logging()\" block so they will\r\r\n * show in debuggers.\r\r\n */\r\r\n *im_vers='\\0';\r\r\n (void) ConcatenateMagickString(im_vers,\r\r\n MagickLibVersionText,MagickPathExtent);\r\r\n (void) ConcatenateMagickString(im_vers,\r\r\n MagickLibAddendum,MagickPathExtent);\r\r\n\r\r\n *libpng_vers='\\0';\r\r\n (void) ConcatenateMagickString(libpng_vers,\r\r\n PNG_LIBPNG_VER_STRING,32);\r\r\n *libpng_runv='\\0';\r\r\n (void) ConcatenateMagickString(libpng_runv,\r\r\n png_get_libpng_ver(NULL),32);\r\r\n\r\r\n *zlib_vers='\\0';\r\r\n (void) ConcatenateMagickString(zlib_vers,\r\r\n ZLIB_VERSION,32);\r\r\n *zlib_runv='\\0';\r\r\n (void) ConcatenateMagickString(zlib_runv,\r\r\n zlib_version,32);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" IM version = %s\", im_vers);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Libpng version = %s\", libpng_vers);\r\r\n if (LocaleCompare(libpng_vers,libpng_runv) != 0)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" running with %s\", libpng_runv);\r\r\n }\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Zlib version = %s\", zlib_vers);\r\r\n if (LocaleCompare(zlib_vers,zlib_runv) != 0)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" running with %s\", zlib_runv);\r\r\n }\r\r\n }\r\r\n\r\r\n /* Initialize some stuff */\r\r\n ping_bit_depth=0,\r\r\n ping_color_type=0,\r\r\n ping_interlace_method=0,\r\r\n ping_compression_method=0,\r\r\n ping_filter_method=0,\r\r\n ping_num_trans = 0;\r\r\n\r\r\n ping_background.red = 0;\r\r\n ping_background.green = 0;\r\r\n ping_background.blue = 0;\r\r\n ping_background.gray = 0;\r\r\n ping_background.index = 0;\r\r\n\r\r\n ping_trans_color.red=0;\r\r\n ping_trans_color.green=0;\r\r\n ping_trans_color.blue=0;\r\r\n ping_trans_color.gray=0;\r\r\n\r\r\n ping_pHYs_unit_type = 0;\r\r\n ping_pHYs_x_resolution = 0;\r\r\n ping_pHYs_y_resolution = 0;\r\r\n\r\r\n ping_have_blob=MagickFalse;\r\r\n ping_have_cheap_transparency=MagickFalse;\r\r\n ping_have_color=MagickTrue;\r\r\n ping_have_non_bw=MagickTrue;\r\r\n ping_have_PLTE=MagickFalse;\r\r\n ping_have_bKGD=MagickFalse;\r\r\n ping_have_eXIf=MagickTrue;\r\r\n ping_have_iCCP=MagickFalse;\r\r\n ping_have_pHYs=MagickFalse;\r\r\n ping_have_sRGB=MagickFalse;\r\r\n ping_have_tRNS=MagickFalse;\r\r\n\r\r\n ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\r\r\n ping_exclude_caNv=mng_info->ping_exclude_caNv;\r\r\n ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\r\r\n ping_exclude_date=mng_info->ping_exclude_date;\r\r\n ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\r\r\n ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\r\r\n ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\r\r\n /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\r\r\n ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\r\r\n ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\r\r\n ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\r\r\n ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\r\r\n ping_exclude_tIME=mng_info->ping_exclude_tIME;\r\r\n /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\r\r\n ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\r\r\n ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\r\r\n\r\r\n ping_preserve_colormap = mng_info->ping_preserve_colormap;\r\r\n ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\r\r\n ping_need_colortype_warning = MagickFalse;\r\r\n\r\r\n /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\r\r\n * i.e., eliminate the ICC profile and set image->rendering_intent.\r\r\n * Note that this will not involve any changes to the actual pixels\r\r\n * but merely passes information to applications that read the resulting\r\r\n * PNG image.\r\r\n *\r\r\n * To do: recognize other variants of the sRGB profile, using the CRC to\r\r\n * verify all recognized variants including the 7 already known.\r\r\n *\r\r\n * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\r\r\n *\r\r\n * Use something other than image->rendering_intent to record the fact\r\r\n * that the sRGB profile was found.\r\r\n *\r\r\n * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\r\r\n * profile. Record the Blackpoint Compensation, if any.\r\r\n */\r\r\n if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\r\r\n {\r\r\n char\r\r\n *name;\r\r\n\r\r\n const StringInfo\r\r\n *profile;\r\r\n\r\r\n ResetImageProfileIterator(image);\r\r\n for (name=GetNextImageProfile(image); name != (const char *) NULL; )\r\r\n {\r\r\n profile=GetImageProfile(image,name);\r\r\n\r\r\n if (profile != (StringInfo *) NULL)\r\r\n {\r\r\n if ((LocaleCompare(name,\"ICC\") == 0) ||\r\r\n (LocaleCompare(name,\"ICM\") == 0))\r\r\n\r\r\n {\r\r\n int\r\r\n icheck,\r\r\n got_crc=0;\r\r\n\r\r\n\r\r\n png_uint_32\r\r\n length,\r\r\n profile_crc=0;\r\r\n\r\r\n unsigned char\r\r\n *data;\r\r\n\r\r\n length=(png_uint_32) GetStringInfoLength(profile);\r\r\n\r\r\n for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\r\r\n {\r\r\n if (length == sRGB_info[icheck].len)\r\r\n {\r\r\n if (got_crc == 0)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Got a %lu-byte ICC profile (potentially sRGB)\",\r\r\n (unsigned long) length);\r\r\n\r\r\n data=GetStringInfoDatum(profile);\r\r\n profile_crc=crc32(0,data,length);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" with crc=%8x\",(unsigned int) profile_crc);\r\r\n got_crc++;\r\r\n }\r\r\n\r\r\n if (profile_crc == sRGB_info[icheck].crc)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" It is sRGB with rendering intent = %s\",\r\r\n Magick_RenderingIntentString_from_PNG_RenderingIntent(\r\r\n sRGB_info[icheck].intent));\r\r\n if (image->rendering_intent==UndefinedIntent)\r\r\n {\r\r\n image->rendering_intent=\r\r\n Magick_RenderingIntent_from_PNG_RenderingIntent(\r\r\n sRGB_info[icheck].intent);\r\r\n }\r\r\n ping_exclude_iCCP = MagickTrue;\r\r\n ping_exclude_zCCP = MagickTrue;\r\r\n ping_have_sRGB = MagickTrue;\r\r\n break;\r\r\n }\r\r\n }\r\r\n }\r\r\n if (sRGB_info[icheck].len == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Got %lu-byte ICC profile not recognized as sRGB\",\r\r\n (unsigned long) length);\r\r\n }\r\r\n }\r\r\n name=GetNextImageProfile(image);\r\r\n }\r\r\n }\r\r\n\r\r\n number_opaque = 0;\r\r\n number_semitransparent = 0;\r\r\n number_transparent = 0;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n if (image->storage_class == UndefinedClass)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->storage_class=UndefinedClass\");\r\r\n if (image->storage_class == DirectClass)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->storage_class=DirectClass\");\r\r\n if (image->storage_class == PseudoClass)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->storage_class=PseudoClass\");\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\r\r\n \" image->taint=MagickTrue\":\r\r\n \" image->taint=MagickFalse\");\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->gamma=%g\", image->gamma);\r\r\n }\r\r\n\r\r\n if (image->storage_class == PseudoClass &&\r\r\n (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\r\r\n mng_info->write_png48 || mng_info->write_png64 ||\r\r\n (mng_info->write_png_colortype != 1 &&\r\r\n mng_info->write_png_colortype != 5)))\r\r\n {\r\r\n (void) SyncImage(image,exception);\r\r\n image->storage_class = DirectClass;\r\r\n }\r\r\n\r\r\n if (ping_preserve_colormap == MagickFalse)\r\r\n {\r\r\n if (image->storage_class != PseudoClass && image->colormap != NULL)\r\r\n {\r\r\n /* Free the bogus colormap; it can cause trouble later */\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Freeing bogus colormap\");\r\r\n (void) RelinquishMagickMemory(image->colormap);\r\r\n image->colormap=NULL;\r\r\n }\r\r\n }\r\r\n\r\r\n if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\r\r\n (void) TransformImageColorspace(image,sRGBColorspace,exception);\r\r\n\r\r\n /*\r\r\n Sometimes we get PseudoClass images whose RGB values don't match\r\r\n the colors in the colormap. This code syncs the RGB values.\r\r\n */\r\r\n if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\r\r\n (void) SyncImage(image,exception);\r\r\n\r\r\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\r\r\n if (image->depth > 8)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Reducing PNG bit depth to 8 since this is a Q8 build.\");\r\r\n\r\r\n image->depth=8;\r\r\n }\r\r\n#endif\r\r\n\r\r\n /* Respect the -depth option */\r\r\n if (image->depth < 4)\r\r\n {\r\r\n register Quantum\r\r\n *r;\r\r\n\r\r\n if (image->depth > 2)\r\r\n {\r\r\n /* Scale to 4-bit */\r\r\n LBR04PacketRGBA(image->background_color);\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n LBR04PixelRGBA(r);\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n\r\r\n if (image->storage_class == PseudoClass && image->colormap != NULL)\r\r\n {\r\r\n for (i=0; i < (ssize_t) image->colors; i++)\r\r\n {\r\r\n LBR04PacketRGBA(image->colormap[i]);\r\r\n }\r\r\n }\r\r\n }\r\r\n else if (image->depth > 1)\r\r\n {\r\r\n /* Scale to 2-bit */\r\r\n LBR02PacketRGBA(image->background_color);\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n LBR02PixelRGBA(r);\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n\r\r\n if (image->storage_class == PseudoClass && image->colormap != NULL)\r\r\n {\r\r\n for (i=0; i < (ssize_t) image->colors; i++)\r\r\n {\r\r\n LBR02PacketRGBA(image->colormap[i]);\r\r\n }\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n /* Scale to 1-bit */\r\r\n LBR01PacketRGBA(image->background_color);\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n LBR01PixelRGBA(r);\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n\r\r\n if (image->storage_class == PseudoClass && image->colormap != NULL)\r\r\n {\r\r\n for (i=0; i < (ssize_t) image->colors; i++)\r\r\n {\r\r\n LBR01PacketRGBA(image->colormap[i]);\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n /* To do: set to next higher multiple of 8 */\r\r\n if (image->depth < 8)\r\r\n image->depth=8;\r\r\n\r\r\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\r\r\n /* PNG does not handle depths greater than 16 so reduce it even\r\r\n * if lossy\r\r\n */\r\r\n if (image->depth > 8)\r\r\n image->depth=16;\r\r\n#endif\r\r\n\r\r\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\r\r\n if (image->depth > 8)\r\r\n {\r\r\n /* To do: fill low byte properly */\r\r\n image->depth=16;\r\r\n }\r\r\n\r\r\n if (image->depth == 16 && mng_info->write_png_depth != 16)\r\r\n if (mng_info->write_png8 ||\r\r\n LosslessReduceDepthOK(image,exception) != MagickFalse)\r\r\n image->depth = 8;\r\r\n#endif\r\r\n\r\r\n image_colors = (int) image->colors;\r\r\n number_opaque = (int) image->colors;\r\r\n number_transparent = 0;\r\r\n number_semitransparent = 0;\r\r\n\r\r\n if (mng_info->write_png_colortype &&\r\r\n (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\r\r\n mng_info->write_png_colortype < 4 &&\r\r\n image->alpha_trait == UndefinedPixelTrait)))\r\r\n {\r\r\n /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\r\r\n * are not going to need the result.\r\r\n */\r\r\n if (mng_info->write_png_colortype == 1 ||\r\r\n mng_info->write_png_colortype == 5)\r\r\n ping_have_color=MagickFalse;\r\r\n\r\r\n if (image->alpha_trait != UndefinedPixelTrait)\r\r\n {\r\r\n number_transparent = 2;\r\r\n number_semitransparent = 1;\r\r\n }\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_colortype < 7)\r\r\n {\r\r\n /* BUILD_PALETTE\r\r\n *\r\r\n * Normally we run this just once, but in the case of writing PNG8\r\r\n * we reduce the transparency to binary and run again, then if there\r\r\n * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\r\r\n * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\r\r\n * palette. Then (To do) we take care of a final reduction that is only\r\r\n * needed if there are still 256 colors present and one of them has both\r\r\n * transparent and opaque instances.\r\r\n */\r\r\n\r\r\n tried_332 = MagickFalse;\r\r\n tried_333 = MagickFalse;\r\r\n tried_444 = MagickFalse;\r\r\n\r\r\n for (j=0; j<6; j++)\r\r\n {\r\r\n /*\r\r\n * Sometimes we get DirectClass images that have 256 colors or fewer.\r\r\n * This code will build a colormap.\r\r\n *\r\r\n * Also, sometimes we get PseudoClass images with an out-of-date\r\r\n * colormap. This code will replace the colormap with a new one.\r\r\n * Sometimes we get PseudoClass images that have more than 256 colors.\r\r\n * This code will delete the colormap and change the image to\r\r\n * DirectClass.\r\r\n *\r\r\n * If image->alpha_trait is MagickFalse, we ignore the alpha channel\r\r\n * even though it sometimes contains left-over non-opaque values.\r\r\n *\r\r\n * Also we gather some information (number of opaque, transparent,\r\r\n * and semitransparent pixels, and whether the image has any non-gray\r\r\n * pixels or only black-and-white pixels) that we might need later.\r\r\n *\r\r\n * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\r\r\n * we need to check for bogus non-opaque values, at least.\r\r\n */\r\r\n\r\r\n int\r\r\n n;\r\r\n\r\r\n PixelInfo\r\r\n opaque[260],\r\r\n semitransparent[260],\r\r\n transparent[260];\r\r\n\r\r\n register const Quantum\r\r\n *s;\r\r\n\r\r\n register Quantum\r\r\n *q,\r\r\n *r;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Enter BUILD_PALETTE:\");\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->columns=%.20g\",(double) image->columns);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->rows=%.20g\",(double) image->rows);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->alpha_trait=%.20g\",(double) image->alpha_trait);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->depth=%.20g\",(double) image->depth);\r\r\n\r\r\n if (image->storage_class == PseudoClass && image->colormap != NULL)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Original colormap:\");\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" i (red,green,blue,alpha)\");\r\r\n\r\r\n for (i=0; i < 256; i++)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" %d (%d,%d,%d,%d)\",\r\r\n (int) i,\r\r\n (int) image->colormap[i].red,\r\r\n (int) image->colormap[i].green,\r\r\n (int) image->colormap[i].blue,\r\r\n (int) image->colormap[i].alpha);\r\r\n }\r\r\n\r\r\n for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\r\r\n {\r\r\n if (i > 255)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" %d (%d,%d,%d,%d)\",\r\r\n (int) i,\r\r\n (int) image->colormap[i].red,\r\r\n (int) image->colormap[i].green,\r\r\n (int) image->colormap[i].blue,\r\r\n (int) image->colormap[i].alpha);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->colors=%d\",(int) image->colors);\r\r\n\r\r\n if (image->colors == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" (zero means unknown)\");\r\r\n\r\r\n if (ping_preserve_colormap == MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Regenerate the colormap\");\r\r\n }\r\r\n\r\r\n image_colors=0;\r\r\n number_opaque = 0;\r\r\n number_semitransparent = 0;\r\r\n number_transparent = 0;\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (q == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (image->alpha_trait == UndefinedPixelTrait ||\r\r\n GetPixelAlpha(image,q) == OpaqueAlpha)\r\r\n {\r\r\n if (number_opaque < 259)\r\r\n {\r\r\n if (number_opaque == 0)\r\r\n {\r\r\n GetPixelInfoPixel(image, q, opaque);\r\r\n opaque[0].alpha=OpaqueAlpha;\r\r\n number_opaque=1;\r\r\n }\r\r\n\r\r\n for (i=0; i< (ssize_t) number_opaque; i++)\r\r\n {\r\r\n if (IsColorEqual(image,q,opaque+i))\r\r\n break;\r\r\n }\r\r\n\r\r\n if (i == (ssize_t) number_opaque && number_opaque < 259)\r\r\n {\r\r\n number_opaque++;\r\r\n GetPixelInfoPixel(image, q, opaque+i);\r\r\n opaque[i].alpha=OpaqueAlpha;\r\r\n }\r\r\n }\r\r\n }\r\r\n else if (GetPixelAlpha(image,q) == TransparentAlpha)\r\r\n {\r\r\n if (number_transparent < 259)\r\r\n {\r\r\n if (number_transparent == 0)\r\r\n {\r\r\n GetPixelInfoPixel(image, q, transparent);\r\r\n ping_trans_color.red=(unsigned short)\r\r\n GetPixelRed(image,q);\r\r\n ping_trans_color.green=(unsigned short)\r\r\n GetPixelGreen(image,q);\r\r\n ping_trans_color.blue=(unsigned short)\r\r\n GetPixelBlue(image,q);\r\r\n ping_trans_color.gray=(unsigned short)\r\r\n GetPixelGray(image,q);\r\r\n number_transparent = 1;\r\r\n }\r\r\n\r\r\n for (i=0; i< (ssize_t) number_transparent; i++)\r\r\n {\r\r\n if (IsColorEqual(image,q,transparent+i))\r\r\n break;\r\r\n }\r\r\n\r\r\n if (i == (ssize_t) number_transparent &&\r\r\n number_transparent < 259)\r\r\n {\r\r\n number_transparent++;\r\r\n GetPixelInfoPixel(image,q,transparent+i);\r\r\n }\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n if (number_semitransparent < 259)\r\r\n {\r\r\n if (number_semitransparent == 0)\r\r\n {\r\r\n GetPixelInfoPixel(image,q,semitransparent);\r\r\n number_semitransparent = 1;\r\r\n }\r\r\n\r\r\n for (i=0; i< (ssize_t) number_semitransparent; i++)\r\r\n {\r\r\n if (IsColorEqual(image,q,semitransparent+i)\r\r\n && GetPixelAlpha(image,q) ==\r\r\n semitransparent[i].alpha)\r\r\n break;\r\r\n }\r\r\n\r\r\n if (i == (ssize_t) number_semitransparent &&\r\r\n number_semitransparent < 259)\r\r\n {\r\r\n number_semitransparent++;\r\r\n GetPixelInfoPixel(image, q, semitransparent+i);\r\r\n }\r\r\n }\r\r\n }\r\r\n q+=GetPixelChannels(image);\r\r\n }\r\r\n }\r\r\n\r\r\n if (mng_info->write_png8 == MagickFalse &&\r\r\n ping_exclude_bKGD == MagickFalse)\r\r\n {\r\r\n /* Add the background color to the palette, if it\r\r\n * isn't already there.\r\r\n */\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Check colormap for background (%d,%d,%d)\",\r\r\n (int) image->background_color.red,\r\r\n (int) image->background_color.green,\r\r\n (int) image->background_color.blue);\r\r\n }\r\r\n for (i=0; i<number_opaque; i++)\r\r\n {\r\r\n if (opaque[i].red == image->background_color.red &&\r\r\n opaque[i].green == image->background_color.green &&\r\r\n opaque[i].blue == image->background_color.blue)\r\r\n break;\r\r\n }\r\r\n if (number_opaque < 259 && i == number_opaque)\r\r\n {\r\r\n opaque[i] = image->background_color;\r\r\n ping_background.index = i;\r\r\n number_opaque++;\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" background_color index is %d\",(int) i);\r\r\n }\r\r\n\r\r\n }\r\r\n else if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" No room in the colormap to add background color\");\r\r\n }\r\r\n\r\r\n image_colors=number_opaque+number_transparent+number_semitransparent;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n if (image_colors > 256)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image has more than 256 colors\");\r\r\n\r\r\n else\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image has %d colors\",image_colors);\r\r\n }\r\r\n\r\r\n if (ping_preserve_colormap != MagickFalse)\r\r\n break;\r\r\n\r\r\n if (mng_info->write_png_colortype != 7) /* We won't need this info */\r\r\n {\r\r\n ping_have_color=MagickFalse;\r\r\n ping_have_non_bw=MagickFalse;\r\r\n\r\r\n if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \"incompatible colorspace\");\r\r\n ping_have_color=MagickTrue;\r\r\n ping_have_non_bw=MagickTrue;\r\r\n }\r\r\n\r\r\n if(image_colors > 256)\r\r\n {\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (q == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n s=q;\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\r\r\n GetPixelRed(image,s) != GetPixelBlue(image,s))\r\r\n {\r\r\n ping_have_color=MagickTrue;\r\r\n ping_have_non_bw=MagickTrue;\r\r\n break;\r\r\n }\r\r\n s+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (ping_have_color != MagickFalse)\r\r\n break;\r\r\n\r\r\n /* Worst case is black-and-white; we are looking at every\r\r\n * pixel twice.\r\r\n */\r\r\n\r\r\n if (ping_have_non_bw == MagickFalse)\r\r\n {\r\r\n s=q;\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (GetPixelRed(image,s) != 0 &&\r\r\n GetPixelRed(image,s) != QuantumRange)\r\r\n {\r\r\n ping_have_non_bw=MagickTrue;\r\r\n break;\r\r\n }\r\r\n s+=GetPixelChannels(image);\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (image_colors < 257)\r\r\n {\r\r\n PixelInfo\r\r\n colormap[260];\r\r\n\r\r\n /*\r\r\n * Initialize image colormap.\r\r\n */\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Sort the new colormap\");\r\r\n\r\r\n /* Sort palette, transparent first */;\r\r\n\r\r\n n = 0;\r\r\n\r\r\n for (i=0; i<number_transparent; i++)\r\r\n colormap[n++] = transparent[i];\r\r\n\r\r\n for (i=0; i<number_semitransparent; i++)\r\r\n colormap[n++] = semitransparent[i];\r\r\n\r\r\n for (i=0; i<number_opaque; i++)\r\r\n colormap[n++] = opaque[i];\r\r\n\r\r\n ping_background.index +=\r\r\n (number_transparent + number_semitransparent);\r\r\n\r\r\n /* image_colors < 257; search the colormap instead of the pixels\r\r\n * to get ping_have_color and ping_have_non_bw\r\r\n */\r\r\n for (i=0; i<n; i++)\r\r\n {\r\r\n if (ping_have_color == MagickFalse)\r\r\n {\r\r\n if (colormap[i].red != colormap[i].green ||\r\r\n colormap[i].red != colormap[i].blue)\r\r\n {\r\r\n ping_have_color=MagickTrue;\r\r\n ping_have_non_bw=MagickTrue;\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n if (ping_have_non_bw == MagickFalse)\r\r\n {\r\r\n if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\r\r\n ping_have_non_bw=MagickTrue;\r\r\n }\r\r\n }\r\r\n\r\r\n if ((mng_info->ping_exclude_tRNS == MagickFalse ||\r\r\n (number_transparent == 0 && number_semitransparent == 0)) &&\r\r\n (((mng_info->write_png_colortype-1) ==\r\r\n PNG_COLOR_TYPE_PALETTE) ||\r\r\n (mng_info->write_png_colortype == 0)))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n if (n != (ssize_t) image_colors)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image_colors (%d) and n (%d) don't match\",\r\r\n image_colors, n);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" AcquireImageColormap\");\r\r\n }\r\r\n\r\r\n image->colors = image_colors;\r\r\n\r\r\n if (AcquireImageColormap(image,image_colors,exception) == MagickFalse)\r\r\n {\r\r\n (void) ThrowMagickException(exception,GetMagickModule(),\r\r\n ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\r\r\n image->filename);\r\r\n break;\r\r\n }\r\r\n\r\r\n for (i=0; i< (ssize_t) image_colors; i++)\r\r\n image->colormap[i] = colormap[i];\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->colors=%d (%d)\",\r\r\n (int) image->colors, image_colors);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Update the pixel indexes\");\r\r\n }\r\r\n\r\r\n /* Sync the pixel indices with the new colormap */\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (q == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n for (i=0; i< (ssize_t) image_colors; i++)\r\r\n {\r\r\n if ((image->alpha_trait == UndefinedPixelTrait ||\r\r\n image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\r\r\n image->colormap[i].red == GetPixelRed(image,q) &&\r\r\n image->colormap[i].green == GetPixelGreen(image,q) &&\r\r\n image->colormap[i].blue == GetPixelBlue(image,q))\r\r\n {\r\r\n SetPixelIndex(image,i,q);\r\r\n break;\r\r\n }\r\r\n }\r\r\n q+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->colors=%d\", (int) image->colors);\r\r\n\r\r\n if (image->colormap != NULL)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" i (red,green,blue,alpha)\");\r\r\n\r\r\n for (i=0; i < (ssize_t) image->colors; i++)\r\r\n {\r\r\n if (i < 300 || i >= (ssize_t) image->colors - 10)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" %d (%d,%d,%d,%d)\",\r\r\n (int) i,\r\r\n (int) image->colormap[i].red,\r\r\n (int) image->colormap[i].green,\r\r\n (int) image->colormap[i].blue,\r\r\n (int) image->colormap[i].alpha);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (number_transparent < 257)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" number_transparent = %d\",\r\r\n number_transparent);\r\r\n else\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" number_transparent > 256\");\r\r\n\r\r\n if (number_opaque < 257)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" number_opaque = %d\",\r\r\n number_opaque);\r\r\n\r\r\n else\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" number_opaque > 256\");\r\r\n\r\r\n if (number_semitransparent < 257)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" number_semitransparent = %d\",\r\r\n number_semitransparent);\r\r\n\r\r\n else\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" number_semitransparent > 256\");\r\r\n\r\r\n if (ping_have_non_bw == MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" All pixels and the background are black or white\");\r\r\n\r\r\n else if (ping_have_color == MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" All pixels and the background are gray\");\r\r\n\r\r\n else\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" At least one pixel or the background is non-gray\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Exit BUILD_PALETTE:\");\r\r\n }\r\r\n\r\r\n if (mng_info->write_png8 == MagickFalse)\r\r\n break;\r\r\n\r\r\n /* Make any reductions necessary for the PNG8 format */\r\r\n if (image_colors <= 256 &&\r\r\n image_colors != 0 && image->colormap != NULL &&\r\r\n number_semitransparent == 0 &&\r\r\n number_transparent <= 1)\r\r\n break;\r\r\n\r\r\n /* PNG8 can't have semitransparent colors so we threshold the\r\r\n * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\r\r\n * transparent color so if more than one is transparent we merge\r\r\n * them into image->background_color.\r\r\n */\r\r\n if (number_semitransparent != 0 || number_transparent > 1)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Thresholding the alpha channel to binary\");\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\r\r\n {\r\r\n SetPixelViaPixelInfo(image,&image->background_color,r);\r\r\n SetPixelAlpha(image,TransparentAlpha,r);\r\r\n }\r\r\n else\r\r\n SetPixelAlpha(image,OpaqueAlpha,r);\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n\r\r\n if (image_colors != 0 && image_colors <= 256 &&\r\r\n image->colormap != NULL)\r\r\n for (i=0; i<image_colors; i++)\r\r\n image->colormap[i].alpha =\r\r\n (image->colormap[i].alpha > TransparentAlpha/2 ?\r\r\n TransparentAlpha : OpaqueAlpha);\r\r\n }\r\r\n continue;\r\r\n }\r\r\n\r\r\n /* PNG8 can't have more than 256 colors so we quantize the pixels and\r\r\n * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette. If the\r\r\n * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\r\r\n * colors or less.\r\r\n */\r\r\n if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the background color to 4-4-4\");\r\r\n\r\r\n tried_444 = MagickTrue;\r\r\n\r\r\n LBR04PacketRGB(image->background_color);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the pixel colors to 4-4-4\");\r\r\n\r\r\n if (image->colormap == NULL)\r\r\n {\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (GetPixelAlpha(image,r) == OpaqueAlpha)\r\r\n LBR04PixelRGB(r);\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n else /* Should not reach this; colormap already exists and\r\r\n must be <= 256 */\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the colormap to 4-4-4\");\r\r\n\r\r\n for (i=0; i<image_colors; i++)\r\r\n {\r\r\n LBR04PacketRGB(image->colormap[i]);\r\r\n }\r\r\n }\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the background color to 3-3-3\");\r\r\n\r\r\n tried_333 = MagickTrue;\r\r\n\r\r\n LBR03PacketRGB(image->background_color);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the pixel colors to 3-3-3-1\");\r\r\n\r\r\n if (image->colormap == NULL)\r\r\n {\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (GetPixelAlpha(image,r) == OpaqueAlpha)\r\r\n LBR03RGB(r);\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n else /* Should not reach this; colormap already exists and\r\r\n must be <= 256 */\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the colormap to 3-3-3-1\");\r\r\n for (i=0; i<image_colors; i++)\r\r\n {\r\r\n LBR03PacketRGB(image->colormap[i]);\r\r\n }\r\r\n }\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the background color to 3-3-2\");\r\r\n\r\r\n tried_332 = MagickTrue;\r\r\n\r\r\n /* Red and green were already done so we only quantize the blue\r\r\n * channel\r\r\n */\r\r\n\r\r\n LBR02PacketBlue(image->background_color);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the pixel colors to 3-3-2-1\");\r\r\n\r\r\n if (image->colormap == NULL)\r\r\n {\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (GetPixelAlpha(image,r) == OpaqueAlpha)\r\r\n LBR02PixelBlue(r);\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n else /* Should not reach this; colormap already exists and\r\r\n must be <= 256 */\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Quantizing the colormap to 3-3-2-1\");\r\r\n for (i=0; i<image_colors; i++)\r\r\n {\r\r\n LBR02PacketBlue(image->colormap[i]);\r\r\n }\r\r\n }\r\r\n continue;\r\r\n }\r\r\n\r\r\n if (image_colors == 0 || image_colors > 256)\r\r\n {\r\r\n /* Take care of special case with 256 opaque colors + 1 transparent\r\r\n * color. We don't need to quantize to 2-3-2-1; we only need to\r\r\n * eliminate one color, so we'll merge the two darkest red\r\r\n * colors (0x49, 0, 0) -> (0x24, 0, 0).\r\r\n */\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Merging two dark red background colors to 3-3-2-1\");\r\r\n\r\r\n if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\r\r\n ScaleQuantumToChar(image->background_color.green) == 0x00 &&\r\r\n ScaleQuantumToChar(image->background_color.blue) == 0x00)\r\r\n {\r\r\n image->background_color.red=ScaleCharToQuantum(0x24);\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Merging two dark red pixel colors to 3-3-2-1\");\r\r\n\r\r\n if (image->colormap == NULL)\r\r\n {\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (r == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\r\r\n ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\r\r\n ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\r\r\n GetPixelAlpha(image,r) == OpaqueAlpha)\r\r\n {\r\r\n SetPixelRed(image,ScaleCharToQuantum(0x24),r);\r\r\n }\r\r\n r+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (SyncAuthenticPixels(image,exception) == MagickFalse)\r\r\n break;\r\r\n\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n for (i=0; i<image_colors; i++)\r\r\n {\r\r\n if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\r\r\n ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\r\r\n ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\r\r\n {\r\r\n image->colormap[i].red=ScaleCharToQuantum(0x24);\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n /* END OF BUILD_PALETTE */\r\r\n\r\r\n /* If we are excluding the tRNS chunk and there is transparency,\r\r\n * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\r\r\n * PNG.\r\r\n */\r\r\n if (mng_info->ping_exclude_tRNS != MagickFalse &&\r\r\n (number_transparent != 0 || number_semitransparent != 0))\r\r\n {\r\r\n unsigned int colortype=mng_info->write_png_colortype;\r\r\n\r\r\n if (ping_have_color == MagickFalse)\r\r\n mng_info->write_png_colortype = 5;\r\r\n\r\r\n else\r\r\n mng_info->write_png_colortype = 7;\r\r\n\r\r\n if (colortype != 0 &&\r\r\n mng_info->write_png_colortype != colortype)\r\r\n ping_need_colortype_warning=MagickTrue;\r\r\n\r\r\n }\r\r\n\r\r\n /* See if cheap transparency is possible. It is only possible\r\r\n * when there is a single transparent color, no semitransparent\r\r\n * color, and no opaque color that has the same RGB components\r\r\n * as the transparent color. We only need this information if\r\r\n * we are writing a PNG with colortype 0 or 2, and we have not\r\r\n * excluded the tRNS chunk.\r\r\n */\r\r\n if (number_transparent == 1 &&\r\r\n mng_info->write_png_colortype < 4)\r\r\n {\r\r\n ping_have_cheap_transparency = MagickTrue;\r\r\n\r\r\n if (number_semitransparent != 0)\r\r\n ping_have_cheap_transparency = MagickFalse;\r\r\n\r\r\n else if (image_colors == 0 || image_colors > 256 ||\r\r\n image->colormap == NULL)\r\r\n {\r\r\n register const Quantum\r\r\n *q;\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n q=GetVirtualPixels(image,0,y,image->columns,1, exception);\r\r\n\r\r\n if (q == (Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n for (x=0; x < (ssize_t) image->columns; x++)\r\r\n {\r\r\n if (GetPixelAlpha(image,q) != TransparentAlpha &&\r\r\n (unsigned short) GetPixelRed(image,q) ==\r\r\n ping_trans_color.red &&\r\r\n (unsigned short) GetPixelGreen(image,q) ==\r\r\n ping_trans_color.green &&\r\r\n (unsigned short) GetPixelBlue(image,q) ==\r\r\n ping_trans_color.blue)\r\r\n {\r\r\n ping_have_cheap_transparency = MagickFalse;\r\r\n break;\r\r\n }\r\r\n\r\r\n q+=GetPixelChannels(image);\r\r\n }\r\r\n\r\r\n if (ping_have_cheap_transparency == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n /* Assuming that image->colormap[0] is the one transparent color\r\r\n * and that all others are opaque.\r\r\n */\r\r\n if (image_colors > 1)\r\r\n for (i=1; i<image_colors; i++)\r\r\n if (image->colormap[i].red == image->colormap[0].red &&\r\r\n image->colormap[i].green == image->colormap[0].green &&\r\r\n image->colormap[i].blue == image->colormap[0].blue)\r\r\n {\r\r\n ping_have_cheap_transparency = MagickFalse;\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n if (ping_have_cheap_transparency == MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Cheap transparency is not possible.\");\r\r\n\r\r\n else\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Cheap transparency is possible.\");\r\r\n }\r\r\n }\r\r\n else\r\r\n ping_have_cheap_transparency = MagickFalse;\r\r\n\r\r\n image_depth=image->depth;\r\r\n\r\r\n quantum_info = (QuantumInfo *) NULL;\r\r\n number_colors=0;\r\r\n image_colors=(int) image->colors;\r\r\n image_matte=image->alpha_trait !=\r\r\n UndefinedPixelTrait ? MagickTrue : MagickFalse;\r\r\n\r\r\n if (mng_info->write_png_colortype < 5)\r\r\n mng_info->IsPalette=image->storage_class == PseudoClass &&\r\r\n image_colors <= 256 && image->colormap != NULL;\r\r\n else\r\r\n mng_info->IsPalette = MagickFalse;\r\r\n\r\r\n if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\r\r\n (image->colors == 0 || image->colormap == NULL))\r\r\n {\r\r\n image_info=DestroyImageInfo(image_info);\r\r\n image=DestroyImage(image);\r\r\n (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\r\r\n \"Cannot write PNG8 or color-type 3; colormap is NULL\",\r\r\n \"`%s'\",IMimage->filename);\r\r\n return(MagickFalse);\r\r\n }\r\r\n\r\r\n /*\r\r\n Allocate the PNG structures\r\r\n */\r\r\n#ifdef PNG_USER_MEM_SUPPORTED\r\r\n error_info.image=image;\r\r\n error_info.exception=exception;\r\r\n ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\r\r\n MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\r\r\n (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\r\r\n\r\r\n#else\r\r\n ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\r\r\n MagickPNGErrorHandler,MagickPNGWarningHandler);\r\r\n\r\r\n#endif\r\r\n if (ping == (png_struct *) NULL)\r\r\n ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n\r\r\n ping_info=png_create_info_struct(ping);\r\r\n\r\r\n if (ping_info == (png_info *) NULL)\r\r\n {\r\r\n png_destroy_write_struct(&ping,(png_info **) NULL);\r\r\n ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\r\r\n }\r\r\n\r\r\n png_set_write_fn(ping,image,png_put_data,png_flush_data);\r\r\n pixel_info=(MemoryInfo *) NULL;\r\r\n\r\r\n if (setjmp(png_jmpbuf(ping)))\r\r\n {\r\r\n /*\r\r\n PNG write failed.\r\r\n */\r\r\n#ifdef PNG_DEBUG\r\r\n if (image_info->verbose)\r\r\n (void) printf(\"PNG write has failed.\\n\");\r\r\n#endif\r\r\n png_destroy_write_struct(&ping,&ping_info);\r\r\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\r\r\n UnlockSemaphoreInfo(ping_semaphore);\r\r\n#endif\r\r\n\r\r\n if (pixel_info != (MemoryInfo *) NULL)\r\r\n pixel_info=RelinquishVirtualMemory(pixel_info);\r\r\n\r\r\n if (quantum_info != (QuantumInfo *) NULL)\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n\r\r\n if (ping_have_blob != MagickFalse)\r\r\n (void) CloseBlob(image);\r\r\n image_info=DestroyImageInfo(image_info);\r\r\n image=DestroyImage(image);\r\r\n return(MagickFalse);\r\r\n }\r\r\n\r\r\n /* { For navigation to end of SETJMP-protected block. Within this\r\r\n * block, use png_error() instead of Throwing an Exception, to ensure\r\r\n * that libpng is able to clean up, and that the semaphore is unlocked.\r\r\n */\r\r\n\r\r\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\r\r\n LockSemaphoreInfo(ping_semaphore);\r\r\n#endif\r\r\n\r\r\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\r\r\n /* Allow benign errors */\r\r\n png_set_benign_errors(ping, 1);\r\r\n#endif\r\r\n\r\r\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\r\r\n /* Reject images with too many rows or columns */\r\r\n png_set_user_limits(ping,\r\r\n (png_uint_32) MagickMin(0x7fffffffL,\r\r\n GetMagickResourceLimit(WidthResource)),\r\r\n (png_uint_32) MagickMin(0x7fffffffL,\r\r\n GetMagickResourceLimit(HeightResource)));\r\r\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\r\r\n\r\r\n /*\r\r\n Prepare PNG for writing.\r\r\n */\r\r\n\r\r\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\r\r\n if (mng_info->write_mng)\r\r\n {\r\r\n (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\r\r\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\r\r\n /* Disable new libpng-1.5.10 feature when writing a MNG because\r\r\n * zero-length PLTE is OK\r\r\n */\r\r\n png_set_check_for_invalid_index (ping, 0);\r\r\n# endif\r\r\n }\r\r\n\r\r\n#else\r\r\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\r\r\n if (mng_info->write_mng)\r\r\n png_permit_empty_plte(ping,MagickTrue);\r\r\n\r\r\n# endif\r\r\n#endif\r\r\n\r\r\n x=0;\r\r\n\r\r\n ping_width=(png_uint_32) image->columns;\r\r\n ping_height=(png_uint_32) image->rows;\r\r\n\r\r\n if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\r\r\n image_depth=8;\r\r\n\r\r\n if (mng_info->write_png48 || mng_info->write_png64)\r\r\n image_depth=16;\r\r\n\r\r\n if (mng_info->write_png_depth != 0)\r\r\n image_depth=mng_info->write_png_depth;\r\r\n\r\r\n /* Adjust requested depth to next higher valid depth if necessary */\r\r\n if (image_depth > 8)\r\r\n image_depth=16;\r\r\n\r\r\n if ((image_depth > 4) && (image_depth < 8))\r\r\n image_depth=8;\r\r\n\r\r\n if (image_depth == 3)\r\r\n image_depth=4;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" width=%.20g\",(double) ping_width);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" height=%.20g\",(double) ping_height);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image_matte=%.20g\",(double) image->alpha_trait);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image->depth=%.20g\",(double) image->depth);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Tentative ping_bit_depth=%.20g\",(double) image_depth);\r\r\n }\r\r\n\r\r\n save_image_depth=image_depth;\r\r\n ping_bit_depth=(png_byte) save_image_depth;\r\r\n\r\r\n\r\r\n#if defined(PNG_pHYs_SUPPORTED)\r\r\n if (ping_exclude_pHYs == MagickFalse)\r\r\n {\r\r\n if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\r\r\n (!mng_info->write_mng || !mng_info->equal_physs))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up pHYs chunk\");\r\r\n\r\r\n if (image->units == PixelsPerInchResolution)\r\r\n {\r\r\n ping_pHYs_unit_type=PNG_RESOLUTION_METER;\r\r\n ping_pHYs_x_resolution=\r\r\n (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\r\r\n ping_pHYs_y_resolution=\r\r\n (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\r\r\n }\r\r\n\r\r\n else if (image->units == PixelsPerCentimeterResolution)\r\r\n {\r\r\n ping_pHYs_unit_type=PNG_RESOLUTION_METER;\r\r\n ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\r\r\n ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\r\r\n ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\r\r\n ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\r\r\n (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\r\r\n (int) ping_pHYs_unit_type);\r\r\n ping_have_pHYs = MagickTrue;\r\r\n }\r\r\n }\r\r\n#endif\r\r\n\r\r\n if (ping_exclude_bKGD == MagickFalse)\r\r\n {\r\r\n if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\r\r\n {\r\r\n unsigned int\r\r\n mask;\r\r\n\r\r\n mask=0xffff;\r\r\n if (ping_bit_depth == 8)\r\r\n mask=0x00ff;\r\r\n\r\r\n if (ping_bit_depth == 4)\r\r\n mask=0x000f;\r\r\n\r\r\n if (ping_bit_depth == 2)\r\r\n mask=0x0003;\r\r\n\r\r\n if (ping_bit_depth == 1)\r\r\n mask=0x0001;\r\r\n\r\r\n ping_background.red=(png_uint_16)\r\r\n (ScaleQuantumToShort(image->background_color.red) & mask);\r\r\n\r\r\n ping_background.green=(png_uint_16)\r\r\n (ScaleQuantumToShort(image->background_color.green) & mask);\r\r\n\r\r\n ping_background.blue=(png_uint_16)\r\r\n (ScaleQuantumToShort(image->background_color.blue) & mask);\r\r\n\r\r\n ping_background.gray=(png_uint_16) ping_background.green;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up bKGD chunk (1)\");\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" background_color index is %d\",\r\r\n (int) ping_background.index);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" ping_bit_depth=%d\",ping_bit_depth);\r\r\n }\r\r\n\r\r\n ping_have_bKGD = MagickTrue;\r\r\n }\r\r\n\r\r\n /*\r\r\n Select the color type.\r\r\n */\r\r\n matte=image_matte;\r\r\n old_bit_depth=0;\r\r\n\r\r\n if (mng_info->IsPalette && mng_info->write_png8)\r\r\n {\r\r\n /* To do: make this a function cause it's used twice, except\r\r\n for reducing the sample depth from 8. */\r\r\n\r\r\n number_colors=image_colors;\r\r\n\r\r\n ping_have_tRNS=MagickFalse;\r\r\n\r\r\n /*\r\r\n Set image palette.\r\r\n */\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up PLTE chunk with %d colors (%d)\",\r\r\n number_colors, image_colors);\r\r\n\r\r\n for (i=0; i < (ssize_t) number_colors; i++)\r\r\n {\r\r\n palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\r\r\n palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\r\r\n palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n#if MAGICKCORE_QUANTUM_DEPTH == 8\r\r\n \" %3ld (%3d,%3d,%3d)\",\r\r\n#else\r\r\n \" %5ld (%5d,%5d,%5d)\",\r\r\n#endif\r\r\n (long) i,palette[i].red,palette[i].green,palette[i].blue);\r\r\n\r\r\n }\r\r\n\r\r\n ping_have_PLTE=MagickTrue;\r\r\n image_depth=ping_bit_depth;\r\r\n ping_num_trans=0;\r\r\n\r\r\n if (matte != MagickFalse)\r\r\n {\r\r\n /*\r\r\n Identify which colormap entry is transparent.\r\r\n */\r\r\n assert(number_colors <= 256);\r\r\n assert(image->colormap != NULL);\r\r\n\r\r\n for (i=0; i < (ssize_t) number_transparent; i++)\r\r\n ping_trans_alpha[i]=0;\r\r\n\r\r\n\r\r\n ping_num_trans=(unsigned short) (number_transparent +\r\r\n number_semitransparent);\r\r\n\r\r\n if (ping_num_trans == 0)\r\r\n ping_have_tRNS=MagickFalse;\r\r\n\r\r\n else\r\r\n ping_have_tRNS=MagickTrue;\r\r\n }\r\r\n\r\r\n if (ping_exclude_bKGD == MagickFalse)\r\r\n {\r\r\n /*\r\r\n * Identify which colormap entry is the background color.\r\r\n */\r\r\n\r\r\n for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\r\r\n if (IsPNGColorEqual(ping_background,image->colormap[i]))\r\r\n break;\r\r\n\r\r\n ping_background.index=(png_byte) i;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" background_color index is %d\",\r\r\n (int) ping_background.index);\r\r\n }\r\r\n }\r\r\n } /* end of write_png8 */\r\r\n\r\r\n else if (mng_info->write_png_colortype == 1)\r\r\n {\r\r\n image_matte=MagickFalse;\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\r\r\n }\r\r\n\r\r\n else if (mng_info->write_png24 || mng_info->write_png48 ||\r\r\n mng_info->write_png_colortype == 3)\r\r\n {\r\r\n image_matte=MagickFalse;\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\r\r\n }\r\r\n\r\r\n else if (mng_info->write_png32 || mng_info->write_png64 ||\r\r\n mng_info->write_png_colortype == 7)\r\r\n {\r\r\n image_matte=MagickTrue;\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\r\r\n }\r\r\n\r\r\n else /* mng_info->write_pngNN not specified */\r\r\n {\r\r\n image_depth=ping_bit_depth;\r\r\n\r\r\n if (mng_info->write_png_colortype != 0)\r\r\n {\r\r\n ping_color_type=(png_byte) mng_info->write_png_colortype-1;\r\r\n\r\r\n if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\r\r\n ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\r\n image_matte=MagickTrue;\r\r\n\r\r\n else\r\r\n image_matte=MagickFalse;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" PNG colortype %d was specified:\",(int) ping_color_type);\r\r\n }\r\r\n\r\r\n else /* write_png_colortype not specified */\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Selecting PNG colortype:\");\r\r\n\r\r\n if (image_info->type == TrueColorType)\r\r\n {\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\r\r\n image_matte=MagickFalse;\r\r\n }\r\r\n else if (image_info->type == TrueColorAlphaType)\r\r\n {\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\r\r\n image_matte=MagickTrue;\r\r\n }\r\r\n else if (image_info->type == PaletteType ||\r\r\n image_info->type == PaletteAlphaType)\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\r\r\n else\r\r\n {\r\r\n if (ping_have_color == MagickFalse)\r\r\n {\r\r\n if (image_matte == MagickFalse)\r\r\n {\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\r\r\n image_matte=MagickFalse;\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\r\r\n image_matte=MagickTrue;\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n if (image_matte == MagickFalse)\r\r\n {\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\r\r\n image_matte=MagickFalse;\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\r\r\n image_matte=MagickTrue;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Selected PNG colortype=%d\",ping_color_type);\r\r\n\r\r\n if (ping_bit_depth < 8)\r\r\n {\r\r\n if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\r\r\n ping_color_type == PNG_COLOR_TYPE_RGB ||\r\r\n ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\r\r\n ping_bit_depth=8;\r\r\n }\r\r\n\r\r\n old_bit_depth=ping_bit_depth;\r\r\n\r\r\n if (ping_color_type == PNG_COLOR_TYPE_GRAY)\r\r\n {\r\r\n if (image->alpha_trait == UndefinedPixelTrait &&\r\r\n ping_have_non_bw == MagickFalse)\r\r\n ping_bit_depth=1;\r\r\n }\r\r\n\r\r\n if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\r\r\n {\r\r\n size_t one = 1;\r\r\n ping_bit_depth=1;\r\r\n\r\r\n if (image->colors == 0)\r\r\n {\r\r\n /* DO SOMETHING */\r\r\n png_error(ping,\"image has 0 colors\");\r\r\n }\r\r\n\r\r\n while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\r\r\n ping_bit_depth <<= 1;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Number of colors: %.20g\",(double) image_colors);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Tentative PNG bit depth: %d\",ping_bit_depth);\r\r\n }\r\r\n\r\r\n if (ping_bit_depth < (int) mng_info->write_png_depth)\r\r\n ping_bit_depth = mng_info->write_png_depth;\r\r\n }\r\r\n\r\r\n image_depth=ping_bit_depth;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Tentative PNG color type: %s (%.20g)\",\r\r\n PngColorTypeToString(ping_color_type),\r\r\n (double) ping_color_type);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image_info->type: %.20g\",(double) image_info->type);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" image_depth: %.20g\",(double) image_depth);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n\r\r\n \" image->depth: %.20g\",(double) image->depth);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" ping_bit_depth: %.20g\",(double) ping_bit_depth);\r\r\n }\r\r\n\r\r\n if (matte != MagickFalse)\r\r\n {\r\r\n if (mng_info->IsPalette)\r\r\n {\r\r\n if (mng_info->write_png_colortype == 0)\r\r\n {\r\r\n ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\r\r\n\r\r\n if (ping_have_color != MagickFalse)\r\r\n ping_color_type=PNG_COLOR_TYPE_RGBA;\r\r\n }\r\r\n\r\r\n /*\r\r\n * Determine if there is any transparent color.\r\r\n */\r\r\n if (number_transparent + number_semitransparent == 0)\r\r\n {\r\r\n /*\r\r\n No transparent pixels are present. Change 4 or 6 to 0 or 2.\r\r\n */\r\r\n\r\r\n image_matte=MagickFalse;\r\r\n\r\r\n if (mng_info->write_png_colortype == 0)\r\r\n ping_color_type&=0x03;\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n unsigned int\r\r\n mask;\r\r\n\r\r\n mask=0xffff;\r\r\n\r\r\n if (ping_bit_depth == 8)\r\r\n mask=0x00ff;\r\r\n\r\r\n if (ping_bit_depth == 4)\r\r\n mask=0x000f;\r\r\n\r\r\n if (ping_bit_depth == 2)\r\r\n mask=0x0003;\r\r\n\r\r\n if (ping_bit_depth == 1)\r\r\n mask=0x0001;\r\r\n\r\r\n ping_trans_color.red=(png_uint_16)\r\r\n (ScaleQuantumToShort(image->colormap[0].red) & mask);\r\r\n\r\r\n ping_trans_color.green=(png_uint_16)\r\r\n (ScaleQuantumToShort(image->colormap[0].green) & mask);\r\r\n\r\r\n ping_trans_color.blue=(png_uint_16)\r\r\n (ScaleQuantumToShort(image->colormap[0].blue) & mask);\r\r\n\r\r\n ping_trans_color.gray=(png_uint_16)\r\r\n (ScaleQuantumToShort(GetPixelInfoIntensity(image,\r\r\n image->colormap)) & mask);\r\r\n\r\r\n ping_trans_color.index=(png_byte) 0;\r\r\n\r\r\n ping_have_tRNS=MagickTrue;\r\r\n }\r\r\n\r\r\n if (ping_have_tRNS != MagickFalse)\r\r\n {\r\r\n /*\r\r\n * Determine if there is one and only one transparent color\r\r\n * and if so if it is fully transparent.\r\r\n */\r\r\n if (ping_have_cheap_transparency == MagickFalse)\r\r\n ping_have_tRNS=MagickFalse;\r\r\n }\r\r\n\r\r\n if (ping_have_tRNS != MagickFalse)\r\r\n {\r\r\n if (mng_info->write_png_colortype == 0)\r\r\n ping_color_type &= 0x03; /* changes 4 or 6 to 0 or 2 */\r\r\n\r\r\n if (image_depth == 8)\r\r\n {\r\r\n ping_trans_color.red&=0xff;\r\r\n ping_trans_color.green&=0xff;\r\r\n ping_trans_color.blue&=0xff;\r\r\n ping_trans_color.gray&=0xff;\r\r\n }\r\r\n }\r\r\n }\r\r\n else\r\r\n {\r\r\n if (image_depth == 8)\r\r\n {\r\r\n ping_trans_color.red&=0xff;\r\r\n ping_trans_color.green&=0xff;\r\r\n ping_trans_color.blue&=0xff;\r\r\n ping_trans_color.gray&=0xff;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n matte=image_matte;\r\r\n\r\r\n if (ping_have_tRNS != MagickFalse)\r\r\n image_matte=MagickFalse;\r\r\n\r\r\n if ((mng_info->IsPalette) &&\r\r\n mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\r\r\n ping_have_color == MagickFalse &&\r\r\n (image_matte == MagickFalse || image_depth >= 8))\r\r\n {\r\r\n size_t one=1;\r\r\n\r\r\n if (image_matte != MagickFalse)\r\r\n ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\r\r\n\r\r\n else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\r\r\n {\r\r\n ping_color_type=PNG_COLOR_TYPE_GRAY;\r\r\n\r\r\n if (save_image_depth == 16 && image_depth == 8)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Scaling ping_trans_color (0)\");\r\r\n }\r\r\n ping_trans_color.gray*=0x0101;\r\r\n }\r\r\n }\r\r\n\r\r\n if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\r\r\n image_depth=MAGICKCORE_QUANTUM_DEPTH;\r\r\n\r\r\n if ((image_colors == 0) ||\r\r\n ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\r\r\n image_colors=(int) (one << image_depth);\r\r\n\r\r\n if (image_depth > 8)\r\r\n ping_bit_depth=16;\r\r\n\r\r\n else\r\r\n {\r\r\n ping_bit_depth=8;\r\r\n if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\r\r\n {\r\r\n if(!mng_info->write_png_depth)\r\r\n {\r\r\n ping_bit_depth=1;\r\r\n\r\r\n while ((int) (one << ping_bit_depth)\r\r\n < (ssize_t) image_colors)\r\r\n ping_bit_depth <<= 1;\r\r\n }\r\r\n }\r\r\n\r\r\n else if (ping_color_type ==\r\r\n PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\r\r\n mng_info->IsPalette)\r\r\n {\r\r\n /* Check if grayscale is reducible */\r\r\n\r\r\n int\r\r\n depth_4_ok=MagickTrue,\r\r\n depth_2_ok=MagickTrue,\r\r\n depth_1_ok=MagickTrue;\r\r\n\r\r\n for (i=0; i < (ssize_t) image_colors; i++)\r\r\n {\r\r\n unsigned char\r\r\n intensity;\r\r\n\r\r\n intensity=ScaleQuantumToChar(image->colormap[i].red);\r\r\n\r\r\n if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\r\r\n depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\r\r\n else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\r\r\n depth_2_ok=depth_1_ok=MagickFalse;\r\r\n else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\r\r\n depth_1_ok=MagickFalse;\r\r\n }\r\r\n\r\r\n if (depth_1_ok && mng_info->write_png_depth <= 1)\r\r\n ping_bit_depth=1;\r\r\n\r\r\n else if (depth_2_ok && mng_info->write_png_depth <= 2)\r\r\n ping_bit_depth=2;\r\r\n\r\r\n else if (depth_4_ok && mng_info->write_png_depth <= 4)\r\r\n ping_bit_depth=4;\r\r\n }\r\r\n }\r\r\n\r\r\n image_depth=ping_bit_depth;\r\r\n }\r\r\n\r\r\n else\r\r\n\r\r\n if (mng_info->IsPalette)\r\r\n {\r\r\n number_colors=image_colors;\r\r\n\r\r\n if (image_depth <= 8)\r\r\n {\r\r\n /*\r\r\n Set image palette.\r\r\n */\r\r\n ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\r\r\n\r\r\n if (!(mng_info->have_write_global_plte && matte == MagickFalse))\r\r\n {\r\r\n for (i=0; i < (ssize_t) number_colors; i++)\r\r\n {\r\r\n palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\r\r\n palette[i].green=\r\r\n ScaleQuantumToChar(image->colormap[i].green);\r\r\n palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up PLTE chunk with %d colors\",\r\r\n number_colors);\r\r\n\r\r\n ping_have_PLTE=MagickTrue;\r\r\n }\r\r\n\r\r\n /* color_type is PNG_COLOR_TYPE_PALETTE */\r\r\n if (mng_info->write_png_depth == 0)\r\r\n {\r\r\n size_t\r\r\n one;\r\r\n\r\r\n ping_bit_depth=1;\r\r\n one=1;\r\r\n\r\r\n while ((one << ping_bit_depth) < (size_t) number_colors)\r\r\n ping_bit_depth <<= 1;\r\r\n }\r\r\n\r\r\n ping_num_trans=0;\r\r\n\r\r\n if (matte != MagickFalse)\r\r\n {\r\r\n /*\r\r\n * Set up trans_colors array.\r\r\n */\r\r\n assert(number_colors <= 256);\r\r\n\r\r\n ping_num_trans=(unsigned short) (number_transparent +\r\r\n number_semitransparent);\r\r\n\r\r\n if (ping_num_trans == 0)\r\r\n ping_have_tRNS=MagickFalse;\r\r\n\r\r\n else\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Scaling ping_trans_color (1)\");\r\r\n }\r\r\n ping_have_tRNS=MagickTrue;\r\r\n\r\r\n for (i=0; i < ping_num_trans; i++)\r\r\n {\r\r\n ping_trans_alpha[i]= (png_byte)\r\r\n ScaleQuantumToChar(image->colormap[i].alpha);\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n\r\r\n if (image_depth < 8)\r\r\n image_depth=8;\r\r\n\r\r\n if ((save_image_depth == 16) && (image_depth == 8))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Scaling ping_trans_color from (%d,%d,%d)\",\r\r\n (int) ping_trans_color.red,\r\r\n (int) ping_trans_color.green,\r\r\n (int) ping_trans_color.blue);\r\r\n }\r\r\n\r\r\n ping_trans_color.red*=0x0101;\r\r\n ping_trans_color.green*=0x0101;\r\r\n ping_trans_color.blue*=0x0101;\r\r\n ping_trans_color.gray*=0x0101;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" to (%d,%d,%d)\",\r\r\n (int) ping_trans_color.red,\r\r\n (int) ping_trans_color.green,\r\r\n (int) ping_trans_color.blue);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (ping_bit_depth < (ssize_t) mng_info->write_png_depth)\r\r\n ping_bit_depth = (ssize_t) mng_info->write_png_depth;\r\r\n\r\r\n /*\r\r\n Adjust background and transparency samples in sub-8-bit grayscale files.\r\r\n */\r\r\n if (ping_bit_depth < 8 && ping_color_type ==\r\r\n PNG_COLOR_TYPE_GRAY)\r\r\n {\r\r\n png_uint_16\r\r\n maxval;\r\r\n\r\r\n size_t\r\r\n one=1;\r\r\n\r\r\n maxval=(png_uint_16) ((one << ping_bit_depth)-1);\r\r\n\r\r\n if (ping_exclude_bKGD == MagickFalse)\r\r\n {\r\r\n\r\r\n ping_background.gray=(png_uint_16) ((maxval/65535.)*\r\r\n (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\r\r\n &image->background_color))) +.5)));\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up bKGD chunk (2)\");\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" background_color index is %d\",\r\r\n (int) ping_background.index);\r\r\n\r\r\n ping_have_bKGD = MagickTrue;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Scaling ping_trans_color.gray from %d\",\r\r\n (int)ping_trans_color.gray);\r\r\n\r\r\n ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\r\r\n ping_trans_color.gray)+.5);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" to %d\", (int)ping_trans_color.gray);\r\r\n }\r\r\n\r\r\n if (ping_exclude_bKGD == MagickFalse)\r\r\n {\r\r\n if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\r\r\n {\r\r\n /*\r\r\n Identify which colormap entry is the background color.\r\r\n */\r\r\n\r\r\n number_colors=image_colors;\r\r\n\r\r\n for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\r\r\n if (IsPNGColorEqual(image->background_color,image->colormap[i]))\r\r\n break;\r\r\n\r\r\n ping_background.index=(png_byte) i;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up bKGD chunk with index=%d\",(int) i);\r\r\n }\r\r\n\r\r\n if (i < (ssize_t) number_colors)\r\r\n {\r\r\n ping_have_bKGD = MagickTrue;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" background =(%d,%d,%d)\",\r\r\n (int) ping_background.red,\r\r\n (int) ping_background.green,\r\r\n (int) ping_background.blue);\r\r\n }\r\r\n }\r\r\n\r\r\n else /* Can't happen */\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" No room in PLTE to add bKGD color\");\r\r\n ping_have_bKGD = MagickFalse;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\r\r\n ping_color_type);\r\r\n /*\r\r\n Initialize compression level and filtering.\r\r\n */\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up deflate compression\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Compression buffer size: 32768\");\r\r\n }\r\r\n\r\r\n png_set_compression_buffer_size(ping,32768L);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Compression mem level: 9\");\r\r\n\r\r\n png_set_compression_mem_level(ping, 9);\r\r\n\r\r\n /* Untangle the \"-quality\" setting:\r\r\n\r\r\n Undefined is 0; the default is used.\r\r\n Default is 75\r\r\n\r\r\n 10's digit:\r\r\n\r\r\n 0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\r\r\n zlib default compression level\r\r\n\r\r\n 1-9: the zlib compression level\r\r\n\r\r\n 1's digit:\r\r\n\r\r\n 0-4: the PNG filter method\r\r\n\r\r\n 5: libpng adaptive filtering if compression level > 5\r\r\n libpng filter type \"none\" if compression level <= 5\r\r\n or if image is grayscale or palette\r\r\n\r\r\n 6: libpng adaptive filtering\r\r\n\r\r\n 7: \"LOCO\" filtering (intrapixel differing) if writing\r\r\n a MNG, otherwise \"none\". Did not work in IM-6.7.0-9\r\r\n and earlier because of a missing \"else\".\r\r\n\r\r\n 8: Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\r\r\n filtering. Unused prior to IM-6.7.0-10, was same as 6\r\r\n\r\r\n 9: Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\r\r\n Unused prior to IM-6.7.0-10, was same as 6\r\r\n\r\r\n Note that using the -quality option, not all combinations of\r\r\n PNG filter type, zlib compression level, and zlib compression\r\r\n strategy are possible. This will be addressed soon in a\r\r\n release that accomodates \"-define png:compression-strategy\", etc.\r\r\n\r\r\n */\r\r\n\r\r\n quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\r\r\n image_info->quality;\r\r\n\r\r\n if (quality <= 9)\r\r\n {\r\r\n if (mng_info->write_png_compression_strategy == 0)\r\r\n mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\r\r\n }\r\r\n\r\r\n else if (mng_info->write_png_compression_level == 0)\r\r\n {\r\r\n int\r\r\n level;\r\r\n\r\r\n level=(int) MagickMin((ssize_t) quality/10,9);\r\r\n\r\r\n mng_info->write_png_compression_level = level+1;\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_compression_strategy == 0)\r\r\n {\r\r\n if ((quality %10) == 8 || (quality %10) == 9)\r\r\n#ifdef Z_RLE /* Z_RLE was added to zlib-1.2.0 */\r\r\n mng_info->write_png_compression_strategy=Z_RLE+1;\r\r\n#else\r\r\n mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\r\r\n#endif\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_compression_filter == 0)\r\r\n mng_info->write_png_compression_filter=((int) quality % 10) + 1;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n if (mng_info->write_png_compression_level)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Compression level: %d\",\r\r\n (int) mng_info->write_png_compression_level-1);\r\r\n\r\r\n if (mng_info->write_png_compression_strategy)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Compression strategy: %d\",\r\r\n (int) mng_info->write_png_compression_strategy-1);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up filtering\");\r\r\n\r\r\n if (mng_info->write_png_compression_filter == 6)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Base filter method: ADAPTIVE\");\r\r\n else if (mng_info->write_png_compression_filter == 0 ||\r\r\n mng_info->write_png_compression_filter == 1)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Base filter method: NONE\");\r\r\n else\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Base filter method: %d\",\r\r\n (int) mng_info->write_png_compression_filter-1);\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_compression_level != 0)\r\r\n png_set_compression_level(ping,mng_info->write_png_compression_level-1);\r\r\n\r\r\n if (mng_info->write_png_compression_filter == 6)\r\r\n {\r\r\n if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\r\r\n ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\r\r\n (quality < 50))\r\r\n png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\r\r\n else\r\r\n png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\r\r\n }\r\r\n else if (mng_info->write_png_compression_filter == 7 ||\r\r\n mng_info->write_png_compression_filter == 10)\r\r\n png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\r\r\n\r\r\n else if (mng_info->write_png_compression_filter == 8)\r\r\n {\r\r\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\r\r\n if (mng_info->write_mng)\r\r\n {\r\r\n if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\r\r\n ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\r\r\n ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\r\r\n }\r\r\n#endif\r\r\n png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\r\r\n }\r\r\n\r\r\n else if (mng_info->write_png_compression_filter == 9)\r\r\n png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\r\r\n\r\r\n else if (mng_info->write_png_compression_filter != 0)\r\r\n png_set_filter(ping,PNG_FILTER_TYPE_BASE,\r\r\n mng_info->write_png_compression_filter-1);\r\r\n\r\r\n if (mng_info->write_png_compression_strategy != 0)\r\r\n png_set_compression_strategy(ping,\r\r\n mng_info->write_png_compression_strategy-1);\r\r\n\r\r\n ping_interlace_method=image_info->interlace != NoInterlace;\r\r\n\r\r\n if (mng_info->write_mng)\r\r\n png_set_sig_bytes(ping,8);\r\r\n\r\r\n /* Bail out if cannot meet defined png:bit-depth or png:color-type */\r\r\n\r\r\n if (mng_info->write_png_colortype != 0)\r\r\n {\r\r\n if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\r\r\n if (ping_have_color != MagickFalse)\r\r\n {\r\r\n ping_color_type = PNG_COLOR_TYPE_RGB;\r\r\n\r\r\n if (ping_bit_depth < 8)\r\r\n ping_bit_depth=8;\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\r\r\n if (ping_have_color != MagickFalse)\r\r\n ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\r\r\n }\r\r\n\r\r\n if (ping_need_colortype_warning != MagickFalse ||\r\r\n ((mng_info->write_png_depth &&\r\r\n (int) mng_info->write_png_depth != ping_bit_depth) ||\r\r\n (mng_info->write_png_colortype &&\r\r\n ((int) mng_info->write_png_colortype-1 != ping_color_type &&\r\r\n mng_info->write_png_colortype != 7 &&\r\r\n !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n if (ping_need_colortype_warning != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Image has transparency but tRNS chunk was excluded\");\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_depth)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Defined png:bit-depth=%u, Computed depth=%u\",\r\r\n mng_info->write_png_depth,\r\r\n ping_bit_depth);\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_colortype)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Defined png:color-type=%u, Computed color type=%u\",\r\r\n mng_info->write_png_colortype-1,\r\r\n ping_color_type);\r\r\n }\r\r\n }\r\r\n\r\r\n png_warning(ping,\r\r\n \"Cannot write image with defined png:bit-depth or png:color-type.\");\r\r\n }\r\r\n\r\r\n if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\r\r\n {\r\r\n /* Add an opaque matte channel */\r\r\n image->alpha_trait = BlendPixelTrait;\r\r\n (void) SetImageAlpha(image,OpaqueAlpha,exception);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Added an opaque matte channel\");\r\r\n }\r\r\n\r\r\n if (number_transparent != 0 || number_semitransparent != 0)\r\r\n {\r\r\n if (ping_color_type < 4)\r\r\n {\r\r\n ping_have_tRNS=MagickTrue;\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting ping_have_tRNS=MagickTrue.\");\r\r\n }\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing PNG header chunks\");\r\r\n\r\r\n png_set_IHDR(ping,ping_info,ping_width,ping_height,\r\r\n ping_bit_depth,ping_color_type,\r\r\n ping_interlace_method,ping_compression_method,\r\r\n ping_filter_method);\r\r\n\r\r\n if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\r\r\n {\r\r\n png_set_PLTE(ping,ping_info,palette,number_colors);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n for (i=0; i< (ssize_t) number_colors; i++)\r\r\n {\r\r\n if (i < ping_num_trans)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\r\r\n (int) i,\r\r\n (int) palette[i].red,\r\r\n (int) palette[i].green,\r\r\n (int) palette[i].blue,\r\r\n (int) i,\r\r\n (int) ping_trans_alpha[i]);\r\r\n else\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" PLTE[%d] = (%d,%d,%d)\",\r\r\n (int) i,\r\r\n (int) palette[i].red,\r\r\n (int) palette[i].green,\r\r\n (int) palette[i].blue);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\r\r\n if (ping_exclude_sRGB != MagickFalse ||\r\r\n (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\r\r\n {\r\r\n if ((ping_exclude_tEXt == MagickFalse ||\r\r\n ping_exclude_zTXt == MagickFalse) &&\r\r\n (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\r\r\n {\r\r\n ResetImageProfileIterator(image);\r\r\n for (name=GetNextImageProfile(image); name != (const char *) NULL; )\r\r\n {\r\r\n profile=GetImageProfile(image,name);\r\r\n\r\r\n if (profile != (StringInfo *) NULL)\r\r\n {\r\r\n#ifdef PNG_WRITE_iCCP_SUPPORTED\r\r\n if ((LocaleCompare(name,\"ICC\") == 0) ||\r\r\n (LocaleCompare(name,\"ICM\") == 0))\r\r\n {\r\r\n ping_have_iCCP = MagickTrue;\r\r\n if (ping_exclude_iCCP == MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up iCCP chunk\");\r\r\n\r\r\n png_set_iCCP(ping,ping_info,(png_charp) name,0,\r\r\n#if (PNG_LIBPNG_VER < 10500)\r\r\n (png_charp) GetStringInfoDatum(profile),\r\r\n#else\r\r\n (const png_byte *) GetStringInfoDatum(profile),\r\r\n#endif\r\r\n (png_uint_32) GetStringInfoLength(profile));\r\r\n }\r\r\n else\r\r\n {\r\r\n /* Do not write hex-encoded ICC chunk */\r\r\n name=GetNextImageProfile(image);\r\r\n continue;\r\r\n }\r\r\n }\r\r\n#endif /* WRITE_iCCP */\r\r\n\r\r\n if (LocaleCompare(name,\"exif\") == 0)\r\r\n {\r\r\n /* Do not write hex-encoded ICC chunk; we will\r\r\n write it later as an eXIf chunk */\r\r\n name=GetNextImageProfile(image);\r\r\n continue;\r\r\n }\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up zTXt chunk with uuencoded %s profile\",\r\r\n name);\r\r\n Magick_png_write_raw_profile(image_info,ping,ping_info,\r\r\n (unsigned char *) name,(unsigned char *) name,\r\r\n GetStringInfoDatum(profile),\r\r\n (png_uint_32) GetStringInfoLength(profile));\r\r\n }\r\r\n name=GetNextImageProfile(image);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\r\r\n if ((mng_info->have_write_global_srgb == 0) &&\r\r\n ping_have_iCCP != MagickTrue &&\r\r\n (ping_have_sRGB != MagickFalse ||\r\r\n png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\r\r\n {\r\r\n if (ping_exclude_sRGB == MagickFalse)\r\r\n {\r\r\n /*\r\r\n Note image rendering intent.\r\r\n */\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up sRGB chunk\");\r\r\n\r\r\n (void) png_set_sRGB(ping,ping_info,(\r\r\n Magick_RenderingIntent_to_PNG_RenderingIntent(\r\r\n image->rendering_intent)));\r\r\n\r\r\n ping_have_sRGB = MagickTrue;\r\r\n }\r\r\n }\r\r\n\r\r\n if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\r\r\n#endif\r\r\n {\r\r\n if (ping_exclude_gAMA == MagickFalse &&\r\r\n ping_have_iCCP == MagickFalse &&\r\r\n ping_have_sRGB == MagickFalse &&\r\r\n (ping_exclude_sRGB == MagickFalse ||\r\r\n (image->gamma < .45 || image->gamma > .46)))\r\r\n {\r\r\n if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\r\r\n {\r\r\n /*\r\r\n Note image gamma.\r\r\n To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\r\r\n */\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up gAMA chunk\");\r\r\n\r\r\n png_set_gAMA(ping,ping_info,image->gamma);\r\r\n }\r\r\n }\r\r\n\r\r\n if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\r\r\n {\r\r\n if ((mng_info->have_write_global_chrm == 0) &&\r\r\n (image->chromaticity.red_primary.x != 0.0))\r\r\n {\r\r\n /*\r\r\n Note image chromaticity.\r\r\n Note: if cHRM+gAMA == sRGB write sRGB instead.\r\r\n */\r\r\n PrimaryInfo\r\r\n bp,\r\r\n gp,\r\r\n rp,\r\r\n wp;\r\r\n\r\r\n wp=image->chromaticity.white_point;\r\r\n rp=image->chromaticity.red_primary;\r\r\n gp=image->chromaticity.green_primary;\r\r\n bp=image->chromaticity.blue_primary;\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up cHRM chunk\");\r\r\n\r\r\n png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\r\r\n bp.x,bp.y);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (ping_exclude_bKGD == MagickFalse)\r\r\n {\r\r\n if (ping_have_bKGD != MagickFalse)\r\r\n {\r\r\n png_set_bKGD(ping,ping_info,&ping_background);\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up bKGD chunk\");\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" background color = (%d,%d,%d)\",\r\r\n (int) ping_background.red,\r\r\n (int) ping_background.green,\r\r\n (int) ping_background.blue);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" index = %d, gray=%d\",\r\r\n (int) ping_background.index,\r\r\n (int) ping_background.gray);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (ping_exclude_pHYs == MagickFalse)\r\r\n {\r\r\n if (ping_have_pHYs != MagickFalse)\r\r\n {\r\r\n png_set_pHYs(ping,ping_info,\r\r\n ping_pHYs_x_resolution,\r\r\n ping_pHYs_y_resolution,\r\r\n ping_pHYs_unit_type);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up pHYs chunk\");\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" x_resolution=%lu\",\r\r\n (unsigned long) ping_pHYs_x_resolution);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" y_resolution=%lu\",\r\r\n (unsigned long) ping_pHYs_y_resolution);\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" unit_type=%lu\",\r\r\n (unsigned long) ping_pHYs_unit_type);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n#if defined(PNG_tIME_SUPPORTED)\r\r\n if (ping_exclude_tIME == MagickFalse)\r\r\n {\r\r\n const char\r\r\n *timestamp;\r\r\n\r\r\n if (image->taint == MagickFalse)\r\r\n {\r\r\n timestamp=GetImageOption(image_info,\"png:tIME\");\r\r\n\r\r\n if (timestamp == (const char *) NULL)\r\r\n timestamp=GetImageProperty(image,\"png:tIME\",exception);\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Reset tIME in tainted image\");\r\r\n\r\r\n timestamp=GetImageProperty(image,\"date:modify\",exception);\r\r\n }\r\r\n\r\r\n if (timestamp != (const char *) NULL)\r\r\n write_tIME_chunk(image,ping,ping_info,timestamp,exception);\r\r\n }\r\r\n#endif\r\r\n\r\r\n if (mng_info->need_blob != MagickFalse)\r\r\n {\r\r\n if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\r\r\n MagickFalse)\r\r\n png_error(ping,\"WriteBlob Failed\");\r\r\n\r\r\n ping_have_blob=MagickTrue;\r\r\n }\r\r\n\r\r\n png_write_info_before_PLTE(ping, ping_info);\r\r\n\r\r\n if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\r\r\n }\r\r\n\r\r\n if (ping_color_type == 3)\r\r\n (void) png_set_tRNS(ping, ping_info,\r\r\n ping_trans_alpha,\r\r\n ping_num_trans,\r\r\n NULL);\r\r\n\r\r\n else\r\r\n {\r\r\n (void) png_set_tRNS(ping, ping_info,\r\r\n NULL,\r\r\n 0,\r\r\n &ping_trans_color);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" tRNS color =(%d,%d,%d)\",\r\r\n (int) ping_trans_color.red,\r\r\n (int) ping_trans_color.green,\r\r\n (int) ping_trans_color.blue);\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n png_write_info(ping,ping_info);\r\r\n\r\r\n /* write orNT if image->orientation is defined */\r\r\n if (image->orientation != UndefinedOrientation)\r\r\n {\r\r\n unsigned char\r\r\n chunk[6];\r\r\n (void) WriteBlobMSBULong(image,1L); /* data length=1 */\r\r\n PNGType(chunk,mng_orNT);\r\r\n LogPNGChunk(logging,mng_orNT,1L);\r\r\n /* PNG uses Exif orientation values */\r\r\n chunk[4]=Magick_Orientation_to_Exif_Orientation(image->orientation);\r\r\n (void) WriteBlob(image,5,chunk);\r\r\n (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\r\r\n }\r\r\n\r\r\n ping_wrote_caNv = MagickFalse;\r\r\n\r\r\n /* write caNv chunk */\r\r\n if (ping_exclude_caNv == MagickFalse)\r\r\n {\r\r\n if ((image->page.width != 0 && image->page.width != image->columns) ||\r\r\n (image->page.height != 0 && image->page.height != image->rows) ||\r\r\n image->page.x != 0 || image->page.y != 0)\r\r\n {\r\r\n unsigned char\r\r\n chunk[20];\r\r\n\r\r\n (void) WriteBlobMSBULong(image,16L); /* data length=8 */\r\r\n PNGType(chunk,mng_caNv);\r\r\n LogPNGChunk(logging,mng_caNv,16L);\r\r\n PNGLong(chunk+4,(png_uint_32) image->page.width);\r\r\n PNGLong(chunk+8,(png_uint_32) image->page.height);\r\r\n PNGsLong(chunk+12,(png_int_32) image->page.x);\r\r\n PNGsLong(chunk+16,(png_int_32) image->page.y);\r\r\n (void) WriteBlob(image,20,chunk);\r\r\n (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\r\r\n ping_wrote_caNv = MagickTrue;\r\r\n }\r\r\n }\r\r\n\r\r\n#if defined(PNG_oFFs_SUPPORTED)\r\r\n if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\r\r\n {\r\r\n if (image->page.x || image->page.y)\r\r\n {\r\r\n png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\r\r\n (png_int_32) image->page.y, 0);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up oFFs chunk with x=%d, y=%d, units=0\",\r\r\n (int) image->page.x, (int) image->page.y);\r\r\n }\r\r\n }\r\r\n#endif\r\r\n\r\r\n#if (PNG_LIBPNG_VER == 10206)\r\r\n /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\r\r\n#define PNG_HAVE_IDAT 0x04\r\r\n ping->mode |= PNG_HAVE_IDAT;\r\r\n#undef PNG_HAVE_IDAT\r\r\n#endif\r\r\n\r\r\n png_set_packing(ping);\r\r\n /*\r\r\n Allocate memory.\r\r\n */\r\r\n rowbytes=image->columns;\r\r\n if (image_depth > 8)\r\r\n rowbytes*=2;\r\r\n switch (ping_color_type)\r\r\n {\r\r\n case PNG_COLOR_TYPE_RGB:\r\r\n rowbytes*=3;\r\r\n break;\r\r\n\r\r\n case PNG_COLOR_TYPE_GRAY_ALPHA:\r\r\n rowbytes*=2;\r\r\n break;\r\r\n\r\r\n case PNG_COLOR_TYPE_RGBA:\r\r\n rowbytes*=4;\r\r\n break;\r\r\n\r\r\n default:\r\r\n break;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing PNG image data\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\r\r\n }\r\r\n pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\r\r\n if (pixel_info == (MemoryInfo *) NULL)\r\r\n png_error(ping,\"Allocation of memory for pixels failed\");\r\r\n ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\r\r\n /*\r\r\n Initialize image scanlines.\r\r\n */\r\r\n quantum_info=AcquireQuantumInfo(image_info,image);\r\r\n if (quantum_info == (QuantumInfo *) NULL)\r\r\n png_error(ping,\"Memory allocation for quantum_info failed\");\r\r\n quantum_info->format=UndefinedQuantumFormat;\r\r\n SetQuantumDepth(image,quantum_info,image_depth);\r\r\n (void) SetQuantumEndian(image,quantum_info,MSBEndian);\r\r\n num_passes=png_set_interlace_handling(ping);\r\r\n\r\r\n if ((!mng_info->write_png8 && !mng_info->write_png24 &&\r\r\n !mng_info->write_png48 && !mng_info->write_png64 &&\r\r\n !mng_info->write_png32) &&\r\r\n (mng_info->IsPalette ||\r\r\n (image_info->type == BilevelType)) &&\r\r\n image_matte == MagickFalse &&\r\r\n ping_have_non_bw == MagickFalse)\r\r\n {\r\r\n /* Palette, Bilevel, or Opaque Monochrome */\r\r\n register const Quantum\r\r\n *p;\r\r\n\r\r\n SetQuantumDepth(image,quantum_info,8);\r\r\n for (pass=0; pass < num_passes; pass++)\r\r\n {\r\r\n /*\r\r\n Convert PseudoClass image to a PNG monochrome image.\r\r\n */\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing row of pixels (0)\");\r\r\n\r\r\n p=GetVirtualPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (p == (const Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n if (mng_info->IsPalette)\r\r\n {\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,GrayQuantum,ping_pixels,exception);\r\r\n if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\r\r\n mng_info->write_png_depth &&\r\r\n mng_info->write_png_depth != old_bit_depth)\r\r\n {\r\r\n /* Undo pixel scaling */\r\r\n for (i=0; i < (ssize_t) image->columns; i++)\r\r\n *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\r\r\n >> (8-old_bit_depth));\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,RedQuantum,ping_pixels,exception);\r\r\n }\r\r\n\r\r\n if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\r\r\n for (i=0; i < (ssize_t) image->columns; i++)\r\r\n *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\r\r\n 255 : 0);\r\r\n\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing row of pixels (1)\");\r\r\n\r\r\n png_write_row(ping,ping_pixels);\r\r\n\r\r\n status=SetImageProgress(image,SaveImageTag,\r\r\n (MagickOffsetType) (pass * image->rows + y),\r\r\n num_passes * image->rows);\r\r\n\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n else /* Not Palette, Bilevel, or Opaque Monochrome */\r\r\n {\r\r\n if ((!mng_info->write_png8 && !mng_info->write_png24 &&\r\r\n !mng_info->write_png48 && !mng_info->write_png64 &&\r\r\n !mng_info->write_png32) && (image_matte != MagickFalse ||\r\r\n (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\r\r\n (mng_info->IsPalette) && ping_have_color == MagickFalse)\r\r\n {\r\r\n register const Quantum\r\r\n *p;\r\r\n\r\r\n for (pass=0; pass < num_passes; pass++)\r\r\n {\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n p=GetVirtualPixels(image,0,y,image->columns,1,exception);\r\r\n\r\r\n if (p == (const Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n if (ping_color_type == PNG_COLOR_TYPE_GRAY)\r\r\n {\r\r\n if (mng_info->IsPalette)\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,GrayQuantum,ping_pixels,exception);\r\r\n\r\r\n else\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,RedQuantum,ping_pixels,exception);\r\r\n\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing GRAY PNG pixels (2)\");\r\r\n }\r\r\n\r\r\n else /* PNG_COLOR_TYPE_GRAY_ALPHA */\r\r\n {\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing GRAY_ALPHA PNG pixels (2)\");\r\r\n\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,GrayAlphaQuantum,ping_pixels,exception);\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing row of pixels (2)\");\r\r\n\r\r\n png_write_row(ping,ping_pixels);\r\r\n\r\r\n status=SetImageProgress(image,SaveImageTag,\r\r\n (MagickOffsetType) (pass * image->rows + y),\r\r\n num_passes * image->rows);\r\r\n\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n register const Quantum\r\r\n *p;\r\r\n\r\r\n for (pass=0; pass < num_passes; pass++)\r\r\n {\r\r\n if ((image_depth > 8) ||\r\r\n mng_info->write_png24 ||\r\r\n mng_info->write_png32 ||\r\r\n mng_info->write_png48 ||\r\r\n mng_info->write_png64 ||\r\r\n (!mng_info->write_png8 && !mng_info->IsPalette))\r\r\n {\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n p=GetVirtualPixels(image,0,y,image->columns,1, exception);\r\r\n\r\r\n if (p == (const Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n if (ping_color_type == PNG_COLOR_TYPE_GRAY)\r\r\n {\r\r\n if (image->storage_class == DirectClass)\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,RedQuantum,ping_pixels,exception);\r\r\n\r\r\n else\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,GrayQuantum,ping_pixels,exception);\r\r\n }\r\r\n\r\r\n else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\r\n {\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,GrayAlphaQuantum,ping_pixels,\r\r\n exception);\r\r\n\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing GRAY_ALPHA PNG pixels (3)\");\r\r\n }\r\r\n\r\r\n else if (image_matte != MagickFalse)\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,RGBAQuantum,ping_pixels,exception);\r\r\n\r\r\n else\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,RGBQuantum,ping_pixels,exception);\r\r\n\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing row of pixels (3)\");\r\r\n\r\r\n png_write_row(ping,ping_pixels);\r\r\n\r\r\n status=SetImageProgress(image,SaveImageTag,\r\r\n (MagickOffsetType) (pass * image->rows + y),\r\r\n num_passes * image->rows);\r\r\n\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n\r\r\n else\r\r\n /* not ((image_depth > 8) ||\r\r\n mng_info->write_png24 || mng_info->write_png32 ||\r\r\n mng_info->write_png48 || mng_info->write_png64 ||\r\r\n (!mng_info->write_png8 && !mng_info->IsPalette))\r\r\n */\r\r\n {\r\r\n if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\r\r\n (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\r\r\n {\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\r\r\n\r\r\n SetQuantumDepth(image,quantum_info,8);\r\r\n image_depth=8;\r\r\n }\r\r\n\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\r\r\n pass);\r\r\n\r\r\n p=GetVirtualPixels(image,0,y,image->columns,1, exception);\r\r\n\r\r\n if (p == (const Quantum *) NULL)\r\r\n break;\r\r\n\r\r\n if (ping_color_type == PNG_COLOR_TYPE_GRAY)\r\r\n {\r\r\n SetQuantumDepth(image,quantum_info,image->depth);\r\r\n\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,GrayQuantum,ping_pixels,exception);\r\r\n }\r\r\n\r\r\n else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\r\r\n {\r\r\n if (logging != MagickFalse && y == 0)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing GRAY_ALPHA PNG pixels (4)\");\r\r\n\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,GrayAlphaQuantum,ping_pixels,\r\r\n exception);\r\r\n }\r\r\n\r\r\n else\r\r\n {\r\r\n (void) ExportQuantumPixels(image,(CacheView *) NULL,\r\r\n quantum_info,IndexQuantum,ping_pixels,exception);\r\r\n\r\r\n if (logging != MagickFalse && y <= 2)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing row of non-gray pixels (4)\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" ping_pixels[0]=%d,ping_pixels[1]=%d\",\r\r\n (int)ping_pixels[0],(int)ping_pixels[1]);\r\r\n }\r\r\n }\r\r\n png_write_row(ping,ping_pixels);\r\r\n\r\r\n status=SetImageProgress(image,SaveImageTag,\r\r\n (MagickOffsetType) (pass * image->rows + y),\r\r\n num_passes * image->rows);\r\r\n\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n }\r\r\n\r\r\n if (quantum_info != (QuantumInfo *) NULL)\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Wrote PNG image data\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Width: %.20g\",(double) ping_width);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Height: %.20g\",(double) ping_height);\r\r\n\r\r\n if (mng_info->write_png_depth)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Defined png:bit-depth: %d\",mng_info->write_png_depth);\r\r\n }\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" PNG bit-depth written: %d\",ping_bit_depth);\r\r\n\r\r\n if (mng_info->write_png_colortype)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Defined png:color-type: %d\",mng_info->write_png_colortype-1);\r\r\n }\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" PNG color-type written: %d\",ping_color_type);\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" PNG Interlace method: %d\",ping_interlace_method);\r\r\n }\r\r\n /*\r\r\n Generate text chunks after IDAT.\r\r\n */\r\r\n if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\r\r\n {\r\r\n ResetImagePropertyIterator(image);\r\r\n property=GetNextImageProperty(image);\r\r\n while (property != (const char *) NULL)\r\r\n {\r\r\n png_textp\r\r\n text;\r\r\n\r\r\n value=GetImageProperty(image,property,exception);\r\r\n\r\r\n /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\r\r\n * \"identify\" or for passing through to another JPEG\r\r\n */\r\r\n if ((LocaleNCompare(property,\"png:\",4) != 0 &&\r\r\n LocaleNCompare(property,\"jpeg:\",5) != 0) &&\r\r\n\r\r\n\r\r\n /* Suppress density and units if we wrote a pHYs chunk */\r\r\n (ping_exclude_pHYs != MagickFalse ||\r\r\n LocaleCompare(property,\"density\") != 0 ||\r\r\n LocaleCompare(property,\"units\") != 0) &&\r\r\n\r\r\n /* Suppress the IM-generated Date:create and Date:modify */\r\r\n (ping_exclude_date == MagickFalse ||\r\r\n LocaleNCompare(property, \"Date:\",5) != 0))\r\r\n {\r\r\n if (value != (const char *) NULL)\r\r\n {\r\r\n\r\r\n#if PNG_LIBPNG_VER >= 10400\r\r\n text=(png_textp) png_malloc(ping,\r\r\n (png_alloc_size_t) sizeof(png_text));\r\r\n#else\r\r\n text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\r\r\n#endif\r\r\n text[0].key=(char *) property;\r\r\n text[0].text=(char *) value;\r\r\n text[0].text_length=strlen(value);\r\r\n\r\r\n if (ping_exclude_tEXt != MagickFalse)\r\r\n text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\r\r\n\r\r\n else if (ping_exclude_zTXt != MagickFalse)\r\r\n text[0].compression=PNG_TEXT_COMPRESSION_NONE;\r\r\n\r\r\n else\r\r\n {\r\r\n text[0].compression=image_info->compression == NoCompression ||\r\r\n (image_info->compression == UndefinedCompression &&\r\r\n text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\r\r\n PNG_TEXT_COMPRESSION_zTXt ;\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n {\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Setting up text chunk\");\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" keyword: '%s'\",text[0].key);\r\r\n }\r\r\n\r\r\n png_set_text(ping,ping_info,text,1);\r\r\n png_free(ping,text);\r\r\n }\r\r\n }\r\r\n property=GetNextImageProperty(image);\r\r\n }\r\r\n }\r\r\n\r\r\n /* write eXIf profile */\r\r\n if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\r\r\n {\r\r\n char\r\r\n *name;\r\r\n\r\r\n ResetImageProfileIterator(image);\r\r\n\r\r\n for (name=GetNextImageProfile(image); name != (const char *) NULL; )\r\r\n {\r\r\n if (LocaleCompare(name,\"exif\") == 0)\r\r\n {\r\r\n const StringInfo\r\r\n *profile;\r\r\n\r\r\n profile=GetImageProfile(image,name);\r\r\n\r\r\n if (profile != (StringInfo *) NULL)\r\r\n {\r\r\n png_uint_32\r\r\n length;\r\r\n\r\r\n unsigned char\r\r\n chunk[4],\r\r\n *data;\r\r\n\r\r\n StringInfo\r\r\n *ping_profile;\r\r\n\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Have eXIf profile\");\r\r\n\r\r\n ping_profile=CloneStringInfo(profile);\r\r\n data=GetStringInfoDatum(ping_profile),\r\r\n length=(png_uint_32) GetStringInfoLength(ping_profile);\r\r\n\r\r\n PNGType(chunk,mng_eXIf);\r\r\n if (length < 7)\r\r\n {\r\r\n ping_profile=DestroyStringInfo(ping_profile);\r\r\n break; /* otherwise crashes */\r\r\n }\r\r\n\r\r\n if (*data == 'E' && *(data+1) == 'x' && *(data+2) == 'i' &&\r\r\n *(data+3) == 'f' && *(data+4) == '\\0' && *(data+5) == '\\0')\r\r\n {\r\r\n /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\r\r\n length -= 6;\r\r\n data += 6;\r\r\n }\r\r\n\r\r\n LogPNGChunk(logging,chunk,length);\r\r\n (void) WriteBlobMSBULong(image,length);\r\r\n (void) WriteBlob(image,4,chunk);\r\r\n (void) WriteBlob(image,length,data);\r\r\n (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4), data,\r\r\n (uInt) length));\r\r\n ping_profile=DestroyStringInfo(ping_profile);\r\r\n break;\r\r\n }\r\r\n }\r\r\n name=GetNextImageProfile(image);\r\r\n }\r\r\n }\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" Writing PNG end info\");\r\r\n\r\r\n png_write_end(ping,ping_info);\r\r\n\r\r\n if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\r\r\n {\r\r\n if (mng_info->page.x || mng_info->page.y ||\r\r\n (ping_width != mng_info->page.width) ||\r\r\n (ping_height != mng_info->page.height))\r\r\n {\r\r\n unsigned char\r\r\n chunk[32];\r\r\n\r\r\n /*\r\r\n Write FRAM 4 with clipping boundaries followed by FRAM 1.\r\r\n */\r\r\n (void) WriteBlobMSBULong(image,27L); /* data length=27 */\r\r\n PNGType(chunk,mng_FRAM);\r\r\n LogPNGChunk(logging,mng_FRAM,27L);\r\r\n chunk[4]=4;\r\r\n chunk[5]=0; /* frame name separator (no name) */\r\r\n chunk[6]=1; /* flag for changing delay, for next frame only */\r\r\n chunk[7]=0; /* flag for changing frame timeout */\r\r\n chunk[8]=1; /* flag for changing frame clipping for next frame */\r\r\n chunk[9]=0; /* flag for changing frame sync_id */\r\r\n PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\r\r\n chunk[14]=0; /* clipping boundaries delta type */\r\r\n PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\r\r\n PNGLong(chunk+19,\r\r\n (png_uint_32) (mng_info->page.x + ping_width));\r\r\n PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\r\r\n PNGLong(chunk+27,\r\r\n (png_uint_32) (mng_info->page.y + ping_height));\r\r\n (void) WriteBlob(image,31,chunk);\r\r\n (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\r\r\n mng_info->old_framing_mode=4;\r\r\n mng_info->framing_mode=1;\r\r\n }\r\r\n\r\r\n else\r\r\n mng_info->framing_mode=3;\r\r\n }\r\r\n if (mng_info->write_mng && !mng_info->need_fram &&\r\r\n ((int) image->dispose == 3))\r\r\n png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\r\r\n\r\r\n /*\r\r\n Free PNG resources.\r\r\n */\r\r\n\r\r\n png_destroy_write_struct(&ping,&ping_info);\r\r\n\r\r\n pixel_info=RelinquishVirtualMemory(pixel_info);\r\r\n\r\r\n if (ping_have_blob != MagickFalse)\r\r\n (void) CloseBlob(image);\r\r\n\r\r\n image_info=DestroyImageInfo(image_info);\r\r\n image=DestroyImage(image);\r\r\n\r\r\n /* Store bit depth actually written */\r\r\n s[0]=(char) ping_bit_depth;\r\r\n s[1]='\\0';\r\r\n\r\r\n (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\r\r\n\r\r\n if (logging != MagickFalse)\r\r\n (void) LogMagickEvent(CoderEvent,GetMagickModule(),\r\r\n \" exit WriteOnePNGImage()\");\r\r\n\r\r\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\r\r\n UnlockSemaphoreInfo(ping_semaphore);\r\r\n#endif\r\r\n\r\r\n /* } for navigation to beginning of SETJMP-protected block. Revert to\r\r\n * Throwing an Exception when an error occurs.\r\r\n */\r\r\n\r\r\n return(MagickTrue);\r\r\n/* End write one PNG image */\r\r\n\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {\r\r\n int ret = 0;\r\r\n htmlParserInputPtr in;\r\r\n int avail = 0;\r\r\n xmlChar cur, next;\r\r\n\r\r\n htmlParserNodeInfo node_info;\r\r\n\r\r\n#ifdef DEBUG_PUSH\r\r\n switch (ctxt->instate) {\r\r\n\tcase XML_PARSER_EOF:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try EOF\\n\"); break;\r\r\n\tcase XML_PARSER_START:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try START\\n\"); break;\r\r\n\tcase XML_PARSER_MISC:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try MISC\\n\");break;\r\r\n\tcase XML_PARSER_COMMENT:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try COMMENT\\n\");break;\r\r\n\tcase XML_PARSER_PROLOG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try PROLOG\\n\");break;\r\r\n\tcase XML_PARSER_START_TAG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try START_TAG\\n\");break;\r\r\n\tcase XML_PARSER_CONTENT:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try CONTENT\\n\");break;\r\r\n\tcase XML_PARSER_CDATA_SECTION:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try CDATA_SECTION\\n\");break;\r\r\n\tcase XML_PARSER_END_TAG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try END_TAG\\n\");break;\r\r\n\tcase XML_PARSER_ENTITY_DECL:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try ENTITY_DECL\\n\");break;\r\r\n\tcase XML_PARSER_ENTITY_VALUE:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try ENTITY_VALUE\\n\");break;\r\r\n\tcase XML_PARSER_ATTRIBUTE_VALUE:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try ATTRIBUTE_VALUE\\n\");break;\r\r\n\tcase XML_PARSER_DTD:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try DTD\\n\");break;\r\r\n\tcase XML_PARSER_EPILOG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try EPILOG\\n\");break;\r\r\n\tcase XML_PARSER_PI:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try PI\\n\");break;\r\r\n\tcase XML_PARSER_SYSTEM_LITERAL:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t \"HPP: try SYSTEM_LITERAL\\n\");break;\r\r\n }\r\r\n#endif\r\r\n\r\r\n while (1) {\r\r\n\r\r\n\tin = ctxt->input;\r\r\n\tif (in == NULL) break;\r\r\n\tif (in->buf == NULL)\r\r\n\t avail = in->length - (in->cur - in->base);\r\r\n\telse\r\r\n\t avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);\r\r\n\tif ((avail == 0) && (terminate)) {\r\r\n\t htmlAutoCloseOnEnd(ctxt);\r\r\n\t if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\r\r\n\t\t/*\r\r\n\t\t * SAX: end of the document processing.\r\r\n\t\t */\r\r\n\t\tctxt->instate = XML_PARSER_EOF;\r\r\n\t\tif ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\r\r\n\t\t ctxt->sax->endDocument(ctxt->userData);\r\r\n\t }\r\r\n\t}\r\r\n if (avail < 1)\r\r\n\t goto done;\r\r\n\tcur = in->cur[0];\r\r\n\tif (cur == 0) {\r\r\n\t SKIP(1);\r\r\n\t continue;\r\r\n\t}\r\r\n\r\r\n switch (ctxt->instate) {\r\r\n case XML_PARSER_EOF:\r\r\n\t /*\r\r\n\t\t * Document parsing is done !\r\r\n\t\t */\r\r\n\t goto done;\r\r\n case XML_PARSER_START:\r\r\n\t /*\r\r\n\t\t * Very first chars read from the document flow.\r\r\n\t\t */\r\r\n\t\tcur = in->cur[0];\r\r\n\t\tif (IS_BLANK_CH(cur)) {\r\r\n\t\t SKIP_BLANKS;\r\r\n\t\t if (in->buf == NULL)\r\r\n\t\t\tavail = in->length - (in->cur - in->base);\r\r\n\t\t else\r\r\n\t\t\tavail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);\r\r\n\t\t}\r\r\n\t\tif ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\r\r\n\t\t ctxt->sax->setDocumentLocator(ctxt->userData,\r\r\n\t\t\t\t\t\t &xmlDefaultSAXLocator);\r\r\n\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\r\r\n\t (!ctxt->disableSAX))\r\r\n\t\t ctxt->sax->startDocument(ctxt->userData);\r\r\n\r\r\n\t\tcur = in->cur[0];\r\r\n\t\tnext = in->cur[1];\r\r\n\t\tif ((cur == '<') && (next == '!') &&\r\r\n\t\t (UPP(2) == 'D') && (UPP(3) == 'O') &&\r\r\n\t\t (UPP(4) == 'C') && (UPP(5) == 'T') &&\r\r\n\t\t (UPP(6) == 'Y') && (UPP(7) == 'P') &&\r\r\n\t\t (UPP(8) == 'E')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing internal subset\\n\");\r\r\n#endif\r\r\n\t\t htmlParseDocTypeDecl(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_PROLOG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering PROLOG\\n\");\r\r\n#endif\r\r\n } else {\r\r\n\t\t ctxt->instate = XML_PARSER_MISC;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering MISC\\n\");\r\r\n#endif\r\r\n\t\t}\r\r\n\t\tbreak;\r\r\n case XML_PARSER_MISC:\r\r\n\t\tSKIP_BLANKS;\r\r\n\t\tif (in->buf == NULL)\r\r\n\t\t avail = in->length - (in->cur - in->base);\r\r\n\t\telse\r\r\n\t\t avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);\r\r\n\t\t/*\r\r\n\t\t * no chars in buffer\r\r\n\t\t */\r\r\n\t\tif (avail < 1)\r\r\n\t\t goto done;\r\r\n\t\t/*\r\r\n\t\t * not enouth chars in buffer\r\r\n\t\t */\r\r\n\t\tif (avail < 2) {\r\r\n\t\t if (!terminate)\r\r\n\t\t\tgoto done;\r\r\n\t\t else\r\r\n\t\t\tnext = ' ';\r\r\n\t\t} else {\r\r\n\t\t next = in->cur[1];\r\r\n\t\t}\r\r\n\t\tcur = in->cur[0];\r\r\n\t if ((cur == '<') && (next == '!') &&\r\r\n\t\t (in->cur[2] == '-') && (in->cur[3] == '-')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '-', '-', '>', 1, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing Comment\\n\");\r\r\n#endif\r\r\n\t\t htmlParseComment(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_MISC;\r\r\n\t } else if ((cur == '<') && (next == '?')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing PI\\n\");\r\r\n#endif\r\r\n\t\t htmlParsePI(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_MISC;\r\r\n\t\t} else if ((cur == '<') && (next == '!') &&\r\r\n\t\t (UPP(2) == 'D') && (UPP(3) == 'O') &&\r\r\n\t\t (UPP(4) == 'C') && (UPP(5) == 'T') &&\r\r\n\t\t (UPP(6) == 'Y') && (UPP(7) == 'P') &&\r\r\n\t\t (UPP(8) == 'E')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing internal subset\\n\");\r\r\n#endif\r\r\n\t\t htmlParseDocTypeDecl(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_PROLOG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering PROLOG\\n\");\r\r\n#endif\r\r\n\t\t} else if ((cur == '<') && (next == '!') &&\r\r\n\t\t (avail < 9)) {\r\r\n\t\t goto done;\r\r\n\t\t} else {\r\r\n\t\t ctxt->instate = XML_PARSER_START_TAG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering START_TAG\\n\");\r\r\n#endif\r\r\n\t\t}\r\r\n\t\tbreak;\r\r\n case XML_PARSER_PROLOG:\r\r\n\t\tSKIP_BLANKS;\r\r\n\t\tif (in->buf == NULL)\r\r\n\t\t avail = in->length - (in->cur - in->base);\r\r\n\t\telse\r\r\n\t\t avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);\r\r\n\t\tif (avail < 2)\r\r\n\t\t goto done;\r\r\n\t\tcur = in->cur[0];\r\r\n\t\tnext = in->cur[1];\r\r\n\t\tif ((cur == '<') && (next == '!') &&\r\r\n\t\t (in->cur[2] == '-') && (in->cur[3] == '-')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '-', '-', '>', 1, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing Comment\\n\");\r\r\n#endif\r\r\n\t\t htmlParseComment(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_PROLOG;\r\r\n\t } else if ((cur == '<') && (next == '?')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing PI\\n\");\r\r\n#endif\r\r\n\t\t htmlParsePI(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_PROLOG;\r\r\n\t\t} else if ((cur == '<') && (next == '!') &&\r\r\n\t\t (avail < 4)) {\r\r\n\t\t goto done;\r\r\n\t\t} else {\r\r\n\t\t ctxt->instate = XML_PARSER_START_TAG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering START_TAG\\n\");\r\r\n#endif\r\r\n\t\t}\r\r\n\t\tbreak;\r\r\n case XML_PARSER_EPILOG:\r\r\n\t\tif (in->buf == NULL)\r\r\n\t\t avail = in->length - (in->cur - in->base);\r\r\n\t\telse\r\r\n\t\t avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);\r\r\n\t\tif (avail < 1)\r\r\n\t\t goto done;\r\r\n\t\tcur = in->cur[0];\r\r\n\t\tif (IS_BLANK_CH(cur)) {\r\r\n\t\t htmlParseCharData(ctxt);\r\r\n\t\t goto done;\r\r\n\t\t}\r\r\n\t\tif (avail < 2)\r\r\n\t\t goto done;\r\r\n\t\tnext = in->cur[1];\r\r\n\t if ((cur == '<') && (next == '!') &&\r\r\n\t\t (in->cur[2] == '-') && (in->cur[3] == '-')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '-', '-', '>', 1, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing Comment\\n\");\r\r\n#endif\r\r\n\t\t htmlParseComment(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_EPILOG;\r\r\n\t } else if ((cur == '<') && (next == '?')) {\r\r\n\t\t if ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t\tgoto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: Parsing PI\\n\");\r\r\n#endif\r\r\n\t\t htmlParsePI(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_EPILOG;\r\r\n\t\t} else if ((cur == '<') && (next == '!') &&\r\r\n\t\t (avail < 4)) {\r\r\n\t\t goto done;\r\r\n\t\t} else {\r\r\n\t\t ctxt->errNo = XML_ERR_DOCUMENT_END;\r\r\n\t\t ctxt->wellFormed = 0;\r\r\n\t\t ctxt->instate = XML_PARSER_EOF;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering EOF\\n\");\r\r\n#endif\r\r\n\t\t if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\r\r\n\t\t\tctxt->sax->endDocument(ctxt->userData);\r\r\n\t\t goto done;\r\r\n\t\t}\r\r\n\t\tbreak;\r\r\n case XML_PARSER_START_TAG: {\r\r\n\t const xmlChar *name;\r\r\n\t\tint failed;\r\r\n\t\tconst htmlElemDesc * info;\r\r\n\r\r\n\t\t/*\r\r\n\t\t * no chars in buffer\r\r\n\t\t */\r\r\n\t\tif (avail < 1)\r\r\n\t\t goto done;\r\r\n\t\t/*\r\r\n\t\t * not enouth chars in buffer\r\r\n\t\t */\r\r\n\t\tif (avail < 2) {\r\r\n\t\t if (!terminate)\r\r\n\t\t\tgoto done;\r\r\n\t\t else\r\r\n\t\t\tnext = ' ';\r\r\n\t\t} else {\r\r\n\t\t next = in->cur[1];\r\r\n\t\t}\r\r\n\t\tcur = in->cur[0];\r\r\n\t if (cur != '<') {\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\t break;\r\r\n\t\t}\r\r\n\t\tif (next == '/') {\r\r\n\t\t ctxt->instate = XML_PARSER_END_TAG;\r\r\n\t\t ctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering END_TAG\\n\");\r\r\n#endif\r\r\n\t\t break;\r\r\n\t\t}\r\r\n\t\tif ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t goto done;\r\r\n\r\r\n /* Capture start position */\r\r\n\t if (ctxt->record_info) {\r\r\n\t node_info.begin_pos = ctxt->input->consumed +\r\r\n\t (CUR_PTR - ctxt->input->base);\r\r\n\t node_info.begin_line = ctxt->input->line;\r\r\n\t }\r\r\n\r\r\n\r\r\n\t\tfailed = htmlParseStartTag(ctxt);\r\r\n\t\tname = ctxt->name;\r\r\n\t\tif ((failed == -1) ||\r\r\n\t\t (name == NULL)) {\r\r\n\t\t if (CUR == '>')\r\r\n\t\t\tNEXT;\r\r\n\t\t break;\r\r\n\t\t}\r\r\n\r\r\n\t\t/*\r\r\n\t\t * Lookup the info for that element.\r\r\n\t\t */\r\r\n\t\tinfo = htmlTagLookup(name);\r\r\n\t\tif (info == NULL) {\r\r\n\t\t htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\r\r\n\t\t \"Tag %s invalid\\n\", name, NULL);\r\r\n\t\t}\r\r\n\r\r\n\t\t/*\r\r\n\t\t * Check for an Empty Element labeled the XML/SGML way\r\r\n\t\t */\r\r\n\t\tif ((CUR == '/') && (NXT(1) == '>')) {\r\r\n\t\t SKIP(2);\r\r\n\t\t if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\r\r\n\t\t\tctxt->sax->endElement(ctxt->userData, name);\r\r\n\t\t htmlnamePop(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\t break;\r\r\n\t\t}\r\r\n\r\r\n\t\tif (CUR == '>') {\r\r\n\t\t NEXT;\r\r\n\t\t} else {\r\r\n\t\t htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\r\r\n\t\t \"Couldn't find end of Start Tag %s\\n\",\r\r\n\t\t\t\t name, NULL);\r\r\n\r\r\n\t\t /*\r\r\n\t\t * end of parsing of this node.\r\r\n\t\t */\r\r\n\t\t if (xmlStrEqual(name, ctxt->name)) {\r\r\n\t\t\tnodePop(ctxt);\r\r\n\t\t\thtmlnamePop(ctxt);\r\r\n\t\t }\r\r\n\r\r\n\t\t if (ctxt->record_info)\r\r\n\t\t htmlNodeInfoPush(ctxt, &node_info);\r\r\n\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t \"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\t break;\r\r\n\t\t}\r\r\n\r\r\n\t\t/*\r\r\n\t\t * Check for an Empty Element from DTD definition\r\r\n\t\t */\r\r\n\t\tif ((info != NULL) && (info->empty)) {\r\r\n\t\t if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\r\r\n\t\t\tctxt->sax->endElement(ctxt->userData, name);\r\r\n\t\t htmlnamePop(ctxt);\r\r\n\t\t}\r\r\n\r\r\n if (ctxt->record_info)\r\r\n\t htmlNodeInfoPush(ctxt, &node_info);\r\r\n\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n break;\r\r\n\t }\r\r\n case XML_PARSER_CONTENT: {\r\r\n\t\tlong cons;\r\r\n /*\r\r\n\t\t * Handle preparsed entities and charRef\r\r\n\t\t */\r\r\n\t\tif (ctxt->token != 0) {\r\r\n\t\t xmlChar chr[2] = { 0 , 0 } ;\r\r\n\r\r\n\t\t chr[0] = (xmlChar) ctxt->token;\r\r\n\t\t htmlCheckParagraph(ctxt);\r\r\n\t\t if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\r\r\n\t\t\tctxt->sax->characters(ctxt->userData, chr, 1);\r\r\n\t\t ctxt->token = 0;\r\r\n\t\t ctxt->checkIndex = 0;\r\r\n\t\t}\r\r\n\t\tif ((avail == 1) && (terminate)) {\r\r\n\t\t cur = in->cur[0];\r\r\n\t\t if ((cur != '<') && (cur != '&')) {\r\r\n\t\t\tif (ctxt->sax != NULL) {\r\r\n\t\t\t if (IS_BLANK_CH(cur)) {\r\r\n\t\t\t\tif (ctxt->keepBlanks) {\r\r\n\t\t\t\t if (ctxt->sax->characters != NULL)\r\r\n\t\t\t\t\tctxt->sax->characters(\r\r\n\t\t\t\t\t\tctxt->userData, &in->cur[0], 1);\r\r\n\t\t\t\t} else {\r\r\n\t\t\t\t if (ctxt->sax->ignorableWhitespace != NULL)\r\r\n\t\t\t\t\tctxt->sax->ignorableWhitespace(\r\r\n\t\t\t\t\t\tctxt->userData, &in->cur[0], 1);\r\r\n\t\t\t\t}\r\r\n\t\t\t } else {\r\r\n\t\t\t\thtmlCheckParagraph(ctxt);\r\r\n\t\t\t\tif (ctxt->sax->characters != NULL)\r\r\n\t\t\t\t ctxt->sax->characters(\r\r\n\t\t\t\t\t ctxt->userData, &in->cur[0], 1);\r\r\n\t\t\t }\r\r\n\t\t\t}\r\r\n\t\t\tctxt->token = 0;\r\r\n\t\t\tctxt->checkIndex = 0;\r\r\n\t\t\tin->cur++;\r\r\n\t\t\tbreak;\r\r\n\t\t }\r\r\n\t\t}\r\r\n\t\tif (avail < 2)\r\r\n\t\t goto done;\r\r\n\t\tcur = in->cur[0];\r\r\n\t\tnext = in->cur[1];\r\r\n\t\tcons = ctxt->nbChars;\r\r\n\t\tif ((xmlStrEqual(ctxt->name, BAD_CAST\"script\")) ||\r\r\n\t\t (xmlStrEqual(ctxt->name, BAD_CAST\"style\"))) {\r\r\n\t\t /*\r\r\n\t\t * Handle SCRIPT/STYLE separately\r\r\n\t\t */\r\r\n\t\t if (!terminate) {\r\r\n\t\t int idx;\r\r\n\t\t\txmlChar val;\r\r\n\r\r\n\t\t\tidx = htmlParseLookupSequence(ctxt, '<', '/', 0, 0, 0);\r\r\n\t\t\tif (idx < 0)\r\r\n\t\t\t goto done;\r\r\n\t\t val = in->cur[idx + 2];\r\r\n\t\t\tif (val == 0) /* bad cut of input */\r\r\n\t\t\t goto done;\r\r\n\t\t }\r\r\n\t\t htmlParseScript(ctxt);\r\r\n\t\t if ((cur == '<') && (next == '/')) {\r\r\n\t\t\tctxt->instate = XML_PARSER_END_TAG;\r\r\n\t\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\t\"HPP: entering END_TAG\\n\");\r\r\n#endif\r\r\n\t\t\tbreak;\r\r\n\t\t }\r\r\n\t\t} else {\r\r\n\t\t /*\r\r\n\t\t * Sometimes DOCTYPE arrives in the middle of the document\r\r\n\t\t */\r\r\n\t\t if ((cur == '<') && (next == '!') &&\r\r\n\t\t\t(UPP(2) == 'D') && (UPP(3) == 'O') &&\r\r\n\t\t\t(UPP(4) == 'C') && (UPP(5) == 'T') &&\r\r\n\t\t\t(UPP(6) == 'Y') && (UPP(7) == 'P') &&\r\r\n\t\t\t(UPP(8) == 'E')) {\r\r\n\t\t\tif ((!terminate) &&\r\r\n\t\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t\t goto done;\r\r\n\t\t\thtmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\r\r\n\t\t\t \"Misplaced DOCTYPE declaration\\n\",\r\r\n\t\t\t\t BAD_CAST \"DOCTYPE\" , NULL);\r\r\n\t\t\thtmlParseDocTypeDecl(ctxt);\r\r\n\t\t } else if ((cur == '<') && (next == '!') &&\r\r\n\t\t\t(in->cur[2] == '-') && (in->cur[3] == '-')) {\r\r\n\t\t\tif ((!terminate) &&\r\r\n\t\t\t (htmlParseLookupSequence(\r\r\n\t\t\t\tctxt, '-', '-', '>', 1, 1) < 0))\r\r\n\t\t\t goto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\t\"HPP: Parsing Comment\\n\");\r\r\n#endif\r\r\n\t\t\thtmlParseComment(ctxt);\r\r\n\t\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\t } else if ((cur == '<') && (next == '?')) {\r\r\n\t\t\tif ((!terminate) &&\r\r\n\t\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t\t goto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\t\"HPP: Parsing PI\\n\");\r\r\n#endif\r\r\n\t\t\thtmlParsePI(ctxt);\r\r\n\t\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\t } else if ((cur == '<') && (next == '!') && (avail < 4)) {\r\r\n\t\t\tgoto done;\r\r\n\t\t } else if ((cur == '<') && (next == '/')) {\r\r\n\t\t\tctxt->instate = XML_PARSER_END_TAG;\r\r\n\t\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\t\"HPP: entering END_TAG\\n\");\r\r\n#endif\r\r\n\t\t\tbreak;\r\r\n\t\t } else if (cur == '<') {\r\r\n\t\t\tctxt->instate = XML_PARSER_START_TAG;\r\r\n\t\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\t\"HPP: entering START_TAG\\n\");\r\r\n#endif\r\r\n\t\t\tbreak;\r\r\n\t\t } else if (cur == '&') {\r\r\n\t\t\tif ((!terminate) &&\r\r\n\t\t\t (htmlParseLookupChars(ctxt,\r\r\n BAD_CAST \"; >/\", 4) < 0))\r\r\n\t\t\t goto done;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\t\"HPP: Parsing Reference\\n\");\r\r\n#endif\r\r\n\t\t\t/* TODO: check generation of subtrees if noent !!! */\r\r\n\t\t\thtmlParseReference(ctxt);\r\r\n\t\t } else {\r\r\n\t\t /*\r\r\n\t\t\t * check that the text sequence is complete\r\r\n\t\t\t * before handing out the data to the parser\r\r\n\t\t\t * to avoid problems with erroneous end of\r\r\n\t\t\t * data detection.\r\r\n\t\t\t */\r\r\n\t\t\tif ((!terminate) &&\r\r\n (htmlParseLookupChars(ctxt, BAD_CAST \"<&\", 2) < 0))\r\r\n\t\t\t goto done;\r\r\n\t\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\t\"HPP: Parsing char data\\n\");\r\r\n#endif\r\r\n\t\t\thtmlParseCharData(ctxt);\r\r\n\t\t }\r\r\n\t\t}\r\r\n\t\tif (cons == ctxt->nbChars) {\r\r\n\t\t if (ctxt->node != NULL) {\r\r\n\t\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t \"detected an error in element content\\n\",\r\r\n\t\t\t\t NULL, NULL);\r\r\n\t\t }\r\r\n\t\t NEXT;\r\r\n\t\t break;\r\r\n\t\t}\r\r\n\r\r\n\t\tbreak;\r\r\n\t }\r\r\n case XML_PARSER_END_TAG:\r\r\n\t\tif (avail < 2)\r\r\n\t\t goto done;\r\r\n\t\tif ((!terminate) &&\r\r\n\t\t (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))\r\r\n\t\t goto done;\r\r\n\t\thtmlParseEndTag(ctxt);\r\r\n\t\tif (ctxt->nameNr == 0) {\r\r\n\t\t ctxt->instate = XML_PARSER_EPILOG;\r\r\n\t\t} else {\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\t}\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t break;\r\r\n case XML_PARSER_CDATA_SECTION:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == CDATA\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n case XML_PARSER_DTD:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == DTD\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n case XML_PARSER_COMMENT:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == COMMENT\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n case XML_PARSER_PI:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == PI\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n case XML_PARSER_ENTITY_DECL:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == ENTITY_DECL\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n case XML_PARSER_ENTITY_VALUE:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == ENTITY_VALUE\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering DTD\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n case XML_PARSER_ATTRIBUTE_VALUE:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == ATTRIBUTE_VALUE\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_START_TAG;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering START_TAG\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n\t case XML_PARSER_SYSTEM_LITERAL:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t \"HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n\t case XML_PARSER_IGNORE:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == XML_PARSER_IGNORE\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n\t case XML_PARSER_PUBLIC_LITERAL:\r\r\n\t\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n\t\t\t\"HPP: internal error, state == XML_PARSER_LITERAL\\n\",\r\r\n\t\t\t NULL, NULL);\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n\t\t\t\"HPP: entering CONTENT\\n\");\r\r\n#endif\r\r\n\t\tbreak;\r\r\n\r\r\n\t}\r\r\n }\r\r\ndone:\r\r\n if ((avail == 0) && (terminate)) {\r\r\n\thtmlAutoCloseOnEnd(ctxt);\r\r\n\tif ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\r\r\n\t /*\r\r\n\t * SAX: end of the document processing.\r\r\n\t */\r\r\n\t ctxt->instate = XML_PARSER_EOF;\r\r\n\t if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\r\r\n\t\tctxt->sax->endDocument(ctxt->userData);\r\r\n\t}\r\r\n }\r\r\n if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL) &&\r\r\n\t((terminate) || (ctxt->instate == XML_PARSER_EOF) ||\r\r\n\t (ctxt->instate == XML_PARSER_EPILOG))) {\r\r\n\txmlDtdPtr dtd;\r\r\n\tdtd = xmlGetIntSubset(ctxt->myDoc);\r\r\n\tif (dtd == NULL)\r\r\n\t ctxt->myDoc->intSubset =\r\r\n\t\txmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\r\r\n\t\t BAD_CAST \"-//W3C//DTD HTML 4.0 Transitional//EN\",\r\r\n\t\t BAD_CAST \"http://www.w3.org/TR/REC-html40/loose.dtd\");\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n xmlGenericError(xmlGenericErrorContext, \"HPP: done %d\\n\", ret);\r\r\n#endif\r\r\n return(ret);\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint vorticella_intumescing = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nsem_t sem;\r\npthread_t t0, t1;\r\nchar *global_str;\r\nint isspace(char c) {\r\n return (c == ' ' || c == '\\t' || c == '\\n');\r\n}\r\nvoid *replaceSpace () {\r\n int i = 0;\r\n printf(\"Replacing spaces\\n\");\r\n \r\n \r\n \r\n sem_wait(&sem); \r\n sem_wait(&sem);\r\n \r\n while(global_str[i] != '\\0') {\r\n if (isspace(global_str[i]) != 0) {\r\n global_str[i] = '_';\r\n }\r\n i++;\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\nvoid *toCap () {\r\n int i = 0;\r\n \r\n \r\n printf(\"Capitalizing input\\n\");\r\n sem_wait(&sem);\r\n \r\n while(global_str[i] != '\\0') {\r\n if (global_str[i] > 'a' && global_str[i] < 'z') {\r\n global_str[i] -= 'a' - 'A';\r\n }\r\n i++;\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int hasSpaces = 0;\r\n int i = 0;\r\n char *barbecuer_overheap = 0;\r\n char **cargos_obiism = 0;\r\n char **unirritableness_kun = 0;\r\n char *leisureless_boito;;\r\n if (__sync_bool_compare_and_swap(&vorticella_intumescing,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n leisureless_boito = getenv(\"REUNE_SHOTTY\");\r\n if (leisureless_boito != 0) {;\r\n cargos_obiism = &leisureless_boito;\r\n unirritableness_kun = cargos_obiism + 5;\r\n if ( *(unirritableness_kun - 5) != 0) {\r\n goto tex_tourmalinize;\r\n }\r\n ++global_variable;\r\n tex_tourmalinize:;\r\n barbecuer_overheap = ((char *)( *(unirritableness_kun - 5)));\r\n \r\n sem_init(&sem, 0, 1);\r\n while(barbecuer_overheap[i] != '\\0') { \r\n if (isspace(barbecuer_overheap[i++]) != 0) { \r\n hasSpaces = 1;\r\n }\r\n }\r\n \r\n global_str = malloc(sizeof(char) * strlen(barbecuer_overheap) + 1);\r\n strcpy(global_str, barbecuer_overheap);\r\n if (hasSpaces == 1) {\r\n \r\n \r\n if (pthread_create(&t0, NULL, replaceSpace, NULL) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n \r\n }\r\n if (pthread_create(&t1, NULL, toCap, NULL) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n if (hasSpaces == 1) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n sem_wait(&sem); \n sem_wait(&sem);\n```", "cwe": "764"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <mongoose.h> \r\n#include <string.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint wittering_uniatism = 0;\r\n\r\nstruct diggings_unordered \r\n{\r\n char *algeria_musked;\r\n double whelk_zostera;\r\n char *andrus_imitt;\r\n char attemper_degasify;\r\n int armhoop_myxospongian;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *qualificator_nonpropagandist);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct diggings_unordered yaounde_tyrosines(struct diggings_unordered transacting_conductible);\r\nvoid sala_chassepots(struct diggings_unordered nontolerable_all);\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid arrFunc (struct data *Data) {\r\n int *arr = malloc(sizeof(int) * Data->qsize);\r\n int i;\r\n int j;\r\n FILE *fp;\r\n static int ctr;\r\n \r\n \r\n ctr = 0; \r\n for(i = 0; \r\n i < Data->data_size; \r\n i++, ctr++)\r\n {\r\n \r\n Data->data[ctr] = '\\0';\r\n printf(\"I: %d, C: %d\\n\", i, ctr);\r\n if (Data->qsize > 5) {\r\n fp = fopen(\"asdfqwer1234\", \"w+\");\r\n fprintf(fp, \"%d\", i);\r\n fclose(fp);\r\n for (j = 0; j < Data->qsize; j++) {\r\n arr[j] = Data->qsize - j;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n }\r\n }\r\n free(arr);\r\n \r\n \r\n \r\n}\r\nvoid *replaceSymbols(void *data) {\r\n struct data *Data = data;\r\n int i;\r\n \r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if (((Data->data[i] >= '!' && Data->data[i] <= '/') ||\r\n (Data->data[i] >= ':' && Data->data[i] <= '@') ||\r\n (Data->data[i] >= '[' && Data->data[i] <= '`') ||\r\n (Data->data[i] >= '{' && Data->data[i] <= '~')) &&\r\n (Data->data[i] != '@' && Data->data[i] != '.'))\r\n {\r\n Data->data[i] = '_';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\nvoid *toCaps(void *data) {\r\n struct data *Data = data;\r\n int threadTiming = 500000;\r\n int j;\r\n int *arr;\r\n int i;\r\n \r\n \r\n arr = malloc(sizeof(int)*threadTiming);\r\n if (arr != NULL) {\r\n for (j = 0; j < threadTiming; j++) {\r\n arr[j] = threadTiming - j;\r\n }\r\n qsort(arr, threadTiming, sizeof(int), &comp);\r\n free (arr);\r\n arr = NULL;\r\n }\r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if(Data->data[i] >= 'a' && Data->data[i] <= 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&wittering_uniatism,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n#define LEPTOKURTOSIS_AQUA(x) sala_chassepots((struct diggings_unordered) x)\r\n\r\nvoid handle_taint(char *qualificator_nonpropagandist)\r\n{\r\n struct diggings_unordered markmote_bankings = {0};\r\n struct diggings_unordered smoothened_pratdesaba;\r\n ++global_variable;;\r\n if (qualificator_nonpropagandist != 0) {;\r\n smoothened_pratdesaba . algeria_musked = ((char *)qualificator_nonpropagandist);\r\n markmote_bankings = yaounde_tyrosines(smoothened_pratdesaba);\r\n\tLEPTOKURTOSIS_AQUA(markmote_bankings);\r\n }\r\n}\r\n\r\nstruct diggings_unordered yaounde_tyrosines(struct diggings_unordered transacting_conductible)\r\n{\r\n ++global_variable;\r\n return transacting_conductible;\r\n}\r\n\r\nvoid sala_chassepots(struct diggings_unordered nontolerable_all)\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data = malloc(sizeof(struct data));\r\n char *chatting_phaneroscope = 0;\r\n ++global_variable;;\r\n chatting_phaneroscope = ((char *)nontolerable_all . algeria_musked);\r\n \r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(chatting_phaneroscope)+ 1));\r\n if (Data->data &&\r\n (sscanf(chatting_phaneroscope, \"%d %s\", &Data->qsize, Data->data) == 2) &&\r\n (strlen(Data->data) != 0)) {\r\n pthread_mutex_init(&mutex, NULL);\r\n Data->data_size = strlen(Data->data);\r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, replaceSymbols, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toCaps, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex);\r\n \r\n \r\n free(Data->data);\r\n \r\n }\r\n else {\r\n printf(\"Error parsing input.\\n\");\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (nontolerable_all . algeria_musked != 0) \r\n free(((char *)nontolerable_all . algeria_musked));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n free(Data->data);\n```", "cwe": "663"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint kobo_schizophrene = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\nstruct struct {\r\n int (* before)(int);\r\n char buffer[64];\r\n int (* after)(int);\r\n};\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n int i = 0;\r\n struct struct* data = NULL;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *eupathy_forsythia = 0;\r\n void *apex_diametrical = 0;\r\n long basaree_propylidene[10];\r\n void *biasing_conveying[10] = {0};\r\n void *crambes_seidule = 0;\r\n char *landladydom_drosky;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&kobo_schizophrene,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n landladydom_drosky = getenv(\"REPRESSOR_POMMELS\");\r\n if (landladydom_drosky != 0) {;\r\n crambes_seidule = ((void *)landladydom_drosky);\r\n biasing_conveying[5] = crambes_seidule;\r\n basaree_propylidene[1] = 5;\r\n apex_diametrical = *(biasing_conveying + basaree_propylidene[1]);\r\n if (((char *)apex_diametrical) != 0) {\r\n goto lusterlessness_monocarps;\r\n }\r\n ++global_variable;\r\n lusterlessness_monocarps:;\r\n eupathy_forsythia = ((char *)((char *)apex_diametrical));\r\n \r\n \r\n \r\n data = (struct struct*) malloc(sizeof(struct struct));\r\n if (data != NULL) {\r\n data->before = toupper;\r\n memset(data->buffer, 'A', 64);\r\n data->buffer[63] = '\\0';\r\n data->after = toupper;\r\n \r\n \r\n \r\n \r\n \r\n taint_len = ((int )(strlen(eupathy_forsythia)));\r\n \r\n \r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n data->buffer[buff_size] = eupathy_forsythia[taint_len];\r\n }\r\n \r\n for (i = 0; i < 64; ++i) {\r\n data->buffer[i] = toupper(data->buffer[i]);\r\n printf(\"%c\",data->before(data->buffer[i]));\r\n }\r\n \r\n \r\n printf(\"\\n\");\r\n free(data);\r\n \r\n \r\n \r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` taint_len = ((int )(strlen(eupathy_forsythia)));\n \n \n for (; taint_len >= 0; (--buff_size , --taint_len)) {\n data->buffer[buff_size] = eupathy_forsythia[taint_len];\n }\n \n for (i = 0; i < 64; ++i) {\n data->buffer[i] = toupper(data->buffer[i]);\n printf(\"%c\",data->before(data->buffer[i]));\n }\n```", "cwe": "124"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/crc.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/avassert.h\"\r\n#include \"avcodec.h\"\r\n#include \"dsputil.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"thread.h\"\r\n#include \"frame_thread_encoder.h\"\r\n#include \"internal.h\"\r\n#include \"bytestream.h\"\r\n#include <stdlib.h>\r\n#include <stdarg.h>\r\n#include <limits.h>\r\n#include <float.h>\r\n#if CONFIG_ICONV\r\n# include <iconv.h>\r\n#endif\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\npthread_spinlock_t ff_avcodec_locked;\r\nstatic pthread_spinlock_t entangled_thread_counter = 0;\r\nstatic int (*ff_lockmgr_cb)(void **, enum AVLockOp );\r\nstatic void *codec_mutex;\r\nstatic void *avformat_mutex;\r\nint iridescent_terrye = 0;\r\nint global_variable;\r\ntypedef char *saliaric_antialbumin;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid herman_precontention(const saliaric_antialbumin vulcanize_miming);\r\nvoid palingenesian_apism(int precolor_weakheartedly,saliaric_antialbumin inhumanism_idealists);\r\nint 190_global_var = 0;\r\n\r\nvoid *av_fast_realloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n if (min_size < ( *size)) {\r\n return ptr;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n ptr = av_realloc(ptr,min_size);\r\n\r\n if (!ptr) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return ptr;\r\n}\r\n\r\ninline static int ff_fast_malloc(void *ptr,unsigned int *size,size_t min_size,int zero_realloc)\r\n{\r\n void **p = ptr;\r\n if (min_size < ( *size)) {\r\n return 0;\r\n }\r\n min_size = (17 * min_size / 16 + 32 > min_size?17 * min_size / 16 + 32 : min_size);\r\n av_free( *p);\r\n *p = (zero_realloc?av_mallocz(min_size) : av_malloc(min_size));\r\n if (!( *p)) {\r\n min_size = 0;\r\n }\r\n *size = min_size;\r\n return 1;\r\n}\r\n\r\nvoid av_fast_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n ff_fast_malloc(ptr,size,min_size,0);\r\n}\r\n\r\nvoid av_fast_padded_malloc(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p + min_size),0,16);\r\n }\r\n}\r\n\r\nvoid av_fast_padded_mallocz(void *ptr,unsigned int *size,size_t min_size)\r\n{\r\n uint8_t **p = ptr;\r\n if (min_size > 18446744073709551615UL - 16) {\r\n av_freep(p);\r\n *size = 0;\r\n return ;\r\n }\r\n if (!ff_fast_malloc(p,size,min_size + 16,1)) {\r\n memset(( *p),0,min_size + 16);\r\n }\r\n}\r\n\r\nstatic AVCodec *first_avcodec = ((void *)0);\r\n\r\nAVCodec *av_codec_next(const AVCodec *c)\r\n{\r\n if (c) {\r\n return c -> next;\r\n }\r\n else {\r\n return first_avcodec;\r\n }\r\n}\r\n\r\nstatic void avcodec_init()\r\n{\r\n static int initialized = 0;\r\n if (initialized != 0) {\r\n return ;\r\n }\r\n initialized = 1;\r\n ff_dsputil_static_init();\r\n}\r\n\r\nint av_codec_is_encoder(const AVCodec *codec)\r\n{\r\n return codec && (codec -> encode_sub || codec -> encode2);\r\n}\r\n\r\nint av_codec_is_decoder(const AVCodec *codec)\r\n{\r\n return codec && codec -> decode;\r\n}\r\n\r\nvoid avcodec_register(AVCodec *codec)\r\n{\r\n AVCodec **p;\r\n avcodec_init();\r\n p = &first_avcodec;\r\n while( *p != ((void *)0))\r\n p = &( *p) -> next;\r\n *p = codec;\r\n codec -> next = ((void *)0);\r\n if (codec -> init_static_data) {\r\n (codec -> init_static_data)(codec);\r\n }\r\n}\r\n\r\nunsigned int avcodec_get_edge_width()\r\n{\r\n return 16;\r\n}\r\n\r\nvoid avcodec_set_dimensions(AVCodecContext *s,int width,int height)\r\n{\r\n s -> coded_width = width;\r\n s -> coded_height = height;\r\n s -> width = -(-width >> s -> lowres);\r\n s -> height = -(-height >> s -> lowres);\r\n}\r\n#define INTERNAL_BUFFER_SIZE (32 + 1)\r\n#if (ARCH_ARM && HAVE_NEON) || ARCH_PPC || HAVE_MMX\r\n# define STRIDE_ALIGN 16\r\n#else\r\n# define STRIDE_ALIGN 8\r\n#endif\r\n\r\nvoid avcodec_align_dimensions2(AVCodecContext *s,int *width,int *height,int linesize_align[8])\r\n{\r\n int i;\r\n int w_align = 1;\r\n int h_align = 1;\r\n switch(s -> pix_fmt){\r\n case AV_PIX_FMT_YUV420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUYV422:\r\n{\r\n }\r\n case AV_PIX_FMT_UYVY422:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY8:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GRAY16LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ440P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVJ444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA420P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA422P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUVA444P:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV420P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV422P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_YUV444P14BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP9BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP10BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP12BE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14LE:\r\n{\r\n }\r\n case AV_PIX_FMT_GBRP14BE:\r\n{\r\n\r\n w_align = 16;\r\n\r\n h_align = 16 * 2;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV411P:\r\n{\r\n }\r\n case AV_PIX_FMT_UYYVYY411:\r\n{\r\n w_align = 32;\r\n h_align = 8;\r\n break; \r\n }\r\n case AV_PIX_FMT_YUV410P:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SVQ1) {\r\n w_align = 64;\r\n h_align = 64;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB555LE:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_RPZA) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_PAL8:\r\n{\r\n }\r\n case AV_PIX_FMT_BGR8:\r\n{\r\n }\r\n case AV_PIX_FMT_RGB8:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_SMC || (s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_BGR24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_MSZH || (s -> codec_id) == AV_CODEC_ID_ZLIB) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n case AV_PIX_FMT_RGB24:\r\n{\r\n if ((s -> codec_id) == AV_CODEC_ID_CINEPAK) {\r\n w_align = 4;\r\n h_align = 4;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n w_align = 1;\r\n h_align = 1;\r\n break; \r\n }\r\n }\r\n if ((s -> codec_id) == AV_CODEC_ID_IFF_ILBM || (s -> codec_id) == AV_CODEC_ID_IFF_BYTERUN1) {\r\n w_align = (w_align > 8?w_align : 8);\r\n }\r\n *width = *width + w_align - 1 & ~(w_align - 1);\r\n *height = *height + h_align - 1 & ~(h_align - 1);\r\n if ((s -> codec_id) == AV_CODEC_ID_H264 || s -> lowres) {\r\n\r\n\r\n *height += 2;\r\n }\r\n for (i = 0; i < 4; i++) \r\n linesize_align[i] = 8;\r\n}\r\n\r\nvoid avcodec_align_dimensions(AVCodecContext *s,int *width,int *height)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n int chroma_shift = (desc -> log2_chroma_w);\r\n int linesize_align[8];\r\n int align;\r\n avcodec_align_dimensions2(s,width,height,linesize_align);\r\n align = (linesize_align[0] > linesize_align[3]?linesize_align[0] : linesize_align[3]);\r\n linesize_align[1] <<= chroma_shift;\r\n linesize_align[2] <<= chroma_shift;\r\n align = (((align > linesize_align[1]?align : linesize_align[1])) > linesize_align[2]?((align > linesize_align[1]?align : linesize_align[1])) : linesize_align[2]);\r\n *width = *width + align - 1 & ~(align - 1);\r\n}\r\n\r\nint avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align)\r\n{\r\n int ch;\r\n int planar;\r\n int needed_size;\r\n int ret = 0;\r\n needed_size = av_samples_get_buffer_size(((void *)0),nb_channels,frame -> nb_samples,sample_fmt,align);\r\n if (buf_size < needed_size) {\r\n return - 22;\r\n }\r\n planar = av_sample_fmt_is_planar(sample_fmt);\r\n if (planar && nb_channels > 8) {\r\n if (!(frame -> extended_data = (av_mallocz(nb_channels * sizeof(( *frame -> extended_data)))))) {\r\n return - '\\f';\r\n }\r\n }\r\n else {\r\n frame -> extended_data = frame -> data;\r\n }\r\n if ((ret = av_samples_fill_arrays(frame -> extended_data,&frame -> linesize[0],((uint8_t *)((intptr_t )buf)),nb_channels,frame -> nb_samples,sample_fmt,align)) < 0) {\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret;\r\n }\r\n if (frame -> extended_data != frame -> data) {\r\n for (ch = 0; ch < 8; ch++) \r\n frame -> data[ch] = frame -> extended_data[ch];\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int audio_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n int buf_size;\r\n int ret;\r\n av_freep((&avci -> audio_data));\r\n buf_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,0);\r\n if (buf_size < 0) {\r\n return - 22;\r\n }\r\n frame -> data[0] = (av_mallocz(buf_size));\r\n if (!frame -> data[0]) {\r\n return - '\\f';\r\n }\r\n ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,frame -> data[0],buf_size,0);\r\n if (ret < 0) {\r\n av_freep((&frame -> data[0]));\r\n return ret;\r\n }\r\n avci -> audio_data = frame -> data[0];\r\n if (avctx -> debug & 0x8000) {\r\n av_log(avctx,48,\"default_get_buffer called on frame %p, internal audio buffer used\\n\",frame);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int video_get_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n int w = s -> width;\r\n int h = s -> height;\r\n InternalBuffer *buf;\r\n AVCodecInternal *avci = s -> internal;\r\n if (pic -> data[0] != ((void *)0)) {\r\n av_log(s,16,\"pic->data[0]!=NULL in avcodec_default_get_buffer\\n\");\r\n return - 1;\r\n }\r\n if (avci -> buffer_count >= 32 + 1) {\r\n av_log(s,16,\"buffer_count overflow (missing release_buffer?)\\n\");\r\n return - 1;\r\n }\r\n if (av_image_check_size(w,h,0,s) || (s -> pix_fmt) < 0) {\r\n av_log(s,16,\"video_get_buffer: image parameters invalid\\n\");\r\n return - 1;\r\n }\r\n if (!avci -> buffer) {\r\n avci -> buffer = (av_mallocz((32 + 1 + 1) * sizeof(InternalBuffer )));\r\n }\r\n buf = &avci -> buffer[avci -> buffer_count];\r\n if (buf -> base[0] && (buf -> width != w || buf -> height != h || (buf -> pix_fmt) != (s -> pix_fmt))) {\r\n for (i = 0; i < 8; i++) {\r\n av_freep((&buf -> base[i]));\r\n buf -> data[i] = ((void *)0);\r\n }\r\n }\r\n if (!buf -> base[0]) {\r\n int h_chroma_shift;\r\n int v_chroma_shift;\r\n int size[4] = {(0)};\r\n int tmpsize;\r\n int unaligned;\r\n AVPicture picture;\r\n int stride_align[8];\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s -> pix_fmt);\r\n const int pixel_size = desc -> comp[0] . step_minus1 + 1;\r\n av_pix_fmt_get_chroma_sub_sample(s -> pix_fmt,&h_chroma_shift,&v_chroma_shift);\r\n avcodec_align_dimensions2(s,&w,&h,stride_align);\r\n if (!(s -> flags & 0x4000)) {\r\n w += 16 * 2;\r\n h += 16 * 2;\r\n }\r\n do {\r\n\r\n\r\n av_image_fill_linesizes(picture . linesize,s -> pix_fmt,w);\r\n\r\n w += w & ~(w - 1);\r\n unaligned = 0;\r\n for (i = 0; i < 4; i++) \r\n unaligned |= picture . linesize[i] % stride_align[i];\r\n }while (unaligned);\r\n tmpsize = av_image_fill_pointers(picture . data,s -> pix_fmt,h,((void *)0),picture . linesize);\r\n if (tmpsize < 0) {\r\n return - 1;\r\n }\r\n for (i = 0; i < 3 && picture . data[i + 1]; i++) \r\n size[i] = (picture . data[i + 1] - picture . data[i]);\r\n size[i] = (tmpsize - (picture . data[i] - picture . data[0]));\r\n memset((buf -> base),0,sizeof(buf -> base));\r\n memset((buf -> data),0,sizeof(buf -> data));\r\n for (i = 0; i < 4 && size[i]; i++) {\r\n const int h_shift = i == 0?0 : h_chroma_shift;\r\n const int v_shift = i == 0?0 : v_chroma_shift;\r\n buf -> linesize[i] = picture . linesize[i];\r\n\r\n buf -> base[i] = (av_malloc((size[i] + 16 + 8 - 1)));\r\n if (buf -> base[i] == ((void *)0)) {\r\n return - '\\f';\r\n }\r\n\r\n if (s -> flags & 0x4000 || !size[2]) {\r\n buf -> data[i] = buf -> base[i];\r\n }\r\n else {\r\n buf -> data[i] = buf -> base[i] + ((buf -> linesize[i] * 16 >> v_shift) + (pixel_size * 16 >> h_shift) + stride_align[i] - 1 & ~(stride_align[i] - 1));\r\n }\r\n }\r\n for (; i < 8; i++) {\r\n buf -> base[i] = buf -> data[i] = ((void *)0);\r\n buf -> linesize[i] = 0;\r\n }\r\n if (size[1] && !size[2]) {\r\n avpriv_set_systematic_pal2(((uint32_t *)buf -> data[1]),s -> pix_fmt);\r\n }\r\n buf -> width = s -> width;\r\n buf -> height = s -> height;\r\n buf -> pix_fmt = s -> pix_fmt;\r\n }\r\n for (i = 0; i < 8; i++) {\r\n pic -> base[i] = buf -> base[i];\r\n pic -> data[i] = buf -> data[i];\r\n pic -> linesize[i] = buf -> linesize[i];\r\n }\r\n pic -> extended_data = pic -> data;\r\n avci -> buffer_count++;\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_get_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n return 0;\r\n}\r\n\r\nvoid avpriv_color_frame(AVFrame *frame,const int c[4])\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get((frame -> format));\r\n int p;\r\n int y;\r\n int x;\r\n do {\r\n if (!((desc -> flags) & 16)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"desc->flags & 16\",\"utils.c\",518);\r\n abort();\r\n }\r\n }while (0);\r\n for (p = 0; p < (desc -> nb_components); p++) {\r\n uint8_t *dst = frame -> data[p];\r\n int is_chroma = p == 1 || p == 2;\r\n int bytes = -(-frame -> width >> ((is_chroma?(desc -> log2_chroma_w) : 0)));\r\n for (y = 0; y < -(-frame -> height >> ((is_chroma?(desc -> log2_chroma_h) : 0))); y++) {\r\n if (desc -> comp[0] . depth_minus1 >= 8) {\r\n for (x = 0; x < bytes; x++) \r\n ((uint16_t *)dst)[x] = c[p];\r\n }\r\n else {\r\n memset(dst,c[p],bytes);\r\n }\r\n dst += frame -> linesize[p];\r\n }\r\n }\r\n}\r\n\r\nint avcodec_default_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n frame -> type = 1;\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n return video_get_buffer(avctx,frame);\r\n case AVMEDIA_TYPE_AUDIO:\r\n return audio_get_buffer(avctx,frame);\r\n default:\r\n return - 1;\r\n }\r\n}\r\n\r\nvoid ff_init_buffer_info(AVCodecContext *s,AVFrame *frame)\r\n{\r\n if (s -> pkt) {\r\n frame -> pkt_pts = s -> pkt -> pts;\r\n av_frame_set_pkt_pos(frame,s -> pkt -> pos);\r\n av_frame_set_pkt_duration(frame,(s -> pkt -> duration));\r\n av_frame_set_pkt_size(frame,s -> pkt -> size);\r\n }\r\n else {\r\n frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_size(frame,- 1);\r\n }\r\n frame -> reordered_opaque = s -> reordered_opaque;\r\n switch(s -> codec -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n frame -> width = s -> width;\r\n frame -> height = s -> height;\r\n frame -> format = (s -> pix_fmt);\r\n frame -> sample_aspect_ratio = s -> sample_aspect_ratio;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n frame -> sample_rate = s -> sample_rate;\r\n frame -> format = (s -> sample_fmt);\r\n frame -> channel_layout = s -> channel_layout;\r\n av_frame_set_channels(frame,s -> channels);\r\n break; \r\n }\r\n }\r\n}\r\n\r\nint ff_get_buffer(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n ff_init_buffer_info(avctx,frame);\r\n return (avctx -> get_buffer)(avctx,frame);\r\n}\r\n\r\nvoid avcodec_default_release_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n int i;\r\n InternalBuffer *buf;\r\n InternalBuffer *last;\r\n AVCodecInternal *avci = s -> internal;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",592);\r\n abort();\r\n }\r\n }while (0);\r\n (void )0;\r\n (void )0;\r\n if (avci -> buffer) {\r\n\r\n buf = ((void *)0);\r\n\r\n for (i = 0; i < avci -> buffer_count; i++) {\r\n buf = &avci -> buffer[i];\r\n if (buf -> data[0] == pic -> data[0]) {\r\n break; \r\n }\r\n }\r\n do {\r\n if (!(i < avci -> buffer_count)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"i < avci->buffer_count\",\"utils.c\",604);\r\n abort();\r\n }\r\n }while (0);\r\n avci -> buffer_count--;\r\n last = &avci -> buffer[avci -> buffer_count];\r\n if (buf != last) {\r\n do {\r\n InternalBuffer SWAP_tmp = *last;\r\n *last = *buf;\r\n *buf = SWAP_tmp;\r\n }while (0);\r\n }\r\n }\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = ((void *)0);\r\n\r\n if (s -> debug & 0x8000) {\r\n av_log(s,48,\"default_release_buffer called on pic %p, %d buffers used\\n\",pic,avci -> buffer_count);\r\n }\r\n}\r\n\r\nint avcodec_default_reget_buffer(AVCodecContext *s,AVFrame *pic)\r\n{\r\n AVFrame temp_pic;\r\n int i;\r\n int ret;\r\n do {\r\n if (!((s -> codec_type) == AVMEDIA_TYPE_VIDEO)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"s->codec_type == AVMEDIA_TYPE_VIDEO\",\"utils.c\",626);\r\n abort();\r\n }\r\n }while (0);\r\n if (pic -> data[0] && (pic -> width != s -> width || pic -> height != s -> height || pic -> format != (s -> pix_fmt))) {\r\n av_log(s,24,\"Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\\n\",pic -> width,pic -> height,av_get_pix_fmt_name((pic -> format)),s -> width,s -> height,av_get_pix_fmt_name(s -> pix_fmt));\r\n (s -> release_buffer)(s,pic);\r\n }\r\n ff_init_buffer_info(s,pic);\r\n\r\n if (pic -> data[0] == ((void *)0)) {\r\n\r\n pic -> buffer_hints |= 0x02;\r\n return ff_get_buffer(s,pic);\r\n }\r\n (void )0;\r\n\r\n if (pic -> type == 1) {\r\n return 0;\r\n }\r\n\r\n temp_pic = *pic;\r\n for (i = 0; i < 8; i++) \r\n pic -> data[i] = pic -> base[i] = ((void *)0);\r\n pic -> opaque = ((void *)0);\r\n\r\n if (ret = ff_get_buffer(s,pic)) {\r\n return ret;\r\n }\r\n\r\n av_picture_copy(((AVPicture *)pic),((AVPicture *)(&temp_pic)),s -> pix_fmt,s -> width,s -> height);\r\n\r\n (s -> release_buffer)(s,&temp_pic);\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute(AVCodecContext *c,int (*func)(AVCodecContext *, void *),void *arg,int *ret,int count,int size)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,(((char *)arg) + i * size));\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avcodec_default_execute2(AVCodecContext *c,int (*func)(AVCodecContext *, void *, int , int ),void *arg,int *ret,int count)\r\n{\r\n int i;\r\n for (i = 0; i < count; i++) {\r\n int r = func(c,arg,i,0);\r\n if (ret) {\r\n ret[i] = r;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)\r\n{\r\n const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\r\n return (desc -> flags) & 8;\r\n}\r\n\r\nenum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s,const enum AVPixelFormat *fmt)\r\n{\r\n while(( *fmt) != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt( *fmt))\r\n ++fmt;\r\n return fmt[0];\r\n}\r\n\r\nvoid avcodec_get_frame_defaults(AVFrame *frame)\r\n{\r\n#if LIBAVCODEC_VERSION_MAJOR >= 55\r\n\r\n\r\n#endif\r\n memset(frame,0,sizeof(AVFrame ));\r\n frame -> pts = frame -> pkt_dts = frame -> pkt_pts = ((int64_t )0x8000000000000000UL);\r\n av_frame_set_best_effort_timestamp(frame,((int64_t )0x8000000000000000UL));\r\n av_frame_set_pkt_duration(frame,0);\r\n av_frame_set_pkt_pos(frame,(- 1));\r\n av_frame_set_pkt_size(frame,- 1);\r\n frame -> key_frame = 1;\r\n frame -> sample_aspect_ratio = ((AVRational ){(0), (1)});\r\n\r\n frame -> format = - 1;\r\n frame -> extended_data = frame -> data;\r\n}\r\n\r\nAVFrame *avcodec_alloc_frame()\r\n{\r\n AVFrame *frame = (av_malloc(sizeof(AVFrame )));\r\n if (frame == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n frame -> extended_data = ((void *)0);\r\n avcodec_get_frame_defaults(frame);\r\n return frame;\r\n}\r\n\r\nvoid avcodec_free_frame(AVFrame **frame)\r\n{\r\n AVFrame *f;\r\n if (!frame || !( *frame)) {\r\n return ;\r\n }\r\n f = *frame;\r\n if (f -> extended_data != f -> data) {\r\n av_freep((&f -> extended_data));\r\n }\r\n av_freep(frame);\r\n}\r\n#define MAKE_ACCESSORS(str, name, type, field) \\\r\n type av_##name##_get_##field(const str *s) { return s->field; } \\\r\n void av_##name##_set_##field(str *s, type v) { s->field = v; }\r\n\r\nint64_t av_frame_get_best_effort_timestamp(const AVFrame *s)\r\n{\r\n return s -> best_effort_timestamp;\r\n}\r\n\r\nvoid av_frame_set_best_effort_timestamp(AVFrame *s,int64_t v)\r\n{\r\n s -> best_effort_timestamp = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_duration(const AVFrame *s)\r\n{\r\n return s -> pkt_duration;\r\n}\r\n\r\nvoid av_frame_set_pkt_duration(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_duration = v;\r\n}\r\n\r\nint64_t av_frame_get_pkt_pos(const AVFrame *s)\r\n{\r\n return s -> pkt_pos;\r\n}\r\n\r\nvoid av_frame_set_pkt_pos(AVFrame *s,int64_t v)\r\n{\r\n s -> pkt_pos = v;\r\n}\r\n\r\nint64_t av_frame_get_channel_layout(const AVFrame *s)\r\n{\r\n return (s -> channel_layout);\r\n}\r\n\r\nvoid av_frame_set_channel_layout(AVFrame *s,int64_t v)\r\n{\r\n s -> channel_layout = v;\r\n}\r\n\r\nint av_frame_get_channels(const AVFrame *s)\r\n{\r\n return s -> channels;\r\n}\r\n\r\nvoid av_frame_set_channels(AVFrame *s,int v)\r\n{\r\n s -> channels = v;\r\n}\r\n\r\nint av_frame_get_sample_rate(const AVFrame *s)\r\n{\r\n return s -> sample_rate;\r\n}\r\n\r\nvoid av_frame_set_sample_rate(AVFrame *s,int v)\r\n{\r\n s -> sample_rate = v;\r\n}\r\n\r\nAVDictionary *av_frame_get_metadata(const AVFrame *s)\r\n{\r\n return s -> metadata;\r\n}\r\n\r\nvoid av_frame_set_metadata(AVFrame *s,AVDictionary *v)\r\n{\r\n s -> metadata = v;\r\n}\r\n\r\nint av_frame_get_decode_error_flags(const AVFrame *s)\r\n{\r\n return s -> decode_error_flags;\r\n}\r\n\r\nvoid av_frame_set_decode_error_flags(AVFrame *s,int v)\r\n{\r\n s -> decode_error_flags = v;\r\n}\r\n\r\nint av_frame_get_pkt_size(const AVFrame *s)\r\n{\r\n return s -> pkt_size;\r\n}\r\n\r\nvoid av_frame_set_pkt_size(AVFrame *s,int v)\r\n{\r\n s -> pkt_size = v;\r\n}\r\n\r\nAVDictionary **ff_frame_get_metadatap(AVFrame *frame)\r\n{\r\n return &frame -> metadata;\r\n}\r\n\r\nAVRational av_codec_get_pkt_timebase(const AVCodecContext *s)\r\n{\r\n return s -> pkt_timebase;\r\n}\r\n\r\nvoid av_codec_set_pkt_timebase(AVCodecContext *s,AVRational v)\r\n{\r\n s -> pkt_timebase = v;\r\n}\r\n\r\nconst AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *s)\r\n{\r\n return s -> codec_descriptor;\r\n}\r\n\r\nvoid av_codec_set_codec_descriptor(AVCodecContext *s,const AVCodecDescriptor *v)\r\n{\r\n s -> codec_descriptor = v;\r\n}\r\n\r\nstatic void avcodec_get_subtitle_defaults(AVSubtitle *sub)\r\n{\r\n memset(sub,0,sizeof(( *sub)));\r\n sub -> pts = ((int64_t )0x8000000000000000UL);\r\n}\r\n\r\nstatic int get_bit_rate(AVCodecContext *ctx)\r\n{\r\n int bit_rate;\r\n int bits_per_sample;\r\n switch(ctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n{\r\n bit_rate = ctx -> bit_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n bits_per_sample = av_get_bits_per_sample(ctx -> codec_id);\r\n bit_rate = (bits_per_sample?ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate);\r\n break; \r\n }\r\n default:\r\n{\r\n bit_rate = 0;\r\n break; \r\n }\r\n }\r\n return bit_rate;\r\n}\r\n#if FF_API_AVCODEC_OPEN\r\n\r\nint avcodec_open(AVCodecContext *avctx,AVCodec *codec)\r\n{\r\n return avcodec_open2(avctx,codec,((void *)0));\r\n}\r\n#endif\r\n\r\nint ff_codec_open2_recursive(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_open2(avctx,codec,options);\r\n ff_lock_avcodec(avctx);\r\n return ret;\r\n}\r\n\r\nint avcodec_open2(AVCodecContext *avctx,const AVCodec *codec,AVDictionary **options)\r\n{\r\n int ret = 0;\r\n AVDictionary *tmp = ((void *)0);\r\n if (avcodec_is_open(avctx)) {\r\n return 0;\r\n }\r\n if (!codec && !avctx -> codec) {\r\n av_log(avctx,16,\"No codec provided to avcodec_open2()\\n\");\r\n return - 22;\r\n }\r\n if (codec && avctx -> codec && codec != avctx -> codec) {\r\n av_log(avctx,16,\"This AVCodecContext was allocated for %s, but %s passed to avcodec_open2()\\n\",avctx -> codec -> name,codec -> name);\r\n return - 22;\r\n }\r\n if (!codec) {\r\n codec = avctx -> codec;\r\n }\r\n if (avctx -> extradata_size < 0 || avctx -> extradata_size >= (1 << 28) - 16) {\r\n return - 22;\r\n }\r\n if (options) {\r\n av_dict_copy(&tmp, *options,0);\r\n }\r\n ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> internal = (av_mallocz(sizeof(AVCodecInternal )));\r\n if (!avctx -> internal) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_data_size > 0) {\r\n if (!avctx -> priv_data) {\r\n avctx -> priv_data = av_mallocz((codec -> priv_data_size));\r\n if (!avctx -> priv_data) {\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n if (codec -> priv_class) {\r\n *((const AVClass **)(avctx -> priv_data)) = codec -> priv_class;\r\n av_opt_set_defaults(avctx -> priv_data);\r\n }\r\n }\r\n if (codec -> priv_class && (ret = av_opt_set_dict(avctx -> priv_data,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n avctx -> priv_data = ((void *)0);\r\n }\r\n if ((ret = av_opt_set_dict(avctx,&tmp)) < 0) {\r\n goto free_and_end;\r\n }\r\n\r\n if (!(avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && (avctx -> codec_id) == AV_CODEC_ID_H264)) {\r\n if (avctx -> coded_width && avctx -> coded_height) {\r\n avcodec_set_dimensions(avctx,avctx -> coded_width,avctx -> coded_height);\r\n }\r\n else {\r\n if (avctx -> width && avctx -> height) {\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n }\r\n }\r\n }\r\n if ((avctx -> coded_width || avctx -> coded_height || avctx -> width || avctx -> height) && (av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx) < 0 || av_image_check_size((avctx -> width),(avctx -> height),0,avctx) < 0)) {\r\n av_log(avctx,24,\"Ignoring invalid width/height values\\n\");\r\n avcodec_set_dimensions(avctx,0,0);\r\n }\r\n\r\n if (av_codec_is_decoder(codec)) {\r\n av_freep((&avctx -> subtitle_header));\r\n }\r\n if ((avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> codec = codec;\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_UNKNOWN || (avctx -> codec_type) == (codec -> type)) && (avctx -> codec_id) == AV_CODEC_ID_NONE) {\r\n avctx -> codec_type = codec -> type;\r\n avctx -> codec_id = codec -> id;\r\n }\r\n if ((avctx -> codec_id) != (codec -> id) || (avctx -> codec_type) != (codec -> type) && (avctx -> codec_type) != AVMEDIA_TYPE_ATTACHMENT) {\r\n av_log(avctx,16,\"Codec type or id mismatches\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n avctx -> frame_number = 0;\r\n avctx -> codec_descriptor = avcodec_descriptor_get(avctx -> codec_id);\r\n if (avctx -> codec -> capabilities & 0x0200 && avctx -> strict_std_compliance > - 2) {\r\n const char *codec_string = (av_codec_is_encoder(codec)?\"encoder\" : \"decoder\");\r\n AVCodec *codec2;\r\n av_log(((void *)0),16,\"The %s '%s' is experimental but experimental codecs are not enabled, add '-strict %d' if you want to use it.\\n\",codec_string,codec -> name,- 2);\r\n codec2 = (av_codec_is_encoder(codec)?avcodec_find_encoder(codec -> id) : avcodec_find_decoder(codec -> id));\r\n if (!(codec2 -> capabilities & 0x0200)) {\r\n av_log(((void *)0),16,\"Alternatively use the non experimental %s '%s'.\\n\",codec_string,codec2 -> name);\r\n }\r\n ret = - 0x2bb2afa8;\r\n goto free_and_end;\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && (!avctx -> time_base . num || !avctx -> time_base . den)) {\r\n avctx -> time_base . num = 1;\r\n avctx -> time_base . den = avctx -> sample_rate;\r\n }\r\n if (!1) {\r\n av_log(avctx,24,\"Warning: not compiled with thread support, using thread emulation\\n\");\r\n }\r\n if (1) {\r\n\r\n ff_unlock_avcodec();\r\n ret = ff_frame_thread_encoder_init(avctx,(options? *options : ((void *)0)));\r\n ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (1 && !avctx -> thread_opaque && !(avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1)) {\r\n ret = ff_thread_init(avctx);\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n if (!1 && !(codec -> capabilities & 0x8000)) {\r\n avctx -> thread_count = 1;\r\n }\r\n if ((avctx -> codec -> max_lowres) < avctx -> lowres || avctx -> lowres < 0) {\r\n av_log(avctx,16,\"The maximum value for lowres supported by the decoder is %d\\n\",(avctx -> codec -> max_lowres));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n int i;\r\n if (avctx -> codec -> sample_fmts) {\r\n for (i = 0; avctx -> codec -> sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {\r\n if ((avctx -> sample_fmt) == avctx -> codec -> sample_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> channels == 1 && (av_get_planar_sample_fmt(avctx -> sample_fmt)) == (av_get_planar_sample_fmt(avctx -> codec -> sample_fmts[i]))) {\r\n avctx -> sample_fmt = avctx -> codec -> sample_fmts[i];\r\n break; \r\n }\r\n }\r\n if (avctx -> codec -> sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> sample_fmt);\r\n av_log(avctx,16,\"Specified sample format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_sample_fmt_name(avctx -> sample_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> pix_fmts) {\r\n for (i = 0; avctx -> codec -> pix_fmts[i] != AV_PIX_FMT_NONE; i++) \r\n if ((avctx -> pix_fmt) == avctx -> codec -> pix_fmts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> pix_fmts[i] == AV_PIX_FMT_NONE && !(((avctx -> codec_id) == AV_CODEC_ID_MJPEG || (avctx -> codec_id) == AV_CODEC_ID_LJPEG) && avctx -> strict_std_compliance <= - 1)) {\r\n char buf[128];\r\n snprintf(buf,sizeof(buf),\"%d\",avctx -> pix_fmt);\r\n av_log(avctx,16,\"Specified pixel format %s is invalid or not supported\\n\",((char *)(av_x_if_null((av_get_pix_fmt_name(avctx -> pix_fmt)),buf))));\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> supported_samplerates) {\r\n for (i = 0; avctx -> codec -> supported_samplerates[i] != 0; i++) \r\n if (avctx -> sample_rate == avctx -> codec -> supported_samplerates[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> supported_samplerates[i] == 0) {\r\n av_log(avctx,16,\"Specified sample rate %d is not supported\\n\",avctx -> sample_rate);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (avctx -> codec -> channel_layouts) {\r\n if (!avctx -> channel_layout) {\r\n av_log(avctx,24,\"Channel layout not specified\\n\");\r\n }\r\n else {\r\n for (i = 0; avctx -> codec -> channel_layouts[i] != 0; i++) \r\n if (avctx -> channel_layout == avctx -> codec -> channel_layouts[i]) {\r\n break; \r\n }\r\n if (avctx -> codec -> channel_layouts[i] == 0) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Specified channel layout '%s' is not supported\\n\",buf);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n if (avctx -> channel_layout && avctx -> channels) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,16,\"Channel layout '%s' with %d channels does not match number of specified channels %d\\n\",buf,channels,avctx -> channels);\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n else {\r\n if (avctx -> channel_layout) {\r\n avctx -> channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n }\r\n }\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && (avctx -> codec_id) != AV_CODEC_ID_PNG) \r\n\r\n{\r\n if (avctx -> width <= 0 || avctx -> height <= 0) {\r\n av_log(avctx,16,\"dimensions not set\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO) && avctx -> bit_rate > 0 && avctx -> bit_rate < 1000) {\r\n av_log(avctx,24,\"Bitrate %d is extreemly low, did you mean %dk\\n\",avctx -> bit_rate,avctx -> bit_rate);\r\n }\r\n if (!avctx -> rc_initial_buffer_occupancy) {\r\n avctx -> rc_initial_buffer_occupancy = avctx -> rc_buffer_size * 3 / 4;\r\n }\r\n }\r\n avctx -> pts_correction_num_faulty_pts = avctx -> pts_correction_num_faulty_dts = 0;\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n if (avctx -> codec -> init && (!(avctx -> active_thread_type & 1) || avctx -> internal -> frame_thread_encoder)) {\r\n ret = ((avctx -> codec -> init)(avctx));\r\n if (ret < 0) {\r\n goto free_and_end;\r\n }\r\n }\r\n ret = 0;\r\n if (av_codec_is_decoder(avctx -> codec)) {\r\n if (!avctx -> bit_rate) {\r\n avctx -> bit_rate = get_bit_rate(avctx);\r\n }\r\n\r\n if (avctx -> channel_layout) {\r\n int channels = av_get_channel_layout_nb_channels(avctx -> channel_layout);\r\n if (!avctx -> channels) {\r\n avctx -> channels = channels;\r\n }\r\n else {\r\n if (channels != avctx -> channels) {\r\n char buf[512];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,avctx -> channel_layout);\r\n av_log(avctx,24,\"Channel layout '%s' with %d channels does not match specified number of channels %d: ignoring specified channel layout\\n\",buf,channels,avctx -> channels);\r\n avctx -> channel_layout = 0;\r\n }\r\n }\r\n }\r\n if (avctx -> channels && avctx -> channels < 0 || (avctx -> channels) > 128U) {\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n if (avctx -> sub_charenc) {\r\n if ((avctx -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Character encoding is only supported with subtitles codecs\\n\");\r\n ret = - 22;\r\n goto free_and_end;\r\n }\r\n else {\r\n if (avctx -> codec_descriptor -> props & 1 << 16) {\r\n av_log(avctx,24,\"Codec '%s' is bitmap-based, subtitles character encoding will be ignored\\n\",avctx -> codec_descriptor -> name);\r\n avctx -> sub_charenc_mode = - 1;\r\n }\r\n else {\r\n\r\n if (avctx -> sub_charenc_mode == 0) {\r\n avctx -> sub_charenc_mode = 1;\r\n }\r\n if (!1 && avctx -> sub_charenc_mode == 1) {\r\n av_log(avctx,16,\"Character encoding subtitles conversion needs a libavcodec built with iconv support for this codec\\n\");\r\n ret = - 38;\r\n goto free_and_end;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n end:\r\n ff_unlock_avcodec();\r\n if (options) {\r\n av_dict_free(options);\r\n *options = tmp;\r\n }\r\n return ret;\r\n free_and_end:\r\n av_dict_free(&tmp);\r\n av_freep((&avctx -> priv_data));\r\n av_freep((&avctx -> internal));\r\n avctx -> codec = ((void *)0);\r\n goto end;\r\n}\r\n\r\nint ff_alloc_packet2(AVCodecContext *avctx,AVPacket *avpkt,int size)\r\n{\r\n if (size < 0 || avpkt -> size < 0 || size > 2147483647 - 16) {\r\n av_log(avctx,16,\"Size %d invalid\\n\",size);\r\n return - 22;\r\n }\r\n if (avctx) {\r\n do {\r\n if (!(!avpkt -> data || avpkt -> data != avctx -> internal -> byte_buffer)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!avpkt->data || avpkt->data != avctx->internal->byte_buffer\",\"utils.c\",1155);\r\n abort();\r\n }\r\n }while (0);\r\n if (!avpkt -> data || avpkt -> size < size) {\r\n av_fast_padded_malloc((&avctx -> internal -> byte_buffer),&avctx -> internal -> byte_buffer_size,size);\r\n avpkt -> data = avctx -> internal -> byte_buffer;\r\n avpkt -> size = (avctx -> internal -> byte_buffer_size);\r\n avpkt -> destruct = ((void *)0);\r\n }\r\n }\r\n if (avpkt -> data) {\r\n void *destruct = (avpkt -> destruct);\r\n if (avpkt -> size < size) {\r\n av_log(avctx,16,\"User packet is too small (%d < %d)\\n\",avpkt -> size,size);\r\n return - 22;\r\n }\r\n av_init_packet(avpkt);\r\n avpkt -> destruct = destruct;\r\n avpkt -> size = size;\r\n return 0;\r\n }\r\n else {\r\n int ret = av_new_packet(avpkt,size);\r\n if (ret < 0) {\r\n av_log(avctx,16,\"Failed to allocate packet of size %d\\n\",size);\r\n }\r\n return ret;\r\n }\r\n}\r\n\r\nint ff_alloc_packet(AVPacket *avpkt,int size)\r\n{\r\n return ff_alloc_packet2(((void *)0),avpkt,size);\r\n}\r\n\r\n\r\nstatic int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src)\r\n{\r\n AVFrame *frame = ((void *)0);\r\n uint8_t *buf = ((void *)0);\r\n int ret;\r\n if (!(frame = avcodec_alloc_frame())) {\r\n return - '\\f';\r\n }\r\n *frame = *src;\r\n if ((ret = av_samples_get_buffer_size(&frame -> linesize[0],s -> channels,s -> frame_size,s -> sample_fmt,0)) < 0) {\r\n goto fail;\r\n }\r\n if (!(buf = (av_malloc(ret)))) {\r\n ret = - '\\f';\r\n goto fail;\r\n }\r\n frame -> nb_samples = s -> frame_size;\r\n if ((ret = avcodec_fill_audio_frame(frame,s -> channels,s -> sample_fmt,buf,ret,0)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_copy(frame -> extended_data,(src -> extended_data),0,0,src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n if ((ret = av_samples_set_silence(frame -> extended_data,src -> nb_samples,frame -> nb_samples - src -> nb_samples,s -> channels,s -> sample_fmt)) < 0) {\r\n goto fail;\r\n }\r\n *dst = frame;\r\n return 0;\r\n fail:\r\n if (frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n av_freep((&buf));\r\n av_freep((&frame));\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n AVFrame tmp;\r\n AVFrame *padded_frame = ((void *)0);\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n return 0;\r\n }\r\n\r\n if (frame && !frame -> extended_data) {\r\n if (av_sample_fmt_is_planar(avctx -> sample_fmt) && avctx -> channels > 8) {\r\n av_log(avctx,16,\"Encoding to a planar sample format, with more than %d channels, but extended_data is not set.\\n\",8);\r\n return - 22;\r\n }\r\n av_log(avctx,24,\"extended_data is not set.\\n\");\r\n tmp = *frame;\r\n tmp . extended_data = tmp . data;\r\n frame = (&tmp);\r\n }\r\n\r\n if (frame) {\r\n if (avctx -> codec -> capabilities & 0x0040) {\r\n if (frame -> nb_samples > avctx -> frame_size) {\r\n av_log(avctx,16,\"more samples than frame size (avcodec_encode_audio2)\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x10000)) {\r\n if (frame -> nb_samples < avctx -> frame_size && !avctx -> internal -> last_audio_frame) {\r\n ret = pad_last_frame(avctx,&padded_frame,frame);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n frame = padded_frame;\r\n avctx -> internal -> last_audio_frame = 1;\r\n }\r\n if (frame -> nb_samples != avctx -> frame_size) {\r\n av_log(avctx,16,\"nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\\n\",frame -> nb_samples,avctx -> frame_size);\r\n ret = - 22;\r\n goto end;\r\n }\r\n }\r\n }\r\n }\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n if (!ret) {\r\n if ( *got_packet_ptr) {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n if (avpkt -> pts == ((int64_t )0x8000000000000000UL)) {\r\n avpkt -> pts = frame -> pts;\r\n }\r\n if (!avpkt -> duration) {\r\n avpkt -> duration = (ff_samples_to_time_base(avctx,(frame -> nb_samples)));\r\n }\r\n }\r\n avpkt -> dts = avpkt -> pts;\r\n }\r\n else {\r\n avpkt -> size = 0;\r\n }\r\n }\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (needs_realloc && avpkt -> data) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n goto end;\r\n }\r\n\r\n avpkt -> flags |= 0x1;\r\n end:\r\n if (padded_frame) {\r\n av_freep((&padded_frame -> data[0]));\r\n if (padded_frame -> extended_data != padded_frame -> data) {\r\n av_freep((&padded_frame -> extended_data));\r\n }\r\n av_freep((&padded_frame));\r\n }\r\n return ret;\r\n}\r\n#if FF_API_OLD_ENCODE_AUDIO\r\n\r\nint avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples)\r\n{\r\n AVPacket pkt;\r\n AVFrame frame0 = {{(0)}};\r\n AVFrame *frame;\r\n int ret;\r\n int samples_size;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n if (samples) {\r\n frame = &frame0;\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> frame_size) {\r\n frame -> nb_samples = avctx -> frame_size;\r\n }\r\n else {\r\n\r\n int64_t nb_samples;\r\n if (!av_get_bits_per_sample(avctx -> codec_id)) {\r\n av_log(avctx,16,\"avcodec_encode_audio() does not support this codec\\n\");\r\n return - 22;\r\n }\r\n nb_samples = ((int64_t )buf_size) * 8 / (av_get_bits_per_sample(avctx -> codec_id) * avctx -> channels);\r\n if (nb_samples >= 2147483647) {\r\n return - 22;\r\n }\r\n frame -> nb_samples = nb_samples;\r\n }\r\n\r\n samples_size = av_samples_get_buffer_size(((void *)0),avctx -> channels,frame -> nb_samples,avctx -> sample_fmt,1);\r\n if ((ret = avcodec_fill_audio_frame(frame,avctx -> channels,avctx -> sample_fmt,((const uint8_t *)samples),samples_size,1)) < 0) {\r\n return ret;\r\n }\r\n\r\n if (avctx -> sample_rate && avctx -> time_base . num) {\r\n frame -> pts = ff_samples_to_time_base(avctx,(avctx -> internal -> sample_count));\r\n }\r\n else {\r\n frame -> pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n avctx -> internal -> sample_count += frame -> nb_samples;\r\n }\r\n else {\r\n frame = ((void *)0);\r\n }\r\n got_packet = 0;\r\n ret = avcodec_encode_audio2(avctx,&pkt,frame,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n ff_packet_free_side_data(&pkt);\r\n if (frame && frame -> extended_data != frame -> data) {\r\n av_freep((&frame -> extended_data));\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n#if FF_API_OLD_ENCODE_VIDEO\r\n\r\nint avcodec_encode_video(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVFrame *pict)\r\n{\r\n AVPacket pkt;\r\n int ret;\r\n int got_packet = 0;\r\n if (buf_size < 16384) {\r\n av_log(avctx,16,\"buffer smaller than minimum size\\n\");\r\n return - 1;\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = buf;\r\n pkt . size = buf_size;\r\n ret = avcodec_encode_video2(avctx,&pkt,pict,&got_packet);\r\n if (!ret && got_packet && avctx -> coded_frame) {\r\n avctx -> coded_frame -> pts = pkt . pts;\r\n avctx -> coded_frame -> key_frame = !(!(pkt . flags & 0x1));\r\n }\r\n\r\n if (pkt . side_data_elems > 0) {\r\n int i;\r\n for (i = 0; i < pkt . side_data_elems; i++) \r\n av_free(pkt . side_data[i] . data);\r\n av_freep((&pkt . side_data));\r\n pkt . side_data_elems = 0;\r\n }\r\n return ret?ret : pkt . size;\r\n}\r\n#endif\r\n\r\nint avcodec_encode_video2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr)\r\n{\r\n int ret;\r\n AVPacket user_pkt = *avpkt;\r\n int needs_realloc = !user_pkt . data;\r\n *got_packet_ptr = 0;\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> active_thread_type & 1) {\r\n return ff_thread_video_encode_frame(avctx,avpkt,frame,got_packet_ptr);\r\n }\r\n if (avctx -> flags & 0x0200 && avctx -> stats_out) {\r\n avctx -> stats_out[0] = '\\0';\r\n }\r\n if (!(avctx -> codec -> capabilities & 0x20) && !frame) {\r\n av_free_packet(avpkt);\r\n av_init_packet(avpkt);\r\n avpkt -> size = 0;\r\n return 0;\r\n }\r\n if (av_image_check_size((avctx -> width),(avctx -> height),0,avctx)) {\r\n return - 22;\r\n }\r\n do {\r\n if (!avctx -> codec -> encode2) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"avctx->codec->encode2\",\"utils.c\",1503);\r\n abort();\r\n }\r\n }while (0);\r\n ret = ((avctx -> codec -> encode2)(avctx,avpkt,frame,got_packet_ptr));\r\n do {\r\n if (!(ret <= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ret <= 0\",\"utils.c\",1506);\r\n abort();\r\n }\r\n }while (0);\r\n if (avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer) {\r\n needs_realloc = 0;\r\n if (user_pkt . data) {\r\n if (user_pkt . size >= avpkt -> size) {\r\n memcpy(user_pkt . data,(avpkt -> data),(avpkt -> size));\r\n }\r\n else {\r\n av_log(avctx,16,\"Provided packet is too small, needs to be %d\\n\",avpkt -> size);\r\n avpkt -> size = user_pkt . size;\r\n ret = - 1;\r\n }\r\n avpkt -> data = user_pkt . data;\r\n avpkt -> destruct = user_pkt . destruct;\r\n }\r\n else {\r\n if (av_dup_packet(avpkt) < 0) {\r\n ret = - '\\f';\r\n }\r\n }\r\n }\r\n if (!ret) {\r\n if (!( *got_packet_ptr)) {\r\n avpkt -> size = 0;\r\n }\r\n else {\r\n if (!(avctx -> codec -> capabilities & 0x20)) {\r\n avpkt -> pts = avpkt -> dts = frame -> pts;\r\n }\r\n }\r\n if (needs_realloc && avpkt -> data && avpkt -> destruct == av_destruct_packet) {\r\n uint8_t *new_data = (av_realloc((avpkt -> data),(avpkt -> size + 16)));\r\n if (new_data) {\r\n avpkt -> data = new_data;\r\n }\r\n }\r\n avctx -> frame_number++;\r\n }\r\n if (ret < 0 || !( *got_packet_ptr)) {\r\n av_free_packet(avpkt);\r\n }\r\n ;\r\n return ret;\r\n}\r\n\r\nint avcodec_encode_subtitle(AVCodecContext *avctx,uint8_t *buf,int buf_size,const AVSubtitle *sub)\r\n{\r\n int ret;\r\n if (sub -> start_display_time) {\r\n av_log(avctx,16,\"start_display_time must be 0.\\n\");\r\n return - 1;\r\n }\r\n ret = ((avctx -> codec -> encode_sub)(avctx,buf,buf_size,sub));\r\n avctx -> frame_number++;\r\n return ret;\r\n}\r\n\r\n\r\nstatic int64_t guess_correct_pts(AVCodecContext *ctx,int64_t reordered_pts,int64_t dts)\r\n{\r\n int64_t pts = (int64_t )0x8000000000000000UL;\r\n if (dts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_dts += (dts <= ctx -> pts_correction_last_dts);\r\n ctx -> pts_correction_last_dts = dts;\r\n }\r\n if (reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n ctx -> pts_correction_num_faulty_pts += (reordered_pts <= ctx -> pts_correction_last_pts);\r\n ctx -> pts_correction_last_pts = reordered_pts;\r\n }\r\n if ((ctx -> pts_correction_num_faulty_pts <= ctx -> pts_correction_num_faulty_dts || dts == ((int64_t )0x8000000000000000UL)) && reordered_pts != ((int64_t )0x8000000000000000UL)) {\r\n pts = reordered_pts;\r\n }\r\n else {\r\n pts = dts;\r\n }\r\n return pts;\r\n}\r\n\r\nstatic void apply_param_change(AVCodecContext *avctx,AVPacket *avpkt)\r\n{\r\n int size = 0;\r\n const uint8_t *data;\r\n uint32_t flags;\r\n if (!(avctx -> codec -> capabilities & 0x4000)) {\r\n return ;\r\n }\r\n data = (av_packet_get_side_data(avpkt,AV_PKT_DATA_PARAM_CHANGE,&size));\r\n if (!data || size < 4) {\r\n return ;\r\n }\r\n flags = bytestream_get_le32(&data);\r\n size -= 4;\r\n\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\r\n avctx -> channels = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> channel_layout = bytestream_get_le64(&data);\r\n size -= 8;\r\n }\r\n if (size < 4) {\r\n return ;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\r\n avctx -> sample_rate = (bytestream_get_le32(&data));\r\n size -= 4;\r\n }\r\n if (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\r\n if (size < 8) {\r\n return ;\r\n }\r\n avctx -> width = (bytestream_get_le32(&data));\r\n avctx -> height = (bytestream_get_le32(&data));\r\n avcodec_set_dimensions(avctx,avctx -> width,avctx -> height);\r\n size -= 8;\r\n }\r\n}\r\n\r\nstatic int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)\r\n{\r\n int size;\r\n int ret = 0;\r\n const uint8_t *side_metadata;\r\n const uint8_t *end;\r\n av_dict_free(&avctx -> metadata);\r\n side_metadata = (av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_STRINGS_METADATA,&size));\r\n if (!side_metadata) {\r\n goto end;\r\n }\r\n end = side_metadata + size;\r\n while(side_metadata < end){\r\n const uint8_t *key = side_metadata;\r\n const uint8_t *val = side_metadata + strlen(key) + 1;\r\n int ret = av_dict_set(ff_frame_get_metadatap(frame),key,val,0);\r\n if (ret < 0) {\r\n break; \r\n }\r\n side_metadata = val + strlen(val) + 1;\r\n }\r\n end:\r\n avctx -> metadata = av_frame_get_metadata(frame);\r\n return ret;\r\n}\r\n\r\nint avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)\r\n{\r\n int ret;\r\n\r\n AVPacket tmp = *avpkt;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_VIDEO) {\r\n av_log(avctx,16,\"Invalid media type for video\\n\");\r\n return - 22;\r\n }\r\n *got_picture_ptr = 0;\r\n if ((avctx -> coded_width || avctx -> coded_height) && av_image_check_size((avctx -> coded_width),(avctx -> coded_height),0,avctx)) {\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(picture);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1) {\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ret = ff_thread_decode_frame(avctx,picture,got_picture_ptr,&tmp);\r\n }\r\n else {\r\n ret = ((avctx -> codec -> decode)(avctx,picture,got_picture_ptr,&tmp));\r\n picture -> pkt_dts = avpkt -> dts;\r\n if (!avctx -> has_b_frames) {\r\n av_frame_set_pkt_pos(picture,avpkt -> pos);\r\n }\r\n\r\n\r\n if (!(avctx -> codec -> capabilities & 0x02)) {\r\n if (!picture -> sample_aspect_ratio . num) {\r\n picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;\r\n }\r\n if (!picture -> width) {\r\n picture -> width = avctx -> width;\r\n }\r\n if (!picture -> height) {\r\n picture -> height = avctx -> height;\r\n }\r\n if (picture -> format == AV_PIX_FMT_NONE) {\r\n picture -> format = (avctx -> pix_fmt);\r\n }\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,picture);\r\n\r\n ;\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_picture_ptr) {\r\n avctx -> frame_number++;\r\n av_frame_set_best_effort_timestamp(picture,guess_correct_pts(avctx,picture -> pkt_pts,picture -> pkt_dts));\r\n }\r\n }\r\n else {\r\n ret = 0;\r\n }\r\n\r\n picture -> extended_data = picture -> data;\r\n return ret;\r\n}\r\n#if FF_API_OLD_DECODE_AUDIO\r\n\r\nint avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)\r\n{\r\n AVFrame frame = {{(0)}};\r\n int ret;\r\n int got_frame = 0;\r\n if (avctx -> get_buffer != avcodec_default_get_buffer) {\r\n av_log(avctx,16,\"Custom get_buffer() for use withavcodec_decode_audio3() detected. Overriding with avcodec_default_get_buffer\\n\");\r\n av_log(avctx,16,\"Please port your application to avcodec_decode_audio4()\\n\");\r\n avctx -> get_buffer = avcodec_default_get_buffer;\r\n avctx -> release_buffer = avcodec_default_release_buffer;\r\n }\r\n ret = avcodec_decode_audio4(avctx,&frame,&got_frame,avpkt);\r\n if (ret >= 0 && got_frame) {\r\n int ch;\r\n int plane_size;\r\n int planar = av_sample_fmt_is_planar(avctx -> sample_fmt);\r\n int data_size = av_samples_get_buffer_size(&plane_size,avctx -> channels,frame . nb_samples,avctx -> sample_fmt,1);\r\n if ( *frame_size_ptr < data_size) {\r\n av_log(avctx,16,\"output buffer size is too small for the current frame (%d < %d)\\n\", *frame_size_ptr,data_size);\r\n return - 22;\r\n }\r\n memcpy(samples,frame . extended_data[0],plane_size);\r\n if (planar && avctx -> channels > 1) {\r\n uint8_t *out = ((uint8_t *)samples) + plane_size;\r\n for (ch = 1; ch < avctx -> channels; ch++) {\r\n memcpy(out,frame . extended_data[ch],plane_size);\r\n out += plane_size;\r\n }\r\n }\r\n *frame_size_ptr = data_size;\r\n }\r\n else {\r\n *frame_size_ptr = 0;\r\n }\r\n return ret;\r\n}\r\n#endif\r\n\r\nint avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)\r\n{\r\n int planar;\r\n int channels;\r\n int ret = 0;\r\n *got_frame_ptr = 0;\r\n if (!avpkt -> data && avpkt -> size) {\r\n av_log(avctx,16,\"invalid packet: NULL data, size != 0\\n\");\r\n return - 22;\r\n }\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_AUDIO) {\r\n av_log(avctx,16,\"Invalid media type for audio\\n\");\r\n return - 22;\r\n }\r\n avcodec_get_frame_defaults(frame);\r\n if (avctx -> codec -> capabilities & 0x20 || avpkt -> size) {\r\n uint8_t *side;\r\n int side_size;\r\n\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n apply_param_change(avctx,&tmp);\r\n avctx -> pkt = &tmp;\r\n ret = ((avctx -> codec -> decode)(avctx,frame,got_frame_ptr,&tmp));\r\n if (ret >= 0 && *got_frame_ptr) {\r\n avctx -> frame_number++;\r\n frame -> pkt_dts = avpkt -> dts;\r\n av_frame_set_best_effort_timestamp(frame,guess_correct_pts(avctx,frame -> pkt_pts,frame -> pkt_dts));\r\n if (frame -> format == AV_SAMPLE_FMT_NONE) {\r\n frame -> format = (avctx -> sample_fmt);\r\n }\r\n if (!frame -> channel_layout) {\r\n frame -> channel_layout = avctx -> channel_layout;\r\n }\r\n if (!av_frame_get_channels(frame)) {\r\n av_frame_set_channels(frame,avctx -> channels);\r\n }\r\n if (!frame -> sample_rate) {\r\n frame -> sample_rate = avctx -> sample_rate;\r\n }\r\n }\r\n add_metadata_from_side_data(avctx,frame);\r\n side = av_packet_get_side_data(avctx -> pkt,AV_PKT_DATA_SKIP_SAMPLES,&side_size);\r\n if (side && side_size >= '\\n') {\r\n avctx -> internal -> skip_samples = (((const union unaligned_32 *)side) -> l);\r\n av_log(avctx,48,\"skip %d samples due to side data\\n\",avctx -> internal -> skip_samples);\r\n }\r\n if (avctx -> internal -> skip_samples && *got_frame_ptr) {\r\n if (frame -> nb_samples <= avctx -> internal -> skip_samples) {\r\n *got_frame_ptr = 0;\r\n avctx -> internal -> skip_samples -= frame -> nb_samples;\r\n av_log(avctx,48,\"skip whole frame, skip left: %d\\n\",avctx -> internal -> skip_samples);\r\n }\r\n else {\r\n av_samples_copy(frame -> extended_data,(frame -> extended_data),0,avctx -> internal -> skip_samples,frame -> nb_samples - avctx -> internal -> skip_samples,avctx -> channels,(frame -> format));\r\n if (avctx -> pkt_timebase . num && avctx -> sample_rate) {\r\n int64_t diff_ts = av_rescale_q((avctx -> internal -> skip_samples),((AVRational ){(1), avctx -> sample_rate}),avctx -> pkt_timebase);\r\n if (frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_pts += diff_ts;\r\n }\r\n if (frame -> pkt_dts != ((int64_t )0x8000000000000000UL)) {\r\n frame -> pkt_dts += diff_ts;\r\n }\r\n if (av_frame_get_pkt_duration(frame) >= diff_ts) {\r\n av_frame_set_pkt_duration(frame,av_frame_get_pkt_duration(frame) - diff_ts);\r\n }\r\n }\r\n else {\r\n av_log(avctx,24,\"Could not update timestamps for skipped samples.\\n\");\r\n }\r\n av_log(avctx,48,\"skip %d/%d samples\\n\",avctx -> internal -> skip_samples,frame -> nb_samples);\r\n frame -> nb_samples -= avctx -> internal -> skip_samples;\r\n avctx -> internal -> skip_samples = 0;\r\n }\r\n }\r\n avctx -> pkt = ((void *)0);\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n }\r\n\r\n if ( *got_frame_ptr) {\r\n planar = av_sample_fmt_is_planar((frame -> format));\r\n channels = av_frame_get_channels(frame);\r\n if (!(planar && channels > 8)) {\r\n frame -> extended_data = frame -> data;\r\n }\r\n }\r\n else {\r\n frame -> extended_data = ((void *)0);\r\n }\r\n return ret;\r\n}\r\n#define UTF8_MAX_BYTES 4 \r\n\r\nstatic int recode_subtitle(AVCodecContext *avctx,AVPacket *outpkt,const AVPacket *inpkt)\r\n{\r\n#if CONFIG_ICONV\r\n iconv_t cd = (iconv_t )(- 1);\r\n int ret = 0;\r\n char *inb;\r\n char *outb;\r\n size_t inl;\r\n size_t outl;\r\n AVPacket tmp;\r\n#endif\r\n if (avctx -> sub_charenc_mode != 1) {\r\n return 0;\r\n }\r\n#if CONFIG_ICONV\r\n cd = iconv_open(\"UTF-8\",(avctx -> sub_charenc));\r\n if (cd == ((iconv_t )(- 1))) {\r\n av_log(avctx,16,\"Unable to open iconv context with input character encoding \\\"%s\\\"\\n\",avctx -> sub_charenc);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n inb = (inpkt -> data);\r\n inl = (inpkt -> size);\r\n if (inl >= (2147483647 / 4 - 16)) {\r\n av_log(avctx,16,\"Subtitles packet is too big for recoding\\n\");\r\n ret = - '\\f';\r\n goto end;\r\n }\r\n ret = av_new_packet(&tmp,(inl * 4));\r\n if (ret < 0) {\r\n goto end;\r\n }\r\n outpkt -> data = tmp . data;\r\n outpkt -> size = tmp . size;\r\n outb = (outpkt -> data);\r\n outl = (outpkt -> size);\r\n if (iconv(cd,&inb,&inl,&outb,&outl) == ((size_t )(- 1)) || iconv(cd,((void *)0),((void *)0),&outb,&outl) == ((size_t )(- 1)) || outl >= (outpkt -> size) || inl != 0) {\r\n av_log(avctx,16,\"Unable to recode subtitle event \\\"%s\\\" from %s to UTF-8\\n\",inpkt -> data,avctx -> sub_charenc);\r\n av_free_packet(&tmp);\r\n ret = -( *__errno_location());\r\n goto end;\r\n }\r\n outpkt -> size -= outl;\r\n memset((outpkt -> data + outpkt -> size),0,outl);\r\n end:\r\n if (cd != ((iconv_t )(- 1))) {\r\n iconv_close(cd);\r\n }\r\n return ret;\r\n#else\r\n#endif\r\n}\r\n\r\nint avcodec_decode_subtitle2(AVCodecContext *avctx,AVSubtitle *sub,int *got_sub_ptr,AVPacket *avpkt)\r\n{\r\n int ret = 0;\r\n if ((avctx -> codec -> type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(avctx,16,\"Invalid media type for subtitles\\n\");\r\n return - 22;\r\n }\r\n *got_sub_ptr = 0;\r\n avcodec_get_subtitle_defaults(sub);\r\n if (avpkt -> size) {\r\n AVPacket pkt_recoded;\r\n AVPacket tmp = *avpkt;\r\n int did_split = av_packet_split_side_data(&tmp);\r\n\r\n pkt_recoded = tmp;\r\n ret = recode_subtitle(avctx,&pkt_recoded,(&tmp));\r\n if (ret < 0) {\r\n *got_sub_ptr = 0;\r\n }\r\n else {\r\n avctx -> pkt = &pkt_recoded;\r\n if (avctx -> pkt_timebase . den && avpkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n sub -> pts = av_rescale_q(avpkt -> pts,avctx -> pkt_timebase,((AVRational ){(1), (1000000)}));\r\n }\r\n ret = ((avctx -> codec -> decode)(avctx,sub,got_sub_ptr,&pkt_recoded));\r\n (void )0;\r\n if (tmp . data != pkt_recoded . data) {\r\n av_free(pkt_recoded . data);\r\n }\r\n sub -> format = (!(avctx -> codec_descriptor -> props & 1 << 16));\r\n avctx -> pkt = ((void *)0);\r\n }\r\n if (did_split) {\r\n ff_packet_free_side_data(&tmp);\r\n if (ret == tmp . size) {\r\n ret = avpkt -> size;\r\n }\r\n }\r\n if ( *got_sub_ptr) {\r\n avctx -> frame_number++;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avsubtitle_free(AVSubtitle *sub)\r\n{\r\n int i;\r\n for (i = 0; i < sub -> num_rects; i++) {\r\n av_freep((&sub -> rects[i] -> pict . data[0]));\r\n av_freep((&sub -> rects[i] -> pict . data[1]));\r\n av_freep((&sub -> rects[i] -> pict . data[2]));\r\n av_freep((&sub -> rects[i] -> pict . data[3]));\r\n av_freep((&sub -> rects[i] -> text));\r\n av_freep((&sub -> rects[i] -> ass));\r\n av_freep((&sub -> rects[i]));\r\n }\r\n av_freep((&sub -> rects));\r\n memset(sub,0,sizeof(AVSubtitle ));\r\n}\r\n\r\nint ff_codec_close_recursive(AVCodecContext *avctx)\r\n{\r\n int ret = 0;\r\n ff_unlock_avcodec();\r\n ret = avcodec_close(avctx);\r\n ff_lock_avcodec(((void *)0));\r\n return ret;\r\n}\r\n\r\nint avcodec_close(AVCodecContext *avctx)\r\n{\r\n int ret = ff_lock_avcodec(avctx);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n if (avcodec_is_open(avctx)) {\r\n if (1 && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1) {\r\n ff_unlock_avcodec();\r\n ff_frame_thread_encoder_free(avctx);\r\n ff_lock_avcodec(avctx);\r\n }\r\n if (1 && avctx -> thread_opaque) {\r\n ff_thread_free(avctx);\r\n }\r\n if (avctx -> codec && avctx -> codec -> close) {\r\n (avctx -> codec -> close)(avctx);\r\n }\r\n avcodec_default_free_buffers(avctx);\r\n avctx -> coded_frame = ((void *)0);\r\n avctx -> internal -> byte_buffer_size = 0;\r\n av_freep((&avctx -> internal -> byte_buffer));\r\n av_freep((&avctx -> internal));\r\n av_dict_free(&avctx -> metadata);\r\n }\r\n if (avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class) {\r\n av_opt_free(avctx -> priv_data);\r\n }\r\n av_opt_free(avctx);\r\n av_freep((&avctx -> priv_data));\r\n if (av_codec_is_encoder(avctx -> codec)) {\r\n av_freep((&avctx -> extradata));\r\n }\r\n avctx -> codec = ((void *)0);\r\n avctx -> active_thread_type = 0;\r\n ff_unlock_avcodec();\r\n return 0;\r\n}\r\n\r\nstatic enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)\r\n{\r\n switch(id){\r\n case AV_CODEC_ID_OPUS_DEPRECATED:\r\n\r\n\r\n\r\n return AV_CODEC_ID_OPUS;\r\n case AV_CODEC_ID_TAK_DEPRECATED:\r\n return AV_CODEC_ID_TAK;\r\n default:\r\n return id;\r\n }\r\n}\r\n\r\nstatic AVCodec *find_encdec(enum AVCodecID id,int encoder)\r\n{\r\n AVCodec *p;\r\n AVCodec *experimental = ((void *)0);\r\n p = first_avcodec;\r\n id = remap_deprecated_codec_id(id);\r\n while(p){\r\n if (((encoder?av_codec_is_encoder(p) : av_codec_is_decoder(p))) && (p -> id) == id) {\r\n if (p -> capabilities & 0x0200 && !experimental) {\r\n experimental = p;\r\n }\r\n else {\r\n return p;\r\n }\r\n }\r\n p = p -> next;\r\n }\r\n return experimental;\r\n}\r\n\r\nAVCodec *avcodec_find_encoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,1);\r\n}\r\n\r\nAVCodec *avcodec_find_encoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_encoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder(enum AVCodecID id)\r\n{\r\n return find_encdec(id,0);\r\n}\r\n\r\nAVCodec *avcodec_find_decoder_by_name(const char *name)\r\n{\r\n AVCodec *p;\r\n if (!name) {\r\n return ((void *)0);\r\n }\r\n p = first_avcodec;\r\n while(p){\r\n if (av_codec_is_decoder(p) && strcmp(name,p -> name) == 0) {\r\n return p;\r\n }\r\n p = p -> next;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nconst char *avcodec_get_name(enum AVCodecID id)\r\n{\r\n const AVCodecDescriptor *cd;\r\n AVCodec *codec;\r\n if (id == AV_CODEC_ID_NONE) {\r\n return \"none\";\r\n }\r\n cd = avcodec_descriptor_get(id);\r\n if (cd) {\r\n return cd -> name;\r\n }\r\n av_log(((void *)0),24,\"Codec 0x%x is not in the full list.\\n\",id);\r\n codec = avcodec_find_decoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n codec = avcodec_find_encoder(id);\r\n if (codec) {\r\n return codec -> name;\r\n }\r\n return \"unknown_codec\";\r\n}\r\n\r\nsize_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)\r\n{\r\n int i;\r\n int len;\r\n int ret = 0;\r\n#define TAG_PRINT(x) \\\r\n (((x) >= '0' && (x) <= '9') || \\\r\n ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || \\\r\n ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))\r\n for (i = 0; i < 4; i++) {\r\n len = snprintf(buf,buf_size,(((codec_tag & 0xff) >= 48 && (codec_tag & 0xff) <= '9' || (codec_tag & 0xff) >= 'a' && (codec_tag & 0xff) <= 'z' || (codec_tag & 0xff) >= 'A' && (codec_tag & 0xff) <= 'Z' || ((codec_tag & 0xff) == '.' || (codec_tag & 0xff) == 32 || (codec_tag & 0xff) == '-' || (codec_tag & 0xff) == '_')?\"%c\" : \"[%d]\")),codec_tag & 0xff);\r\n buf += len;\r\n buf_size = (buf_size > len?buf_size - len : 0);\r\n ret += len;\r\n codec_tag >>= 8;\r\n }\r\n return ret;\r\n}\r\n\r\nvoid avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)\r\n{\r\n const char *codec_type;\r\n const char *codec_name;\r\n const char *profile = ((void *)0);\r\n const AVCodec *p;\r\n int bitrate;\r\n AVRational display_aspect_ratio;\r\n if (!buf || buf_size <= 0) {\r\n return ;\r\n }\r\n codec_type = av_get_media_type_string(enc -> codec_type);\r\n codec_name = avcodec_get_name(enc -> codec_id);\r\n if (enc -> profile != - 'c') {\r\n if (enc -> codec) {\r\n p = enc -> codec;\r\n }\r\n else {\r\n p = ((encode?avcodec_find_encoder(enc -> codec_id) : avcodec_find_decoder(enc -> codec_id)));\r\n }\r\n if (p) {\r\n profile = av_get_profile_name(p,enc -> profile);\r\n }\r\n }\r\n snprintf(buf,buf_size,\"%s: %s%s\",(codec_type?codec_type : \"unknown\"),codec_name,(enc -> mb_decision?\" (hq)\" : \"\"));\r\n\r\n buf[0] ^= 'a' ^ 'A';\r\n if (profile) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s)\",profile);\r\n }\r\n if (enc -> codec_tag) {\r\n char tag_buf[32];\r\n av_get_codec_tag_string(tag_buf,sizeof(tag_buf),enc -> codec_tag);\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%s / 0x%04X)\",tag_buf,enc -> codec_tag);\r\n }\r\n switch(enc -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if ((enc -> pix_fmt) != AV_PIX_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_pix_fmt_name(enc -> pix_fmt));\r\n if (enc -> bits_per_raw_sample && enc -> bits_per_raw_sample <= av_pix_fmt_desc_get(enc -> pix_fmt) -> comp[0] . depth_minus1) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" (%d bpc)\",enc -> bits_per_raw_sample);\r\n }\r\n }\r\n if (enc -> width) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %dx%d\",enc -> width,enc -> height);\r\n if (enc -> sample_aspect_ratio . num) {\r\n av_reduce(&display_aspect_ratio . num,&display_aspect_ratio . den,(enc -> width * enc -> sample_aspect_ratio . num),(enc -> height * enc -> sample_aspect_ratio . den),(1024 * 1024));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\" [SAR %d:%d DAR %d:%d]\",enc -> sample_aspect_ratio . num,enc -> sample_aspect_ratio . den,display_aspect_ratio . num,display_aspect_ratio . den);\r\n }\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n if (encode) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", q=%d-%d\",enc -> qmin,enc -> qmax);\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (enc -> sample_rate) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d Hz\",enc -> sample_rate);\r\n }\r\n av_strlcat(buf,\", \",buf_size);\r\n av_get_channel_layout_string(buf + strlen(buf),(buf_size - strlen(buf)),enc -> channels,enc -> channel_layout);\r\n if ((enc -> sample_fmt) != AV_SAMPLE_FMT_NONE) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %s\",av_get_sample_fmt_name(enc -> sample_fmt));\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n if (av_log_get_level() >= 48) {\r\n int g = (av_gcd(enc -> time_base . num,enc -> time_base . den));\r\n if (g) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d/%d\",enc -> time_base . num / g,enc -> time_base . den / g);\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n return ;\r\n }\r\n if (encode) {\r\n if (enc -> flags & 0x0200) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 1\");\r\n }\r\n if (enc -> flags & 0x0400) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", pass 2\");\r\n }\r\n }\r\n bitrate = get_bit_rate(enc);\r\n if (bitrate != 0) {\r\n snprintf(buf + strlen(buf),buf_size - strlen(buf),\", %d kb/s\",bitrate / 1000);\r\n }\r\n}\r\n\r\nconst char *av_get_profile_name(const AVCodec *codec,int profile)\r\n{\r\n const AVProfile *p;\r\n if (profile == - 'c' || !codec -> profiles) {\r\n return ((void *)0);\r\n }\r\n for (p = codec -> profiles; p -> profile != - 'c'; p++) \r\n if (p -> profile == profile) {\r\n return p -> name;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nunsigned int avcodec_version()\r\n{\r\n\r\n do {\r\n if (!(AV_CODEC_ID_PCM_S8_PLANAR == 65563)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_PCM_S8_PLANAR==65563\",\"utils.c\",2307);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(AV_CODEC_ID_ADPCM_G722 == 69660)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_ADPCM_G722==69660\",\"utils.c\",2308);\r\n abort();\r\n }\r\n }while (0);\r\n\r\n do {\r\n if (!(AV_CODEC_ID_SRT == 94216)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_CODEC_ID_SRT==94216\",\"utils.c\",2310);\r\n abort();\r\n }\r\n }while (0);\r\n do {\r\n if (!(100 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"100 >= 100\",\"utils.c\",2311);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 92 << 8 | 100);\r\n}\r\n\r\nconst char *avcodec_configuration()\r\n{\r\n saliaric_antialbumin endosternum_sunstone = 0;\r\n char *tangency_flaminical;;\r\n if (__sync_bool_compare_and_swap(&iridescent_terrye,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n tangency_flaminical = getenv(\"ACCEPTANCE_METHS\");\r\n if (tangency_flaminical != 0) {;\r\n endosternum_sunstone = tangency_flaminical;\r\n herman_precontention(endosternum_sunstone);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avcodec_license()\r\n{\r\n#define LICENSE_PREFIX \"libavcodec license: \"\r\n return (\"libavcodec license: LGPL version 2.1 or later\" + sizeof(\"libavcodec license: \") - 1);\r\n}\r\n\r\nvoid avcodec_flush_buffers(AVCodecContext *avctx)\r\n{\r\n if (1 && avctx -> active_thread_type & 1) {\r\n ff_thread_flush(avctx);\r\n }\r\n else {\r\n if (avctx -> codec -> flush) {\r\n (avctx -> codec -> flush)(avctx);\r\n }\r\n }\r\n avctx -> pts_correction_last_pts = avctx -> pts_correction_last_dts = - 9223372036854775807L - 1;\r\n}\r\n\r\nstatic void video_free_buffers(AVCodecContext *s)\r\n{\r\n AVCodecInternal *avci = s -> internal;\r\n int i;\r\n int j;\r\n if (!avci -> buffer) {\r\n return ;\r\n }\r\n if (avci -> buffer_count) {\r\n av_log(s,24,\"Found %i unreleased buffers!\\n\",avci -> buffer_count);\r\n }\r\n for (i = 0; i < 32 + 1; i++) {\r\n InternalBuffer *buf = &avci -> buffer[i];\r\n for (j = 0; j < 4; j++) {\r\n av_freep((&buf -> base[j]));\r\n buf -> data[j] = ((void *)0);\r\n }\r\n }\r\n av_freep((&avci -> buffer));\r\n avci -> buffer_count = 0;\r\n}\r\n\r\nstatic void audio_free_buffers(AVCodecContext *avctx)\r\n{\r\n AVCodecInternal *avci = avctx -> internal;\r\n av_freep((&avci -> audio_data));\r\n}\r\n\r\nvoid avcodec_default_free_buffers(AVCodecContext *avctx)\r\n{\r\n switch(avctx -> codec_type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n video_free_buffers(avctx);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n audio_free_buffers(avctx);\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n}\r\n\r\nint av_get_exact_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_8SVX_EXP:\r\n{\r\n }\r\n case AV_CODEC_ID_8SVX_FIB:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_CT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_APC:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_OKI:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WS:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_G722:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_YAMAHA:\r\n return 4;\r\n case AV_CODEC_ID_PCM_ALAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_MULAW:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S8_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U8:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_ZORK:\r\n return 8;\r\n case AV_CODEC_ID_PCM_S16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_FIRST_AUDIO:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U16LE:\r\n return 16;\r\n case AV_CODEC_ID_PCM_S24DAUD:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U24LE:\r\n return 24;\r\n case AV_CODEC_ID_PCM_S32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_U32LE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F32LE:\r\n return 32;\r\n case AV_CODEC_ID_PCM_F64BE:\r\n{\r\n }\r\n case AV_CODEC_ID_PCM_F64LE:\r\n return 64;\r\n default:\r\n return 0;\r\n }\r\n}\r\n\r\nenum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt,int be)\r\n{\r\n static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {[0UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [1UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [2UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [3UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [4UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}, [5UL]{(AV_CODEC_ID_PCM_U8), (AV_CODEC_ID_PCM_U8)}, [6UL]{(AV_CODEC_ID_FIRST_AUDIO), (AV_CODEC_ID_PCM_S16BE)}, [7UL]{(AV_CODEC_ID_PCM_S32LE), (AV_CODEC_ID_PCM_S32BE)}, [8UL]{(AV_CODEC_ID_PCM_F32LE), (AV_CODEC_ID_PCM_F32BE)}, [9UL]{(AV_CODEC_ID_PCM_F64LE), (AV_CODEC_ID_PCM_F64BE)}};\r\n if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n if (be < 0 || be > 1) {\r\n be = 0;\r\n }\r\n return map[fmt][be];\r\n}\r\n\r\nint av_get_bits_per_sample(enum AVCodecID codec_id)\r\n{\r\n switch(codec_id){\r\n case AV_CODEC_ID_ADPCM_SBPRO_2:\r\n return 2;\r\n case AV_CODEC_ID_ADPCM_SBPRO_3:\r\n return 3;\r\n case AV_CODEC_ID_ADPCM_SBPRO_4:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_SWF:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return 4;\r\n default:\r\n return av_get_exact_bits_per_sample(codec_id);\r\n }\r\n}\r\n\r\nint av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)\r\n{\r\n int id;\r\n int sr;\r\n int ch;\r\n int ba;\r\n int tag;\r\n int bps;\r\n id = (avctx -> codec_id);\r\n sr = avctx -> sample_rate;\r\n ch = avctx -> channels;\r\n ba = avctx -> block_align;\r\n tag = (avctx -> codec_tag);\r\n bps = av_get_exact_bits_per_sample(avctx -> codec_id);\r\n\r\n if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) {\r\n return (frame_bytes * 8LL / (bps * ch));\r\n }\r\n bps = avctx -> bits_per_coded_sample;\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_ADX:\r\n return 32;\r\n case AV_CODEC_ID_ADPCM_IMA_QT:\r\n return 64;\r\n case AV_CODEC_ID_ADPCM_EA_XAS:\r\n return 128;\r\n case AV_CODEC_ID_AMR_NB:\r\n{\r\n }\r\n case AV_CODEC_ID_EVRC:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM:\r\n{\r\n }\r\n case AV_CODEC_ID_QCELP:\r\n{\r\n }\r\n case AV_CODEC_ID_RA_288:\r\n return 160;\r\n case AV_CODEC_ID_AMR_WB:\r\n{\r\n }\r\n case AV_CODEC_ID_GSM_MS:\r\n return 320;\r\n case AV_CODEC_ID_MP1:\r\n return 384;\r\n case AV_CODEC_ID_ATRAC1:\r\n return 512;\r\n case AV_CODEC_ID_ATRAC3:\r\n return 1024;\r\n case AV_CODEC_ID_MP2:\r\n{\r\n }\r\n case AV_CODEC_ID_MUSEPACK7:\r\n return 1152;\r\n case AV_CODEC_ID_AC3:\r\n return 1536;\r\n }\r\n if (sr > 0) {\r\n\r\n if (id == AV_CODEC_ID_TTA) {\r\n return 256 * sr / 245;\r\n }\r\n if (ch > 0) {\r\n\r\n if (id == AV_CODEC_ID_BINKAUDIO_DCT) {\r\n return (480 << sr / 22050) / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n if (id == AV_CODEC_ID_SIPR) {\r\n switch(ba){\r\n case 20:\r\n return 160;\r\n case 19:\r\n return 144;\r\n case 29:\r\n return 288;\r\n case 37:\r\n return 480;\r\n }\r\n }\r\n else {\r\n if (id == AV_CODEC_ID_ILBC) {\r\n switch(ba){\r\n case 38:\r\n return 160;\r\n case 50:\r\n return 240;\r\n }\r\n }\r\n }\r\n }\r\n if (frame_bytes > 0) {\r\n\r\n if (id == AV_CODEC_ID_TRUESPEECH) {\r\n return 240 * (frame_bytes / 32);\r\n }\r\n if (id == AV_CODEC_ID_NELLYMOSER) {\r\n return 256 * (frame_bytes / 64);\r\n }\r\n if (id == AV_CODEC_ID_RA_144) {\r\n return 160 * (frame_bytes / 20);\r\n }\r\n if (id == AV_CODEC_ID_G723_1) {\r\n return 240 * (frame_bytes / 24);\r\n }\r\n if (bps > 0) {\r\n\r\n if (id == AV_CODEC_ID_ADPCM_G726) {\r\n return frame_bytes * 8 / bps;\r\n }\r\n }\r\n if (ch > 0) {\r\n\r\n switch(id){\r\n case AV_CODEC_ID_ADPCM_AFC:\r\n return frame_bytes / ('\\t' * ch) * 16;\r\n case AV_CODEC_ID_ADPCM_4XM:\r\n{\r\n }\r\n case AV_CODEC_ID_ADPCM_IMA_ISS:\r\n return (frame_bytes - 4 * ch) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\r\n return (frame_bytes - 4) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_IMA_AMV:\r\n return (frame_bytes - 8) * 2 / ch;\r\n case AV_CODEC_ID_ADPCM_XA:\r\n return frame_bytes / 128 * 224 / ch;\r\n case AV_CODEC_ID_INTERPLAY_DPCM:\r\n return (frame_bytes - 6 - ch) / ch;\r\n case AV_CODEC_ID_ROQ_DPCM:\r\n return (frame_bytes - 8) / ch;\r\n case AV_CODEC_ID_XAN_DPCM:\r\n return (frame_bytes - 2 * ch) / ch;\r\n case AV_CODEC_ID_MACE3:\r\n return 3 * frame_bytes / ch;\r\n case AV_CODEC_ID_MACE6:\r\n return 6 * frame_bytes / ch;\r\n case AV_CODEC_ID_PCM_LXF:\r\n return 2 * (frame_bytes / (5 * ch));\r\n case AV_CODEC_ID_IAC:\r\n{\r\n }\r\n case AV_CODEC_ID_IMC:\r\n return 4 * frame_bytes / ch;\r\n }\r\n if (tag) {\r\n\r\n if (id == AV_CODEC_ID_SOL_DPCM) {\r\n if (tag == 3) {\r\n return frame_bytes / ch;\r\n }\r\n else {\r\n return frame_bytes * 2 / ch;\r\n }\r\n }\r\n }\r\n if (ba > 0) {\r\n\r\n int blocks = frame_bytes / ba;\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_ADPCM_IMA_WAV:\r\n return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\r\n case AV_CODEC_ID_ADPCM_IMA_DK3:\r\n return blocks * ((ba - 16) * 2 / 3 * 4 / ch);\r\n case AV_CODEC_ID_ADPCM_IMA_DK4:\r\n return blocks * (1 + (ba - 4 * ch) * 2 / ch);\r\n case AV_CODEC_ID_ADPCM_MS:\r\n return blocks * (2 + (ba - 7 * ch) * 2 / ch);\r\n }\r\n }\r\n if (bps > 0) {\r\n\r\n switch(avctx -> codec_id){\r\n case AV_CODEC_ID_PCM_DVD:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return 2 * (frame_bytes / (bps * 2 / 8 * ch));\r\n }\r\n case AV_CODEC_ID_PCM_BLURAY:\r\n{\r\n if (bps < 4) {\r\n return 0;\r\n }\r\n return frame_bytes / ((ch + 2 - 1 & ~(2 - 1)) * bps / 8);\r\n }\r\n case AV_CODEC_ID_S302M:\r\n return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\r\n }\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nunsigned int av_xiphlacing(unsigned char *s,unsigned int v)\r\n{\r\n unsigned int n = 0;\r\n while(v >= 0xff){\r\n *(s++) = 0xff;\r\n v -= 0xff;\r\n n++;\r\n }\r\n *s = v;\r\n n++;\r\n return n;\r\n}\r\n\r\nint ff_match_2uint16(const uint16_t (*tab)[2],int size,int a,int b)\r\n{\r\n int i;\r\n for (i = 0; i < size && !(tab[i][0] == a && tab[i][1] == b); i++) \r\n ;\r\n return i;\r\n}\r\n\r\nvoid av_log_missing_feature(void *avc,const char *feature,int want_sample)\r\n{\r\n av_log(avc,24,\"%s is not implemented. Update your FFmpeg version to the newest one from Git. If the problem still occurs, it means that your file has a feature which has not been implemented.\\n\",feature);\r\n if (want_sample) {\r\n av_log_ask_for_sample(avc,((void *)0));\r\n }\r\n}\r\n\r\nvoid av_log_ask_for_sample(void *avc,const char *msg,... )\r\n{\r\n va_list argument_list;\r\n __builtin_va_start(argument_list,msg);\r\n if (msg) {\r\n av_vlog(avc,24,msg,argument_list);\r\n }\r\n av_log(avc,24,\"If you want to help, upload a sample of this file to ftp:\r\n __builtin_va_end(argument_list);\r\n}\r\nstatic AVHWAccel *first_hwaccel = ((void *)0);\r\n\r\nvoid av_register_hwaccel(AVHWAccel *hwaccel)\r\n{\r\n AVHWAccel **p = &first_hwaccel;\r\n while( *p)\r\n p = &( *p) -> next;\r\n *p = hwaccel;\r\n hwaccel -> next = ((void *)0);\r\n}\r\n\r\nAVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel)\r\n{\r\n return hwaccel?hwaccel -> next : first_hwaccel;\r\n}\r\n\r\nAVHWAccel *ff_find_hwaccel(enum AVCodecID codec_id,enum AVPixelFormat pix_fmt)\r\n{\r\n AVHWAccel *hwaccel = ((void *)0);\r\n while(hwaccel = av_hwaccel_next(hwaccel))\r\n if ((hwaccel -> id) == codec_id && (hwaccel -> pix_fmt) == pix_fmt) {\r\n return hwaccel;\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint av_lockmgr_register(int (*cb)(void **, enum AVLockOp ))\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_DESTROY)) {\r\n return - 1;\r\n }\r\n }\r\n ff_lockmgr_cb = cb;\r\n if (ff_lockmgr_cb) {\r\n if (ff_lockmgr_cb(&codec_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n if (ff_lockmgr_cb(&avformat_mutex,AV_LOCK_CREATE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint ff_lock_avcodec(AVCodecContext *log_ctx)\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n entangled_thread_counter++;\r\n if (entangled_thread_counter != 1) {\r\n av_log(log_ctx,16,\"Insufficient thread locking around avcodec_open/close()\\n\");\r\n ff_avcodec_locked = 1;\r\n ff_unlock_avcodec();\r\n return - 22;\r\n }\r\n do {\r\n if (!(!ff_avcodec_locked)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!ff_avcodec_locked\",\"utils.c\",2743);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 1;\r\n return 0;\r\n}\r\n\r\nint ff_unlock_avcodec()\r\n{\r\n do {\r\n if (!ff_avcodec_locked) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ff_avcodec_locked\",\"utils.c\",2750);\r\n abort();\r\n }\r\n }while (0);\r\n ff_avcodec_locked = 0;\r\n entangled_thread_counter--;\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&codec_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_lock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_OBTAIN)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nint avpriv_unlock_avformat()\r\n{\r\n if (ff_lockmgr_cb) {\r\n if (( *ff_lockmgr_cb)(&avformat_mutex,AV_LOCK_RELEASE)) {\r\n return - 1;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nunsigned int avpriv_toupper4(unsigned int x)\r\n{\r\n return (av_toupper((x & 0xff)) + (av_toupper((x >> 8 & 0xff)) << 8) + (av_toupper((x >> 16 & 0xff)) << 16) + (av_toupper((x >> 24 & 0xff)) << 24));\r\n}\r\n#if !HAVE_THREADS\r\n#endif\r\n\r\nenum AVMediaType avcodec_get_type(enum AVCodecID codec_id)\r\n{\r\n AVCodec *c = avcodec_find_decoder(codec_id);\r\n if (!c) {\r\n c = avcodec_find_encoder(codec_id);\r\n }\r\n if (c) {\r\n return c -> type;\r\n }\r\n if (codec_id <= AV_CODEC_ID_NONE) {\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_AUDIO) {\r\n return AVMEDIA_TYPE_VIDEO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_SUBTITLE) {\r\n return AVMEDIA_TYPE_AUDIO;\r\n }\r\n else {\r\n if (codec_id < AV_CODEC_ID_FIRST_UNKNOWN) {\r\n return AVMEDIA_TYPE_SUBTITLE;\r\n }\r\n }\r\n }\r\n }\r\n return AVMEDIA_TYPE_UNKNOWN;\r\n}\r\n\r\nint avcodec_is_open(AVCodecContext *s)\r\n{\r\n return !(!s -> internal);\r\n}\r\n\r\nint avpriv_bprint_to_extradata(AVCodecContext *avctx,struct AVBPrint *buf)\r\n{\r\n int ret;\r\n char *str;\r\n ret = av_bprint_finalize(buf,&str);\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avctx -> extradata = str;\r\n\r\n avctx -> extradata_size = (buf -> len);\r\n return 0;\r\n}\r\n\r\nvoid herman_precontention(const saliaric_antialbumin vulcanize_miming)\r\n{\r\n int watershut_gorsebird = 7;\r\n ++global_variable;;\r\n palingenesian_apism(watershut_gorsebird,vulcanize_miming);\r\n}\r\n\r\nvoid palingenesian_apism(int precolor_weakheartedly,saliaric_antialbumin inhumanism_idealists)\r\n{\r\n int tainted_int = 0;\r\n int output_counter = 0;\r\n char *descure_unregrettable = 0;\r\n ++global_variable;\r\n precolor_weakheartedly--;\r\n if (precolor_weakheartedly > 0) {\r\n palingenesian_apism(precolor_weakheartedly,inhumanism_idealists);\r\n return ;\r\n }\r\n descure_unregrettable = ((char *)((saliaric_antialbumin )inhumanism_idealists));\r\n \r\n tainted_int = atoi(descure_unregrettable);\r\n if (tainted_int > 0) {\r\n \r\n\r\n tainted_int = tainted_int * tainted_int;\r\n \r\n \r\n \r\n while (tainted_int != 0) {\r\n\r\n if (tainted_int != INT_MIN) {\r\n tainted_int--;\r\n }\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n ++190_global_var;\r\n if (190_global_var >= INT_MAX) {\r\n 190_global_var = 0;\r\n }\r\n }\r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while (tainted_int != 0) {\n\n if (tainted_int != INT_MIN) {\n tainted_int--;\n }\n \n if (output_counter == 0) {\n printf(\"evaluating input\\n\");\n }\n output_counter++;\n if (output_counter == 1000000) {\n output_counter = 0;\n }\n ++190_global_var;\n if (190_global_var >= INT_MAX) {\n 190_global_var = 0;\n }\n }\n```", "cwe": "190"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint gorgoneum_prospero = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid demisable_unparalysed(char *const unmitigatedly_intolerable);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int movie_gweduck = 0;\r\n char *sweetbriar_overdoses = 0;\r\n int validation_jasmone = 61;\r\n char *aminated_staghunter;;\r\n if (__sync_bool_compare_and_swap(&gorgoneum_prospero,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&aminated_staghunter,\"1152\",validation_jasmone);\r\n if (aminated_staghunter != 0) {;\r\n movie_gweduck = ((int )(strlen(aminated_staghunter)));\r\n sweetbriar_overdoses = ((char *)(malloc(movie_gweduck + 1)));\r\n if (sweetbriar_overdoses == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(sweetbriar_overdoses,0,movie_gweduck + 1);\r\n memcpy(sweetbriar_overdoses,aminated_staghunter,movie_gweduck);\r\n if (aminated_staghunter != 0) \r\n free(((char *)aminated_staghunter));\r\n demisable_unparalysed(sweetbriar_overdoses);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid demisable_unparalysed(char *const unmitigatedly_intolerable)\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[1020];\r\n char filename[80];\r\n char *dapperest_ujiji = 0;\r\n int jawed_bundoc;\r\n int uncavilling_anencephalic;\r\n ++global_variable;;\r\n uncavilling_anencephalic = 5;\r\n while(1 == 1){\r\n uncavilling_anencephalic = uncavilling_anencephalic * 2;\r\n uncavilling_anencephalic = uncavilling_anencephalic + 2;\r\n if (uncavilling_anencephalic > 1000) {\r\n break; \r\n }\r\n }\r\n jawed_bundoc = uncavilling_anencephalic;\r\n dapperest_ujiji = ((char *)((char *)unmitigatedly_intolerable));\r\n \r\n files = fopen(dapperest_ujiji,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n if (files != 0)\r\n fclose(files);\r\n \r\n;\r\n if (((char *)unmitigatedly_intolerable) != 0) \r\n free(((char *)((char *)unmitigatedly_intolerable)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi] = file;\n ssi++;\n }\n```", "cwe": "775"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image)\r\r\n{\r\r\n const char\r\r\n *value;\r\r\n\r\r\n const StringInfo\r\r\n *profile;\r\r\n\r\r\n DPXInfo\r\r\n dpx;\r\r\n\r\r\n MagickBooleanType\r\r\n status;\r\r\n\r\r\n MagickOffsetType\r\r\n offset;\r\r\n\r\r\n MagickStatusType\r\r\n flags;\r\r\n\r\r\n GeometryInfo\r\r\n geometry_info;\r\r\n\r\r\n QuantumInfo\r\r\n *quantum_info;\r\r\n\r\r\n QuantumType\r\r\n quantum_type;\r\r\n\r\r\n register const PixelPacket\r\r\n *p;\r\r\n\r\r\n register ssize_t\r\r\n i;\r\r\n\r\r\n ssize_t\r\r\n count,\r\r\n horizontal_factor,\r\r\n vertical_factor,\r\r\n y;\r\r\n\r\r\n size_t\r\r\n extent;\r\r\n\r\r\n time_t\r\r\n seconds;\r\r\n\r\r\n unsigned char\r\r\n *pixels;\r\r\n\r\r\n /*\r\r\n Open output image file.\r\r\n */\r\r\n assert(image_info != (const ImageInfo *) NULL);\r\r\n assert(image_info->signature == MagickSignature);\r\r\n assert(image != (Image *) NULL);\r\r\n assert(image->signature == MagickSignature);\r\r\n if (image->debug != MagickFalse)\r\r\n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\r\r\n horizontal_factor=4;\r\r\n vertical_factor=4;\r\r\n if (image_info->sampling_factor != (char *) NULL)\r\r\n {\r\r\n GeometryInfo\r\r\n geometry_info;\r\r\n\r\r\n MagickStatusType\r\r\n flags;\r\r\n\r\r\n flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\r\r\n horizontal_factor=(ssize_t) geometry_info.rho;\r\r\n vertical_factor=(ssize_t) geometry_info.sigma;\r\r\n if ((flags & SigmaValue) == 0)\r\r\n vertical_factor=horizontal_factor;\r\r\n if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\r\r\n (horizontal_factor != 4) && (vertical_factor != 1) &&\r\r\n (vertical_factor != 2) && (vertical_factor != 4))\r\r\n ThrowWriterException(CorruptImageError,\"UnexpectedSamplingFactor\");\r\r\n }\r\r\n if ((image->colorspace == YCbCrColorspace) &&\r\r\n ((horizontal_factor == 2) || (vertical_factor == 2)))\r\r\n if ((image->columns % 2) != 0)\r\r\n image->columns++;\r\r\n status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\r\r\n if (status == MagickFalse)\r\r\n return(status);\r\r\n /*\r\r\n Write file header.\r\r\n */\r\r\n (void) ResetMagickMemory(&dpx,0,sizeof(dpx));\r\r\n offset=0;\r\r\n dpx.file.magic=0x53445058U;\r\r\n offset+=WriteBlobLong(image,dpx.file.magic);\r\r\n dpx.file.image_offset=0x2000U;\r\r\n profile=GetImageProfile(image,\"dpx:user-data\");\r\r\n if (profile != (StringInfo *) NULL)\r\r\n {\r\r\n if (GetStringInfoLength(profile) > 1048576)\r\r\n ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\r\r\n dpx.file.image_offset+=(unsigned int) GetStringInfoLength(profile);\r\r\n dpx.file.image_offset=(((dpx.file.image_offset+0x2000-1)/0x2000)*0x2000);\r\r\n }\r\r\n offset+=WriteBlobLong(image,dpx.file.image_offset);\r\r\n (void) strncpy(dpx.file.version,\"V2.0\",sizeof(dpx.file.version)-1);\r\r\n offset+=WriteBlob(image,8,(unsigned char *) &dpx.file.version);\r\r\n dpx.file.file_size=(unsigned int) (4U*image->columns*image->rows+\r\r\n dpx.file.image_offset);\r\r\n offset+=WriteBlobLong(image,dpx.file.file_size);\r\r\n dpx.file.ditto_key=1U; /* new frame */\r\r\n offset+=WriteBlobLong(image,dpx.file.ditto_key);\r\r\n dpx.file.generic_size=0x00000680U;\r\r\n offset+=WriteBlobLong(image,dpx.file.generic_size);\r\r\n dpx.file.industry_size=0x00000180U;\r\r\n offset+=WriteBlobLong(image,dpx.file.industry_size);\r\r\n dpx.file.user_size=0;\r\r\n if (profile != (StringInfo *) NULL)\r\r\n {\r\r\n dpx.file.user_size+=(unsigned int) GetStringInfoLength(profile);\r\r\n dpx.file.user_size=(((dpx.file.user_size+0x2000-1)/0x2000)*0x2000);\r\r\n }\r\r\n offset+=WriteBlobLong(image,dpx.file.user_size);\r\r\n value=GetImageArtifact(image,\"dpx:file.filename\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.file.filename,value,sizeof(dpx.file.filename)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.file.filename),(unsigned char *)\r\r\n dpx.file.filename);\r\r\n seconds=time((time_t *) NULL);\r\r\n (void) FormatMagickTime(seconds,sizeof(dpx.file.timestamp),\r\r\n dpx.file.timestamp);\r\r\n offset+=WriteBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\r\r\n dpx.file.timestamp);\r\r\n (void) strncpy(dpx.file.creator,GetMagickVersion((size_t *) NULL),\r\r\n sizeof(dpx.file.creator)-1);\r\r\n value=GetImageArtifact(image,\"dpx:file.creator\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.file.creator,value,sizeof(dpx.file.creator)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.file.creator),(unsigned char *)\r\r\n dpx.file.creator);\r\r\n value=GetImageArtifact(image,\"dpx:file.project\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.file.project,value,sizeof(dpx.file.project)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.file.project),(unsigned char *)\r\r\n dpx.file.project);\r\r\n value=GetImageArtifact(image,\"dpx:file.copyright\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.file.copyright,value,sizeof(dpx.file.copyright)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\r\r\n dpx.file.copyright);\r\r\n dpx.file.encrypt_key=(~0U);\r\r\n offset+=WriteBlobLong(image,dpx.file.encrypt_key);\r\r\n offset+=WriteBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\r\r\n dpx.file.reserve);\r\r\n /*\r\r\n Write image header.\r\r\n */\r\r\n switch (image->orientation)\r\r\n {\r\r\n default:\r\r\n case TopLeftOrientation: dpx.image.orientation=0; break;\r\r\n case TopRightOrientation: dpx.image.orientation=1; break;\r\r\n case BottomLeftOrientation: dpx.image.orientation=2; break;\r\r\n case BottomRightOrientation: dpx.image.orientation=3; break;\r\r\n case LeftTopOrientation: dpx.image.orientation=4; break;\r\r\n case RightTopOrientation: dpx.image.orientation=5; break;\r\r\n case LeftBottomOrientation: dpx.image.orientation=6; break;\r\r\n case RightBottomOrientation: dpx.image.orientation=7; break;\r\r\n }\r\r\n offset+=WriteBlobShort(image,dpx.image.orientation);\r\r\n dpx.image.number_elements=1;\r\r\n offset+=WriteBlobShort(image,dpx.image.number_elements);\r\r\n if ((image->columns != (unsigned int) image->columns) ||\r\r\n (image->rows != (unsigned int) image->rows))\r\r\n ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\r\r\n offset+=WriteBlobLong(image,(unsigned int) image->columns);\r\r\n offset+=WriteBlobLong(image,(unsigned int) image->rows);\r\r\n for (i=0; i < 8; i++)\r\r\n {\r\r\n dpx.image.image_element[i].data_sign=0U;\r\r\n offset+=WriteBlobLong(image,dpx.image.image_element[i].data_sign);\r\r\n dpx.image.image_element[i].low_data=0U;\r\r\n offset+=WriteBlobLong(image,dpx.image.image_element[i].low_data);\r\r\n dpx.image.image_element[i].low_quantity=0.0f;\r\r\n offset+=WriteBlobFloat(image,dpx.image.image_element[i].low_quantity);\r\r\n dpx.image.image_element[i].high_data=0U;\r\r\n offset+=WriteBlobLong(image,dpx.image.image_element[i].high_data);\r\r\n dpx.image.image_element[i].high_quantity=0.0f;\r\r\n offset+=WriteBlobFloat(image,dpx.image.image_element[i].high_quantity);\r\r\n dpx.image.image_element[i].descriptor=0;\r\r\n if (i == 0)\r\r\n switch (image->colorspace)\r\r\n {\r\r\n case Rec601YCbCrColorspace:\r\r\n case Rec709YCbCrColorspace:\r\r\n case YCbCrColorspace:\r\r\n {\r\r\n dpx.image.image_element[i].descriptor=CbYCr444ComponentType;\r\r\n if (image->matte != MagickFalse)\r\r\n dpx.image.image_element[i].descriptor=CbYCrA4444ComponentType;\r\r\n break;\r\r\n }\r\r\n default:\r\r\n {\r\r\n dpx.image.image_element[i].descriptor=RGBComponentType;\r\r\n if (image->matte != MagickFalse)\r\r\n dpx.image.image_element[i].descriptor=RGBAComponentType;\r\r\n if ((image_info->type != TrueColorType) &&\r\r\n (image->matte == MagickFalse) &&\r\r\n (IsGrayImage(image,&image->exception) != MagickFalse))\r\r\n dpx.image.image_element[i].descriptor=LumaComponentType;\r\r\n break;\r\r\n }\r\r\n }\r\r\n offset+=WriteBlobByte(image,dpx.image.image_element[i].descriptor);\r\r\n dpx.image.image_element[i].transfer_characteristic=0;\r\r\n if (image->colorspace == LogColorspace)\r\r\n dpx.image.image_element[0].transfer_characteristic=\r\r\n PrintingDensityColorimetric;\r\r\n offset+=WriteBlobByte(image,\r\r\n dpx.image.image_element[i].transfer_characteristic);\r\r\n dpx.image.image_element[i].colorimetric=0;\r\r\n offset+=WriteBlobByte(image,dpx.image.image_element[i].colorimetric);\r\r\n dpx.image.image_element[i].bit_size=0;\r\r\n if (i == 0)\r\r\n dpx.image.image_element[i].bit_size=(unsigned char) image->depth;\r\r\n offset+=WriteBlobByte(image,dpx.image.image_element[i].bit_size);\r\r\n dpx.image.image_element[i].packing=0;\r\r\n if ((image->depth == 10) || (image->depth == 12))\r\r\n dpx.image.image_element[i].packing=1;\r\r\n offset+=WriteBlobShort(image,dpx.image.image_element[i].packing);\r\r\n dpx.image.image_element[i].encoding=0;\r\r\n offset+=WriteBlobShort(image,dpx.image.image_element[i].encoding);\r\r\n dpx.image.image_element[i].data_offset=0U;\r\r\n if (i == 0)\r\r\n dpx.image.image_element[i].data_offset=dpx.file.image_offset;\r\r\n offset+=WriteBlobLong(image,dpx.image.image_element[i].data_offset);\r\r\n dpx.image.image_element[i].end_of_line_padding=0U;\r\r\n offset+=WriteBlobLong(image,dpx.image.image_element[i].end_of_line_padding);\r\r\n offset+=WriteBlobLong(image,\r\r\n dpx.image.image_element[i].end_of_image_padding);\r\r\n offset+=WriteBlob(image,sizeof(dpx.image.image_element[i].description),\r\r\n (unsigned char *) dpx.image.image_element[i].description);\r\r\n }\r\r\n offset+=WriteBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\r\r\n dpx.image.reserve);\r\r\n /*\r\r\n Write orientation header.\r\r\n */\r\r\n if ((image->rows != image->magick_rows) ||\r\r\n (image->columns != image->magick_columns))\r\r\n {\r\r\n /*\r\r\n These properties are not valid if image size changed.\r\r\n */\r\r\n (void) DeleteImageProperty(image,\"dpx:orientation.x_offset\");\r\r\n (void) DeleteImageProperty(image,\"dpx:orientation.y_offset\");\r\r\n (void) DeleteImageProperty(image,\"dpx:orientation.x_center\");\r\r\n (void) DeleteImageProperty(image,\"dpx:orientation.y_center\");\r\r\n (void) DeleteImageProperty(image,\"dpx:orientation.x_size\");\r\r\n (void) DeleteImageProperty(image,\"dpx:orientation.y_size\");\r\r\n }\r\r\n dpx.orientation.x_offset=0U;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.x_offset\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.orientation.x_offset=(unsigned int) StringToUnsignedLong(value);\r\r\n offset+=WriteBlobLong(image,dpx.orientation.x_offset);\r\r\n dpx.orientation.y_offset=0U;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.y_offset\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.orientation.y_offset=(unsigned int) StringToUnsignedLong(value);\r\r\n offset+=WriteBlobLong(image,dpx.orientation.y_offset);\r\r\n dpx.orientation.x_center=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.x_center\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.orientation.x_center=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.orientation.x_center);\r\r\n dpx.orientation.y_center=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.y_center\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.orientation.y_center=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.orientation.y_center);\r\r\n dpx.orientation.x_size=0U;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.x_size\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.orientation.x_size=(unsigned int) StringToUnsignedLong(value);\r\r\n offset+=WriteBlobLong(image,dpx.orientation.x_size);\r\r\n dpx.orientation.y_size=0U;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.y_size\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.orientation.y_size=(unsigned int) StringToUnsignedLong(value);\r\r\n offset+=WriteBlobLong(image,dpx.orientation.y_size);\r\r\n value=GetImageArtifact(image,\"dpx:orientation.filename\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.orientation.filename,value,\r\r\n sizeof(dpx.orientation.filename)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\r\r\n dpx.orientation.filename);\r\r\n offset+=WriteBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\r\r\n dpx.orientation.timestamp);\r\r\n value=GetImageArtifact(image,\"dpx:orientation.device\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.orientation.device,value,\r\r\n sizeof(dpx.orientation.device)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\r\r\n dpx.orientation.device);\r\r\n value=GetImageArtifact(image,\"dpx:orientation.serial\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.orientation.serial,value,\r\r\n sizeof(dpx.orientation.serial)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\r\r\n dpx.orientation.serial);\r\r\n for (i=0; i < 4; i++)\r\r\n dpx.orientation.border[i]=0;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.border\");\r\r\n if (value != (const char *) NULL)\r\r\n {\r\r\n flags=ParseGeometry(value,&geometry_info);\r\r\n if ((flags & SigmaValue) == 0)\r\r\n geometry_info.sigma=geometry_info.rho;\r\r\n dpx.orientation.border[0]=(unsigned short) (geometry_info.rho+0.5);\r\r\n dpx.orientation.border[1]=(unsigned short) (geometry_info.sigma+0.5);\r\r\n dpx.orientation.border[2]=(unsigned short) (geometry_info.xi+0.5);\r\r\n dpx.orientation.border[3]=(unsigned short) (geometry_info.psi+0.5);\r\r\n }\r\r\n for (i=0; i < 4; i++)\r\r\n offset+=WriteBlobShort(image,dpx.orientation.border[i]);\r\r\n for (i=0; i < 2; i++)\r\r\n dpx.orientation.aspect_ratio[i]=0U;\r\r\n value=GetImageArtifact(image,\"dpx:orientation.aspect_ratio\");\r\r\n if (value != (const char *) NULL)\r\r\n {\r\r\n flags=ParseGeometry(value,&geometry_info);\r\r\n if ((flags & SigmaValue) == 0)\r\r\n geometry_info.sigma=geometry_info.rho;\r\r\n dpx.orientation.aspect_ratio[0]=(unsigned int) (geometry_info.rho+0.5);\r\r\n dpx.orientation.aspect_ratio[1]=(unsigned int) (geometry_info.sigma+0.5);\r\r\n }\r\r\n for (i=0; i < 2; i++)\r\r\n offset+=WriteBlobLong(image,dpx.orientation.aspect_ratio[i]);\r\r\n offset+=WriteBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\r\r\n dpx.orientation.reserve);\r\r\n /*\r\r\n Write film header.\r\r\n */\r\r\n (void) ResetMagickMemory(dpx.film.id,0,sizeof(dpx.film.id));\r\r\n value=GetImageArtifact(image,\"dpx:film.id\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.id,value,sizeof(dpx.film.id)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\r\r\n (void) ResetMagickMemory(dpx.film.type,0,sizeof(dpx.film.type));\r\r\n value=GetImageArtifact(image,\"dpx:film.type\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.type,value,sizeof(dpx.film.type)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.type),(unsigned char *)\r\r\n dpx.film.type);\r\r\n (void) ResetMagickMemory(dpx.film.offset,0,sizeof(dpx.film.offset));\r\r\n value=GetImageArtifact(image,\"dpx:film.offset\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.offset,value,sizeof(dpx.film.offset)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.offset),(unsigned char *)\r\r\n dpx.film.offset);\r\r\n (void) ResetMagickMemory(dpx.film.prefix,0,sizeof(dpx.film.prefix));\r\r\n value=GetImageArtifact(image,\"dpx:film.prefix\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.prefix,value,sizeof(dpx.film.prefix)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\r\r\n dpx.film.prefix);\r\r\n (void) ResetMagickMemory(dpx.film.count,0,sizeof(dpx.film.count));\r\r\n value=GetImageArtifact(image,\"dpx:film.count\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.count,value,sizeof(dpx.film.count)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.count),(unsigned char *)\r\r\n dpx.film.count);\r\r\n (void) ResetMagickMemory(dpx.film.format,0,sizeof(dpx.film.format));\r\r\n value=GetImageArtifact(image,\"dpx:film.format\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.format,value,sizeof(dpx.film.format)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.format),(unsigned char *)\r\r\n dpx.film.format);\r\r\n dpx.film.frame_position=0U;\r\r\n value=GetImageArtifact(image,\"dpx:film.frame_position\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.film.frame_position=(unsigned int) StringToUnsignedLong(value);\r\r\n offset+=WriteBlobLong(image,dpx.film.frame_position);\r\r\n dpx.film.sequence_extent=0U;\r\r\n value=GetImageArtifact(image,\"dpx:film.sequence_extent\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.film.sequence_extent=(unsigned int) StringToUnsignedLong(value);\r\r\n offset+=WriteBlobLong(image,dpx.film.sequence_extent);\r\r\n dpx.film.held_count=0U;\r\r\n value=GetImageArtifact(image,\"dpx:film.held_count\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.film.held_count=(unsigned int) StringToUnsignedLong(value);\r\r\n offset+=WriteBlobLong(image,dpx.film.held_count);\r\r\n dpx.film.frame_rate=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:film.frame_rate\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.film.frame_rate=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.film.frame_rate);\r\r\n dpx.film.shutter_angle=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:film.shutter_angle\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.film.shutter_angle=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.film.shutter_angle);\r\r\n (void) ResetMagickMemory(dpx.film.frame_id,0,sizeof(dpx.film.frame_id));\r\r\n value=GetImageArtifact(image,\"dpx:film.frame_id\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.frame_id,value,sizeof(dpx.film.frame_id)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\r\r\n dpx.film.frame_id);\r\r\n value=GetImageArtifact(image,\"dpx:film.slate\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.film.slate,value,sizeof(dpx.film.slate)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.slate),(unsigned char *)\r\r\n dpx.film.slate);\r\r\n offset+=WriteBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\r\r\n dpx.film.reserve);\r\r\n /*\r\r\n Write television header.\r\r\n */\r\r\n value=GetImageArtifact(image,\"dpx:television.time.code\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.time_code=StringToTimeCode(value);\r\r\n offset+=WriteBlobLong(image,dpx.television.time_code);\r\r\n value=GetImageArtifact(image,\"dpx:television.user.bits\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.user_bits=StringToTimeCode(value);\r\r\n offset+=WriteBlobLong(image,dpx.television.user_bits);\r\r\n value=GetImageArtifact(image,\"dpx:television.interlace\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.interlace=(unsigned char) StringToLong(value);\r\r\n offset+=WriteBlobByte(image,dpx.television.interlace);\r\r\n value=GetImageArtifact(image,\"dpx:television.field_number\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.field_number=(unsigned char) StringToLong(value);\r\r\n offset+=WriteBlobByte(image,dpx.television.field_number);\r\r\n dpx.television.video_signal=0;\r\r\n value=GetImageArtifact(image,\"dpx:television.video_signal\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.video_signal=(unsigned char) StringToLong(value);\r\r\n offset+=WriteBlobByte(image,dpx.television.video_signal);\r\r\n dpx.television.padding=0;\r\r\n value=GetImageArtifact(image,\"dpx:television.padding\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.padding=(unsigned char) StringToLong(value);\r\r\n offset+=WriteBlobByte(image,dpx.television.padding);\r\r\n dpx.television.horizontal_sample_rate=0.0f;\r\r\n value=GetImageArtifact(image,\r\r\n \"dpx:television.horizontal_sample_rate\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.horizontal_sample_rate=StringToDouble(value,\r\r\n (char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.horizontal_sample_rate);\r\r\n dpx.television.vertical_sample_rate=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.vertical_sample_rate\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.vertical_sample_rate=StringToDouble(value,\r\r\n (char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.vertical_sample_rate);\r\r\n dpx.television.frame_rate=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.frame_rate\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.frame_rate=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.frame_rate);\r\r\n dpx.television.time_offset=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.time_offset\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.time_offset=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.time_offset);\r\r\n dpx.television.gamma=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.gamma\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.gamma=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.gamma);\r\r\n dpx.television.black_level=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.black_level\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.black_level=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.black_level);\r\r\n dpx.television.black_gain=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.black_gain\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.black_gain=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.black_gain);\r\r\n dpx.television.break_point=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.break_point\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.break_point=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.break_point);\r\r\n dpx.television.white_level=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.white_level\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.white_level=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.white_level);\r\r\n dpx.television.integration_times=0.0f;\r\r\n value=GetImageArtifact(image,\"dpx:television.integration_times\");\r\r\n if (value != (const char *) NULL)\r\r\n dpx.television.integration_times=StringToDouble(value,(char **) NULL);\r\r\n offset+=WriteBlobFloat(image,dpx.television.integration_times);\r\r\n offset+=WriteBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\r\r\n dpx.television.reserve);\r\r\n /*\r\r\n Write user header.\r\r\n */\r\r\n value=GetImageArtifact(image,\"dpx:user.id\");\r\r\n if (value != (const char *) NULL)\r\r\n (void) strncpy(dpx.user.id,value,sizeof(dpx.user.id)-1);\r\r\n offset+=WriteBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\r\r\n if (profile != (StringInfo *) NULL)\r\r\n offset+=WriteBlob(image,GetStringInfoLength(profile),\r\r\n GetStringInfoDatum(profile));\r\r\n while (offset < (MagickOffsetType) dpx.image.image_element[0].data_offset)\r\r\n {\r\r\n count=WriteBlobByte(image,0x00);\r\r\n if (count != 1)\r\r\n {\r\r\n ThrowFileException(&image->exception,FileOpenError,\"UnableToWriteFile\",\r\r\n image->filename);\r\r\n break;\r\r\n }\r\r\n offset+=count;\r\r\n }\r\r\n /*\r\r\n Convert pixel packets to DPX raster image.\r\r\n */\r\r\n quantum_info=AcquireQuantumInfo(image_info,image);\r\r\n SetQuantumQuantum(quantum_info,32);\r\r\n SetQuantumPack(quantum_info,dpx.image.image_element[0].packing == 0 ?\r\r\n MagickTrue : MagickFalse);\r\r\n quantum_type=RGBQuantum;\r\r\n if (image->matte != MagickFalse)\r\r\n quantum_type=RGBAQuantum;\r\r\n if (image->colorspace == YCbCrColorspace)\r\r\n {\r\r\n quantum_type=CbYCrQuantum;\r\r\n if (image->matte != MagickFalse)\r\r\n quantum_type=CbYCrAQuantum;\r\r\n if ((horizontal_factor == 2) || (vertical_factor == 2))\r\r\n quantum_type=CbYCrYQuantum;\r\r\n }\r\r\n extent=GetBytesPerRow(image->columns,image->matte != MagickFalse ? 4UL : 3UL,\r\r\n image->depth,MagickTrue);\r\r\n if ((image_info->type != TrueColorType) && (image->matte == MagickFalse) &&\r\r\n (IsGrayImage(image,&image->exception) != MagickFalse))\r\r\n {\r\r\n quantum_type=GrayQuantum;\r\r\n extent=GetBytesPerRow(image->columns,1UL,image->depth,MagickTrue);\r\r\n }\r\r\n pixels=GetQuantumPixels(quantum_info);\r\r\n for (y=0; y < (ssize_t) image->rows; y++)\r\r\n {\r\r\n p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\r\r\n if (p == (const PixelPacket *) NULL)\r\r\n break;\r\r\n (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\r\r\n quantum_type,pixels,&image->exception);\r\r\n count=WriteBlob(image,extent,pixels);\r\r\n if (count != (ssize_t) extent)\r\r\n break;\r\r\n status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\r\r\n image->rows);\r\r\n if (status == MagickFalse)\r\r\n break;\r\r\n }\r\r\n quantum_info=DestroyQuantumInfo(quantum_info);\r\r\n (void) CloseBlob(image);\r\r\n return(status);\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <mongoose.h> \r\n#include <string.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\n#include <sys/stat.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint cortices_surnaming = 0;\r\nint global_variable;\r\nvoid handle_taint(char *puschkinia_terzet);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\npthread_t t0, t1, t2;\r\nsem_t sem;\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *arr;\r\n int i = 0;\r\n int i = 0;\r\n \r\n printf(\"Inside toCap\\n\");\r\n \r\n sem_wait(&sem); \r\n \r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n for(i = 0; i < strlen(Data->data); i++) {\r\n if (Data->data[i] >= 'a' && Data->data[i] <= 'z') { \r\n Data->data[i] -= 32; \r\n }\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\nint isalpha(char c) {\r\n return ((c >= 'A' && c <= 'Z') ||\r\n (c >= 'a' && c <= 'z'));\r\n}\r\nvoid *delNonAlpha (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n int j = 0;\r\n char *temp = NULL;\r\n \r\n printf(\"Inside delNonAlpha\\n\");\r\n \r\n sem_wait(&sem);\r\n temp = malloc(sizeof(char) * (strlen(Data->data) + 1));\r\n while(Data->data[i] != '\\0') {\r\n if (isalpha(Data->data[i])) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[++j] = '\\0';\r\n free(Data->data);\r\n Data->data = NULL; \r\n \r\n \r\n readFile(Data->file2);\r\n \r\n Data->data = temp;\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{;\r\n if (__sync_bool_compare_and_swap(&cortices_surnaming,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nvoid handle_taint(char *puschkinia_terzet)\r\n{\r\n pthread_t t0, t1;\r\n int hasNonAlpha = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *excitive_lietuva = 0;\r\n int ihs_printable;\r\n char **oikophobia_spreed = 0;\r\n char **quaintnesses_lambitive = 0;\r\n char *outdress_nolition[27] = {0};\r\n ++global_variable;;\r\n if (puschkinia_terzet != 0) {;\r\n outdress_nolition[23] = puschkinia_terzet;\r\n ihs_printable = 1;\r\n oikophobia_spreed = outdress_nolition;\r\n quaintnesses_lambitive = ((char **)(((unsigned long )oikophobia_spreed) * ihs_printable * ihs_printable)) + 5;\r\n excitive_lietuva = ((char *)(quaintnesses_lambitive - 5)[23]);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(excitive_lietuva) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(excitive_lietuva) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(excitive_lietuva) + 1));\r\n if (Data->data) {\r\n if ((sscanf(excitive_lietuva, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0)) {\r\n sem_init(&sem, 0, 1);\r\n while (Data->data[i] != '\\0') { \r\n if(isalpha(Data->data[i]) == 0) {\r\n hasNonAlpha = 1;\r\n }\r\n i++;\r\n }\r\n if (hasNonAlpha != 0) {\r\n \r\n \r\n sem_post(&sem);\r\n pthread_create(&t0, NULL, delNonAlpha, Data); \r\n \r\n } \r\n pthread_create(&t1, NULL, toCap, Data);\r\n if (hasNonAlpha != 0) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n } else {\r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ((quaintnesses_lambitive - 5)[23] != 0) \r\n free(((char *)(quaintnesses_lambitive - 5)[23]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n readFile(Data->file2);\n```", "cwe": "765"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "int http_wait_for_request(struct session *s, struct channel *req, int an_bit)\r\r\n{\r\r\n\t/*\r\r\n\t * We will parse the partial (or complete) lines.\r\r\n\t * We will check the request syntax, and also join multi-line\r\r\n\t * headers. An index of all the lines will be elaborated while\r\r\n\t * parsing.\r\r\n\t *\r\r\n\t * For the parsing, we use a 28 states FSM.\r\r\n\t *\r\r\n\t * Here is the information we currently have :\r\r\n\t * req->buf->p = beginning of request\r\r\n\t * req->buf->p + msg->eoh = end of processed headers / start of current one\r\r\n\t * req->buf->p + req->buf->i = end of input data\r\r\n\t * msg->eol = end of current header or line (LF or CRLF)\r\r\n\t * msg->next = first non-visited byte\r\r\n\t *\r\r\n\t * At end of parsing, we may perform a capture of the error (if any), and\r\r\n\t * we will set a few fields (txn->meth, sn->flags/SN_REDIRECTABLE).\r\r\n\t * We also check for monitor-uri, logging, HTTP/0.9 to 1.0 conversion, and\r\r\n\t * finally headers capture.\r\r\n\t */\r\r\n\r\r\n\tint cur_idx;\r\r\n\tint use_close_only;\r\r\n\tstruct http_txn *txn = &s->txn;\r\r\n\tstruct http_msg *msg = &txn->req;\r\r\n\tstruct hdr_ctx ctx;\r\r\n\r\r\n\tDPRINTF(stderr,\"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bh=%d analysers=%02x\\n\",\r\r\n\t\tnow_ms, __FUNCTION__,\r\r\n\t\ts,\r\r\n\t\treq,\r\r\n\t\treq->rex, req->wex,\r\r\n\t\treq->flags,\r\r\n\t\treq->buf->i,\r\r\n\t\treq->analysers);\r\r\n\r\r\n\t/* we're speaking HTTP here, so let's speak HTTP to the client */\r\r\n\ts->srv_error = http_return_srv_error;\r\r\n\r\r\n\t/* There's a protected area at the end of the buffer for rewriting\r\r\n\t * purposes. We don't want to start to parse the request if the\r\r\n\t * protected area is affected, because we may have to move processed\r\r\n\t * data later, which is much more complicated.\r\r\n\t */\r\r\n\tif (buffer_not_empty(req->buf) && msg->msg_state < HTTP_MSG_ERROR) {\r\r\n\t\tif (txn->flags & TX_NOT_FIRST) {\r\r\n\t\t\tif (unlikely(!channel_reserved(req))) {\r\r\n\t\t\t\tif (req->flags & (CF_SHUTW|CF_SHUTW_NOW|CF_WRITE_ERROR|CF_WRITE_TIMEOUT))\r\r\n\t\t\t\t\tgoto failed_keep_alive;\r\r\n\t\t\t\t/* some data has still not left the buffer, wake us once that's done */\r\r\n\t\t\t\tchannel_dont_connect(req);\r\r\n\t\t\t\treq->flags |= CF_READ_DONTWAIT; /* try to get back here ASAP */\r\r\n\t\t\t\treq->flags |= CF_WAKE_WRITE;\r\r\n\t\t\t\treturn 0;\r\r\n\t\t\t}\r\r\n\t\t\tif (unlikely(bi_end(req->buf) < b_ptr(req->buf, msg->next) ||\r\r\n\t\t\t bi_end(req->buf) > req->buf->data + req->buf->size - global.tune.maxrewrite))\r\r\n\t\t\t\tbuffer_slow_realign(req->buf);\r\r\n\t\t}\r\r\n\r\r\n\t\t/* Note that we have the same problem with the response ; we\r\r\n\t\t * may want to send a redirect, error or anything which requires\r\r\n\t\t * some spare space. So we'll ensure that we have at least\r\r\n\t\t * maxrewrite bytes available in the response buffer before\r\r\n\t\t * processing that one. This will only affect pipelined\r\r\n\t\t * keep-alive requests.\r\r\n\t\t */\r\r\n\t\tif ((txn->flags & TX_NOT_FIRST) &&\r\r\n\t\t unlikely(!channel_reserved(s->rep) ||\r\r\n\t\t\t bi_end(s->rep->buf) < b_ptr(s->rep->buf, txn->rsp.next) ||\r\r\n\t\t\t bi_end(s->rep->buf) > s->rep->buf->data + s->rep->buf->size - global.tune.maxrewrite)) {\r\r\n\t\t\tif (s->rep->buf->o) {\r\r\n\t\t\t\tif (s->rep->flags & (CF_SHUTW|CF_SHUTW_NOW|CF_WRITE_ERROR|CF_WRITE_TIMEOUT))\r\r\n\t\t\t\t\tgoto failed_keep_alive;\r\r\n\t\t\t\t/* don't let a connection request be initiated */\r\r\n\t\t\t\tchannel_dont_connect(req);\r\r\n\t\t\t\ts->rep->flags &= ~CF_EXPECT_MORE; /* speed up sending a previous response */\r\r\n\t\t\t\ts->rep->flags |= CF_WAKE_WRITE;\r\r\n\t\t\t\ts->rep->analysers |= an_bit; /* wake us up once it changes */\r\r\n\t\t\t\treturn 0;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\r\r\n\t\tif (likely(msg->next < req->buf->i)) /* some unparsed data are available */\r\r\n\t\t\thttp_msg_analyzer(msg, &txn->hdr_idx);\r\r\n\t}\r\r\n\r\r\n\t/* 1: we might have to print this header in debug mode */\r\r\n\tif (unlikely((global.mode & MODE_DEBUG) &&\r\r\n\t\t (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)) &&\r\r\n\t\t (msg->msg_state >= HTTP_MSG_BODY || msg->msg_state == HTTP_MSG_ERROR))) {\r\r\n\t\tchar *eol, *sol;\r\r\n\r\r\n\t\tsol = req->buf->p;\r\r\n\t\t/* this is a bit complex : in case of error on the request line,\r\r\n\t\t * we know that rq.l is still zero, so we display only the part\r\r\n\t\t * up to the end of the line (truncated by debug_hdr).\r\r\n\t\t */\r\r\n\t\teol = sol + (msg->sl.rq.l ? msg->sl.rq.l : req->buf->i);\r\r\n\t\tdebug_hdr(\"clireq\", s, sol, eol);\r\r\n\r\r\n\t\tsol += hdr_idx_first_pos(&txn->hdr_idx);\r\r\n\t\tcur_idx = hdr_idx_first_idx(&txn->hdr_idx);\r\r\n\r\r\n\t\twhile (cur_idx) {\r\r\n\t\t\teol = sol + txn->hdr_idx.v[cur_idx].len;\r\r\n\t\t\tdebug_hdr(\"clihdr\", s, sol, eol);\r\r\n\t\t\tsol = eol + txn->hdr_idx.v[cur_idx].cr + 1;\r\r\n\t\t\tcur_idx = txn->hdr_idx.v[cur_idx].next;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\r\r\n\t/*\r\r\n\t * Now we quickly check if we have found a full valid request.\r\r\n\t * If not so, we check the FD and buffer states before leaving.\r\r\n\t * A full request is indicated by the fact that we have seen\r\r\n\t * the double LF/CRLF, so the state is >= HTTP_MSG_BODY. Invalid\r\r\n\t * requests are checked first. When waiting for a second request\r\r\n\t * on a keep-alive session, if we encounter and error, close, t/o,\r\r\n\t * we note the error in the session flags but don't set any state.\r\r\n\t * Since the error will be noted there, it will not be counted by\r\r\n\t * process_session() as a frontend error.\r\r\n\t * Last, we may increase some tracked counters' http request errors on\r\r\n\t * the cases that are deliberately the client's fault. For instance,\r\r\n\t * a timeout or connection reset is not counted as an error. However\r\r\n\t * a bad request is.\r\r\n\t */\r\r\n\r\r\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY)) {\r\r\n\t\t/*\r\r\n\t\t * First, let's catch bad requests.\r\r\n\t\t */\r\r\n\t\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {\r\r\n\t\t\tsession_inc_http_req_ctr(s);\r\r\n\t\t\tsession_inc_http_err_ctr(s);\r\r\n\t\t\tproxy_inc_fe_req_ctr(s->fe);\r\r\n\t\t\tgoto return_bad_req;\r\r\n\t\t}\r\r\n\r\r\n\t\t/* 1: Since we are in header mode, if there's no space\r\r\n\t\t * left for headers, we won't be able to free more\r\r\n\t\t * later, so the session will never terminate. We\r\r\n\t\t * must terminate it now.\r\r\n\t\t */\r\r\n\t\tif (unlikely(buffer_full(req->buf, global.tune.maxrewrite))) {\r\r\n\t\t\t/* FIXME: check if URI is set and return Status\r\r\n\t\t\t * 414 Request URI too long instead.\r\r\n\t\t\t */\r\r\n\t\t\tsession_inc_http_req_ctr(s);\r\r\n\t\t\tsession_inc_http_err_ctr(s);\r\r\n\t\t\tproxy_inc_fe_req_ctr(s->fe);\r\r\n\t\t\tif (msg->err_pos < 0)\r\r\n\t\t\t\tmsg->err_pos = req->buf->i;\r\r\n\t\t\tgoto return_bad_req;\r\r\n\t\t}\r\r\n\r\r\n\t\t/* 2: have we encountered a read error ? */\r\r\n\t\telse if (req->flags & CF_READ_ERROR) {\r\r\n\t\t\tif (!(s->flags & SN_ERR_MASK))\r\r\n\t\t\t\ts->flags |= SN_ERR_CLICL;\r\r\n\r\r\n\t\t\tif (txn->flags & TX_WAIT_NEXT_RQ)\r\r\n\t\t\t\tgoto failed_keep_alive;\r\r\n\r\r\n\t\t\t/* we cannot return any message on error */\r\r\n\t\t\tif (msg->err_pos >= 0) {\r\r\n\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, msg->msg_state, s->fe);\r\r\n\t\t\t\tsession_inc_http_err_ctr(s);\r\r\n\t\t\t}\r\r\n\r\r\n\t\t\ttxn->status = 400;\r\r\n\t\t\tstream_int_retnclose(req->prod, NULL);\r\r\n\t\t\tmsg->msg_state = HTTP_MSG_ERROR;\r\r\n\t\t\treq->analysers = 0;\r\r\n\r\r\n\t\t\tsession_inc_http_req_ctr(s);\r\r\n\t\t\tproxy_inc_fe_req_ctr(s->fe);\r\r\n\t\t\ts->fe->fe_counters.failed_req++;\r\r\n\t\t\tif (s->listener->counters)\r\r\n\t\t\t\ts->listener->counters->failed_req++;\r\r\n\r\r\n\t\t\tif (!(s->flags & SN_FINST_MASK))\r\r\n\t\t\t\ts->flags |= SN_FINST_R;\r\r\n\t\t\treturn 0;\r\r\n\t\t}\r\r\n\r\r\n\t\t/* 3: has the read timeout expired ? */\r\r\n\t\telse if (req->flags & CF_READ_TIMEOUT || tick_is_expired(req->analyse_exp, now_ms)) {\r\r\n\t\t\tif (!(s->flags & SN_ERR_MASK))\r\r\n\t\t\t\ts->flags |= SN_ERR_CLITO;\r\r\n\r\r\n\t\t\tif (txn->flags & TX_WAIT_NEXT_RQ)\r\r\n\t\t\t\tgoto failed_keep_alive;\r\r\n\r\r\n\t\t\t/* read timeout : give up with an error message. */\r\r\n\t\t\tif (msg->err_pos >= 0) {\r\r\n\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, msg->msg_state, s->fe);\r\r\n\t\t\t\tsession_inc_http_err_ctr(s);\r\r\n\t\t\t}\r\r\n\t\t\ttxn->status = 408;\r\r\n\t\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_408));\r\r\n\t\t\tmsg->msg_state = HTTP_MSG_ERROR;\r\r\n\t\t\treq->analysers = 0;\r\r\n\r\r\n\t\t\tsession_inc_http_req_ctr(s);\r\r\n\t\t\tproxy_inc_fe_req_ctr(s->fe);\r\r\n\t\t\ts->fe->fe_counters.failed_req++;\r\r\n\t\t\tif (s->listener->counters)\r\r\n\t\t\t\ts->listener->counters->failed_req++;\r\r\n\r\r\n\t\t\tif (!(s->flags & SN_FINST_MASK))\r\r\n\t\t\t\ts->flags |= SN_FINST_R;\r\r\n\t\t\treturn 0;\r\r\n\t\t}\r\r\n\r\r\n\t\t/* 4: have we encountered a close ? */\r\r\n\t\telse if (req->flags & CF_SHUTR) {\r\r\n\t\t\tif (!(s->flags & SN_ERR_MASK))\r\r\n\t\t\t\ts->flags |= SN_ERR_CLICL;\r\r\n\r\r\n\t\t\tif (txn->flags & TX_WAIT_NEXT_RQ)\r\r\n\t\t\t\tgoto failed_keep_alive;\r\r\n\r\r\n\t\t\tif (msg->err_pos >= 0)\r\r\n\t\t\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, msg->msg_state, s->fe);\r\r\n\t\t\ttxn->status = 400;\r\r\n\t\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_400));\r\r\n\t\t\tmsg->msg_state = HTTP_MSG_ERROR;\r\r\n\t\t\treq->analysers = 0;\r\r\n\r\r\n\t\t\tsession_inc_http_err_ctr(s);\r\r\n\t\t\tsession_inc_http_req_ctr(s);\r\r\n\t\t\tproxy_inc_fe_req_ctr(s->fe);\r\r\n\t\t\ts->fe->fe_counters.failed_req++;\r\r\n\t\t\tif (s->listener->counters)\r\r\n\t\t\t\ts->listener->counters->failed_req++;\r\r\n\r\r\n\t\t\tif (!(s->flags & SN_FINST_MASK))\r\r\n\t\t\t\ts->flags |= SN_FINST_R;\r\r\n\t\t\treturn 0;\r\r\n\t\t}\r\r\n\r\r\n\t\tchannel_dont_connect(req);\r\r\n\t\treq->flags |= CF_READ_DONTWAIT; /* try to get back here ASAP */\r\r\n\t\ts->rep->flags &= ~CF_EXPECT_MORE; /* speed up sending a previous response */\r\r\n#ifdef TCP_QUICKACK\r\r\n\t\tif (s->listener->options & LI_O_NOQUICKACK && req->buf->i && objt_conn(s->req->prod->end) && conn_ctrl_ready(__objt_conn(s->req->prod->end))) {\r\r\n\t\t\t/* We need more data, we have to re-enable quick-ack in case we\r\r\n\t\t\t * previously disabled it, otherwise we might cause the client\r\r\n\t\t\t * to delay next data.\r\r\n\t\t\t */\r\r\n\t\t\tsetsockopt(__objt_conn(s->req->prod->end)->t.sock.fd, IPPROTO_TCP, TCP_QUICKACK, &one, sizeof(one));\r\r\n\t\t}\r\r\n#endif\r\r\n\r\r\n\t\tif ((msg->msg_state != HTTP_MSG_RQBEFORE) && (txn->flags & TX_WAIT_NEXT_RQ)) {\r\r\n\t\t\t/* If the client starts to talk, let's fall back to\r\r\n\t\t\t * request timeout processing.\r\r\n\t\t\t */\r\r\n\t\t\ttxn->flags &= ~TX_WAIT_NEXT_RQ;\r\r\n\t\t\treq->analyse_exp = TICK_ETERNITY;\r\r\n\t\t}\r\r\n\r\r\n\t\t/* just set the request timeout once at the beginning of the request */\r\r\n\t\tif (!tick_isset(req->analyse_exp)) {\r\r\n\t\t\tif ((msg->msg_state == HTTP_MSG_RQBEFORE) &&\r\r\n\t\t\t (txn->flags & TX_WAIT_NEXT_RQ) &&\r\r\n\t\t\t tick_isset(s->be->timeout.httpka))\r\r\n\t\t\t\treq->analyse_exp = tick_add(now_ms, s->be->timeout.httpka);\r\r\n\t\t\telse\r\r\n\t\t\t\treq->analyse_exp = tick_add_ifset(now_ms, s->be->timeout.httpreq);\r\r\n\t\t}\r\r\n\r\r\n\t\t/* we're not ready yet */\r\r\n\t\treturn 0;\r\r\n\r\r\n\tfailed_keep_alive:\r\r\n\t\t/* Here we process low-level errors for keep-alive requests. In\r\r\n\t\t * short, if the request is not the first one and it experiences\r\r\n\t\t * a timeout, read error or shutdown, we just silently close so\r\r\n\t\t * that the client can try again.\r\r\n\t\t */\r\r\n\t\ttxn->status = 0;\r\r\n\t\tmsg->msg_state = HTTP_MSG_RQBEFORE;\r\r\n\t\treq->analysers = 0;\r\r\n\t\ts->logs.logwait = 0;\r\r\n\t\ts->logs.level = 0;\r\r\n\t\ts->rep->flags &= ~CF_EXPECT_MORE; /* speed up sending a previous response */\r\r\n\t\tstream_int_retnclose(req->prod, NULL);\r\r\n\t\treturn 0;\r\r\n\t}\r\r\n\r\r\n\t/* OK now we have a complete HTTP request with indexed headers. Let's\r\r\n\t * complete the request parsing by setting a few fields we will need\r\r\n\t * later. At this point, we have the last CRLF at req->buf->data + msg->eoh.\r\r\n\t * If the request is in HTTP/0.9 form, the rule is still true, and eoh\r\r\n\t * points to the CRLF of the request line. msg->next points to the first\r\r\n\t * byte after the last LF. msg->sov points to the first byte of data.\r\r\n\t * msg->eol cannot be trusted because it may have been left uninitialized\r\r\n\t * (for instance in the absence of headers).\r\r\n\t */\r\r\n\r\r\n\tsession_inc_http_req_ctr(s);\r\r\n\tproxy_inc_fe_req_ctr(s->fe); /* one more valid request for this FE */\r\r\n\r\r\n\tif (txn->flags & TX_WAIT_NEXT_RQ) {\r\r\n\t\t/* kill the pending keep-alive timeout */\r\r\n\t\ttxn->flags &= ~TX_WAIT_NEXT_RQ;\r\r\n\t\treq->analyse_exp = TICK_ETERNITY;\r\r\n\t}\r\r\n\r\r\n\r\r\n\t/* Maybe we found in invalid header name while we were configured not\r\r\n\t * to block on that, so we have to capture it now.\r\r\n\t */\r\r\n\tif (unlikely(msg->err_pos >= 0))\r\r\n\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, msg->msg_state, s->fe);\r\r\n\r\r\n\t/*\r\r\n\t * 1: identify the method\r\r\n\t */\r\r\n\ttxn->meth = find_http_meth(req->buf->p, msg->sl.rq.m_l);\r\r\n\r\r\n\t/* we can make use of server redirect on GET and HEAD */\r\r\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\r\r\n\t\ts->flags |= SN_REDIRECTABLE;\r\r\n\r\r\n\t/*\r\r\n\t * 2: check if the URI matches the monitor_uri.\r\r\n\t * We have to do this for every request which gets in, because\r\r\n\t * the monitor-uri is defined by the frontend.\r\r\n\t */\r\r\n\tif (unlikely((s->fe->monitor_uri_len != 0) &&\r\r\n\t\t (s->fe->monitor_uri_len == msg->sl.rq.u_l) &&\r\r\n\t\t !memcmp(req->buf->p + msg->sl.rq.u,\r\r\n\t\t\t s->fe->monitor_uri,\r\r\n\t\t\t s->fe->monitor_uri_len))) {\r\r\n\t\t/*\r\r\n\t\t * We have found the monitor URI\r\r\n\t\t */\r\r\n\t\tstruct acl_cond *cond;\r\r\n\r\r\n\t\ts->flags |= SN_MONITOR;\r\r\n\t\ts->fe->fe_counters.intercepted_req++;\r\r\n\r\r\n\t\t/* Check if we want to fail this monitor request or not */\r\r\n\t\tlist_for_each_entry(cond, &s->fe->mon_fail_cond, list) {\r\r\n\t\t\tint ret = acl_exec_cond(cond, s->fe, s, txn, SMP_OPT_DIR_REQ|SMP_OPT_FINAL);\r\r\n\r\r\n\t\t\tret = acl_pass(ret);\r\r\n\t\t\tif (cond->pol == ACL_COND_UNLESS)\r\r\n\t\t\t\tret = !ret;\r\r\n\r\r\n\t\t\tif (ret) {\r\r\n\t\t\t\t/* we fail this request, let's return 503 service unavail */\r\r\n\t\t\t\ttxn->status = 503;\r\r\n\t\t\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_503));\r\r\n\t\t\t\tif (!(s->flags & SN_ERR_MASK))\r\r\n\t\t\t\t\ts->flags |= SN_ERR_LOCAL; /* we don't want a real error here */\r\r\n\t\t\t\tgoto return_prx_cond;\r\r\n\t\t\t}\r\r\n\t\t}\r\r\n\r\r\n\t\t/* nothing to fail, let's reply normaly */\r\r\n\t\ttxn->status = 200;\r\r\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_200));\r\r\n\t\tif (!(s->flags & SN_ERR_MASK))\r\r\n\t\t\ts->flags |= SN_ERR_LOCAL; /* we don't want a real error here */\r\r\n\t\tgoto return_prx_cond;\r\r\n\t}\r\r\n\r\r\n\t/*\r\r\n\t * 3: Maybe we have to copy the original REQURI for the logs ?\r\r\n\t * Note: we cannot log anymore if the request has been\r\r\n\t * classified as invalid.\r\r\n\t */\r\r\n\tif (unlikely(s->logs.logwait & LW_REQ)) {\r\r\n\t\t/* we have a complete HTTP request that we must log */\r\r\n\t\tif ((txn->uri = pool_alloc2(pool2_requri)) != NULL) {\r\r\n\t\t\tint urilen = msg->sl.rq.l;\r\r\n\r\r\n\t\t\tif (urilen >= REQURI_LEN)\r\r\n\t\t\t\turilen = REQURI_LEN - 1;\r\r\n\t\t\tmemcpy(txn->uri, req->buf->p, urilen);\r\r\n\t\t\ttxn->uri[urilen] = 0;\r\r\n\r\r\n\t\t\tif (!(s->logs.logwait &= ~(LW_REQ|LW_INIT)))\r\r\n\t\t\t\ts->do_log(s);\r\r\n\t\t} else {\r\r\n\t\t\tAlert(\"HTTP logging : out of memory.\\n\");\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\t/* 4. We may have to convert HTTP/0.9 requests to HTTP/1.0 */\r\r\n\tif (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(txn))\r\r\n\t\tgoto return_bad_req;\r\r\n\r\r\n\t/* ... and check if the request is HTTP/1.1 or above */\r\r\n\tif ((msg->sl.rq.v_l == 8) &&\r\r\n\t ((req->buf->p[msg->sl.rq.v + 5] > '1') ||\r\r\n\t ((req->buf->p[msg->sl.rq.v + 5] == '1') &&\r\r\n\t (req->buf->p[msg->sl.rq.v + 7] >= '1'))))\r\r\n\t\tmsg->flags |= HTTP_MSGF_VER_11;\r\r\n\r\r\n\t/* \"connection\" has not been parsed yet */\r\r\n\ttxn->flags &= ~(TX_HDR_CONN_PRS | TX_HDR_CONN_CLO | TX_HDR_CONN_KAL | TX_HDR_CONN_UPG);\r\r\n\r\r\n\t/* if the frontend has \"option http-use-proxy-header\", we'll check if\r\r\n\t * we have what looks like a proxied connection instead of a connection,\r\r\n\t * and in this case set the TX_USE_PX_CONN flag to use Proxy-connection.\r\r\n\t * Note that this is *not* RFC-compliant, however browsers and proxies\r\r\n\t * happen to do that despite being non-standard :-(\r\r\n\t * We consider that a request not beginning with either '/' or '*' is\r\r\n\t * a proxied connection, which covers both \"scheme://location\" and\r\r\n\t * CONNECT ip:port.\r\r\n\t */\r\r\n\tif ((s->fe->options2 & PR_O2_USE_PXHDR) &&\r\r\n\t req->buf->p[msg->sl.rq.u] != '/' && req->buf->p[msg->sl.rq.u] != '*')\r\r\n\t\ttxn->flags |= TX_USE_PX_CONN;\r\r\n\r\r\n\t/* transfer length unknown*/\r\r\n\tmsg->flags &= ~HTTP_MSGF_XFER_LEN;\r\r\n\r\r\n\t/* 5: we may need to capture headers */\r\r\n\tif (unlikely((s->logs.logwait & LW_REQHDR) && txn->req.cap))\r\r\n\t\tcapture_headers(req->buf->p, &txn->hdr_idx,\r\r\n\t\t\t\ttxn->req.cap, s->fe->req_cap);\r\r\n\r\r\n\t/* 6: determine the transfer-length.\r\r\n\t * According to RFC2616 #4.4, amended by the HTTPbis working group,\r\r\n\t * the presence of a message-body in a REQUEST and its transfer length\r\r\n\t * must be determined that way (in order of precedence) :\r\r\n\t * 1. The presence of a message-body in a request is signaled by the\r\r\n\t * inclusion of a Content-Length or Transfer-Encoding header field\r\r\n\t * in the request's header fields. When a request message contains\r\r\n\t * both a message-body of non-zero length and a method that does\r\r\n\t * not define any semantics for that request message-body, then an\r\r\n\t * origin server SHOULD either ignore the message-body or respond\r\r\n\t * with an appropriate error message (e.g., 413). A proxy or\r\r\n\t * gateway, when presented the same request, SHOULD either forward\r\r\n\t * the request inbound with the message- body or ignore the\r\r\n\t * message-body when determining a response.\r\r\n\t *\r\r\n\t * 2. If a Transfer-Encoding header field (Section 9.7) is present\r\r\n\t * and the \"chunked\" transfer-coding (Section 6.2) is used, the\r\r\n\t * transfer-length is defined by the use of this transfer-coding.\r\r\n\t * If a Transfer-Encoding header field is present and the \"chunked\"\r\r\n\t * transfer-coding is not present, the transfer-length is defined\r\r\n\t * by the sender closing the connection.\r\r\n\t *\r\r\n\t * 3. If a Content-Length header field is present, its decimal value in\r\r\n\t * OCTETs represents both the entity-length and the transfer-length.\r\r\n\t * If a message is received with both a Transfer-Encoding header\r\r\n\t * field and a Content-Length header field, the latter MUST be ignored.\r\r\n\t *\r\r\n\t * 4. By the server closing the connection. (Closing the connection\r\r\n\t * cannot be used to indicate the end of a request body, since that\r\r\n\t * would leave no possibility for the server to send back a response.)\r\r\n\t *\r\r\n\t * Whenever a transfer-coding is applied to a message-body, the set of\r\r\n\t * transfer-codings MUST include \"chunked\", unless the message indicates\r\r\n\t * it is terminated by closing the connection. When the \"chunked\"\r\r\n\t * transfer-coding is used, it MUST be the last transfer-coding applied\r\r\n\t * to the message-body.\r\r\n\t */\r\r\n\r\r\n\tuse_close_only = 0;\r\r\n\tctx.idx = 0;\r\r\n\t/* set TE_CHNK and XFER_LEN only if \"chunked\" is seen last */\r\r\n\twhile ((msg->flags & HTTP_MSGF_VER_11) &&\r\r\n\t http_find_header2(\"Transfer-Encoding\", 17, req->buf->p, &txn->hdr_idx, &ctx)) {\r\r\n\t\tif (ctx.vlen == 7 && strncasecmp(ctx.line + ctx.val, \"chunked\", 7) == 0)\r\r\n\t\t\tmsg->flags |= (HTTP_MSGF_TE_CHNK | HTTP_MSGF_XFER_LEN);\r\r\n\t\telse if (msg->flags & HTTP_MSGF_TE_CHNK) {\r\r\n\t\t\t/* bad transfer-encoding (chunked followed by something else) */\r\r\n\t\t\tuse_close_only = 1;\r\r\n\t\t\tmsg->flags &= ~(HTTP_MSGF_TE_CHNK | HTTP_MSGF_XFER_LEN);\r\r\n\t\t\tbreak;\r\r\n\t\t}\r\r\n\t}\r\r\n\r\r\n\tctx.idx = 0;\r\r\n\twhile (!(msg->flags & HTTP_MSGF_TE_CHNK) && !use_close_only &&\r\r\n\t http_find_header2(\"Content-Length\", 14, req->buf->p, &txn->hdr_idx, &ctx)) {\r\r\n\t\tsigned long long cl;\r\r\n\r\r\n\t\tif (!ctx.vlen) {\r\r\n\t\t\tmsg->err_pos = ctx.line + ctx.val - req->buf->p;\r\r\n\t\t\tgoto return_bad_req;\r\r\n\t\t}\r\r\n\r\r\n\t\tif (strl2llrc(ctx.line + ctx.val, ctx.vlen, &cl)) {\r\r\n\t\t\tmsg->err_pos = ctx.line + ctx.val - req->buf->p;\r\r\n\t\t\tgoto return_bad_req; /* parse failure */\r\r\n\t\t}\r\r\n\r\r\n\t\tif (cl < 0) {\r\r\n\t\t\tmsg->err_pos = ctx.line + ctx.val - req->buf->p;\r\r\n\t\t\tgoto return_bad_req;\r\r\n\t\t}\r\r\n\r\r\n\t\tif ((msg->flags & HTTP_MSGF_CNT_LEN) && (msg->chunk_len != cl)) {\r\r\n\t\t\tmsg->err_pos = ctx.line + ctx.val - req->buf->p;\r\r\n\t\t\tgoto return_bad_req; /* already specified, was different */\r\r\n\t\t}\r\r\n\r\r\n\t\tmsg->flags |= HTTP_MSGF_CNT_LEN | HTTP_MSGF_XFER_LEN;\r\r\n\t\tmsg->body_len = msg->chunk_len = cl;\r\r\n\t}\r\r\n\r\r\n\t/* bodyless requests have a known length */\r\r\n\tif (!use_close_only)\r\r\n\t\tmsg->flags |= HTTP_MSGF_XFER_LEN;\r\r\n\r\r\n\t/* Until set to anything else, the connection mode is set as Keep-Alive. It will\r\r\n\t * only change if both the request and the config reference something else.\r\r\n\t * Option httpclose by itself sets tunnel mode where headers are mangled.\r\r\n\t * However, if another mode is set, it will affect it (eg: server-close/\r\r\n\t * keep-alive + httpclose = close). Note that we avoid to redo the same work\r\r\n\t * if FE and BE have the same settings (common). The method consists in\r\r\n\t * checking if options changed between the two calls (implying that either\r\r\n\t * one is non-null, or one of them is non-null and we are there for the first\r\r\n\t * time.\r\r\n\t */\r\r\n\tif (!(txn->flags & TX_HDR_CONN_PRS) ||\r\r\n\t ((s->fe->options & PR_O_HTTP_MODE) != (s->be->options & PR_O_HTTP_MODE))) {\r\r\n\t\tint tmp = TX_CON_WANT_KAL;\r\r\n\r\r\n\t\tif (!((s->fe->options2|s->be->options2) & PR_O2_FAKE_KA)) {\r\r\n\t\t\tif ((s->fe->options & PR_O_HTTP_MODE) == PR_O_HTTP_TUN ||\r\r\n\t\t\t (s->be->options & PR_O_HTTP_MODE) == PR_O_HTTP_TUN)\r\r\n\t\t\t\ttmp = TX_CON_WANT_TUN;\r\r\n\r\r\n\t\t\tif ((s->fe->options & PR_O_HTTP_MODE) == PR_O_HTTP_PCL ||\r\r\n\t\t\t (s->be->options & PR_O_HTTP_MODE) == PR_O_HTTP_PCL)\r\r\n\t\t\t\ttmp = TX_CON_WANT_TUN;\r\r\n\t\t}\r\r\n\r\r\n\t\tif ((s->fe->options & PR_O_HTTP_MODE) == PR_O_HTTP_SCL ||\r\r\n\t\t (s->be->options & PR_O_HTTP_MODE) == PR_O_HTTP_SCL) {\r\r\n\t\t\t/* option httpclose + server_close => forceclose */\r\r\n\t\t\tif ((s->fe->options & PR_O_HTTP_MODE) == PR_O_HTTP_PCL ||\r\r\n\t\t\t (s->be->options & PR_O_HTTP_MODE) == PR_O_HTTP_PCL)\r\r\n\t\t\t\ttmp = TX_CON_WANT_CLO;\r\r\n\t\t\telse\r\r\n\t\t\t\ttmp = TX_CON_WANT_SCL;\r\r\n\t\t}\r\r\n\r\r\n\t\tif ((s->fe->options & PR_O_HTTP_MODE) == PR_O_HTTP_FCL ||\r\r\n\t\t (s->be->options & PR_O_HTTP_MODE) == PR_O_HTTP_FCL)\r\r\n\t\t\ttmp = TX_CON_WANT_CLO;\r\r\n\r\r\n\t\tif ((txn->flags & TX_CON_WANT_MSK) < tmp)\r\r\n\t\t\ttxn->flags = (txn->flags & ~TX_CON_WANT_MSK) | tmp;\r\r\n\r\r\n\t\tif (!(txn->flags & TX_HDR_CONN_PRS) &&\r\r\n\t\t (txn->flags & TX_CON_WANT_MSK) != TX_CON_WANT_TUN) {\r\r\n\t\t\t/* parse the Connection header and possibly clean it */\r\r\n\t\t\tint to_del = 0;\r\r\n\t\t\tif ((msg->flags & HTTP_MSGF_VER_11) ||\r\r\n\t\t\t ((txn->flags & TX_CON_WANT_MSK) >= TX_CON_WANT_SCL &&\r\r\n\t\t\t !((s->fe->options2|s->be->options2) & PR_O2_FAKE_KA)))\r\r\n\t\t\t\tto_del |= 2; /* remove \"keep-alive\" */\r\r\n\t\t\tif (!(msg->flags & HTTP_MSGF_VER_11))\r\r\n\t\t\t\tto_del |= 1; /* remove \"close\" */\r\r\n\t\t\thttp_parse_connection_header(txn, msg, to_del);\r\r\n\t\t}\r\r\n\r\r\n\t\t/* check if client or config asks for explicit close in KAL/SCL */\r\r\n\t\tif (((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL ||\r\r\n\t\t (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL) &&\r\r\n\t\t ((txn->flags & TX_HDR_CONN_CLO) || /* \"connection: close\" */\r\r\n\t\t (!(msg->flags & HTTP_MSGF_VER_11) && !(txn->flags & TX_HDR_CONN_KAL)) || /* no \"connection: k-a\" in 1.0 */\r\r\n\t\t !(msg->flags & HTTP_MSGF_XFER_LEN) || /* no length known => close */\r\r\n\t\t s->fe->state == PR_STSTOPPED)) /* frontend is stopping */\r\r\n\t\t txn->flags = (txn->flags & ~TX_CON_WANT_MSK) | TX_CON_WANT_CLO;\r\r\n\t}\r\r\n\r\r\n\t/* end of job, return OK */\r\r\n\treq->analysers &= ~an_bit;\r\r\n\treq->analyse_exp = TICK_ETERNITY;\r\r\n\treturn 1;\r\r\n\r\r\n return_bad_req:\r\r\n\t/* We centralize bad requests processing here */\r\r\n\tif (unlikely(msg->msg_state == HTTP_MSG_ERROR) || msg->err_pos >= 0) {\r\r\n\t\t/* we detected a parsing error. We want to archive this request\r\r\n\t\t * in the dedicated proxy area for later troubleshooting.\r\r\n\t\t */\r\r\n\t\thttp_capture_bad_message(&s->fe->invalid_req, s, msg, msg->msg_state, s->fe);\r\r\n\t}\r\r\n\r\r\n\ttxn->req.msg_state = HTTP_MSG_ERROR;\r\r\n\ttxn->status = 400;\r\r\n\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_400));\r\r\n\r\r\n\ts->fe->fe_counters.failed_req++;\r\r\n\tif (s->listener->counters)\r\r\n\t\ts->listener->counters->failed_req++;\r\r\n\r\r\n return_prx_cond:\r\r\n\tif (!(s->flags & SN_ERR_MASK))\r\r\n\t\ts->flags |= SN_ERR_PRXCOND;\r\r\n\tif (!(s->flags & SN_FINST_MASK))\r\r\n\t\ts->flags |= SN_FINST_R;\r\r\n\r\r\n\treq->analysers = 0;\r\r\n\treq->analyse_exp = TICK_ETERNITY;\r\r\n\treturn 0;\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint dui_ganglial = 0;\r\ntypedef char *unresidual_outburst;\r\nint global_variable;\r\nvoid dekaliters_anthropophagy(unresidual_outburst *jagras_boroglycerine);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid racketier_rubbernecking(void (*versation_anticoagulator)(unresidual_outburst *));\r\nunresidual_outburst maurita_copromoted(unresidual_outburst quires_representee);\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&dui_ganglial,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n racketier_rubbernecking(dekaliters_anthropophagy);\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid dekaliters_anthropophagy(unresidual_outburst *jagras_boroglycerine)\r\n{\r\n unresidual_outburst incarcerate_overswarm = 0;\r\n int macrochiran_unkeeled = 28;\r\n char *storying_cesure;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&storying_cesure,\"7752\",macrochiran_unkeeled);\r\n if (storying_cesure != 0) {;\r\n incarcerate_overswarm = storying_cesure;\r\n *jagras_boroglycerine = incarcerate_overswarm;\r\n }\r\n}\r\n\r\nvoid racketier_rubbernecking(void (*versation_anticoagulator)(unresidual_outburst *))\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *retinerved_nations = 0;\r\n unresidual_outburst preoccupies_kinds = 0;\r\n ++global_variable;\r\n unresidual_outburst difforme_seance = 0;\r\n versation_anticoagulator(&difforme_seance);\r\n if (difforme_seance != 0) {;\r\n preoccupies_kinds = maurita_copromoted(difforme_seance);\r\n retinerved_nations = ((char *)preoccupies_kinds);\r\n \r\n if (strlen(retinerved_nations) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,retinerved_nations);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (preoccupies_kinds != 0) \r\n free(((char *)preoccupies_kinds));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nunresidual_outburst maurita_copromoted(unresidual_outburst quires_representee)\r\n{\r\n ++global_variable;\r\n return quires_representee;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n fpipe = popen(command_buffer,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "78"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint offshoots_sternforemost = 0;\r\nint global_variable;\r\nvoid handle_taint(char *malmock_albuminize);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct struct_data {\r\n char *buffer_member;\r\n unsigned short size_member;\r\n};\r\nstruct struct_data *init_data(long number_param)\r\n{\r\n \r\n struct struct_data *init_data_ptr = 0;\r\n init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\r\n if (init_data_ptr == 0)\r\n return 0;\r\n init_data_ptr -> size_member = 0;\r\n \r\n\r\n init_data_ptr -> size_member = number_param;\r\n init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\r\n \r\n \r\n \r\n if (init_data_ptr -> buffer_member == 0) {\r\n free(init_data_ptr);\r\n return 0;\r\n }\r\n memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\r\n init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\r\n return init_data_ptr;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&offshoots_sternforemost,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *malmock_albuminize)\r\n{\r\n long number;\r\n struct struct_data *data = 0;\r\n char *frouzy_feetage = 0;\r\n int fadlike_amnestying;\r\n int decanol_foursquarely;\r\n void *stinson_gilbertson = 0;\r\n int *stymphalian_presecular = 0;\r\n int iodometric_longjaw;\r\n void *cathartically_annihilable[10] = {0};\r\n void *pseudonavicula_blowhard = 0;\r\n ++global_variable;;\r\n if (malmock_albuminize != 0) {;\r\n pseudonavicula_blowhard = ((void *)malmock_albuminize);\r\n cathartically_annihilable[5] = pseudonavicula_blowhard;\r\n iodometric_longjaw = 5;\r\n stymphalian_presecular = &iodometric_longjaw;\r\n stinson_gilbertson = *(cathartically_annihilable + *stymphalian_presecular);\r\n decanol_foursquarely = 5;\r\n while(1 == 1){\r\n decanol_foursquarely = decanol_foursquarely * 2;\r\n decanol_foursquarely = decanol_foursquarely + 2;\r\n if (decanol_foursquarely > 1000) {\r\n break; \r\n }\r\n }\r\n fadlike_amnestying = decanol_foursquarely;\r\n frouzy_feetage = ((char *)((char *)stinson_gilbertson));\r\n \r\n number = strtol(frouzy_feetage,0U,10);\r\n if (number > 0) {\r\n data = init_data(number);\r\n if (data != 0) {\r\n \r\n\r\n memset(data -> buffer_member, 98, number);\r\n \r\n data -> buffer_member[number - 1] = 0;\r\n printf(\"%s\\n\", data -> buffer_member);\r\n if (data -> buffer_member != 0U)\r\n free(data -> buffer_member);\r\n if (data != 0U)\r\n free(data);\r\n }\r\n } else {\r\n printf(\"Input is less than or equal to 0\\n\");\r\n }\r\n \r\n;\r\n if (((char *)stinson_gilbertson) != 0) \r\n free(((char *)((char *)stinson_gilbertson)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n memset(data -> buffer_member, 98, number);\n```", "cwe": "197"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint hierogamy_wondercraft = 0;\r\ntypedef char *durmast_badly;\r\nint global_variable;\r\nvoid handle_taint(char *sherardizer_avilla);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid aghastness_tritiated(int thromboangiitis_syllabified,durmast_badly *gnni_outplods);\r\nvoid lizzy_overtinseling(int dst_senath,durmast_badly *tex_insectiferous);\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&hierogamy_wondercraft,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid handle_taint(char *sherardizer_avilla)\r\n{\r\n int cystathionine_lincolndale = 7;\r\n durmast_badly *pourpoint_raft = 0;\r\n durmast_badly *gauricus_etruscan = 0;\r\n durmast_badly tizes_pelecypodous = 0;\r\n ++global_variable;;\r\n if (sherardizer_avilla != 0) {;\r\n tizes_pelecypodous = sherardizer_avilla;\r\n pourpoint_raft = &tizes_pelecypodous;\r\n gauricus_etruscan = pourpoint_raft + 5;\r\n aghastness_tritiated(cystathionine_lincolndale,gauricus_etruscan);\r\n }\r\n}\r\n\r\nvoid aghastness_tritiated(int thromboangiitis_syllabified,durmast_badly *gnni_outplods)\r\n{\r\n int stack_size = 0;\r\n char *overmatureness_resilement = 0;\r\n ++global_variable;\r\n thromboangiitis_syllabified--;\r\n if (thromboangiitis_syllabified > 0) {\r\n lizzy_overtinseling(thromboangiitis_syllabified,gnni_outplods);\r\n return ;\r\n }\r\n overmatureness_resilement = ((char *)( *(gnni_outplods - 5)));\r\n \r\n \r\n \r\n if (strlen(overmatureness_resilement) > 1 &&\r\n overmatureness_resilement[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n stack_size = strtoul(overmatureness_resilement,0,0);\r\n printf(\"Allocating stack array\\n\");\r\n \r\n \r\n \r\n char stack_string[stack_size];\r\n memset(stack_string,'x',stack_size - 1);\r\n \r\n }\r\n \r\n \r\n;\r\n if ( *(gnni_outplods - 5) != 0) \r\n free(((char *)( *(gnni_outplods - 5))));\r\nclose_printf_context();\r\n}\r\n\r\nvoid lizzy_overtinseling(int dst_senath,durmast_badly *tex_insectiferous)\r\n{\r\n ++global_variable;\r\n aghastness_tritiated(dst_senath,tex_insectiferous);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n char stack_string[stack_size];\n memset(stack_string,'x',stack_size - 1);\n```", "cwe": "789"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/common.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/rational.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"audio.h\"\r\n#include \"avfilter.h\"\r\n#include \"formats.h\"\r\n#include \"internal.h\"\r\n#include \"audio.h\"\r\n#include <sys/stat.h> \r\n#include <openssl/evp.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <sys/types.h> \r\n#include <sys/wait.h> \r\n#include <unistd.h> \r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame);\r\nint valew_retiring = 0;\r\nint global_variable;\r\n\r\nstruct bankruptcies_arrester \r\n{\r\n char *nonprossing_predescend;\r\n double hydrocoralline_grosmark;\r\n char *exareolate_staggerwort;\r\n char leos_pseudoembryo;\r\n int jerry_linemen;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid unbereaven_cheapener(int nonremovable_irrationally,struct bankruptcies_arrester effluent_massiveness);\r\nvoid saprophytic_trainer(int ordinariness_brininess,struct bankruptcies_arrester protevangelion_subaggregative);\r\nvoid evp_hash(const char *algorithm_name,char *filename) {\r\n int ii = 0;\r\n FILE *file_stream = 0;\r\n char hash_print_val[129] = {0};\r\n unsigned char file_contents[1024];\r\n size_t file_contents_size = 1024;\r\n size_t file_contents_size_read = 0;\r\n const EVP_MD *md_engine = 0;\r\n unsigned char md_value[64];\r\n unsigned int md_value_len = 0;\r\n EVP_MD_CTX *md_context = 0;\r\n int hash_update_result = 0;\r\n \r\n memset(md_value,0,64);\r\n file_stream = fopen(filename,\"rb\");\r\n if (file_stream != 0) {\r\n md_engine = EVP_get_digestbyname(algorithm_name);\r\n if (md_engine != 0) {\r\n md_context = EVP_MD_CTX_create();\r\n if (md_context != 0) {\r\n if (EVP_DigestInit_ex(md_context,md_engine,0)) {\r\n \r\n while(!feof(file_stream)) {\r\n \r\n memset(file_contents,0,file_contents_size);\r\n file_contents_size_read = fread(file_contents,\r\n sizeof(unsigned char ),file_contents_size,file_stream);\r\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\r\n if (1 != hash_update_result) {\r\n break;\r\n }\r\n }\r\n \r\n if (1 == hash_update_result) {\r\n if (EVP_DigestFinal_ex(md_context,md_value,&md_value_len)) {\r\n for (ii = 0; ii < md_value_len; ++ii) {\r\n sprintf(&hash_print_val[ii * 2],\"%02x\",md_value[ii]);\r\n }\r\n printf(\"%s %s\\n\",hash_print_val,filename);\r\n } else {\r\n printf(\"Failure finalizing hash for file '%s' with algorithm '%s'.\\n\",\r\n filename,algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failure hashing file '%s' with algorithm '%s'.\\n\",filename,algorithm_name);\r\n }\r\n }\r\n EVP_MD_CTX_destroy(md_context);\r\n } else {\r\n printf(\"Could not create a context for hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Could not load hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failed to open file: '%s'\\n\",filename);\r\n }\r\n if (file_stream != 0) {\r\n fclose(file_stream);\r\n file_stream = 0;\r\n }\r\n}\r\nstruct pid_fd {\r\n pid_t pid;\r\n int fd_array[2];\r\n};\r\n\r\nchar *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms)\r\n{\r\n snprintf(buf,buf_size,\"%s%s%s%s%s%s\",(perms & 0x1?\"r\" : \"\"),(perms & 0x02?\"w\" : \"\"),(perms & 0x04?\"p\" : \"\"),(perms & 0x08?\"u\" : \"\"),(perms & 0x10?\"U\" : \"\"),(perms & 0x20?\"n\" : \"\"));\r\n return buf;\r\n}\r\n\r\nvoid ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end)\r\n{\r\n char buf[16] __attribute__((unused)) ;\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld\",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);\r\n }\r\n }while (0);\r\n if (ref -> video) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" a:%d/%d s:%dx%d i:%c iskey:%d type:%c\",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?80 : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));\r\n }\r\n }while (0);\r\n\r\n\r\n }\r\n if (ref -> audio) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\" cl:%ldd n:%d r:%d\",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);\r\n }\r\n }while (0);\r\n }\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"]%s\",(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n}\r\n\r\nunsigned int avfilter_version()\r\n{\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avfilter.c\",80);\r\n abort();\r\n }\r\n }while (0);\r\n return (3 << 16 | 42 << 8 | 103);\r\n}\r\n\r\nconst char *avfilter_configuration()\r\n{\r\n int homo_rifton = 7;\r\n struct bankruptcies_arrester heptastrophic_moralize = {0};\r\n int *warrigals_allumine = 0;\r\n int cludder_petiolus;\r\n struct bankruptcies_arrester wildling_coquettishness[10] = {0};\r\n struct bankruptcies_arrester mokamoka_forras;\r\n char *cephalanthus_microthyriaceae;;\r\n if (__sync_bool_compare_and_swap(&valew_retiring,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cephalanthus_microthyriaceae = getenv(\"HOPE_SUPERMEDICINE\");\r\n if (cephalanthus_microthyriaceae != 0) {;\r\n mokamoka_forras . nonprossing_predescend = ((char *)cephalanthus_microthyriaceae);\r\n wildling_coquettishness[5] = mokamoka_forras;\r\n cludder_petiolus = 5;\r\n warrigals_allumine = &cludder_petiolus;\r\n heptastrophic_moralize = *(wildling_coquettishness + *warrigals_allumine);\r\n unbereaven_cheapener(homo_rifton,heptastrophic_moralize);\r\n }\r\n }\r\n }\r\n ;\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lcrypto -ldl'\";\r\n}\r\n\r\nconst char *avfilter_license()\r\n{\r\n#define LICENSE_PREFIX \"libavfilter license: \"\r\n return (\"libavfilter license: LGPL version 2.1 or later\" + sizeof(\"libavfilter license: \") - 1);\r\n}\r\n\r\nvoid ff_command_queue_pop(AVFilterContext *filter)\r\n{\r\n AVFilterCommand *c = filter -> command_queue;\r\n av_freep((&c -> arg));\r\n av_freep((&c -> command));\r\n filter -> command_queue = c -> next;\r\n av_free(c);\r\n}\r\n\r\nvoid ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad)\r\n{\r\n unsigned int i;\r\n idx = (idx > *count? *count : idx);\r\n *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));\r\n *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));\r\n memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));\r\n memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));\r\n memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));\r\n ( *links)[idx] = ((void *)0);\r\n ( *count)++;\r\n for (i = idx + 1; i < *count; i++) \r\n if ( *links[i]) {\r\n ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;\r\n }\r\n}\r\n\r\nint avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)\r\n{\r\n AVFilterLink *link;\r\n if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {\r\n return - 1;\r\n }\r\n if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {\r\n av_log(src,16,\"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\\n\",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),\"?\"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),\"?\"))));\r\n return - 22;\r\n }\r\n src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));\r\n link -> src = src;\r\n link -> dst = dst;\r\n link -> srcpad = &src -> output_pads[srcpad];\r\n link -> dstpad = &dst -> input_pads[dstpad];\r\n link -> type = src -> output_pads[srcpad] . type;\r\n do {\r\n if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1\",\"avfilter.c\",150);\r\n abort();\r\n }\r\n }while (0);\r\n link -> format = - 1;\r\n return 0;\r\n}\r\n\r\nvoid avfilter_link_free(AVFilterLink **link)\r\n{\r\n if (!( *link)) {\r\n return ;\r\n }\r\n if (( *link) -> pool) {\r\n ff_free_pool(( *link) -> pool);\r\n }\r\n avfilter_unref_bufferp(&( *link) -> partial_buf);\r\n av_freep(link);\r\n}\r\n\r\nint avfilter_link_get_channels(AVFilterLink *link)\r\n{\r\n return link -> channels;\r\n}\r\n\r\nvoid avfilter_link_set_closed(AVFilterLink *link,int closed)\r\n{\r\n link -> closed = closed;\r\n}\r\n\r\nint avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)\r\n{\r\n int ret;\r\n unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);\r\n av_log((link -> dst),40,\"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\\n\",filt -> name,link -> src -> name,link -> dst -> name);\r\n link -> dst -> inputs[dstpad_idx] = ((void *)0);\r\n if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {\r\n\r\n link -> dst -> inputs[dstpad_idx] = link;\r\n return ret;\r\n }\r\n\r\n link -> dst = filt;\r\n link -> dstpad = &filt -> input_pads[filt_srcpad_idx];\r\n filt -> inputs[filt_srcpad_idx] = link;\r\n\r\n if (link -> out_formats) {\r\n ff_formats_changeref(&link -> out_formats,&filt -> outputs[filt_dstpad_idx] -> out_formats);\r\n }\r\n if (link -> out_samplerates) {\r\n ff_formats_changeref(&link -> out_samplerates,&filt -> outputs[filt_dstpad_idx] -> out_samplerates);\r\n }\r\n if (link -> out_channel_layouts) {\r\n ff_channel_layouts_changeref(&link -> out_channel_layouts,&filt -> outputs[filt_dstpad_idx] -> out_channel_layouts);\r\n }\r\n return 0;\r\n}\r\n\r\nint avfilter_config_links(AVFilterContext *filter)\r\n{\r\n int (*config_link)(AVFilterLink *);\r\n unsigned int i;\r\n int ret;\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n AVFilterLink *link = filter -> inputs[i];\r\n AVFilterLink *inlink;\r\n if (!link) {\r\n continue; \r\n }\r\n inlink = (link -> src -> nb_inputs?link -> src -> inputs[0] : ((void *)0));\r\n link -> current_pts = ((int64_t )0x8000000000000000UL);\r\n switch(link -> init_state){\r\n case AVLINK_INIT:\r\n continue; \r\n case AVLINK_STARTINIT:\r\n{\r\n av_log(filter,32,\"circular filter chain detected\\n\");\r\n return 0;\r\n }\r\n case AVLINK_UNINIT:\r\n{\r\n link -> init_state = AVLINK_STARTINIT;\r\n if ((ret = avfilter_config_links(link -> src)) < 0) {\r\n return ret;\r\n }\r\n if (!(config_link = link -> srcpad -> config_props)) {\r\n if (link -> src -> nb_inputs != 1) {\r\n av_log((link -> src),16,\"Source filters and filters with more than one input must set config_props() callbacks on all outputs\\n\");\r\n return - 22;\r\n }\r\n }\r\n else {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure output pad on %s\\n\",link -> src -> name);\r\n return ret;\r\n }\r\n }\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = (inlink?inlink -> time_base : ((AVRational ){(1), (1000000)}));\r\n }\r\n if (!link -> sample_aspect_ratio . num && !link -> sample_aspect_ratio . den) {\r\n link -> sample_aspect_ratio = (inlink?inlink -> sample_aspect_ratio : ((AVRational ){(1), (1)}));\r\n }\r\n if (inlink && !link -> frame_rate . num && !link -> frame_rate . den) {\r\n link -> frame_rate = inlink -> frame_rate;\r\n }\r\n if (inlink) {\r\n if (!link -> w) {\r\n link -> w = inlink -> w;\r\n }\r\n if (!link -> h) {\r\n link -> h = inlink -> h;\r\n }\r\n }\r\n else {\r\n if (!link -> w || !link -> h) {\r\n av_log((link -> src),16,\"Video source filters must set their output link's width and height\\n\");\r\n return - 22;\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (inlink) {\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = inlink -> time_base;\r\n }\r\n }\r\n if (!link -> time_base . num && !link -> time_base . den) {\r\n link -> time_base = ((AVRational ){(1), link -> sample_rate});\r\n }\r\n }\r\n }\r\n if (config_link = link -> dstpad -> config_props) {\r\n if ((ret = config_link(link)) < 0) {\r\n av_log((link -> src),16,\"Failed to configure input pad on %s\\n\",link -> dst -> name);\r\n return ret;\r\n }\r\n }\r\n link -> init_state = AVLINK_INIT;\r\n }\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nvoid ff_tlog_link(void *ctx,AVFilterLink *link,int end)\r\n{\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p s:%dx%d fmt:%s %s->%s]%s\",link,link -> w,link -> h,av_get_pix_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n else {\r\n char buf[128];\r\n av_get_channel_layout_string(buf,(sizeof(buf)),- 1,link -> channel_layout);\r\n do {\r\n if (0) {\r\n av_log(ctx,48,\"link[%p r:%d cl:%s fmt:%s %s->%s]%s\",link,((int )(link -> sample_rate)),buf,av_get_sample_fmt_name((link -> format)),(link -> src?link -> src -> filter -> name : \"\"),(link -> dst?link -> dst -> filter -> name : \"\"),(end?\"\\n\" : \"\"));\r\n }\r\n }while (0);\r\n }\r\n}\r\n\r\nint ff_request_frame(AVFilterLink *link)\r\n{\r\n int ret = - 1;\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"request_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n if (link -> closed) {\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (link -> srcpad -> request_frame) {\r\n ret = ((link -> srcpad -> request_frame)(link));\r\n }\r\n else {\r\n if (link -> src -> inputs[0]) {\r\n ret = ff_request_frame(link -> src -> inputs[0]);\r\n }\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) && link -> partial_buf) {\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n link -> partial_buf = ((void *)0);\r\n ff_filter_frame_framed(link,pbuf);\r\n return 0;\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n link -> closed = 1;\r\n }\r\n return ret;\r\n}\r\n\r\nint ff_poll_frame(AVFilterLink *link)\r\n{\r\n int i;\r\n int min = 2147483647;\r\n if (link -> srcpad -> poll_frame) {\r\n return (link -> srcpad -> poll_frame)(link);\r\n }\r\n for (i = 0; i < link -> src -> nb_inputs; i++) {\r\n int val;\r\n if (!link -> src -> inputs[i]) {\r\n return - 1;\r\n }\r\n val = ff_poll_frame(link -> src -> inputs[i]);\r\n min = (min > val?val : min);\r\n }\r\n return min;\r\n}\r\n\r\nvoid ff_update_link_current_pts(AVFilterLink *link,int64_t pts)\r\n{\r\n if (pts == ((int64_t )0x8000000000000000UL)) {\r\n return ;\r\n }\r\n link -> current_pts = av_rescale_q(pts,link -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n if (link -> graph && link -> age_index >= 0) {\r\n ff_avfilter_graph_update_heap(link -> graph,link);\r\n }\r\n}\r\n\r\nint avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)\r\n{\r\n if (!strcmp(cmd,\"ping\")) {\r\n av_strlcatf(res,res_len,\"pong from:%s %s\\n\",filter -> filter -> name,filter -> name);\r\n return 0;\r\n }\r\n else {\r\n if (filter -> filter -> process_command) {\r\n return (filter -> filter -> process_command)(filter,cmd,arg,res,res_len,flags);\r\n }\r\n }\r\n return - 38;\r\n}\r\n#define MAX_REGISTERED_AVFILTERS_NB 256\r\nstatic AVFilter *registered_avfilters[256 + 1];\r\nstatic int next_registered_avfilter_idx = 0;\r\n\r\nAVFilter *avfilter_get_by_name(const char *name)\r\n{\r\n int i;\r\n for (i = 0; registered_avfilters[i]; i++) \r\n if (!strcmp(registered_avfilters[i] -> name,name)) {\r\n return registered_avfilters[i];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nint avfilter_register(AVFilter *filter)\r\n{\r\n int i;\r\n if (next_registered_avfilter_idx == 256) {\r\n av_log(((void *)0),16,\"Maximum number of registered filters %d reached, impossible to register filter with name '%s'\\n\",256,filter -> name);\r\n return - '\\f';\r\n }\r\n for (i = 0; filter -> inputs && filter -> inputs[i] . name; i++) {\r\n const AVFilterPad *input = &filter -> inputs[i];\r\n do {\r\n if (!(!input -> filter_frame || !input -> start_frame && !input -> end_frame)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"!input->filter_frame || (!input->start_frame && !input->end_frame)\",\"avfilter.c\",426);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n registered_avfilters[next_registered_avfilter_idx++] = filter;\r\n return 0;\r\n}\r\n\r\nAVFilter **av_filter_next(AVFilter **filter)\r\n{\r\n return filter?++filter : &registered_avfilters[0];\r\n}\r\n\r\nvoid avfilter_uninit()\r\n{\r\n memset(registered_avfilters,0,sizeof(registered_avfilters));\r\n next_registered_avfilter_idx = 0;\r\n}\r\n\r\nstatic int pad_count(const AVFilterPad *pads)\r\n{\r\n int count;\r\n if (!pads) {\r\n return 0;\r\n }\r\n for (count = 0; pads -> name; count++) \r\n pads++;\r\n return count;\r\n}\r\n\r\nstatic const char *default_filter_name(void *filter_ctx)\r\n{\r\n AVFilterContext *ctx = filter_ctx;\r\n return ctx -> name?(ctx -> name) : ctx -> filter -> name;\r\n}\r\n\r\nstatic void *filter_child_next(void *obj,void *prev)\r\n{\r\n AVFilterContext *ctx = obj;\r\n if (!prev && ctx -> filter && ctx -> filter -> priv_class) {\r\n return ctx -> priv;\r\n }\r\n return (void *)0;\r\n}\r\n\r\nstatic const AVClass *filter_child_class_next(const AVClass *prev)\r\n{\r\n AVFilter **filter_ptr = ((void *)0);\r\n\r\n while(prev && *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class == prev) {\r\n break; \r\n }\r\n\r\n if (prev && !( *filter_ptr)) {\r\n return ((void *)0);\r\n }\r\n\r\n while( *(filter_ptr = av_filter_next(filter_ptr)))\r\n if (( *filter_ptr) -> priv_class) {\r\n return ( *filter_ptr) -> priv_class;\r\n }\r\n return ((void *)0);\r\n}\r\nstatic const AVClass avfilter_class = {.class_name = \"AVFilter\", .item_name = default_filter_name, .version = 52 << 16 | 18 << 8 | 100, .category = AV_CLASS_CATEGORY_FILTER, .child_next = filter_child_next, .child_class_next = filter_child_class_next};\r\n\r\nconst AVClass *avfilter_get_class()\r\n{\r\n return &avfilter_class;\r\n}\r\n\r\nint avfilter_open(AVFilterContext **filter_ctx,AVFilter *filter,const char *inst_name)\r\n{\r\n AVFilterContext *ret;\r\n *filter_ctx = ((void *)0);\r\n if (!filter) {\r\n return - 22;\r\n }\r\n ret = (av_mallocz(sizeof(AVFilterContext )));\r\n if (!ret) {\r\n return - '\\f';\r\n }\r\n ret -> av_class = &avfilter_class;\r\n ret -> filter = filter;\r\n ret -> name = (inst_name?av_strdup(inst_name) : ((void *)0));\r\n if (filter -> priv_size) {\r\n ret -> priv = av_mallocz((filter -> priv_size));\r\n if (!ret -> priv) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_inputs = (pad_count(filter -> inputs));\r\n if (ret -> nb_inputs) {\r\n ret -> input_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_inputs)));\r\n if (!ret -> input_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> input_pads),(filter -> inputs),sizeof(AVFilterPad ) * (ret -> nb_inputs));\r\n ret -> inputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_inputs)));\r\n if (!ret -> inputs) {\r\n goto err;\r\n }\r\n }\r\n ret -> nb_outputs = (pad_count(filter -> outputs));\r\n if (ret -> nb_outputs) {\r\n ret -> output_pads = (av_malloc(sizeof(AVFilterPad ) * (ret -> nb_outputs)));\r\n if (!ret -> output_pads) {\r\n goto err;\r\n }\r\n memcpy((ret -> output_pads),(filter -> outputs),sizeof(AVFilterPad ) * (ret -> nb_outputs));\r\n ret -> outputs = (av_mallocz(sizeof(AVFilterLink *) * (ret -> nb_outputs)));\r\n if (!ret -> outputs) {\r\n goto err;\r\n }\r\n }\r\n#if FF_API_FOO_COUNT\r\n ret -> output_count = ret -> nb_outputs;\r\n ret -> input_count = ret -> nb_inputs;\r\n#endif\r\n *filter_ctx = ret;\r\n return 0;\r\n err:\r\n av_freep((&ret -> inputs));\r\n av_freep((&ret -> input_pads));\r\n ret -> nb_inputs = 0;\r\n av_freep((&ret -> outputs));\r\n av_freep((&ret -> output_pads));\r\n ret -> nb_outputs = 0;\r\n av_freep((&ret -> priv));\r\n av_free(ret);\r\n return - '\\f';\r\n}\r\n\r\nvoid avfilter_free(AVFilterContext *filter)\r\n{\r\n int i;\r\n AVFilterLink *link;\r\n if (!filter) {\r\n return ;\r\n }\r\n if (filter -> filter -> uninit) {\r\n (filter -> filter -> uninit)(filter);\r\n }\r\n for (i = 0; i < filter -> nb_inputs; i++) {\r\n if (link = filter -> inputs[i]) {\r\n if (link -> src) {\r\n link -> src -> outputs[link -> srcpad - link -> src -> output_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n for (i = 0; i < filter -> nb_outputs; i++) {\r\n if (link = filter -> outputs[i]) {\r\n if (link -> dst) {\r\n link -> dst -> inputs[link -> dstpad - link -> dst -> input_pads] = ((void *)0);\r\n }\r\n ff_formats_unref(&link -> in_formats);\r\n ff_formats_unref(&link -> out_formats);\r\n ff_formats_unref(&link -> in_samplerates);\r\n ff_formats_unref(&link -> out_samplerates);\r\n ff_channel_layouts_unref(&link -> in_channel_layouts);\r\n ff_channel_layouts_unref(&link -> out_channel_layouts);\r\n }\r\n avfilter_link_free(&link);\r\n }\r\n av_freep((&filter -> name));\r\n av_freep((&filter -> input_pads));\r\n av_freep((&filter -> output_pads));\r\n av_freep((&filter -> inputs));\r\n av_freep((&filter -> outputs));\r\n av_freep((&filter -> priv));\r\n while(filter -> command_queue){\r\n ff_command_queue_pop(filter);\r\n }\r\n av_free(filter);\r\n}\r\n\r\nint avfilter_init_filter(AVFilterContext *filter,const char *args,void *opaque)\r\n{\r\n int ret = 0;\r\n if (filter -> filter -> init_opaque) {\r\n ret = ((filter -> filter -> init_opaque)(filter,args,opaque));\r\n }\r\n else {\r\n if (filter -> filter -> init) {\r\n ret = ((filter -> filter -> init)(filter,args));\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nconst char *avfilter_pad_get_name(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . name;\r\n}\r\n\r\nenum AVMediaType avfilter_pad_get_type(AVFilterPad *pads,int pad_idx)\r\n{\r\n return pads[pad_idx] . type;\r\n}\r\n\r\nstatic int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n return ff_filter_frame(link -> dst -> outputs[0],frame);\r\n}\r\n\r\nstatic int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);\r\n AVFilterPad *src = link -> srcpad;\r\n AVFilterPad *dst = link -> dstpad;\r\n AVFilterBufferRef *out;\r\n int perms;\r\n int ret;\r\n AVFilterCommand *cmd = link -> dst -> command_queue;\r\n int64_t pts;\r\n if (link -> closed) {\r\n avfilter_unref_buffer(frame);\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (!(filter_frame = dst -> filter_frame)) {\r\n filter_frame = default_filter_frame;\r\n }\r\n (void )0;\r\n frame -> perms &= ~src -> rej_perms;\r\n perms = frame -> perms;\r\n if (frame -> linesize[0] < 0) {\r\n perms |= 0x20;\r\n }\r\n\r\n if ((dst -> min_perms & perms) != dst -> min_perms || dst -> rej_perms & perms) {\r\n av_log((link -> dst),48,\"Copying data in avfilter (have perms %x, need %x, reject %x)\\n\",perms,link -> dstpad -> min_perms,link -> dstpad -> rej_perms);\r\n\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n out = ff_get_video_buffer(link,dst -> min_perms,link -> w,link -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n out = ff_get_audio_buffer(link,dst -> min_perms,frame -> audio -> nb_samples);\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n if (!out) {\r\n avfilter_unref_buffer(frame);\r\n return - '\\f';\r\n }\r\n avfilter_copy_buffer_ref_props(out,frame);\r\n switch(link -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n av_image_copy(out -> data,out -> linesize,((const uint8_t **)(frame -> data)),(frame -> linesize),(frame -> format),frame -> video -> w,frame -> video -> h);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n av_samples_copy(out -> extended_data,(frame -> extended_data),0,0,frame -> audio -> nb_samples,av_get_channel_layout_nb_channels(frame -> audio -> channel_layout),(frame -> format));\r\n break; \r\n }\r\n default:\r\n return - 22;\r\n }\r\n avfilter_unref_buffer(frame);\r\n }\r\n else {\r\n out = frame;\r\n }\r\n while(cmd && cmd -> time <= (out -> pts) * av_q2d(link -> time_base)){\r\n av_log((link -> dst),48,\"Processing command time:%f command:%s arg:%s\\n\",cmd -> time,cmd -> command,cmd -> arg);\r\n avfilter_process_command(link -> dst,(cmd -> command),(cmd -> arg),0,0,cmd -> flags);\r\n ff_command_queue_pop(link -> dst);\r\n cmd = link -> dst -> command_queue;\r\n }\r\n pts = out -> pts;\r\n ret = filter_frame(link,out);\r\n ff_update_link_current_pts(link,pts);\r\n return ret;\r\n}\r\n\r\nstatic int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n int insamples = frame -> audio -> nb_samples;\r\n int inpos = 0;\r\n int nb_samples;\r\n AVFilterBufferRef *pbuf = link -> partial_buf;\r\n int nb_channels = frame -> audio -> channels;\r\n int ret = 0;\r\n\r\n while(insamples){\r\n if (!pbuf) {\r\n AVRational samples_tb = {(1), link -> sample_rate};\r\n int perms = link -> dstpad -> min_perms | 0x02;\r\n pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);\r\n if (!pbuf) {\r\n av_log((link -> dst),24,\"Samples dropped due to memory allocation failure.\\n\");\r\n return 0;\r\n }\r\n avfilter_copy_buffer_ref_props(pbuf,frame);\r\n pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);\r\n pbuf -> audio -> nb_samples = 0;\r\n }\r\n nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);\r\n av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));\r\n inpos += nb_samples;\r\n insamples -= nb_samples;\r\n pbuf -> audio -> nb_samples += nb_samples;\r\n if (pbuf -> audio -> nb_samples >= link -> min_samples) {\r\n ret = ff_filter_frame_framed(link,pbuf);\r\n pbuf = ((void *)0);\r\n }\r\n }\r\n avfilter_unref_buffer(frame);\r\n link -> partial_buf = pbuf;\r\n return ret;\r\n}\r\n\r\nint ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)\r\n{\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"%-16s: \",\"filter_frame\");\r\n }\r\n }while (0);\r\n ff_tlog_link(((void *)0),link,1);\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\" \");\r\n }\r\n }while (0);\r\n ff_tlog_ref(((void *)0),frame,1);\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_VIDEO) {\r\n if (strcmp(link -> dst -> filter -> name,\"scale\")) {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n }\r\n else {\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n (void )0;\r\n }\r\n\r\n if ((link -> type) == AVMEDIA_TYPE_AUDIO && link -> min_samples && (link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples)) {\r\n return ff_filter_frame_needs_framing(link,frame);\r\n }\r\n else {\r\n return ff_filter_frame_framed(link,frame);\r\n }\r\n}\r\n\r\nvoid unbereaven_cheapener(int nonremovable_irrationally,struct bankruptcies_arrester effluent_massiveness)\r\n{\r\n int child_signal = 0;\r\n int child_pids_count = 21;\r\n pid_t child_pids[21];\r\n pid_t child_pid = -1;\r\n int ii = 0;\r\n int jj = 0;\r\n int algorithms_count = 7;\r\n const char *algorithms[7];\r\n struct pid_fd fd_array[21];\r\n int error = 0;\r\n int index = -1;\r\n char buf;\r\n char *knottiness_disklike = 0;\r\n ++global_variable;\r\n nonremovable_irrationally--;\r\n if (nonremovable_irrationally > 0) {\r\n saprophytic_trainer(nonremovable_irrationally,effluent_massiveness);\r\n return ;\r\n }\r\n knottiness_disklike = ((char *)effluent_massiveness . nonprossing_predescend);\r\n \r\n algorithms[0] = \"MD5\";\r\n algorithms[1] = \"SHA1\";\r\n algorithms[2] = \"SHA224\";\r\n algorithms[3] = \"SHA256\";\r\n algorithms[4] = \"SHA384\";\r\n algorithms[5] = \"SHA512\";\r\n algorithms[6] = \"RIPEMD160\";\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_pids[ii] = -1;\r\n }\r\n if (!error) {\r\n OPENSSL_add_all_algorithms_noconf();\r\n fflush(stdout);\r\n fflush(stdin);\r\n \r\n for (ii = 0; ii < 3; ++ii) {\r\n for (jj = 0; jj < algorithms_count; ++jj) {\r\n index = jj + ii * algorithms_count;\r\n if (pipe(fd_array[index].fd_array) == -1) {\r\n error = 1;\r\n printf(\"Error opening pipe\\n\");\r\n } else {\r\n child_pid = fork();\r\n if (child_pid >= 0) {\r\n if (child_pid == 0) {\r\n close(fd_array[index].fd_array[0]);\r\n dup2(fd_array[index].fd_array[1], STDOUT_FILENO);\r\n \r\n \r\n evp_hash(algorithms[jj], knottiness_disklike);\r\n \r\n close(fd_array[index].fd_array[1]);\r\n exit(0);\r\n } else {\r\n close(fd_array[index].fd_array[1]);\r\n fd_array[index].pid = child_pid;\r\n continue;\r\n }\r\n } else {\r\n \r\n printf(\"Failed to fork a child process.\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n }\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_signal = 0;\r\n if (fd_array[ii].pid < 1) {\r\n continue;\r\n }\r\n if (-1 == waitpid(fd_array[ii].pid, &child_signal, 0)) {\r\n \r\n printf(\"Failed to wait for child process: %d\\n\",child_signal);\r\n } else {\r\n if (WIFEXITED(child_signal)) {\r\n printf(\"Child process exited with status: %d\\n\",WEXITSTATUS(child_signal));\r\n } else if (WIFSIGNALED(child_signal)) {\r\n \r\n printf(\"Child process received signal: %d\\n\",WTERMSIG(child_signal));\r\n }\r\n while (read(fd_array[ii].fd_array[0], &buf, 1) > 0) {\r\n printf(\"%c\", buf);\r\n }\r\n close(fd_array[ii].fd_array[0]);\r\n }\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n\r\nvoid saprophytic_trainer(int ordinariness_brininess,struct bankruptcies_arrester protevangelion_subaggregative)\r\n{\r\n ++global_variable;\r\n unbereaven_cheapener(ordinariness_brininess,protevangelion_subaggregative);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(!feof(file_stream)) {\n \n memset(file_contents,0,file_contents_size);\n file_contents_size_read = fread(file_contents,\n sizeof(unsigned char ),file_contents_size,file_stream);\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\n if (1 != hash_update_result) {\n break;\n }\n }\n```", "cwe": "400"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include \"config.h\"\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#if HAVE_ISATTY\r\n#if HAVE_IO_H\r\n#include <io.h>\r\n#endif\r\n#if HAVE_UNISTD_H\r\n#include <unistd.h>\r\n#endif\r\n#endif\r\n#include \"libavformat/avformat.h\"\r\n#include \"libavdevice/avdevice.h\"\r\n#include \"libswscale/swscale.h\"\r\n#include \"libswresample/swresample.h\"\r\n#include \"libavutil/opt.h\"\r\n#include \"libavutil/channel_layout.h\"\r\n#include \"libavutil/parseutils.h\"\r\n#include \"libavutil/samplefmt.h\"\r\n#include \"libavutil/colorspace.h\"\r\n#include \"libavutil/fifo.h\"\r\n#include \"libavutil/intreadwrite.h\"\r\n#include \"libavutil/dict.h\"\r\n#include \"libavutil/mathematics.h\"\r\n#include \"libavutil/pixdesc.h\"\r\n#include \"libavutil/avstring.h\"\r\n#include \"libavutil/libm.h\"\r\n#include \"libavutil/imgutils.h\"\r\n#include \"libavutil/timestamp.h\"\r\n#include \"libavutil/bprint.h\"\r\n#include \"libavutil/time.h\"\r\n#include \"libavformat/os_support.h\"\r\n#include \"libavformat/ffm.h\" \r\n# include \"libavfilter/avcodec.h\"\r\n# include \"libavfilter/avfilter.h\"\r\n# include \"libavfilter/avfiltergraph.h\"\r\n# include \"libavfilter/buffersrc.h\"\r\n# include \"libavfilter/buffersink.h\"\r\n#if HAVE_SYS_RESOURCE_H\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <sys/resource.h>\r\n#elif HAVE_GETPROCESSTIMES\r\n#include <windows.h>\r\n#endif\r\n#if HAVE_GETPROCESSMEMORYINFO\r\n#include <windows.h>\r\n#include <psapi.h>\r\n#endif\r\n#if HAVE_SYS_SELECT_H\r\n#include <sys/select.h>\r\n#endif\r\n#if HAVE_TERMIOS_H\r\n#include <fcntl.h>\r\n#include <sys/ioctl.h>\r\n#include <sys/time.h>\r\n#include <termios.h>\r\n#elif HAVE_KBHIT\r\n#include <conio.h>\r\n#endif\r\n#if HAVE_PTHREADS\r\n#include <pthread.h>\r\n#endif\r\n#include <time.h>\r\n#include \"ffmpeg.h\"\r\n#include \"cmdutils.h\"\r\n#include \"libavutil/avassert.h\"\r\n#if TRACE\r\n#include </trace.h>\r\n#endif\r\nconst char program_name[] = \"ffmpeg\";\r\nconst int program_birth_year = 2000;\r\nstatic FILE *vstats_file;\r\nconst char *const forced_keyframes_const_names[] = {(\"n\"), (\"n_forced\"), (\"prev_forced_n\"), (\"prev_forced_t\"), (\"t\"), (((void *)0))};\r\nstatic void do_video_stats(OutputStream *ost,int frame_size);\r\nstatic int64_t getutime();\r\nstatic int64_t getmaxrss();\r\nstatic int run_as_daemon = 0;\r\nstatic int64_t video_size = 0;\r\nstatic int64_t audio_size = 0;\r\nstatic int64_t subtitle_size = 0;\r\nstatic int64_t extra_size = 0;\r\nstatic int nb_frames_dup = 0;\r\nstatic int nb_frames_drop = 0;\r\nstatic int current_time;\r\nAVIOContext *progress_avio = ((void *)0);\r\nstatic uint8_t *subtitle_out;\r\n#if HAVE_PTHREADS\r\n\r\nstatic int transcoding_finished;\r\n#endif\r\n#define DEFAULT_PASS_LOGFILENAME_PREFIX \"ffmpeg2pass\"\r\nInputStream **input_streams = ((void *)0);\r\nint nb_input_streams = 0;\r\nInputFile **input_files = ((void *)0);\r\nint nb_input_files = 0;\r\nOutputStream **output_streams = ((void *)0);\r\nint nb_output_streams = 0;\r\nOutputFile **output_files = ((void *)0);\r\nint nb_output_files = 0;\r\nFilterGraph **filtergraphs;\r\nint nb_filtergraphs;\r\n#if HAVE_TERMIOS_H\r\n\r\nstatic struct termios oldtty;\r\nstatic int restore_tty;\r\n#endif\r\nstatic void free_input_threads();\r\n\r\nint glyptodon_metter = 0;\r\nint global_variable;\r\ntypedef char *strums_obstructivism;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid reticence_pneumobranchia(const strums_obstructivism shaniko_backstays);\r\nvoid spck_commelinaceae(int locustid_neutralities,strums_obstructivism overgown_nymphette);\r\n\r\nstatic void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r)\r\n{\r\n uint32_t *pal;\r\n uint32_t *dst2;\r\n uint8_t *src;\r\n uint8_t *src2;\r\n int x;\r\n int y;\r\n if ((r -> type) != SUBTITLE_BITMAP) {\r\n av_log(((void *)0),24,\"sub2video: non-bitmap subtitle\\n\");\r\n return ;\r\n }\r\n if (r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h) {\r\n av_log(((void *)0),24,\"sub2video: rectangle overflowing\\n\");\r\n return ;\r\n }\r\n dst += r -> y * dst_linesize + r -> x * 4;\r\n src = r -> pict . data[0];\r\n pal = ((uint32_t *)r -> pict . data[1]);\r\n for (y = 0; y < r -> h; y++) {\r\n dst2 = ((uint32_t *)dst);\r\n src2 = src;\r\n for (x = 0; x < r -> w; x++) \r\n *(dst2++) = pal[ *(src2++)];\r\n dst += dst_linesize;\r\n src += r -> pict . linesize[0];\r\n }\r\n}\r\n\r\nstatic void sub2video_push_ref(InputStream *ist,int64_t pts)\r\n{\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int i;\r\n ist -> sub2video . last_pts = ref -> pts = pts;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,avfilter_ref_buffer(ref,~0),AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n}\r\n\r\nstatic void sub2video_update(InputStream *ist,AVSubtitle *sub)\r\n{\r\n int w = ist -> sub2video . w;\r\n int h = ist -> sub2video . h;\r\n AVFilterBufferRef *ref = ist -> sub2video . ref;\r\n int8_t *dst;\r\n int dst_linesize;\r\n int num_rects;\r\n int i;\r\n int64_t pts;\r\n int64_t end_pts;\r\n if (!ref) {\r\n return ;\r\n }\r\n if (sub) {\r\n pts = av_rescale_q(sub -> pts + (sub -> start_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n end_pts = av_rescale_q(sub -> pts + (sub -> end_display_time * 1000),((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n num_rects = (sub -> num_rects);\r\n }\r\n else {\r\n pts = ist -> sub2video . end_pts;\r\n end_pts = 9223372036854775807L;\r\n num_rects = 0;\r\n }\r\n dst = ref -> data[0];\r\n dst_linesize = ref -> linesize[0];\r\n memset(dst,0,(h * dst_linesize));\r\n for (i = 0; i < num_rects; i++) \r\n sub2video_copy_rect(dst,dst_linesize,w,h,sub -> rects[i]);\r\n sub2video_push_ref(ist,pts);\r\n ist -> sub2video . end_pts = end_pts;\r\n}\r\n\r\nstatic void sub2video_heartbeat(InputStream *ist,int64_t pts)\r\n{\r\n strums_obstructivism neutrophil_futureless = 0;\r\n char *kronos_euphorbia;\r\n InputFile *infile = input_files[ist -> file_index];\r\n int i;\r\n int j;\r\n int nb_reqs;\r\n int64_t pts2;\r\n if (__sync_bool_compare_and_swap(&glyptodon_metter,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&kronos_euphorbia,\"AEQUOREAL_BOUNDLY\");\r\n if (kronos_euphorbia != 0) {;\r\n neutrophil_futureless = kronos_euphorbia;\r\n reticence_pneumobranchia(neutrophil_futureless);\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < infile -> nb_streams; i++) {\r\n InputStream *ist2 = input_streams[infile -> ist_index + i];\r\n if (!ist2 -> sub2video . ref) {\r\n continue; \r\n }\r\n\r\n pts2 = av_rescale_q(pts,ist -> st -> time_base,ist2 -> st -> time_base) - 1;\r\n\r\n if (pts2 <= ist2 -> sub2video . last_pts) {\r\n continue; \r\n }\r\n if (pts2 >= ist2 -> sub2video . end_pts) {\r\n sub2video_update(ist2,((void *)0));\r\n }\r\n for ((j = 0 , nb_reqs = 0); j < ist2 -> nb_filters; j++) \r\n nb_reqs += av_buffersrc_get_nb_failed_requests(ist2 -> filters[j] -> filter);\r\n if (nb_reqs) {\r\n sub2video_push_ref(ist2,pts2);\r\n }\r\n }\r\n}\r\n\r\nstatic void sub2video_flush(InputStream *ist)\r\n{\r\n int i;\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n}\r\n\r\n\r\nvoid term_exit()\r\n{\r\n av_log(((void *)0),- 8,\"%s\",\"\");\r\n#if HAVE_TERMIOS_H\r\n if (restore_tty) {\r\n tcsetattr(0,0,(&oldtty));\r\n }\r\n#endif\r\n}\r\nstatic pthread_spinlock_t received_sigterm = 0;\r\nstatic pthread_spinlock_t received_nb_signals = 0;\r\n\r\nstatic void sigterm_handler(int sig)\r\n{\r\n received_sigterm = sig;\r\n received_nb_signals++;\r\n term_exit();\r\n if (received_nb_signals > 3) {\r\n exit(123);\r\n }\r\n}\r\n\r\nvoid term_init()\r\n{\r\n#if HAVE_TERMIOS_H\r\n if (!run_as_daemon) {\r\n struct termios tty;\r\n int istty = 1;\r\n#if HAVE_ISATTY\r\n istty = isatty(0) && isatty(2);\r\n#endif\r\n if (istty && tcgetattr(0,&tty) == 0) {\r\n oldtty = tty;\r\n restore_tty = 1;\r\n atexit(term_exit);\r\n tty . c_iflag &= (~(0000001 | 0000002 | 0000010 | 0x20 | 0000100 | 0x80 | 0000400 | 0002000));\r\n tty . c_oflag |= 0000001;\r\n tty . c_lflag &= (~(0000010 | 0000100 | 0000002 | 0x8000));\r\n tty . c_cflag &= (~(0000060 | 0000400));\r\n tty . c_cflag |= 0000060;\r\n tty . c_cc[6] = 1;\r\n tty . c_cc[5] = 0;\r\n tcsetattr(0,0,(&tty));\r\n }\r\n\r\n signal(3,sigterm_handler);\r\n }\r\n#endif\r\n avformat_network_deinit();\r\n\r\n signal(2,sigterm_handler);\r\n\r\n signal(15,sigterm_handler);\r\n#ifdef SIGXCPU\r\n signal(24,sigterm_handler);\r\n#endif\r\n}\r\n\r\n\r\nstatic int read_key()\r\n{\r\n unsigned char ch;\r\n#if HAVE_TERMIOS_H\r\n int n = 1;\r\n struct timeval tv;\r\n fd_set rfds;\r\n do {\r\n int __d0;\r\n int __d1;\r\n __asm__ (\"cld; rep; stosq\" : \"=c\" (__d0), \"=D\" (__d1) : \"a\" (0), \"0\" ((sizeof(fd_set ) / sizeof(__fd_mask ))), \"1\" ((&(&rfds) -> fds_bits[0])) : \"memory\");\r\n }while (0);\r\n (&rfds) -> fds_bits[0 / (8 * ((int )(sizeof(__fd_mask ))))] |= ((__fd_mask )1) << 0 % (8 * ((int )(sizeof(__fd_mask ))));\r\n tv . tv_sec = 0;\r\n tv . tv_usec = 0;\r\n n = select(1,&rfds,((void *)0),((void *)0),&tv);\r\n if (n > 0) {\r\n n = (read(0,(&ch),1));\r\n if (n == 1) {\r\n return ch;\r\n }\r\n return n;\r\n }\r\n#elif HAVE_KBHIT\r\n# if HAVE_PEEKNAMEDPIPE\r\n\r\n\r\n\r\n# endif\r\n#endif\r\n return - 1;\r\n}\r\n\r\nstatic int decode_interrupt_cb(void *ctx)\r\n{\r\n return received_nb_signals > 1;\r\n}\r\nconst AVIOInterruptCB int_cb = {(decode_interrupt_cb), ((void *)0)};\r\n\r\nstatic void exit_program()\r\n{\r\n int i;\r\n int j;\r\n if (do_benchmark) {\r\n int maxrss = (getmaxrss() / 1024);\r\n printf(\"bench: maxrss=%ikB\\n\",maxrss);\r\n }\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n avfilter_graph_free(&filtergraphs[i] -> graph);\r\n for (j = 0; j < filtergraphs[i] -> nb_inputs; j++) {\r\n av_freep((&filtergraphs[i] -> inputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> inputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> inputs));\r\n for (j = 0; j < filtergraphs[i] -> nb_outputs; j++) {\r\n av_freep((&filtergraphs[i] -> outputs[j] -> name));\r\n av_freep((&filtergraphs[i] -> outputs[j]));\r\n }\r\n av_freep((&filtergraphs[i] -> outputs));\r\n av_freep((&filtergraphs[i]));\r\n }\r\n av_freep((&filtergraphs));\r\n av_freep((&subtitle_out));\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n AVFormatContext *s = output_files[i] -> ctx;\r\n if (!(s -> oformat -> flags & 0000001) && s -> pb) {\r\n avio_close(s -> pb);\r\n }\r\n avformat_free_context(s);\r\n av_dict_free(&output_files[i] -> opts);\r\n av_freep((&output_files[i]));\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVBitStreamFilterContext *bsfc = output_streams[i] -> bitstream_filters;\r\n while(bsfc){\r\n AVBitStreamFilterContext *next = bsfc -> next;\r\n av_bitstream_filter_close(bsfc);\r\n bsfc = next;\r\n }\r\n output_streams[i] -> bitstream_filters = ((void *)0);\r\n avcodec_free_frame(&output_streams[i] -> filtered_frame);\r\n av_freep((&output_streams[i] -> forced_keyframes));\r\n av_expr_free(output_streams[i] -> forced_keyframes_pexpr);\r\n av_freep((&output_streams[i] -> avfilter));\r\n av_freep((&output_streams[i] -> logfile_prefix));\r\n av_freep((&output_streams[i]));\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n for (i = 0; i < nb_input_files; i++) {\r\n avformat_close_input(&input_files[i] -> ctx);\r\n av_freep((&input_files[i]));\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n avcodec_free_frame(&input_streams[i] -> decoded_frame);\r\n av_dict_free(&input_streams[i] -> opts);\r\n free_buffer_pool(&input_streams[i] -> buffer_pool);\r\n avsubtitle_free(&input_streams[i] -> prev_sub . subtitle);\r\n avfilter_unref_bufferp(&input_streams[i] -> sub2video . ref);\r\n av_freep((&input_streams[i] -> filters));\r\n av_freep((&input_streams[i]));\r\n }\r\n if (vstats_file) {\r\n fclose(vstats_file);\r\n }\r\n av_free(vstats_filename);\r\n av_freep((&input_streams));\r\n av_freep((&input_files));\r\n av_freep((&output_streams));\r\n av_freep((&output_files));\r\n uninit_opts();\r\n avfilter_uninit();\r\n avformat_network_deinit();\r\n if (received_sigterm) {\r\n av_log(((void *)0),32,\"Received signal %d: terminating.\\n\",((int )received_sigterm));\r\n }\r\n}\r\n\r\nvoid assert_avoptions(AVDictionary *m)\r\n{\r\n AVDictionaryEntry *t;\r\n if (t = av_dict_get(m,\"\",((void *)0),2)) {\r\n av_log(((void *)0),8,\"Option %s not found.\\n\",t -> key);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void abort_codec_experimental(AVCodec *c,int encoder)\r\n{\r\n exit(1);\r\n}\r\n\r\nstatic void update_benchmark(const char *fmt,... )\r\n{\r\n if (do_benchmark_all) {\r\n int64_t t = getutime();\r\n va_list va;\r\n char buf[1024];\r\n if (fmt) {\r\n __builtin_va_start(va,fmt);\r\n vsnprintf(buf,sizeof(buf),fmt,va);\r\n __builtin_va_end(va);\r\n printf(\"bench: %8lu %s \\n\",t - current_time,buf);\r\n }\r\n current_time = t;\r\n }\r\n}\r\n\r\nstatic void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost)\r\n{\r\n AVBitStreamFilterContext *bsfc = ost -> bitstream_filters;\r\n AVCodecContext *avctx = ost -> st -> codec;\r\n int ret;\r\n if ((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || (avctx -> codec_type) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0) {\r\n pkt -> pts = pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (((avctx -> codec_type) == AVMEDIA_TYPE_AUDIO || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO) && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t max = ost -> st -> cur_dts + (!(s -> oformat -> flags & 0x8020000));\r\n if (ost -> st -> cur_dts && ost -> st -> cur_dts != ((int64_t )0x8000000000000000UL) && max > pkt -> dts) {\r\n av_log(s,(max - pkt -> dts > 2 || (avctx -> codec_type) == AVMEDIA_TYPE_VIDEO?24 : 48),\"st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\\n\",pkt -> stream_index,pkt -> pts,pkt -> dts,max);\r\n if (pkt -> pts >= pkt -> dts) {\r\n pkt -> pts = (pkt -> pts > max?pkt -> pts : max);\r\n }\r\n pkt -> dts = max;\r\n }\r\n }\r\n\r\n if (!((avctx -> codec_type) == AVMEDIA_TYPE_VIDEO && avctx -> codec)) {\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n av_free_packet(pkt);\r\n return ;\r\n }\r\n ost -> frame_number++;\r\n }\r\n while(bsfc){\r\n AVPacket new_pkt = *pkt;\r\n int a = av_bitstream_filter_filter(bsfc,avctx,((void *)0),&new_pkt . data,&new_pkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001);\r\n if (a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct) {\r\n\r\n uint8_t *t = (av_malloc((new_pkt . size + 16)));\r\n if (t) {\r\n memcpy(t,new_pkt . data,new_pkt . size);\r\n memset((t + new_pkt . size),0,16);\r\n new_pkt . data = t;\r\n a = 1;\r\n }\r\n else {\r\n a = - 12;\r\n }\r\n }\r\n if (a > 0) {\r\n av_free_packet(pkt);\r\n new_pkt . destruct = av_destruct_packet;\r\n }\r\n else {\r\n if (a < 0) {\r\n av_log(((void *)0),16,\"Failed to open bitstream filter %s for stream %d with codec %s\",bsfc -> filter -> name,pkt -> stream_index,(avctx -> codec?avctx -> codec -> name : \"copy\"));\r\n print_error(\"\",a);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n }\r\n *pkt = new_pkt;\r\n bsfc = bsfc -> next;\r\n }\r\n pkt -> stream_index = ost -> index;\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\\n\",av_get_media_type_string(ost -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt -> pts),av_ts_make_time_string(((char [32]){(0)}),pkt -> pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt -> dts),av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&ost -> st -> time_base),pkt -> size);\r\n }\r\n ret = av_interleaved_write_frame(s,pkt);\r\n if (ret < 0) {\r\n print_error(\"av_interleaved_write_frame()\",ret);\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void close_output_stream(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n ost -> finished = 1;\r\n if (of -> shortest) {\r\n int64_t end = av_rescale_q(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,((AVRational ){(1), (1000000)}));\r\n of -> recording_time = (of -> recording_time > end?end : of -> recording_time);\r\n }\r\n}\r\n\r\nstatic int check_recording_time(OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n if (of -> recording_time != 9223372036854775807L && av_compare_ts(ost -> sync_opts - ost -> first_pts,ost -> st -> codec -> time_base,of -> recording_time,((AVRational ){(1), (1000000)})) >= 0) {\r\n close_output_stream(ost);\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_audio_out(AVFormatContext *s,OutputStream *ost,AVFrame *frame)\r\n{\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVPacket pkt;\r\n int got_packet = 0;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (frame -> pts == ((int64_t )0x8000000000000000UL) || audio_sync_method < 0) {\r\n frame -> pts = ost -> sync_opts;\r\n }\r\n ost -> sync_opts = frame -> pts + (frame -> nb_samples);\r\n do {\r\n if (!(pkt . size || !pkt . data)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"pkt.size || !pkt.data\",\"ffmpeg.c\",663);\r\n abort();\r\n }\r\n }while (0);\r\n update_benchmark(((void *)0));\r\n if (avcodec_encode_audio2(enc,&pkt,frame,&got_packet) < 0) {\r\n av_log(((void *)0),8,\"Audio encoding failed (avcodec_encode_audio2)\\n\");\r\n exit(1);\r\n }\r\n update_benchmark(\"encode_audio %d.%d\",ost -> file_index,ost -> index);\r\n if (got_packet) {\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:audio pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n audio_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n }\r\n}\r\n#if FF_API_DEINTERLACE\r\n\r\nstatic void pre_process_video_frame(InputStream *ist,AVPicture *picture,void **bufp)\r\n{\r\n AVCodecContext *dec;\r\n AVPicture *picture2;\r\n AVPicture picture_tmp;\r\n uint8_t *buf = 0;\r\n dec = ist -> st -> codec;\r\n\r\n if ('6' < 56 && do_deinterlace) {\r\n int size;\r\n\r\n size = avpicture_get_size(dec -> pix_fmt,dec -> width,dec -> height);\r\n if (size < 0) {\r\n return ;\r\n }\r\n buf = (av_malloc(size));\r\n if (!buf) {\r\n return ;\r\n }\r\n picture2 = &picture_tmp;\r\n avpicture_fill(picture2,buf,dec -> pix_fmt,dec -> width,dec -> height);\r\n if (avpicture_deinterlace(picture2,picture,dec -> pix_fmt,dec -> width,dec -> height) < 0) {\r\n\r\n av_log(((void *)0),24,\"Deinterlacing failed\\n\");\r\n av_free(buf);\r\n buf = ((void *)0);\r\n picture2 = picture;\r\n }\r\n }\r\n else {\r\n picture2 = picture;\r\n }\r\n if (picture != picture2) {\r\n *picture = *picture2;\r\n }\r\n *bufp = buf;\r\n}\r\n#endif\r\n\r\nstatic void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub)\r\n{\r\n int subtitle_out_max_size = 1024 * 1024;\r\n int subtitle_out_size;\r\n int nb;\r\n int i;\r\n AVCodecContext *enc;\r\n AVPacket pkt;\r\n int64_t pts;\r\n if (sub -> pts == ((int64_t )0x8000000000000000UL)) {\r\n av_log(((void *)0),16,\"Subtitle packets must have a pts\\n\");\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n return ;\r\n }\r\n enc = ost -> st -> codec;\r\n if (!subtitle_out) {\r\n subtitle_out = (av_malloc(subtitle_out_max_size));\r\n }\r\n\r\n\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n nb = 2;\r\n }\r\n else {\r\n nb = 1;\r\n }\r\n\r\n pts = sub -> pts - output_files[ost -> file_index] -> start_time;\r\n for (i = 0; i < nb; i++) {\r\n ost -> sync_opts = av_rescale_q(pts,((AVRational ){(1), (1000000)}),enc -> time_base);\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n sub -> pts = pts;\r\n\r\n sub -> pts += av_rescale_q((sub -> start_display_time),((AVRational ){(1), (1000)}),((AVRational ){(1), (1000000)}));\r\n sub -> end_display_time -= sub -> start_display_time;\r\n sub -> start_display_time = 0;\r\n if (i == 1) {\r\n sub -> num_rects = 0;\r\n }\r\n subtitle_out_size = avcodec_encode_subtitle(enc,subtitle_out,subtitle_out_max_size,sub);\r\n if (subtitle_out_size < 0) {\r\n av_log(((void *)0),8,\"Subtitle encoding failed\\n\");\r\n exit(1);\r\n }\r\n av_init_packet(&pkt);\r\n pkt . data = subtitle_out;\r\n pkt . size = subtitle_out_size;\r\n pkt . pts = av_rescale_q(sub -> pts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n pkt . duration = (av_rescale_q((sub -> end_display_time),((AVRational ){(1), (1000)}),ost -> st -> time_base));\r\n if ((enc -> codec_id) == AV_CODEC_ID_DVB_SUBTITLE) {\r\n\r\n if (i == 0) {\r\n pkt . pts += ('Z' * sub -> start_display_time);\r\n }\r\n else {\r\n pkt . pts += ('Z' * sub -> end_display_time);\r\n }\r\n }\r\n subtitle_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n}\r\n\r\nstatic void do_video_out(AVFormatContext *s,OutputStream *ost,AVFrame *in_picture)\r\n{\r\n int ret;\r\n int format_video_sync;\r\n AVPacket pkt;\r\n AVCodecContext *enc = ost -> st -> codec;\r\n int nb_frames;\r\n int i;\r\n double sync_ipts;\r\n double delta;\r\n double duration = 0;\r\n int frame_size = 0;\r\n InputStream *ist = ((void *)0);\r\n if (ost -> source_index >= 0) {\r\n ist = input_streams[ost -> source_index];\r\n }\r\n if (ist && ist -> st -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> first_dts != ((int64_t )0x8000000000000000UL) && ost -> frame_rate . num) {\r\n duration = 1 / (av_q2d(ost -> frame_rate) * av_q2d(enc -> time_base));\r\n }\r\n sync_ipts = (in_picture -> pts);\r\n delta = sync_ipts - (ost -> sync_opts) + duration;\r\n\r\n nb_frames = 1;\r\n format_video_sync = video_sync_method;\r\n if (format_video_sync == - 1) {\r\n format_video_sync = (s -> oformat -> flags & 0002000?((s -> oformat -> flags & 0x80?0 : 2)) : 1);\r\n }\r\n switch(format_video_sync){\r\n case 1:\r\n{\r\n\r\n if (delta < - 1.1) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 1.1) {\r\n nb_frames = (lrintf(delta));\r\n }\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (delta <= - 0.6) {\r\n nb_frames = 0;\r\n }\r\n else {\r\n if (delta > 0.6) {\r\n ost -> sync_opts = lrint(sync_ipts);\r\n }\r\n }\r\n break; \r\n }\r\n case 0xff:\r\n{\r\n }\r\n case 0:\r\n{\r\n ost -> sync_opts = lrint(sync_ipts);\r\n break; \r\n }\r\n default:\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",855);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n nb_frames = ((nb_frames > ost -> max_frames - (ost -> frame_number)?ost -> max_frames - (ost -> frame_number) : nb_frames));\r\n if (nb_frames == 0) {\r\n nb_frames_drop++;\r\n av_log(((void *)0),40,\"*** drop!\\n\");\r\n return ;\r\n }\r\n else {\r\n if (nb_frames > 1) {\r\n if (nb_frames > dts_error_threshold * 30) {\r\n av_log(((void *)0),16,\"%d frame duplication too large, skipping\\n\",nb_frames - 1);\r\n nb_frames_drop++;\r\n return ;\r\n }\r\n nb_frames_dup += nb_frames - 1;\r\n av_log(((void *)0),40,\"*** %d dup!\\n\",nb_frames - 1);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_frames; i++) {\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n in_picture -> pts = ost -> sync_opts;\r\n if (!check_recording_time(ost)) {\r\n return ;\r\n }\r\n if (s -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n\r\n enc -> coded_frame -> interlaced_frame = in_picture -> interlaced_frame;\r\n enc -> coded_frame -> top_field_first = in_picture -> top_field_first;\r\n if (enc -> coded_frame -> interlaced_frame) {\r\n enc -> field_order = ((enc -> coded_frame -> top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n pkt . data = ((uint8_t *)in_picture);\r\n pkt . size = (sizeof(AVPicture ));\r\n pkt . pts = av_rescale_q(in_picture -> pts,enc -> time_base,ost -> st -> time_base);\r\n pkt . flags |= 0000001;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n }\r\n else {\r\n int got_packet;\r\n int forced_keyframe = 0;\r\n AVFrame big_picture;\r\n double pts_time;\r\n big_picture = *in_picture;\r\n\r\n big_picture . interlaced_frame = in_picture -> interlaced_frame;\r\n if (ost -> st -> codec -> flags & (0x00040000 | 0x20000000)) {\r\n if (ost -> top_field_first == - 1) {\r\n big_picture . top_field_first = in_picture -> top_field_first;\r\n }\r\n else {\r\n big_picture . top_field_first = !(!ost -> top_field_first);\r\n }\r\n }\r\n if (big_picture . interlaced_frame) {\r\n if ((enc -> codec -> id) == AV_CODEC_ID_MJPEG) {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TT : AV_FIELD_BB));\r\n }\r\n else {\r\n enc -> field_order = ((big_picture . top_field_first?AV_FIELD_TB : AV_FIELD_BT));\r\n }\r\n }\r\n else {\r\n enc -> field_order = AV_FIELD_PROGRESSIVE;\r\n }\r\n big_picture . quality = ost -> st -> codec -> global_quality;\r\n if (!enc -> me_threshold) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_NONE;\r\n }\r\n pts_time = (big_picture . pts != ((int64_t )0x8000000000000000UL)?big_picture . pts * av_q2d(enc -> time_base) : (__builtin_nanf(\"\")));\r\n if (ost -> forced_kf_index < ost -> forced_kf_count && big_picture . pts >= ost -> forced_kf_pts[ost -> forced_kf_index]) {\r\n ost -> forced_kf_index++;\r\n forced_keyframe = 1;\r\n }\r\n else {\r\n if (ost -> forced_keyframes_pexpr) {\r\n double res;\r\n ost -> forced_keyframes_expr_const_values[FKF_T] = pts_time;\r\n res = av_expr_eval(ost -> forced_keyframes_pexpr,(ost -> forced_keyframes_expr_const_values),((void *)0));\r\n do {\r\n if (0) {\r\n av_log(((void *)0),48,\"force_key_frame: n:%f n_forced:%f prev_forced_n:%f t:%f prev_forced_t:%f -> res:%f\\n\",ost -> forced_keyframes_expr_const_values[FKF_N],ost -> forced_keyframes_expr_const_values[FKF_N_FORCED],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N],ost -> forced_keyframes_expr_const_values[FKF_T],ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T],res);\r\n }\r\n }while (0);\r\n if (res) {\r\n forced_keyframe = 1;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = ost -> forced_keyframes_expr_const_values[FKF_N];\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = ost -> forced_keyframes_expr_const_values[FKF_T];\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] += 1;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] += 1;\r\n }\r\n }\r\n if (forced_keyframe) {\r\n big_picture . pict_type = AV_PICTURE_TYPE_I;\r\n av_log(((void *)0),48,\"Forced keyframe at time %f\\n\",pts_time);\r\n }\r\n update_benchmark(((void *)0));\r\n ret = avcodec_encode_video2(enc,&pkt,(&big_picture),&got_packet);\r\n update_benchmark(\"encode_video %d.%d\",ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"Video encoding failed\\n\");\r\n exit(1);\r\n }\r\n if (got_packet) {\r\n if (pkt . pts == ((int64_t )0x8000000000000000UL) && !(enc -> codec -> capabilities & 0x20)) {\r\n pkt . pts = ost -> sync_opts;\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"encoder -> type:video pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ost -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ost -> st -> time_base));\r\n }\r\n frame_size = pkt . size;\r\n video_size += pkt . size;\r\n write_frame(s,&pkt,ost);\r\n av_free_packet(&pkt);\r\n\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n }\r\n }\r\n ost -> sync_opts++;\r\n\r\n ost -> frame_number++;\r\n }\r\n if (vstats_filename && frame_size) {\r\n do_video_stats(ost,frame_size);\r\n }\r\n}\r\n\r\nstatic double psnr(double d)\r\n{\r\n return - 10.0 * log(d) / log(10.0);\r\n}\r\n\r\nstatic void do_video_stats(OutputStream *ost,int frame_size)\r\n{\r\n AVCodecContext *enc;\r\n int frame_number;\r\n double ti1;\r\n double bitrate;\r\n double avg_bitrate;\r\n\r\n if (!vstats_file) {\r\n vstats_file = fopen(vstats_filename,\"w\");\r\n if (!vstats_file) {\r\n perror(\"fopen\");\r\n exit(1);\r\n }\r\n }\r\n enc = ost -> st -> codec;\r\n if ((enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n frame_number = (ost -> st -> nb_frames);\r\n fprintf(vstats_file,\"frame= %5d q= %2.1f \",frame_number,((enc -> coded_frame -> quality) / ((float )'v')));\r\n if (enc -> flags & 0x8000) {\r\n fprintf(vstats_file,\"PSNR= %6.2f \",psnr(enc -> coded_frame -> error[0] / ((enc -> width * enc -> height) * 255.0 * 255.0)));\r\n }\r\n fprintf(vstats_file,\"f_size= %6d \",frame_size);\r\n\r\n ti1 = ost -> st -> pts . val * av_q2d(enc -> time_base);\r\n if (ti1 < 0.01) {\r\n ti1 = 0.01;\r\n }\r\n bitrate = (frame_size * 8) / av_q2d(enc -> time_base) / 1000.0;\r\n avg_bitrate = ((double )(video_size * 8)) / ti1 / 1000.0;\r\n fprintf(vstats_file,\"s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s \",((double )video_size) / 1024,ti1,bitrate,avg_bitrate);\r\n fprintf(vstats_file,\"type= %c\\n\",(av_get_picture_type_char(enc -> coded_frame -> pict_type)));\r\n }\r\n}\r\n\r\n\r\nstatic int reap_filters()\r\n{\r\n AVFilterBufferRef *picref;\r\n AVFrame *filtered_frame = ((void *)0);\r\n int i;\r\n int64_t frame_pts;\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ret = 0;\r\n if (!ost -> filter) {\r\n continue; \r\n }\r\n if (!ost -> filtered_frame && !(ost -> filtered_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n else {\r\n avcodec_get_frame_defaults(ost -> filtered_frame);\r\n }\r\n filtered_frame = ost -> filtered_frame;\r\n while(1){\r\n ret = av_buffersink_get_buffer_ref(ost -> filter -> filter,&picref,2);\r\n if (ret < 0) {\r\n if (ret != - 11 && ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n char buf[256];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),24,\"Error in av_buffersink_get_buffer_ref(): %s\\n\",buf);\r\n }\r\n break; \r\n }\r\n frame_pts = ((int64_t )0x8000000000000000UL);\r\n if (picref -> pts != ((int64_t )0x8000000000000000UL)) {\r\n filtered_frame -> pts = frame_pts = av_rescale_q(picref -> pts,ost -> filter -> filter -> inputs[0] -> time_base,ost -> st -> codec -> time_base) - av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> codec -> time_base);\r\n if (of -> start_time && filtered_frame -> pts < 0) {\r\n avfilter_unref_buffer(picref);\r\n continue; \r\n }\r\n }\r\n\r\n\r\n switch(ost -> filter -> filter -> inputs[0] -> type){\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!ost -> frame_aspect_ratio) {\r\n ost -> st -> codec -> sample_aspect_ratio = picref -> video -> sample_aspect_ratio;\r\n }\r\n do_video_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n avfilter_copy_buf_props(filtered_frame,picref);\r\n filtered_frame -> pts = frame_pts;\r\n if (!(ost -> st -> codec -> codec -> capabilities & 0x4000) && ost -> st -> codec -> channels != av_frame_get_channels(filtered_frame)) {\r\n av_log(((void *)0),16,\"Audio filter graph output is not normalized and encoder does not support parameter changes\\n\");\r\n break; \r\n }\r\n do_audio_out(of -> ctx,ost,filtered_frame);\r\n break; \r\n }\r\n default:\r\n\r\n do {\r\n if (!0) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"0\",\"ffmpeg.c\",1133);\r\n abort();\r\n }\r\n }while (0);\r\n }\r\n avfilter_unref_buffer(picref);\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_report(int is_last_report,int64_t timer_start,int64_t cur_time)\r\n{\r\n char buf[1024];\r\n AVBPrint buf_script;\r\n OutputStream *ost;\r\n AVFormatContext *oc;\r\n int64_t total_size;\r\n AVCodecContext *enc;\r\n int frame_number;\r\n int vid;\r\n int i;\r\n double bitrate;\r\n int64_t pts = - 9223372036854775807L - 1;\r\n static int64_t last_time = (- 1);\r\n static int qp_histogram['4'];\r\n int hours;\r\n int mins;\r\n int secs;\r\n int us;\r\n if (!print_stats && !is_last_report && !progress_avio) {\r\n return ;\r\n }\r\n if (!is_last_report) {\r\n if (last_time == (- 1)) {\r\n last_time = cur_time;\r\n return ;\r\n }\r\n if (cur_time - last_time < 500000) {\r\n return ;\r\n }\r\n last_time = cur_time;\r\n }\r\n oc = output_files[0] -> ctx;\r\n total_size = avio_size(oc -> pb);\r\n\r\n if (total_size <= 0) {\r\n total_size = avio_tell(oc -> pb);\r\n }\r\n buf[0] = '\\0';\r\n vid = 0;\r\n av_bprint_init(&buf_script,0,1);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n float q = (- 1);\r\n ost = output_streams[i];\r\n enc = ost -> st -> codec;\r\n if (!ost -> stream_copy && enc -> coded_frame) {\r\n q = (enc -> coded_frame -> quality) / ((float )'v');\r\n }\r\n if (vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"q=%2.1f \",q);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n }\r\n if (!vid && (enc -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n float fps;\r\n float t = ((cur_time - timer_start) / 1000000.0);\r\n frame_number = ost -> frame_number;\r\n fps = (t > 1?frame_number / t : 0);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"frame=%5d fps=%3.*f q=%3.1f \",frame_number,fps < 9.95,fps,q);\r\n av_bprintf(&buf_script,\"frame=%d\\n\",frame_number);\r\n av_bprintf(&buf_script,\"fps=%.1f\\n\",fps);\r\n av_bprintf(&buf_script,\"stream_%d_%d_q=%.1f\\n\",ost -> file_index,ost -> index,q);\r\n if (is_last_report) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"L\");\r\n }\r\n if (qp_hist) {\r\n int j;\r\n int qp = (lrintf(q));\r\n if (qp >= 0 && qp < sizeof(qp_histogram) / sizeof(qp_histogram[0])) {\r\n qp_histogram[qp]++;\r\n }\r\n for (j = 0; j < 32; j++) \r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%X\",((int )(lrintf((log2((qp_histogram[j] + 1)))))));\r\n }\r\n if (enc -> flags & 0x8000 && (enc -> coded_frame || is_last_report)) {\r\n int j;\r\n double error;\r\n double error_sum = 0;\r\n double scale;\r\n double scale_sum = 0;\r\n double p;\r\n char type[3] = {('Y'), ('U'), ('V')};\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"PSNR=\");\r\n for (j = 0; j < 3; j++) {\r\n if (is_last_report) {\r\n error = enc -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0 * frame_number;\r\n }\r\n else {\r\n error = enc -> coded_frame -> error[j];\r\n scale = (enc -> width * enc -> height) * 255.0 * 255.0;\r\n }\r\n if (j) {\r\n scale /= 4;\r\n }\r\n error_sum += error;\r\n scale_sum += scale;\r\n p = psnr(error / scale);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%c:%2.2f \",type[j],p);\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_%c=%2.2f\\n\",ost -> file_index,ost -> index,type[j] | 32,p);\r\n }\r\n p = psnr(error_sum / scale_sum);\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"*:%2.2f \",psnr(error_sum / scale_sum));\r\n av_bprintf(&buf_script,\"stream_%d_%d_psnr_all=%2.2f\\n\",ost -> file_index,ost -> index,p);\r\n }\r\n vid = 1;\r\n }\r\n\r\n if ((is_last_report || !ost -> finished) && ost -> st -> pts . val != ((int64_t )0x8000000000000000UL)) {\r\n pts = (pts > av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)}))?pts : av_rescale_q(ost -> st -> pts . val,ost -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n }\r\n secs = (pts / 1000000);\r\n us = (pts % 1000000);\r\n mins = secs / 60;\r\n secs %= 60;\r\n hours = mins / 60;\r\n mins %= 60;\r\n bitrate = (pts && total_size >= 0?(total_size * 8) / (pts / 1000.0) : (- 1));\r\n if (total_size < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=N/A time=\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"size=%8.0fkB time=\",total_size / 1024.0);\r\n }\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"%02d:%02d:%02d.%02d \",hours,mins,secs,100 * us / 1000000);\r\n if (bitrate < 0) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=N/A\");\r\n }\r\n else {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\"bitrate=%6.1fkbits/s\",bitrate);\r\n }\r\n if (total_size < 0) {\r\n av_bprintf(&buf_script,\"total_size=N/A\\n\");\r\n }\r\n else {\r\n av_bprintf(&buf_script,\"total_size=%ld\\n\",total_size);\r\n }\r\n av_bprintf(&buf_script,\"out_time_ms=%ld\\n\",pts);\r\n av_bprintf(&buf_script,\"out_time=%02d:%02d:%02d.%06d\\n\",hours,mins,secs,us);\r\n if (nb_frames_dup || nb_frames_drop) {\r\n snprintf(buf + strlen(buf),sizeof(buf) - strlen(buf),\" dup=%d drop=%d\",nb_frames_dup,nb_frames_drop);\r\n }\r\n av_bprintf(&buf_script,\"dup_frames=%d\\n\",nb_frames_dup);\r\n av_bprintf(&buf_script,\"drop_frames=%d\\n\",nb_frames_drop);\r\n if (print_stats || is_last_report) {\r\n if (print_stats == 1 && 32 > av_log_get_level()) {\r\n fprintf(stderr,\"%s \\r\",buf);\r\n }\r\n else {\r\n av_log(((void *)0),32,\"%s \\r\",buf);\r\n }\r\n fflush(stderr);\r\n }\r\n if (progress_avio) {\r\n av_bprintf(&buf_script,\"progress=%s\\n\",(is_last_report?\"end\" : \"continue\"));\r\n avio_write(progress_avio,buf_script . str,(buf_script . len > buf_script . size - 1?buf_script . size - 1 : buf_script . len));\r\n avio_flush(progress_avio);\r\n av_bprint_finalize(&buf_script,((void *)0));\r\n if (is_last_report) {\r\n avio_close(progress_avio);\r\n progress_avio = ((void *)0);\r\n }\r\n }\r\n if (is_last_report) {\r\n int64_t raw = audio_size + video_size + subtitle_size + extra_size;\r\n av_log(((void *)0),32,\"\\n\");\r\n av_log(((void *)0),32,\"video:%1.0fkB audio:%1.0fkB subtitle:%1.0f global headers:%1.0fkB muxing overhead %f%%\\n\",video_size / 1024.0,audio_size / 1024.0,subtitle_size / 1024.0,extra_size / 1024.0,100.0 * (total_size - raw) / raw);\r\n if (video_size + audio_size + subtitle_size + extra_size == 0) {\r\n av_log(((void *)0),24,\"Output file is empty, nothing was encoded (check -ss / -t / -frames parameters if used)\\n\");\r\n }\r\n }\r\n}\r\n\r\nstatic void flush_encoders()\r\n{\r\n int i;\r\n int ret;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n AVCodecContext *enc = ost -> st -> codec;\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n int stop_encoding = 0;\r\n if (!ost -> encoding_needed) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1) {\r\n continue; \r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && (enc -> codec -> id) == AV_CODEC_ID_RAWVIDEO) {\r\n continue; \r\n }\r\n for (; ; ) {\r\n int (*encode)(AVCodecContext *, AVPacket *, const AVFrame *, int *) = ((void *)0);\r\n const char *desc;\r\n int64_t *size;\r\n switch(ost -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n encode = avcodec_encode_audio2;\r\n desc = \"Audio\";\r\n size = &audio_size;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n encode = avcodec_encode_video2;\r\n desc = \"Video\";\r\n size = &video_size;\r\n break; \r\n }\r\n default:\r\n stop_encoding = 1;\r\n }\r\n if (encode) {\r\n AVPacket pkt;\r\n int got_packet;\r\n av_init_packet(&pkt);\r\n pkt . data = ((void *)0);\r\n pkt . size = 0;\r\n update_benchmark(((void *)0));\r\n ret = encode(enc,&pkt,((void *)0),&got_packet);\r\n update_benchmark(\"flush %s %d.%d\",desc,ost -> file_index,ost -> index);\r\n if (ret < 0) {\r\n av_log(((void *)0),8,\"%s encoding failed\\n\",desc);\r\n exit(1);\r\n }\r\n *size += pkt . size;\r\n if (ost -> logfile && enc -> stats_out) {\r\n fprintf(ost -> logfile,\"%s\",enc -> stats_out);\r\n }\r\n if (!got_packet) {\r\n stop_encoding = 1;\r\n break; \r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts = av_rescale_q(pkt . pts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts = av_rescale_q(pkt . dts,enc -> time_base,ost -> st -> time_base);\r\n }\r\n if (pkt . duration > 0) {\r\n pkt . duration = (av_rescale_q(pkt . duration,enc -> time_base,ost -> st -> time_base));\r\n }\r\n write_frame(os,&pkt,ost);\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && vstats_filename) {\r\n do_video_stats(ost,pkt . size);\r\n }\r\n }\r\n if (stop_encoding) {\r\n break; \r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic int check_output_constraints(InputStream *ist,OutputStream *ost)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int ist_index = input_files[ist -> file_index] -> ist_index + ist -> st -> index;\r\n if (ost -> source_index != ist_index) {\r\n return 0;\r\n }\r\n if (of -> start_time && ist -> pts < of -> start_time) {\r\n return 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic void do_streamcopy(InputStream *ist,OutputStream *ost,const AVPacket *pkt)\r\n{\r\n OutputFile *of = output_files[ost -> file_index];\r\n int64_t ost_tb_start_time = av_rescale_q(of -> start_time,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n AVPicture pict;\r\n AVPacket opkt;\r\n av_init_packet(&opkt);\r\n if (!ost -> frame_number && !(pkt -> flags & 0000001) && !ost -> copy_initial_nonkeyframes) {\r\n return ;\r\n }\r\n if (!ost -> frame_number && ist -> pts < of -> start_time && !ost -> copy_prior_start) {\r\n return ;\r\n }\r\n if (of -> recording_time != 9223372036854775807L && ist -> pts >= of -> recording_time + of -> start_time) {\r\n close_output_stream(ost);\r\n return ;\r\n }\r\n\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {\r\n audio_size += (pkt -> size);\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n video_size += (pkt -> size);\r\n ost -> sync_opts++;\r\n }\r\n else {\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_SUBTITLE) {\r\n subtitle_size += (pkt -> size);\r\n }\r\n }\r\n }\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n opkt . pts = av_rescale_q(pkt -> pts,ist -> st -> time_base,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n else {\r\n opkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt -> dts == ((int64_t )0x8000000000000000UL)) {\r\n opkt . dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ost -> st -> time_base);\r\n }\r\n else {\r\n opkt . dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,ost -> st -> time_base);\r\n }\r\n opkt . dts -= ost_tb_start_time;\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO && pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n int duration = av_get_audio_frame_duration(ist -> st -> codec,pkt -> size);\r\n if (!duration) {\r\n duration = ist -> st -> codec -> frame_size;\r\n }\r\n opkt . dts = opkt . pts = av_rescale_delta(ist -> st -> time_base,pkt -> dts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),duration,&ist -> filter_in_rescale_delta_last,ost -> st -> time_base) - ost_tb_start_time;\r\n }\r\n opkt . duration = (av_rescale_q((pkt -> duration),ist -> st -> time_base,ost -> st -> time_base));\r\n opkt . flags = pkt -> flags;\r\n\r\n if ((ost -> st -> codec -> codec_id) != AV_CODEC_ID_H264 && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG1VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_MPEG2VIDEO && (ost -> st -> codec -> codec_id) != AV_CODEC_ID_VC1) {\r\n if (av_parser_change(ist -> st -> parser,ost -> st -> codec,&opkt . data,&opkt . size,(pkt -> data),pkt -> size,pkt -> flags & 0000001)) {\r\n opkt . destruct = av_destruct_packet;\r\n }\r\n }\r\n else {\r\n opkt . data = pkt -> data;\r\n opkt . size = pkt -> size;\r\n }\r\n if ((ost -> st -> codec -> codec_type) == AVMEDIA_TYPE_VIDEO && of -> ctx -> oformat -> flags & 0x20) {\r\n\r\n avpicture_fill(&pict,opkt . data,ost -> st -> codec -> pix_fmt,ost -> st -> codec -> width,ost -> st -> codec -> height);\r\n opkt . data = ((uint8_t *)(&pict));\r\n opkt . size = (sizeof(AVPicture ));\r\n opkt . flags |= 0000001;\r\n }\r\n write_frame(of -> ctx,&opkt,ost);\r\n ost -> st -> codec -> frame_number++;\r\n}\r\n\r\nstatic void rate_emu_sleep(InputStream *ist)\r\n{\r\n if (input_files[ist -> file_index] -> rate_emu) {\r\n int64_t pts = av_rescale(ist -> dts,1000000,1000000);\r\n int64_t now = av_gettime() - ist -> start;\r\n if (pts > now) {\r\n av_usleep((pts - now));\r\n }\r\n }\r\n}\r\n\r\nint guess_input_channel_layout(InputStream *ist)\r\n{\r\n AVCodecContext *dec = ist -> st -> codec;\r\n if (!dec -> channel_layout) {\r\n char layout_name[256];\r\n if (dec -> channels > ist -> guess_layout_max) {\r\n return 0;\r\n }\r\n dec -> channel_layout = (av_get_default_channel_layout(dec -> channels));\r\n if (!dec -> channel_layout) {\r\n return 0;\r\n }\r\n av_get_channel_layout_string(layout_name,(sizeof(layout_name)),dec -> channels,dec -> channel_layout);\r\n av_log(((void *)0),24,\"Guessed Channel Layout for Input Stream #%d.%d : %s\\n\",ist -> file_index,ist -> st -> index,layout_name);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n AVCodecContext *avctx = ist -> st -> codec;\r\n int i;\r\n int ret;\r\n int resample_changed;\r\n AVRational decoded_frame_tb;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_audio4(avctx,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_audio %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (ret >= 0 && avctx -> sample_rate <= 0) {\r\n av_log(avctx,16,\"Sample rate %d invalid\\n\",avctx -> sample_rate);\r\n ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));\r\n }\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n#if 1\r\n\r\n ist -> next_pts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n ist -> next_dts += ((int64_t )1000000) * (decoded_frame -> nb_samples) / (avctx -> sample_rate);\r\n#endif\r\n rate_emu_sleep(ist);\r\n resample_changed = ist -> resample_sample_fmt != decoded_frame -> format || ist -> resample_channels != avctx -> channels || ist -> resample_channel_layout != decoded_frame -> channel_layout || ist -> resample_sample_rate != decoded_frame -> sample_rate;\r\n if (resample_changed) {\r\n char layout1[64];\r\n char layout2[64];\r\n if (!guess_input_channel_layout(ist)) {\r\n av_log(((void *)0),8,\"Unable to find default channel layout for Input Stream #%d.%d\\n\",ist -> file_index,ist -> st -> index);\r\n exit(1);\r\n }\r\n decoded_frame -> channel_layout = avctx -> channel_layout;\r\n av_get_channel_layout_string(layout1,(sizeof(layout1)),ist -> resample_channels,ist -> resample_channel_layout);\r\n av_get_channel_layout_string(layout2,(sizeof(layout2)),avctx -> channels,decoded_frame -> channel_layout);\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:%s to rate:%d fmt:%s ch:%d chl:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_sample_rate,av_get_sample_fmt_name((ist -> resample_sample_fmt)),ist -> resample_channels,layout1,decoded_frame -> sample_rate,av_get_sample_fmt_name((decoded_frame -> format)),avctx -> channels,layout2);\r\n ist -> resample_sample_fmt = decoded_frame -> format;\r\n ist -> resample_sample_rate = decoded_frame -> sample_rate;\r\n ist -> resample_channel_layout = decoded_frame -> channel_layout;\r\n ist -> resample_channels = avctx -> channels;\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if (ist_in_filtergraph(filtergraphs[i],ist)) {\r\n FilterGraph *fg = filtergraphs[i];\r\n int j;\r\n if (configure_filtergraph(fg) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n for (j = 0; j < fg -> nb_outputs; j++) {\r\n OutputStream *ost = fg -> outputs[j] -> ost;\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n }\r\n }\r\n }\r\n\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> dts = ist -> next_dts = ist -> pts = ist -> next_pts = av_rescale_q(decoded_frame -> pts,avctx -> time_base,((AVRational ){(1), (1000000)}));\r\n decoded_frame_tb = avctx -> time_base;\r\n }\r\n else {\r\n if (decoded_frame -> pkt_pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = decoded_frame -> pkt_pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n if (pkt -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = pkt -> pts;\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n decoded_frame_tb = ist -> st -> time_base;\r\n }\r\n else {\r\n decoded_frame -> pts = ist -> dts;\r\n decoded_frame_tb = ((AVRational ){(1), (1000000)});\r\n }\r\n }\r\n }\r\n if (decoded_frame -> pts != ((int64_t )0x8000000000000000UL)) {\r\n decoded_frame -> pts = av_rescale_delta(decoded_frame_tb,decoded_frame -> pts,((AVRational ){(1), ist -> st -> codec -> sample_rate}),decoded_frame -> nb_samples,&ist -> filter_in_rescale_delta_last,((AVRational ){(1), ist -> st -> codec -> sample_rate}));\r\n }\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH);\r\n decoded_frame -> pts = ((int64_t )0x8000000000000000UL);\r\n return ret;\r\n}\r\n\r\nstatic int decode_video(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVFrame *decoded_frame;\r\n void *buffer_to_free = (void *)0;\r\n int i;\r\n int ret = 0;\r\n int resample_changed;\r\n int64_t best_effort_timestamp;\r\n AVRational *frame_sample_aspect;\r\n if (!ist -> decoded_frame && !(ist -> decoded_frame = avcodec_alloc_frame())) {\r\n return - 12;\r\n }\r\n decoded_frame = ist -> decoded_frame;\r\n pkt -> dts = av_rescale_q(ist -> dts,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n update_benchmark(((void *)0));\r\n ret = avcodec_decode_video2(ist -> st -> codec,decoded_frame,got_output,pkt);\r\n update_benchmark(\"decode_video %d.%d\",ist -> file_index,ist -> st -> index);\r\n if (!( *got_output) || ret < 0) {\r\n if (!pkt -> size) {\r\n for (i = 0; i < ist -> nb_filters; i++) \r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,((void *)0),0);\r\n }\r\n return ret;\r\n }\r\n if (ist -> top_field_first >= 0) {\r\n decoded_frame -> top_field_first = ist -> top_field_first;\r\n }\r\n best_effort_timestamp = av_frame_get_best_effort_timestamp(decoded_frame);\r\n if (best_effort_timestamp != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts = av_rescale_q(decoded_frame -> pts = best_effort_timestamp,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"decoder -> ist_index:%d type:video frame_pts:%s frame_pts_time:%s best_effort_ts:%ld best_effort_ts_time:%s keyframe:%d frame_type:%d \\n\",ist -> st -> index,av_ts_make_string(((char [32]){(0)}),decoded_frame -> pts),av_ts_make_time_string(((char [32]){(0)}),decoded_frame -> pts,&ist -> st -> time_base),best_effort_timestamp,av_ts_make_time_string(((char [32]){(0)}),best_effort_timestamp,&ist -> st -> time_base),decoded_frame -> key_frame,decoded_frame -> pict_type);\r\n }\r\n pkt -> size = 0;\r\n#if FF_API_DEINTERLACE\r\n pre_process_video_frame(ist,((AVPicture *)decoded_frame),&buffer_to_free);\r\n#endif\r\n rate_emu_sleep(ist);\r\n if (ist -> st -> sample_aspect_ratio . num) {\r\n decoded_frame -> sample_aspect_ratio = ist -> st -> sample_aspect_ratio;\r\n }\r\n resample_changed = ist -> resample_width != decoded_frame -> width || ist -> resample_height != decoded_frame -> height || ist -> resample_pix_fmt != decoded_frame -> format;\r\n if (resample_changed) {\r\n av_log(((void *)0),32,\"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",ist -> file_index,ist -> st -> index,ist -> resample_width,ist -> resample_height,av_get_pix_fmt_name((ist -> resample_pix_fmt)),decoded_frame -> width,decoded_frame -> height,av_get_pix_fmt_name((decoded_frame -> format)));\r\n ist -> resample_width = decoded_frame -> width;\r\n ist -> resample_height = decoded_frame -> height;\r\n ist -> resample_pix_fmt = decoded_frame -> format;\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n if (ist_in_filtergraph(filtergraphs[i],ist) && ist -> reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) {\r\n av_log(((void *)0),8,\"Error reinitializing filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n frame_sample_aspect = (av_opt_ptr(avcodec_get_frame_class(),decoded_frame,\"sample_aspect_ratio\"));\r\n for (i = 0; i < ist -> nb_filters; i++) {\r\n int changed = ist -> st -> codec -> width != ist -> filters[i] -> filter -> outputs[0] -> w || ist -> st -> codec -> height != ist -> filters[i] -> filter -> outputs[0] -> h || (ist -> st -> codec -> pix_fmt) != ist -> filters[i] -> filter -> outputs[0] -> format;\r\n if (!frame_sample_aspect -> num) {\r\n *frame_sample_aspect = ist -> st -> sample_aspect_ratio;\r\n }\r\n if (ist -> dr1 && decoded_frame -> type == 2 && !changed) {\r\n FrameBuffer *buf = (decoded_frame -> opaque);\r\n AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays((decoded_frame -> data),(decoded_frame -> linesize),0000001 | 0x04,ist -> st -> codec -> width,ist -> st -> codec -> height,ist -> st -> codec -> pix_fmt);\r\n avfilter_copy_frame_props(fb,decoded_frame);\r\n fb -> buf -> priv = buf;\r\n fb -> buf -> free = filter_release_buffer;\r\n do {\r\n if (!(buf -> refcount > 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"buf->refcount>0\",\"ffmpeg.c\",1741);\r\n abort();\r\n }\r\n }while (0);\r\n buf -> refcount++;\r\n av_buffersrc_add_ref(ist -> filters[i] -> filter,fb,AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT | AV_BUFFERSRC_FLAG_NO_COPY | AV_BUFFERSRC_FLAG_PUSH);\r\n }\r\n else {\r\n if (av_buffersrc_add_frame(ist -> filters[i] -> filter,decoded_frame,AV_BUFFERSRC_FLAG_PUSH) < 0) {\r\n av_log(((void *)0),8,\"Failed to inject frame into filter network\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n av_free(buffer_to_free);\r\n return ret;\r\n}\r\n\r\nstatic int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)\r\n{\r\n AVSubtitle subtitle;\r\n int i;\r\n int ret = avcodec_decode_subtitle2(ist -> st -> codec,&subtitle,got_output,pkt);\r\n if (ret < 0 || !( *got_output)) {\r\n if (!pkt -> size) {\r\n sub2video_flush(ist);\r\n }\r\n return ret;\r\n }\r\n if (ist -> fix_sub_duration) {\r\n if (ist -> prev_sub . got_output) {\r\n int end = (av_rescale(subtitle . pts - ist -> prev_sub . subtitle . pts,1000,1000000));\r\n if (end < ist -> prev_sub . subtitle . end_display_time) {\r\n av_log((ist -> st -> codec),48,\"Subtitle duration reduced from %d to %d\\n\",ist -> prev_sub . subtitle . end_display_time,end);\r\n ist -> prev_sub . subtitle . end_display_time = end;\r\n }\r\n }\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . got_output;\r\n ist -> prev_sub . got_output = *got_output;\r\n *got_output = SWAP_tmp;\r\n }while (0);\r\n do {\r\n int SWAP_tmp = ist -> prev_sub . ret;\r\n ist -> prev_sub . ret = ret;\r\n ret = SWAP_tmp;\r\n }while (0);\r\n do {\r\n AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle;\r\n ist -> prev_sub . subtitle = subtitle;\r\n subtitle = SWAP_tmp;\r\n }while (0);\r\n }\r\n sub2video_update(ist,&subtitle);\r\n if (!( *got_output) || !subtitle . num_rects) {\r\n return ret;\r\n }\r\n rate_emu_sleep(ist);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || !ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_subtitle_out(output_files[ost -> file_index] -> ctx,ost,ist,&subtitle);\r\n }\r\n avsubtitle_free(&subtitle);\r\n return ret;\r\n}\r\n\r\n\r\nstatic int output_packet(InputStream *ist,const AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n int i;\r\n int got_output;\r\n AVPacket avpkt;\r\n if (!ist -> saw_first_ts) {\r\n ist -> dts = ((ist -> st -> avg_frame_rate . num?(-ist -> st -> codec -> has_b_frames * 1000000) / av_q2d(ist -> st -> avg_frame_rate) : 0));\r\n ist -> pts = 0;\r\n if (pkt != ((void *)0) && pkt -> pts != ((int64_t )0x8000000000000000UL) && !ist -> decoding_needed) {\r\n ist -> dts += av_rescale_q(pkt -> pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n\r\n ist -> pts = ist -> dts;\r\n }\r\n ist -> saw_first_ts = 1;\r\n }\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts;\r\n }\r\n if (ist -> next_pts == ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_pts = ist -> pts;\r\n }\r\n if (pkt == ((void *)0)) {\r\n\r\n av_init_packet(&avpkt);\r\n avpkt . data = ((void *)0);\r\n avpkt . size = 0;\r\n goto handle_eof;\r\n }\r\n else {\r\n avpkt = *pkt;\r\n }\r\n if (pkt -> dts != ((int64_t )0x8000000000000000UL)) {\r\n ist -> next_dts = ist -> dts = av_rescale_q(pkt -> dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_VIDEO || !ist -> decoding_needed) {\r\n ist -> next_pts = ist -> pts = ist -> dts;\r\n }\r\n }\r\n\r\n while(ist -> decoding_needed && (avpkt . size > 0 || !pkt && got_output)){\r\n int duration;\r\n handle_eof:\r\n ist -> pts = ist -> next_pts;\r\n ist -> dts = ist -> next_dts;\r\n if (avpkt . size && avpkt . size != pkt -> size) {\r\n av_log(((void *)0),(ist -> showed_multi_packet_warning?40 : 24),\"Multiple frames in a packet from stream %d\\n\",pkt -> stream_index);\r\n ist -> showed_multi_packet_warning = 1;\r\n }\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ret = decode_audio(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n ret = decode_video(ist,&avpkt,&got_output);\r\n if (avpkt . duration) {\r\n duration = (av_rescale_q(avpkt . duration,ist -> st -> time_base,((AVRational ){(1), (1000000)})));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n duration = (((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den);\r\n }\r\n else {\r\n duration = 0;\r\n }\r\n }\r\n if (ist -> dts != ((int64_t )0x8000000000000000UL) && duration) {\r\n ist -> next_dts += duration;\r\n }\r\n else {\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (got_output) {\r\n\r\n ist -> next_pts += duration;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n ret = transcode_subtitles(ist,&avpkt,&got_output);\r\n break; \r\n }\r\n default:\r\n return - 1;\r\n }\r\n if (ret < 0) {\r\n return ret;\r\n }\r\n avpkt . dts = avpkt . pts = ((int64_t )0x8000000000000000UL);\r\n\r\n if (pkt) {\r\n if ((ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_AUDIO) {\r\n ret = avpkt . size;\r\n }\r\n avpkt . data += ret;\r\n avpkt . size -= ret;\r\n }\r\n if (!got_output) {\r\n continue; \r\n }\r\n }\r\n\r\n if (!ist -> decoding_needed) {\r\n rate_emu_sleep(ist);\r\n ist -> dts = ist -> next_dts;\r\n switch(ist -> st -> codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n ist -> next_dts += ((int64_t )1000000) * (ist -> st -> codec -> frame_size) / (ist -> st -> codec -> sample_rate);\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n if (pkt -> duration) {\r\n ist -> next_dts += av_rescale_q((pkt -> duration),ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n }\r\n else {\r\n if (ist -> st -> codec -> time_base . num != 0) {\r\n int ticks = ist -> st -> parser?ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame;\r\n ist -> next_dts += ((int64_t )1000000) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;\r\n }\r\n }\r\n break; \r\n }\r\n }\r\n ist -> pts = ist -> dts;\r\n ist -> next_pts = ist -> next_dts;\r\n }\r\n for (i = 0; pkt && i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n if (!check_output_constraints(ist,ost) || ost -> encoding_needed) {\r\n continue; \r\n }\r\n do_streamcopy(ist,ost,pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void print_sdp()\r\n{\r\n char sdp[16384];\r\n int i;\r\n AVFormatContext **avc = (av_malloc(sizeof(( *avc)) * nb_output_files));\r\n if (!avc) {\r\n exit(1);\r\n }\r\n for (i = 0; i < nb_output_files; i++) \r\n avc[i] = output_files[i] -> ctx;\r\n av_sdp_create(avc,nb_output_files,sdp,(sizeof(sdp)));\r\n printf(\"SDP:\\n%s\\n\",sdp);\r\n fflush(stdout);\r\n av_freep((&avc));\r\n}\r\n\r\nstatic int init_input_stream(int ist_index,char *error,int error_len)\r\n{\r\n int ret;\r\n InputStream *ist = input_streams[ist_index];\r\n if (ist -> decoding_needed) {\r\n AVCodec *codec = ist -> dec;\r\n if (!codec) {\r\n snprintf(error,error_len,\"Decoder (codec %s) not found for input stream #%d:%d\",avcodec_get_name(ist -> st -> codec -> codec_id),ist -> file_index,ist -> st -> index);\r\n return - 22;\r\n }\r\n ist -> dr1 = codec -> capabilities & 0000002 && !('6' < 56 && do_deinterlace);\r\n if ((codec -> type) == AVMEDIA_TYPE_VIDEO && ist -> dr1) {\r\n ist -> st -> codec -> get_buffer = codec_get_buffer;\r\n ist -> st -> codec -> release_buffer = codec_release_buffer;\r\n ist -> st -> codec -> opaque = (&ist -> buffer_pool);\r\n }\r\n if (!av_dict_get(ist -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ist -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ist -> st -> codec,codec,&ist -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,0);\r\n }\r\n snprintf(error,error_len,\"Error while opening decoder for input stream #%d:%d\",ist -> file_index,ist -> st -> index);\r\n return ret;\r\n }\r\n assert_avoptions(ist -> opts);\r\n }\r\n ist -> next_pts = ((int64_t )0x8000000000000000UL);\r\n ist -> next_dts = ((int64_t )0x8000000000000000UL);\r\n ist -> is_start = 1;\r\n return 0;\r\n}\r\n\r\nstatic InputStream *get_input_stream(OutputStream *ost)\r\n{\r\n if (ost -> source_index >= 0) {\r\n return input_streams[ost -> source_index];\r\n }\r\n return ((void *)0);\r\n}\r\n\r\nstatic int compare_int64(const void *a,const void *b)\r\n{\r\n int64_t va = *((int64_t *)a);\r\n int64_t vb = *((int64_t *)b);\r\n return va < vb?- 1 : ((va > vb?+1 : 0));\r\n}\r\n\r\nstatic void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)\r\n{\r\n char *p;\r\n int n = 1;\r\n int i;\r\n int size;\r\n int index = 0;\r\n int64_t t;\r\n int64_t *pts;\r\n for (p = kf; *p; p++) \r\n if (( *p) == ',') {\r\n n++;\r\n }\r\n size = n;\r\n pts = (av_malloc(sizeof(( *pts)) * size));\r\n if (!pts) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n p = kf;\r\n for (i = 0; i < n; i++) {\r\n char *next = strchr(p,',');\r\n if (next) {\r\n *(next++) = 0;\r\n }\r\n if (!memcmp(p,\"chapters\",8)) {\r\n AVFormatContext *avf = output_files[ost -> file_index] -> ctx;\r\n int j;\r\n if (avf -> nb_chapters > (2147483647 - size) || !(pts = (av_realloc_f(pts,(size += avf -> nb_chapters - 1),sizeof(( *pts)))))) {\r\n av_log(((void *)0),8,\"Could not allocate forced key frames array.\\n\");\r\n exit(1);\r\n }\r\n t = (p[8]?parse_time_or_die(\"force_key_frames\",(p + 8),1) : 0);\r\n t = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n for (j = 0; j < avf -> nb_chapters; j++) {\r\n AVChapter *c = avf -> chapters[j];\r\n (void )0;\r\n pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;\r\n }\r\n }\r\n else {\r\n t = parse_time_or_die(\"force_key_frames\",p,1);\r\n (void )0;\r\n pts[index++] = av_rescale_q(t,((AVRational ){(1), (1000000)}),avctx -> time_base);\r\n }\r\n p = next;\r\n }\r\n do {\r\n if (!(index == size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"index == size\",\"ffmpeg.c\",2068);\r\n abort();\r\n }\r\n }while (0);\r\n qsort(pts,size,sizeof(( *pts)),compare_int64);\r\n ost -> forced_kf_count = size;\r\n ost -> forced_kf_pts = pts;\r\n}\r\n\r\nstatic void report_new_stream(int input_index,AVPacket *pkt)\r\n{\r\n InputFile *file = input_files[input_index];\r\n AVStream *st = file -> ctx -> streams[pkt -> stream_index];\r\n if (pkt -> stream_index < file -> nb_streams_warn) {\r\n return ;\r\n }\r\n av_log((file -> ctx),24,\"New %s stream %d:%d at pos:%ld and DTS:%ss\\n\",av_get_media_type_string(st -> codec -> codec_type),input_index,pkt -> stream_index,pkt -> pos,av_ts_make_time_string(((char [32]){(0)}),pkt -> dts,&st -> time_base));\r\n file -> nb_streams_warn = pkt -> stream_index + 1;\r\n}\r\n\r\nstatic int transcode_init()\r\n{\r\n int ret = 0;\r\n int i;\r\n int j;\r\n int k;\r\n AVFormatContext *oc;\r\n AVCodecContext *codec;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n char error[1024];\r\n int want_sdp = 1;\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n if (ifile -> rate_emu) {\r\n for (j = 0; j < ifile -> nb_streams; j++) \r\n input_streams[j + ifile -> ist_index] -> start = av_gettime();\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n if (!oc -> nb_streams && !(oc -> oformat -> flags & 0x1000)) {\r\n av_dump_format(oc,i,(oc -> filename),1);\r\n av_log(((void *)0),16,\"Output file #%d does not contain any stream\\n\",i);\r\n return - 22;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_filtergraphs; i++) \r\n if ((ret = avfilter_graph_config(filtergraphs[i] -> graph,((void *)0))) < 0) {\r\n return ret;\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n AVCodecContext *icodec = ((void *)0);\r\n ost = output_streams[i];\r\n oc = output_files[ost -> file_index] -> ctx;\r\n ist = get_input_stream(ost);\r\n if (ost -> attachment_filename) {\r\n continue; \r\n }\r\n codec = ost -> st -> codec;\r\n if (ist) {\r\n icodec = ist -> st -> codec;\r\n ost -> st -> disposition = ist -> st -> disposition;\r\n codec -> bits_per_raw_sample = icodec -> bits_per_raw_sample;\r\n codec -> chroma_sample_location = icodec -> chroma_sample_location;\r\n }\r\n if (ost -> stream_copy) {\r\n uint64_t extra_size;\r\n do {\r\n if (!(ist && !ost -> filter)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ist && !ost->filter\",\"ffmpeg.c\",2145);\r\n abort();\r\n }\r\n }while (0);\r\n extra_size = ((uint64_t )(icodec -> extradata_size)) + 16;\r\n if (extra_size > 2147483647) {\r\n return - 22;\r\n }\r\n\r\n codec -> codec_id = icodec -> codec_id;\r\n codec -> codec_type = icodec -> codec_type;\r\n if (!codec -> codec_tag) {\r\n unsigned int codec_tag;\r\n if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {\r\n codec -> codec_tag = icodec -> codec_tag;\r\n }\r\n }\r\n codec -> bit_rate = icodec -> bit_rate;\r\n codec -> rc_max_rate = icodec -> rc_max_rate;\r\n codec -> rc_buffer_size = icodec -> rc_buffer_size;\r\n codec -> field_order = icodec -> field_order;\r\n codec -> extradata = (av_mallocz(extra_size));\r\n if (!codec -> extradata) {\r\n return - 12;\r\n }\r\n memcpy((codec -> extradata),(icodec -> extradata),(icodec -> extradata_size));\r\n codec -> extradata_size = icodec -> extradata_size;\r\n codec -> bits_per_coded_sample = icodec -> bits_per_coded_sample;\r\n codec -> time_base = ist -> st -> time_base;\r\n\r\n if (!strcmp(oc -> oformat -> name,\"avi\")) {\r\n if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {\r\n codec -> time_base . num = ist -> st -> r_frame_rate . den;\r\n codec -> time_base . den = 2 * ist -> st -> r_frame_rate . num;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n else {\r\n if (copy_tb < 0 && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > 2 * av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n codec -> time_base . den *= 2;\r\n codec -> ticks_per_frame = 2;\r\n }\r\n }\r\n }\r\n else {\r\n if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,\"mov\") && strcmp(oc -> oformat -> name,\"mp4\") && strcmp(oc -> oformat -> name,\"3gp\") && strcmp(oc -> oformat -> name,\"3g2\") && strcmp(oc -> oformat -> name,\"psp\") && strcmp(oc -> oformat -> name,\"ipod\") && strcmp(oc -> oformat -> name,\"f4v\")) {\r\n if (copy_tb < 0 && icodec -> time_base . den && av_q2d(icodec -> time_base) * (icodec -> ticks_per_frame) > av_q2d(ist -> st -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 || copy_tb == 0) {\r\n codec -> time_base = icodec -> time_base;\r\n codec -> time_base . num *= icodec -> ticks_per_frame;\r\n }\r\n }\r\n }\r\n if (codec -> codec_tag == ((const union unaligned_32 *)\"tmcd\") -> l && icodec -> time_base . num < icodec -> time_base . den && icodec -> time_base . num > 0 && 121LL * icodec -> time_base . num > icodec -> time_base . den) {\r\n codec -> time_base = icodec -> time_base;\r\n }\r\n if (ost -> frame_rate . num) {\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n }\r\n av_reduce(&codec -> time_base . num,&codec -> time_base . den,codec -> time_base . num,codec -> time_base . den,2147483647);\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n if (audio_volume != 256) {\r\n av_log(((void *)0),8,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\r\n exit(1);\r\n }\r\n codec -> channel_layout = icodec -> channel_layout;\r\n codec -> sample_rate = icodec -> sample_rate;\r\n codec -> channels = icodec -> channels;\r\n codec -> frame_size = icodec -> frame_size;\r\n codec -> audio_service_type = icodec -> audio_service_type;\r\n codec -> block_align = icodec -> block_align;\r\n if ((codec -> block_align == 1 || codec -> block_align == 1152 || codec -> block_align == 576) && (codec -> codec_id) == AV_CODEC_ID_MP3) {\r\n codec -> block_align = 0;\r\n }\r\n if ((codec -> codec_id) == AV_CODEC_ID_AC3) {\r\n codec -> block_align = 0;\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> pix_fmt = icodec -> pix_fmt;\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n codec -> has_b_frames = icodec -> has_b_frames;\r\n if (!codec -> sample_aspect_ratio . num) {\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ist -> st -> sample_aspect_ratio . num?ist -> st -> sample_aspect_ratio : ((ist -> st -> codec -> sample_aspect_ratio . num?ist -> st -> codec -> sample_aspect_ratio : ((AVRational ){(0), (1)}))));\r\n }\r\n ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> width = icodec -> width;\r\n codec -> height = icodec -> height;\r\n break; \r\n }\r\n case AVMEDIA_TYPE_DATA:\r\n{\r\n }\r\n case AVMEDIA_TYPE_ATTACHMENT:\r\n break; \r\n default:\r\n abort();\r\n }\r\n }\r\n else {\r\n if (!ost -> enc) {\r\n ost -> enc = avcodec_find_encoder(codec -> codec_id);\r\n }\r\n if (!ost -> enc) {\r\n\r\n snprintf(error,sizeof(error),\"Encoder (codec %s) not found for output stream #%d:%d\",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n if (ist) {\r\n ist -> decoding_needed++;\r\n }\r\n ost -> encoding_needed = 1;\r\n if (!ost -> filter && ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO || (codec -> codec_type) == AVMEDIA_TYPE_AUDIO)) {\r\n FilterGraph *fg;\r\n fg = init_simple_filtergraph(ist,ost);\r\n if (configure_filtergraph(fg)) {\r\n av_log(((void *)0),8,\"Error opening filters!\\n\");\r\n exit(1);\r\n }\r\n }\r\n if ((codec -> codec_type) == AVMEDIA_TYPE_VIDEO) {\r\n if (ost -> filter && !ost -> frame_rate . num) {\r\n ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = ist -> framerate;\r\n }\r\n if (ist && !ost -> frame_rate . num) {\r\n ost -> frame_rate = (ist -> st -> r_frame_rate . num?ist -> st -> r_frame_rate : ((AVRational ){(25), (1)}));\r\n }\r\n\r\n if (ost -> enc && ost -> enc -> supported_framerates && !ost -> force_fps) {\r\n int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);\r\n ost -> frame_rate = ost -> enc -> supported_framerates[idx];\r\n }\r\n }\r\n switch(codec -> codec_type){\r\n case AVMEDIA_TYPE_AUDIO:\r\n{\r\n codec -> sample_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n codec -> sample_rate = ost -> filter -> filter -> inputs[0] -> sample_rate;\r\n codec -> channel_layout = ost -> filter -> filter -> inputs[0] -> channel_layout;\r\n codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);\r\n codec -> time_base = ((AVRational ){(1), codec -> sample_rate});\r\n break; \r\n }\r\n case AVMEDIA_TYPE_VIDEO:\r\n{\r\n codec -> time_base = av_inv_q(ost -> frame_rate);\r\n if (ost -> filter && !(codec -> time_base . num && codec -> time_base . den)) {\r\n codec -> time_base = ost -> filter -> filter -> inputs[0] -> time_base;\r\n }\r\n if (av_q2d(codec -> time_base) < 0.001 && video_sync_method != 0 && (video_sync_method == 1 || video_sync_method == - 1 && !(oc -> oformat -> flags & 0002000))) {\r\n av_log(oc,24,\"Frame rate very high for a muxer not efficiently supporting it.\\nPlease consider specifying a lower framerate, a different muxer or -vsync 2\\n\");\r\n }\r\n for (j = 0; j < ost -> forced_kf_count; j++) \r\n ost -> forced_kf_pts[j] = av_rescale_q(ost -> forced_kf_pts[j],((AVRational ){(1), (1000000)}),codec -> time_base);\r\n codec -> width = ost -> filter -> filter -> inputs[0] -> w;\r\n codec -> height = ost -> filter -> filter -> inputs[0] -> h;\r\n codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);\r\n\r\n codec -> pix_fmt = (ost -> filter -> filter -> inputs[0] -> format);\r\n if (!icodec || codec -> width != icodec -> width || codec -> height != icodec -> height || (codec -> pix_fmt) != (icodec -> pix_fmt)) {\r\n codec -> bits_per_raw_sample = frame_bits_per_raw_sample;\r\n }\r\n if (ost -> forced_keyframes) {\r\n if (!strncmp((ost -> forced_keyframes),\"expr:\",5)) {\r\n ret = av_expr_parse(&ost -> forced_keyframes_pexpr,(ost -> forced_keyframes + 5),forced_keyframes_const_names,((void *)0),((void *)0),((void *)0),((void *)0),0,((void *)0));\r\n if (ret < 0) {\r\n av_log(((void *)0),16,\"Invalid force_key_frames expression '%s'\\n\",ost -> forced_keyframes + 5);\r\n return ret;\r\n }\r\n ost -> forced_keyframes_expr_const_values[FKF_N] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_N_FORCED] = 0;\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_N] = (__builtin_nanf(\"\"));\r\n ost -> forced_keyframes_expr_const_values[FKF_PREV_FORCED_T] = (__builtin_nanf(\"\"));\r\n }\r\n else {\r\n parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);\r\n }\r\n }\r\n break; \r\n }\r\n case AVMEDIA_TYPE_SUBTITLE:\r\n{\r\n codec -> time_base = ((AVRational ){(1), (1000)});\r\n if (!codec -> width) {\r\n codec -> width = input_streams[ost -> source_index] -> st -> codec -> width;\r\n codec -> height = input_streams[ost -> source_index] -> st -> codec -> height;\r\n }\r\n break; \r\n }\r\n default:\r\n{\r\n abort();\r\n break; \r\n }\r\n }\r\n\r\n if (codec -> flags & (0x0200 | 0002000)) {\r\n char logfilename[1024];\r\n FILE *f;\r\n snprintf(logfilename,sizeof(logfilename),\"%s-%d.log\",(ost -> logfile_prefix?ost -> logfile_prefix : \"ffmpeg2pass\"),i);\r\n if (!strcmp(ost -> enc -> name,\"libx264\")) {\r\n av_dict_set(&ost -> opts,\"stats\",logfilename,16);\r\n }\r\n else {\r\n if (codec -> flags & 0002000) {\r\n char *logbuffer;\r\n size_t logbuffer_size;\r\n if (cmdutils_read_file(logfilename,&logbuffer,&logbuffer_size) < 0) {\r\n av_log(((void *)0),8,\"Error reading log file '%s' for pass-2 encoding\\n\",logfilename);\r\n exit(1);\r\n }\r\n codec -> stats_in = logbuffer;\r\n }\r\n if (codec -> flags & 0x0200) {\r\n f = fopen(logfilename,\"wb\");\r\n if (!f) {\r\n av_log(((void *)0),8,\"Cannot write log file '%s' for pass-1 encoding: %s\\n\",logfilename,strerror( *__errno_location()));\r\n exit(1);\r\n }\r\n ost -> logfile = f;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n AVCodec *codec = ost -> enc;\r\n AVCodecContext *dec = ((void *)0);\r\n if (ist = get_input_stream(ost)) {\r\n dec = ist -> st -> codec;\r\n }\r\n if (dec && dec -> subtitle_header) {\r\n\r\n ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));\r\n if (!ost -> st -> codec -> subtitle_header) {\r\n ret = - 12;\r\n goto dump_format;\r\n }\r\n memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));\r\n ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;\r\n }\r\n if (!av_dict_get(ost -> opts,\"threads\",((void *)0),0)) {\r\n av_dict_set(&ost -> opts,\"threads\",\"auto\",0);\r\n }\r\n if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {\r\n if (ret == - 0x2bb2afa8) {\r\n abort_codec_experimental(codec,1);\r\n }\r\n snprintf(error,sizeof(error),\"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height\",ost -> file_index,ost -> index);\r\n goto dump_format;\r\n }\r\n if ((ost -> enc -> type) == AVMEDIA_TYPE_AUDIO && !(ost -> enc -> capabilities & 0x10000)) {\r\n av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));\r\n }\r\n assert_avoptions(ost -> opts);\r\n if (ost -> st -> codec -> bit_rate && ost -> st -> codec -> bit_rate < 1000) {\r\n av_log(((void *)0),24,\"The bitrate parameter is set too low. It takes bits/s as argument, not kbits/s\\n\");\r\n }\r\n extra_size += (ost -> st -> codec -> extradata_size);\r\n if (ost -> st -> codec -> me_threshold) {\r\n input_streams[ost -> source_index] -> st -> codec -> debug |= 32;\r\n }\r\n }\r\n else {\r\n av_opt_set_dict((ost -> st -> codec),&ost -> opts);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) \r\n if ((ret = init_input_stream(i,error,(sizeof(error)))) < 0) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n goto dump_format;\r\n }\r\n\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *ifile = input_files[i];\r\n for (j = 0; j < ifile -> ctx -> nb_programs; j++) {\r\n AVProgram *p = ifile -> ctx -> programs[j];\r\n int discard = AVDISCARD_ALL;\r\n for (k = 0; k < p -> nb_stream_indexes; k++) \r\n if (!input_streams[(ifile -> ist_index) + p -> stream_index[k]] -> discard) {\r\n discard = AVDISCARD_DEFAULT;\r\n break; \r\n }\r\n p -> discard = discard;\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n oc = output_files[i] -> ctx;\r\n oc -> interrupt_callback = int_cb;\r\n if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {\r\n char errbuf[128];\r\n const char *errbuf_ptr = errbuf;\r\n if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {\r\n errbuf_ptr = (strerror(-ret));\r\n }\r\n snprintf(error,sizeof(error),\"Could not write header for output file #%d (incorrect codec parameters ?): %s\",i,errbuf_ptr);\r\n ret = - 22;\r\n goto dump_format;\r\n }\r\n\r\n if (strcmp(oc -> oformat -> name,\"rtp\")) {\r\n want_sdp = 0;\r\n }\r\n }\r\n dump_format:\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n av_dump_format(output_files[i] -> ctx,i,(output_files[i] -> ctx -> filename),1);\r\n }\r\n\r\n av_log(((void *)0),32,\"Stream mapping:\\n\");\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n for (j = 0; j < ist -> nb_filters; j++) {\r\n if (ist -> filters[j] -> graph -> graph_desc) {\r\n av_log(((void *)0),32,\" Stream #%d:%d (%s) -> %s\",ist -> file_index,ist -> st -> index,(ist -> dec?ist -> dec -> name : \"?\"),ist -> filters[j] -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ist -> filters[j] -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n }\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> attachment_filename) {\r\n\r\n av_log(((void *)0),32,\" File %s -> Stream #%d:%d\\n\",ost -> attachment_filename,ost -> file_index,ost -> index);\r\n continue; \r\n }\r\n if (ost -> filter && ost -> filter -> graph -> graph_desc) {\r\n\r\n av_log(((void *)0),32,\" %s\",ost -> filter -> name);\r\n if (nb_filtergraphs > 1) {\r\n av_log(((void *)0),32,\" (graph %d)\",ost -> filter -> graph -> index);\r\n }\r\n av_log(((void *)0),32,\" -> Stream #%d:%d (%s)\\n\",ost -> file_index,ost -> index,(ost -> enc?ost -> enc -> name : \"?\"));\r\n continue; \r\n }\r\n av_log(((void *)0),32,\" Stream #%d:%d -> #%d:%d\",input_streams[ost -> source_index] -> file_index,input_streams[ost -> source_index] -> st -> index,ost -> file_index,ost -> index);\r\n if (ost -> sync_ist != input_streams[ost -> source_index]) {\r\n av_log(((void *)0),32,\" [sync #%d:%d]\",ost -> sync_ist -> file_index,ost -> sync_ist -> st -> index);\r\n }\r\n if (ost -> stream_copy) {\r\n av_log(((void *)0),32,\" (copy)\");\r\n }\r\n else {\r\n av_log(((void *)0),32,\" (%s -> %s)\",(input_streams[ost -> source_index] -> dec?input_streams[ost -> source_index] -> dec -> name : \"?\"),(ost -> enc?ost -> enc -> name : \"?\"));\r\n }\r\n av_log(((void *)0),32,\"\\n\");\r\n }\r\n if (ret) {\r\n av_log(((void *)0),16,\"%s\\n\",error);\r\n return ret;\r\n }\r\n if (want_sdp) {\r\n print_sdp();\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int need_output()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n OutputFile *of = output_files[ost -> file_index];\r\n AVFormatContext *os = output_files[ost -> file_index] -> ctx;\r\n if (ost -> finished || os -> pb && (avio_tell(os -> pb)) >= of -> limit_filesize) {\r\n continue; \r\n }\r\n if ((ost -> frame_number) >= ost -> max_frames) {\r\n int j;\r\n for (j = 0; j < of -> ctx -> nb_streams; j++) \r\n close_output_stream(output_streams[of -> ost_index + j]);\r\n continue; \r\n }\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic OutputStream *choose_output()\r\n{\r\n int i;\r\n int64_t opts_min = 9223372036854775807L;\r\n OutputStream *ost_min = ((void *)0);\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n int64_t opts = av_rescale_q(ost -> st -> cur_dts,ost -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n if (!ost -> unavailable && !ost -> finished && opts < opts_min) {\r\n opts_min = opts;\r\n ost_min = ost;\r\n }\r\n }\r\n return ost_min;\r\n}\r\n\r\nstatic int check_keyboard_interaction(int64_t cur_time)\r\n{\r\n int i;\r\n int ret;\r\n int key;\r\n static int64_t last_time;\r\n if (received_nb_signals) {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n\r\n if (cur_time - last_time >= 100000 && !run_as_daemon) {\r\n key = read_key();\r\n last_time = cur_time;\r\n }\r\n else {\r\n key = - 1;\r\n }\r\n if (key == 'q') {\r\n return -((int )(('E' | 'X' << 8 | 'I' << 16) | ((unsigned int )'T') << 24));\r\n }\r\n if (key == '+') {\r\n av_log_set_level(av_log_get_level() + 10);\r\n }\r\n if (key == '-') {\r\n av_log_set_level(av_log_get_level() - 10);\r\n }\r\n if (key == 's') {\r\n qp_hist ^= 1;\r\n }\r\n if (key == 'h') {\r\n if (do_hex_dump) {\r\n do_hex_dump = do_pkt_dump = 0;\r\n }\r\n else {\r\n if (do_pkt_dump) {\r\n do_hex_dump = 1;\r\n }\r\n else {\r\n do_pkt_dump = 1;\r\n }\r\n }\r\n av_log_set_level(48);\r\n }\r\n if (key == 'c' || key == 'C') {\r\n char buf[4096];\r\n char target[64];\r\n char command[256];\r\n char arg[256] = {(0)};\r\n double time;\r\n int k;\r\n int n = 0;\r\n fprintf(stderr,\"\\nEnter command: <target> <time> <command>[ <argument>]\\n\");\r\n i = 0;\r\n while((k = read_key()) != 10 && k != '\\r' && i < sizeof(buf) - 1)\r\n if (k > 0) {\r\n buf[i++] = k;\r\n }\r\n buf[i] = 0;\r\n if (k > 0 && (n = sscanf(buf,\"%63[^ ] %lf %255[^ ] %255[^\\n]\",target,&time,command,arg)) >= 3) {\r\n av_log(((void *)0),48,\"Processing command target:%s time:%f command:%s arg:%s\",target,time,command,arg);\r\n for (i = 0; i < nb_filtergraphs; i++) {\r\n FilterGraph *fg = filtergraphs[i];\r\n if (fg -> graph) {\r\n if (time < 0) {\r\n ret = avfilter_graph_send_command(fg -> graph,target,command,arg,buf,(sizeof(buf)),(key == 'c'?1 : 0));\r\n fprintf(stderr,\"Command reply for stream %d: ret:%d res:%s\\n\",i,ret,buf);\r\n }\r\n else {\r\n ret = avfilter_graph_queue_command(fg -> graph,target,command,arg,0,time);\r\n }\r\n }\r\n }\r\n }\r\n else {\r\n av_log(((void *)0),16,\"Parse error, at least 3 arguments were expected, only %d given in string '%s'\\n\",n,buf);\r\n }\r\n }\r\n if (key == 100 || key == 'D') {\r\n int debug = 0;\r\n if (key == 'D') {\r\n debug = input_streams[0] -> st -> codec -> debug << 1;\r\n if (!debug) {\r\n debug = 1;\r\n }\r\n\r\n while(debug & (0000100 | 0x00002000 | 0x4000))\r\n debug += debug;\r\n }\r\n else {\r\n if (scanf(\"%d\",&debug) != 1) {\r\n fprintf(stderr,\"error parsing debug value\\n\");\r\n }\r\n }\r\n for (i = 0; i < nb_input_streams; i++) {\r\n input_streams[i] -> st -> codec -> debug = debug;\r\n }\r\n for (i = 0; i < nb_output_streams; i++) {\r\n OutputStream *ost = output_streams[i];\r\n ost -> st -> codec -> debug = debug;\r\n }\r\n if (debug) {\r\n av_log_set_level(48);\r\n }\r\n fprintf(stderr,\"debug=%d\\n\",debug);\r\n }\r\n if (key == 63) {\r\n fprintf(stderr,\"key function\\n? show this help\\n+ increase verbosity\\n- decrease verbosity\\nc Send command to filtergraph\\nD cycle through available debug modes\\nh dump packets/hex press to cycle through the 3 states\\nq quit\\ns Show QP histogram\\n\");\r\n }\r\n return 0;\r\n}\r\n#if HAVE_PTHREADS\r\n\r\nstatic void *input_thread(void *arg)\r\n{\r\n InputFile *f = arg;\r\n int ret = 0;\r\n while(!transcoding_finished && ret >= 0){\r\n AVPacket pkt;\r\n ret = av_read_frame(f -> ctx,&pkt);\r\n if (ret == - 11) {\r\n av_usleep(10000);\r\n ret = 0;\r\n continue; \r\n }\r\n else {\r\n if (ret < 0) {\r\n break; \r\n }\r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(!av_fifo_space(f -> fifo))\r\n pthread_cond_wait(&f -> fifo_cond,&f -> fifo_lock);\r\n av_dup_packet(&pkt);\r\n av_fifo_generic_write(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n }\r\n f -> finished = 1;\r\n return (void *)0;\r\n}\r\n\r\nstatic void free_input_threads()\r\n{\r\n int i;\r\n if (nb_input_files == 1) {\r\n return ;\r\n }\r\n transcoding_finished = 1;\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n AVPacket pkt;\r\n if (!f -> fifo || f -> joined) {\r\n continue; \r\n }\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n pthread_cond_signal(&f -> fifo_cond);\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n pthread_join(f -> thread,((void *)0));\r\n f -> joined = 1;\r\n while(av_fifo_size(f -> fifo)){\r\n av_fifo_generic_read(f -> fifo,(&pkt),(sizeof(pkt)),((void *)0));\r\n av_free_packet(&pkt);\r\n }\r\n av_fifo_free(f -> fifo);\r\n }\r\n}\r\n\r\nstatic int init_input_threads()\r\n{\r\n int i;\r\n int ret;\r\n if (nb_input_files == 1) {\r\n return 0;\r\n }\r\n for (i = 0; i < nb_input_files; i++) {\r\n InputFile *f = input_files[i];\r\n if (!(f -> fifo = av_fifo_alloc((8 * sizeof(AVPacket ))))) {\r\n return - 12;\r\n }\r\n pthread_mutex_init(&f -> fifo_lock,((void *)0));\r\n pthread_cond_init(&f -> fifo_cond,((void *)0));\r\n if (ret = pthread_create(&f -> thread,((void *)0),input_thread,f)) {\r\n return -ret;\r\n }\r\n }\r\n return 0;\r\n}\r\n\r\nstatic int get_input_packet_mt(InputFile *f,AVPacket *pkt)\r\n{\r\n int ret = 0;\r\n pthread_mutex_lock(&f -> fifo_lock);\r\n if (av_fifo_size(f -> fifo)) {\r\n av_fifo_generic_read(f -> fifo,pkt,(sizeof(( *pkt))),((void *)0));\r\n pthread_cond_signal(&f -> fifo_cond);\r\n }\r\n else {\r\n if (f -> finished) {\r\n ret = -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n else {\r\n ret = - 11;\r\n }\r\n }\r\n pthread_mutex_unlock(&f -> fifo_lock);\r\n return ret;\r\n}\r\n#endif\r\n\r\nstatic int get_input_packet(InputFile *f,AVPacket *pkt)\r\n{\r\n#if HAVE_PTHREADS\r\n if (nb_input_files > 1) {\r\n return get_input_packet_mt(f,pkt);\r\n }\r\n#endif\r\n return av_read_frame(f -> ctx,pkt);\r\n}\r\n\r\nstatic int got_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_output_streams; i++) \r\n if (output_streams[i] -> unavailable) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nstatic void reset_eagain()\r\n{\r\n int i;\r\n for (i = 0; i < nb_input_files; i++) \r\n input_files[i] -> eagain = 0;\r\n for (i = 0; i < nb_output_streams; i++) \r\n output_streams[i] -> unavailable = 0;\r\n}\r\n\r\n\r\nstatic int process_input(int file_index)\r\n{\r\n InputFile *ifile = input_files[file_index];\r\n AVFormatContext *is;\r\n InputStream *ist;\r\n AVPacket pkt;\r\n int ret;\r\n int i;\r\n int j;\r\n is = ifile -> ctx;\r\n ret = get_input_packet(ifile,&pkt);\r\n if (ret == - 11) {\r\n ifile -> eagain = 1;\r\n return ret;\r\n }\r\n if (ret < 0) {\r\n if (ret != -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n print_error((is -> filename),ret);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n ifile -> eof_reached = 1;\r\n for (i = 0; i < ifile -> nb_streams; i++) {\r\n ist = input_streams[ifile -> ist_index + i];\r\n if (ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n\r\n for (j = 0; j < nb_output_streams; j++) {\r\n OutputStream *ost = output_streams[j];\r\n if (ost -> source_index == ifile -> ist_index + i && (ost -> stream_copy || (ost -> enc -> type) == AVMEDIA_TYPE_SUBTITLE)) {\r\n close_output_stream(ost);\r\n }\r\n }\r\n }\r\n return - 11;\r\n }\r\n reset_eagain();\r\n if (do_pkt_dump) {\r\n av_pkt_dump_log2(((void *)0),48,&pkt,do_hex_dump,is -> streams[pkt . stream_index]);\r\n }\r\n\r\n if (pkt . stream_index >= ifile -> nb_streams) {\r\n report_new_stream(file_index,&pkt);\r\n goto discard_packet;\r\n }\r\n ist = input_streams[ifile -> ist_index + pkt . stream_index];\r\n if (ist -> discard) {\r\n goto discard_packet;\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer -> ist_index:%d type:%s next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),ist -> next_dts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_dts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),ist -> next_pts),av_ts_make_time_string(((char [32]){(0)}),ist -> next_pts,&((AVRational ){(1), (1000000)})),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n if (!ist -> wrap_correction_done && is -> start_time != ((int64_t )0x8000000000000000UL) && ist -> st -> pts_wrap_bits < 64) {\r\n int64_t stime;\r\n int64_t stime2;\r\n\r\n\r\n\r\n if (ist -> next_dts == ((int64_t )0x8000000000000000UL) && ifile -> ts_offset == -is -> start_time && is -> iformat -> flags & 0x0200) {\r\n int64_t new_start_time = 9223372036854775807L;\r\n for (i = 0; i < is -> nb_streams; i++) {\r\n AVStream *st = is -> streams[i];\r\n if ((st -> discard) == AVDISCARD_ALL || st -> start_time == ((int64_t )0x8000000000000000UL)) {\r\n continue; \r\n }\r\n new_start_time = (new_start_time > av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)}))?av_rescale_q(st -> start_time,st -> time_base,((AVRational ){(1), (1000000)})) : new_start_time);\r\n }\r\n if (new_start_time > is -> start_time) {\r\n av_log(is,40,\"Correcting start time by %ld\\n\",new_start_time - is -> start_time);\r\n ifile -> ts_offset = -new_start_time;\r\n }\r\n }\r\n stime = av_rescale_q(is -> start_time,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n stime2 = (stime + (1ULL << ist -> st -> pts_wrap_bits));\r\n ist -> wrap_correction_done = 1;\r\n if (stime2 > stime && pkt . dts != ((int64_t )0x8000000000000000UL) && pkt . dts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . dts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n if (stime2 > stime && pkt . pts != ((int64_t )0x8000000000000000UL) && pkt . pts > stime + (1LL << ist -> st -> pts_wrap_bits - 1)) {\r\n pkt . pts -= 1ULL << ist -> st -> pts_wrap_bits;\r\n ist -> wrap_correction_done = 0;\r\n }\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts += av_rescale_q(ifile -> ts_offset,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . dts *= ist -> ts_scale;\r\n }\r\n if (pkt . dts != ((int64_t )0x8000000000000000UL) && ist -> next_dts != ((int64_t )0x8000000000000000UL) && !copy_ts) {\r\n int64_t pkt_dts = av_rescale_q(pkt . dts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n int64_t delta = pkt_dts - ist -> next_dts;\r\n if (is -> iformat -> flags & 0x0200) {\r\n if (delta < (- 1LL) * dts_delta_threshold * 1000000 || delta > 1LL * dts_delta_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE || pkt_dts + 1 < ist -> pts) {\r\n ifile -> ts_offset -= delta;\r\n av_log(((void *)0),48,\"timestamp discontinuity %ld, new offset= %ld\\n\",delta,ifile -> ts_offset);\r\n pkt . dts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n pkt . pts -= av_rescale_q(delta,((AVRational ){(1), (1000000)}),ist -> st -> time_base);\r\n }\r\n }\r\n }\r\n else {\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"DTS %ld, next:%ld st:%d invalid dropping\\n\",pkt . dts,ist -> next_dts,pkt . stream_index);\r\n pkt . dts = ((int64_t )0x8000000000000000UL);\r\n }\r\n if (pkt . pts != ((int64_t )0x8000000000000000UL)) {\r\n int64_t pkt_pts = av_rescale_q(pkt . pts,ist -> st -> time_base,((AVRational ){(1), (1000000)}));\r\n delta = pkt_pts - ist -> next_dts;\r\n if (delta < (- 1LL) * dts_error_threshold * 1000000 || delta > 1LL * dts_error_threshold * 1000000 && (ist -> st -> codec -> codec_type) != AVMEDIA_TYPE_SUBTITLE) {\r\n av_log(((void *)0),24,\"PTS %ld, next:%ld invalid dropping st:%d\\n\",pkt . pts,ist -> next_dts,pkt . stream_index);\r\n pkt . pts = ((int64_t )0x8000000000000000UL);\r\n }\r\n }\r\n }\r\n }\r\n if (debug_ts) {\r\n av_log(((void *)0),32,\"demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s off:%s off_time:%s\\n\",ifile -> ist_index + pkt . stream_index,av_get_media_type_string(ist -> st -> codec -> codec_type),av_ts_make_string(((char [32]){(0)}),pkt . pts),av_ts_make_time_string(((char [32]){(0)}),pkt . pts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),pkt . dts),av_ts_make_time_string(((char [32]){(0)}),pkt . dts,&ist -> st -> time_base),av_ts_make_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset),av_ts_make_time_string(((char [32]){(0)}),input_files[ist -> file_index] -> ts_offset,&((AVRational ){(1), (1000000)})));\r\n }\r\n sub2video_heartbeat(ist,pkt . pts);\r\n ret = output_packet(ist,(&pkt));\r\n if (ret < 0) {\r\n char buf[128];\r\n av_strerror(ret,buf,sizeof(buf));\r\n av_log(((void *)0),16,\"Error while decoding stream #%d:%d: %s\\n\",ist -> file_index,ist -> st -> index,buf);\r\n if (exit_on_error) {\r\n exit(1);\r\n }\r\n }\r\n discard_packet:\r\n av_free_packet(&pkt);\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)\r\n{\r\n int i;\r\n int ret;\r\n int nb_requests;\r\n int nb_requests_max = 0;\r\n InputFilter *ifilter;\r\n InputStream *ist;\r\n *best_ist = ((void *)0);\r\n ret = avfilter_graph_request_oldest(graph -> graph);\r\n if (ret >= 0) {\r\n return reap_filters();\r\n }\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))) {\r\n ret = reap_filters();\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n close_output_stream(graph -> outputs[i] -> ost);\r\n return ret;\r\n }\r\n if (ret != - 11) {\r\n return ret;\r\n }\r\n for (i = 0; i < graph -> nb_inputs; i++) {\r\n ifilter = graph -> inputs[i];\r\n ist = ifilter -> ist;\r\n if (input_files[ist -> file_index] -> eagain || input_files[ist -> file_index] -> eof_reached) {\r\n continue; \r\n }\r\n nb_requests = (av_buffersrc_get_nb_failed_requests(ifilter -> filter));\r\n if (nb_requests > nb_requests_max) {\r\n nb_requests_max = nb_requests;\r\n *best_ist = ist;\r\n }\r\n }\r\n if (!( *best_ist)) {\r\n for (i = 0; i < graph -> nb_outputs; i++) \r\n graph -> outputs[i] -> ost -> unavailable = 1;\r\n }\r\n return 0;\r\n}\r\n\r\n\r\nstatic int transcode_step()\r\n{\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int ret;\r\n ost = choose_output();\r\n if (!ost) {\r\n if (got_eagain()) {\r\n reset_eagain();\r\n av_usleep(10000);\r\n return 0;\r\n }\r\n av_log(((void *)0),40,\"No more inputs to read from, finishing.\\n\");\r\n return -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24));\r\n }\r\n if (ost -> filter) {\r\n if ((ret = transcode_from_filter(ost -> filter -> graph,&ist)) < 0) {\r\n return ret;\r\n }\r\n if (!ist) {\r\n return 0;\r\n }\r\n }\r\n else {\r\n do {\r\n if (!(ost -> source_index >= 0)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"ost->source_index >= 0\",\"ffmpeg.c\",3115);\r\n abort();\r\n }\r\n }while (0);\r\n ist = input_streams[ost -> source_index];\r\n }\r\n ret = process_input(ist -> file_index);\r\n if (ret == - 11) {\r\n if (input_files[ist -> file_index] -> eagain) {\r\n ost -> unavailable = 1;\r\n }\r\n return 0;\r\n }\r\n if (ret < 0) {\r\n return ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24))?0 : ret;\r\n }\r\n return reap_filters();\r\n}\r\n\r\n\r\nstatic int transcode()\r\n{\r\n int ret;\r\n int i;\r\n AVFormatContext *os;\r\n OutputStream *ost;\r\n InputStream *ist;\r\n int64_t timer_start;\r\n ret = transcode_init();\r\n if (ret < 0) {\r\n goto fail;\r\n }\r\n if (stdin_interaction) {\r\n av_log(((void *)0),32,\"Press [q] to stop, [?] for help\\n\");\r\n }\r\n timer_start = av_gettime();\r\n#if HAVE_PTHREADS\r\n if ((ret = init_input_threads()) < 0) {\r\n goto fail;\r\n }\r\n#endif\r\n while(!received_sigterm){\r\n int64_t cur_time = av_gettime();\r\n\r\n if (stdin_interaction) {\r\n if (check_keyboard_interaction(cur_time) < 0) {\r\n break; \r\n }\r\n }\r\n\r\n if (!need_output()) {\r\n av_log(((void *)0),40,\"No more output streams to write to, finishing.\\n\");\r\n break; \r\n }\r\n ret = transcode_step();\r\n if (ret < 0) {\r\n if (ret == -((int )(('E' | 'O' << 8 | 'F' << 16) | ((unsigned int )32) << 24)) || ret == - 11) {\r\n continue; \r\n }\r\n av_log(((void *)0),16,\"Error while filtering.\\n\");\r\n break; \r\n }\r\n\r\n print_report(0,timer_start,cur_time);\r\n }\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (!input_files[ist -> file_index] -> eof_reached && ist -> decoding_needed) {\r\n output_packet(ist,((void *)0));\r\n }\r\n }\r\n flush_encoders();\r\n term_exit();\r\n\r\n for (i = 0; i < nb_output_files; i++) {\r\n os = output_files[i] -> ctx;\r\n av_write_trailer(os);\r\n }\r\n\r\n print_report(1,timer_start,av_gettime());\r\n\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost -> encoding_needed) {\r\n av_freep((&ost -> st -> codec -> stats_in));\r\n avcodec_close(ost -> st -> codec);\r\n }\r\n }\r\n\r\n for (i = 0; i < nb_input_streams; i++) {\r\n ist = input_streams[i];\r\n if (ist -> decoding_needed) {\r\n avcodec_close(ist -> st -> codec);\r\n }\r\n }\r\n\r\n ret = 0;\r\n fail:\r\n#if HAVE_PTHREADS\r\n free_input_threads();\r\n#endif\r\n if (output_streams) {\r\n for (i = 0; i < nb_output_streams; i++) {\r\n ost = output_streams[i];\r\n if (ost) {\r\n if (ost -> stream_copy) {\r\n av_freep((&ost -> st -> codec -> extradata));\r\n }\r\n if (ost -> logfile) {\r\n fclose(ost -> logfile);\r\n ost -> logfile = ((void *)0);\r\n }\r\n av_freep((&ost -> st -> codec -> subtitle_header));\r\n av_free((ost -> forced_kf_pts));\r\n av_dict_free(&ost -> opts);\r\n av_dict_free(&ost -> swr_opts);\r\n av_dict_free(&ost -> resample_opts);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int64_t getutime()\r\n{\r\n#if HAVE_GETRUSAGE\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return (rusage . ru_utime . tv_sec * 1000000LL + rusage . ru_utime . tv_usec);\r\n#elif HAVE_GETPROCESSTIMES\r\n#else\r\n#endif\r\n}\r\n\r\nstatic int64_t getmaxrss()\r\n{\r\n#if HAVE_GETRUSAGE && HAVE_STRUCT_RUSAGE_RU_MAXRSS\r\n struct rusage rusage;\r\n getrusage(RUSAGE_SELF,&rusage);\r\n return ((int64_t )rusage . ru_maxrss) * 1024;\r\n#elif HAVE_GETPROCESSMEMORYINFO\r\n#else\r\n#endif\r\n}\r\n\r\nstatic void log_callback_null(void *ptr,int level,const char *fmt,va_list vl)\r\n{\r\n}\r\n#if TRACE\r\n\r\nstatic void do_atexit_tracepoint()\r\n{\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_end . state)),0)) {\r\n __tracepoint_cb_trace___trace_end();\r\n }\r\n }while (0);\r\n}\r\n#endif\r\n\r\nint main(int argc,char **argv)\r\n{\r\n #if TRACE\r\n do {\r\n ;\r\n if (__builtin_expect((!(!__tracepoint_trace___trace_start . state)),0)) {\r\n __tracepoint_cb_trace___trace_start(\"ffmpeg\");\r\n }\r\n }while (0);\r\n atexit(do_atexit_tracepoint);\r\n #endif\r\n int ret;\r\n int64_t ti;\r\n atexit(exit_program);\r\n\r\n setvbuf(stderr,((void *)0),2,0);\r\n av_log_set_flags(1);\r\n parse_loglevel(argc,argv,options);\r\n if (argc > 1 && !strcmp(argv[1],\"-d\")) {\r\n run_as_daemon = 1;\r\n av_log_set_callback(log_callback_null);\r\n argc--;\r\n argv++;\r\n }\r\n avcodec_register_all();\r\n#if CONFIG_AVDEVICE\r\n avdevice_register_all();\r\n#endif\r\n avfilter_register_all();\r\n av_register_all();\r\n avformat_network_init();\r\n show_banner(argc,argv,options);\r\n term_init();\r\n\r\n ret = ffmpeg_parse_options(argc,argv);\r\n if (ret < 0) {\r\n exit(1);\r\n }\r\n if (nb_output_files <= 0 && nb_input_files == 0) {\r\n show_usage();\r\n av_log(((void *)0),24,\"Use -h to get full help or, even better, run 'man %s'\\n\",program_name);\r\n exit(1);\r\n }\r\n\r\n if (nb_output_files <= 0) {\r\n av_log(((void *)0),8,\"At least one output file must be specified\\n\");\r\n exit(1);\r\n }\r\n\r\n\r\n\r\n\r\n current_time = (ti = getutime());\r\n if (transcode() < 0) {\r\n exit(1);\r\n }\r\n ti = getutime() - ti;\r\n if (do_benchmark) {\r\n printf(\"bench: utime=%0.3fs\\n\",ti / 1000000.0);\r\n }\r\n exit((received_nb_signals?255 : 0));\r\n return 0;\r\n}\r\n\r\nvoid reticence_pneumobranchia(const strums_obstructivism shaniko_backstays)\r\n{\r\n int causers_cosonant = 7;\r\n ++global_variable;;\r\n spck_commelinaceae(causers_cosonant,shaniko_backstays);\r\n}\r\n\r\nvoid spck_commelinaceae(int locustid_neutralities,strums_obstructivism overgown_nymphette)\r\n{\r\n char buffer[100];\r\n FILE *fpipe = 0;\r\n char cmd_string[1000] = {0};\r\n int is_valid = 1;\r\n int i = 0;\r\n char base_cmd[1000];\r\n char *burt_mismeets = 0;\r\n ++global_variable;\r\n locustid_neutralities--;\r\n if (locustid_neutralities > 0) {\r\n spck_commelinaceae(locustid_neutralities,overgown_nymphette);\r\n return ;\r\n }\r\n burt_mismeets = ((char *)((strums_obstructivism )overgown_nymphette));\r\n \r\n snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt//workspace/testData/temp\" );\r\n \r\n for (; i < strlen(burt_mismeets); ++i) {\r\n if (burt_mismeets[i] == ';') {\r\n if (i == 0 || burt_mismeets[i - 1] != '\\\\') {\r\n is_valid = 0;\r\n break;\r\n }\r\n }\r\n }\r\n if (is_valid == 1) {\r\n \r\n\r\n snprintf(cmd_string,1000,\"%s%s\",base_cmd,burt_mismeets);\r\n \r\n \r\n \r\n\r\n fpipe = popen(cmd_string,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (((strums_obstructivism )overgown_nymphette) != 0) \r\n free(((char *)((strums_obstructivism )overgown_nymphette)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n fpipe = popen(cmd_string,\"r\");\n if (fpipe != 0) {\n while(fgets(buffer,100,fpipe) != 0) {\n printf(buffer);\n }\n pclose(fpipe);\n }\n```", "cwe": "88"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint galvanographic_racily = 0;\r\n\r\nstruct electrobiology_treasonous \r\n{\r\n char *disenabled_endeign;\r\n double landskip_cumming;\r\n char *coact_factionism;\r\n char tympani_darcey;\r\n int mesotherm_retaker;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *tettigoniidae_theravada = 0;\r\n jmp_buf unsoundnesses_blackberries;\r\n int jger_tintamar;\r\n struct electrobiology_treasonous rsfsr_pithecus;\r\n char *aft_poudreuse;;\r\n if (__sync_bool_compare_and_swap(&galvanographic_racily,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n aft_poudreuse = getenv(\"LAXER_SICKLY\");\r\n if (aft_poudreuse != 0) {;\r\n rsfsr_pithecus . disenabled_endeign = ((char *)aft_poudreuse);\r\n jger_tintamar = setjmp(unsoundnesses_blackberries);\r\n if (jger_tintamar == 0) {\r\n longjmp(unsoundnesses_blackberries,1);\r\n }\r\n tettigoniidae_theravada = ((char *)rsfsr_pithecus . disenabled_endeign);\r\n \r\n \r\n csv = fopen(tettigoniidae_theravada,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include <openssl/evp.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <sys/wait.h> \r\nint bli_trachyline = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid reapproachable_rerouted(char *const aborting_bisectors);\r\nvoid evp_hash(const char *algorithm_name,char *filename) {\r\n int ii = 0;\r\n FILE *file_stream = 0;\r\n char hash_print_val[129] = {0};\r\n unsigned char file_contents[1024];\r\n size_t file_contents_size = 1024;\r\n size_t file_contents_size_read = 0;\r\n const EVP_MD *md_engine = 0;\r\n unsigned char md_value[64];\r\n unsigned int md_value_len = 0;\r\n EVP_MD_CTX *md_context = 0;\r\n int hash_update_result = 0;\r\n \r\n memset(md_value,0,64);\r\n file_stream = fopen(filename,\"rb\");\r\n if (file_stream != 0) {\r\n md_engine = EVP_get_digestbyname(algorithm_name);\r\n if (md_engine != 0) {\r\n md_context = EVP_MD_CTX_create();\r\n if (md_context != 0) {\r\n if (EVP_DigestInit_ex(md_context,md_engine,0)) {\r\n \r\n while(!feof(file_stream)) {\r\n \r\n memset(file_contents,0,file_contents_size);\r\n file_contents_size_read = fread(file_contents,\r\n sizeof(unsigned char ),file_contents_size,file_stream);\r\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\r\n if (1 != hash_update_result) {\r\n break;\r\n }\r\n }\r\n \r\n if (1 == hash_update_result) {\r\n if (EVP_DigestFinal_ex(md_context,md_value,&md_value_len)) {\r\n for (ii = 0; ii < md_value_len; ++ii) {\r\n sprintf(&hash_print_val[ii * 2],\"%02x\",md_value[ii]);\r\n }\r\n printf(\"%s %s\\n\",hash_print_val,filename);\r\n } else {\r\n printf(\"Failure finalizing hash for file '%s' with algorithm '%s'.\\n\",\r\n filename,algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failure hashing file '%s' with algorithm '%s'.\\n\",filename,algorithm_name);\r\n }\r\n }\r\n EVP_MD_CTX_destroy(md_context);\r\n } else {\r\n printf(\"Could not create a context for hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Could not load hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failed to open file: '%s'\\n\",filename);\r\n }\r\n if (file_stream != 0) {\r\n fclose(file_stream);\r\n file_stream = 0;\r\n }\r\n}\r\nstruct pid_fd {\r\n pid_t pid;\r\n int fd_array[2];\r\n};\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int palmyra_upcrop = 0;\r\n char *tenour_marchpane = 0;\r\n char *galahad_oilpapers;;\r\n if (__sync_bool_compare_and_swap(&bli_trachyline,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n galahad_oilpapers = getenv(\"ASTEREOGNOSIS_ANDRIAS\");\r\n if (galahad_oilpapers != 0) {;\r\n palmyra_upcrop = ((int )(strlen(galahad_oilpapers)));\r\n tenour_marchpane = ((char *)(malloc(palmyra_upcrop + 1)));\r\n if (tenour_marchpane == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(tenour_marchpane,0,palmyra_upcrop + 1);\r\n memcpy(tenour_marchpane,galahad_oilpapers,palmyra_upcrop);\r\n reapproachable_rerouted(tenour_marchpane);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid reapproachable_rerouted(char *const aborting_bisectors)\r\n{\r\n int child_signal = 0;\r\n int child_pids_count = 21;\r\n pid_t child_pids[21];\r\n pid_t child_pid = -1;\r\n int ii = 0;\r\n int jj = 0;\r\n int algorithms_count = 7;\r\n const char *algorithms[7];\r\n struct pid_fd fd_array[21];\r\n int error = 0;\r\n int index = -1;\r\n char buf;\r\n char *totalling_susuidae = 0;\r\n int sniffily_wealthiness;\r\n int cumbernauld_baldberry;\r\n ++global_variable;;\r\n cumbernauld_baldberry = 5;\r\n while(1 == 1){\r\n cumbernauld_baldberry = cumbernauld_baldberry * 2;\r\n cumbernauld_baldberry = cumbernauld_baldberry + 2;\r\n if (cumbernauld_baldberry > 1000) {\r\n break; \r\n }\r\n }\r\n sniffily_wealthiness = cumbernauld_baldberry;\r\n totalling_susuidae = ((char *)((char *)aborting_bisectors));\r\n \r\n algorithms[0] = \"MD5\";\r\n algorithms[1] = \"SHA1\";\r\n algorithms[2] = \"SHA224\";\r\n algorithms[3] = \"SHA256\";\r\n algorithms[4] = \"SHA384\";\r\n algorithms[5] = \"SHA512\";\r\n algorithms[6] = \"RIPEMD160\";\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_pids[ii] = -1;\r\n }\r\n if (!error) {\r\n OPENSSL_add_all_algorithms_noconf();\r\n fflush(stdout);\r\n fflush(stdin);\r\n \r\n for (ii = 0; ii < 3; ++ii) {\r\n for (jj = 0; jj < algorithms_count; ++jj) {\r\n index = jj + ii * algorithms_count;\r\n if (pipe(fd_array[index].fd_array) == -1) {\r\n error = 1;\r\n printf(\"Error opening pipe\\n\");\r\n } else {\r\n child_pid = fork();\r\n if (child_pid >= 0) {\r\n if (child_pid == 0) {\r\n close(fd_array[index].fd_array[0]);\r\n dup2(fd_array[index].fd_array[1], STDOUT_FILENO);\r\n \r\n \r\n evp_hash(algorithms[jj], totalling_susuidae);\r\n \r\n close(fd_array[index].fd_array[1]);\r\n exit(0);\r\n } else {\r\n close(fd_array[index].fd_array[1]);\r\n fd_array[index].pid = child_pid;\r\n continue;\r\n }\r\n } else {\r\n \r\n printf(\"Failed to fork a child process.\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n }\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_signal = 0;\r\n if (fd_array[ii].pid < 1) {\r\n continue;\r\n }\r\n if (-1 == waitpid(fd_array[ii].pid, &child_signal, 0)) {\r\n \r\n printf(\"Failed to wait for child process: %d\\n\",child_signal);\r\n } else {\r\n if (WIFEXITED(child_signal)) {\r\n printf(\"Child process exited with status: %d\\n\",WEXITSTATUS(child_signal));\r\n } else if (WIFSIGNALED(child_signal)) {\r\n \r\n printf(\"Child process received signal: %d\\n\",WTERMSIG(child_signal));\r\n }\r\n while (read(fd_array[ii].fd_array[0], &buf, 1) > 0) {\r\n printf(\"%c\", buf);\r\n }\r\n close(fd_array[ii].fd_array[0]);\r\n }\r\n }\r\n }\r\n \r\n;\r\n if (((char *)aborting_bisectors) != 0) \r\n free(((char *)((char *)aborting_bisectors)));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(!feof(file_stream)) {\n \n memset(file_contents,0,file_contents_size);\n file_contents_size_read = fread(file_contents,\n sizeof(unsigned char ),file_contents_size,file_stream);\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\n if (1 != hash_update_result) {\n break;\n }\n }\n```", "cwe": "400"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <openssl/err.h>\r\n#include <openssl/bio.h>\r\n\r\n#ifndef OPENSSL_NO_ERR\r\n#define ERR_FUNC(func) ERR_PACK(ERR_LIB_BIO,func,0)\r\n#define ERR_REASON(reason) ERR_PACK(ERR_LIB_BIO,0,reason)\r\n#include <string.h> \r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic ERR_STRING_DATA BIO_str_functs[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )100) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"ACPT_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )101) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_accept\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )102) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_BER_GET_HEADER\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )131) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_callback_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )103) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_ctrl\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )120) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gethostbyname\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )104) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_gets\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )105) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_accept_socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )106) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_host_ip\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )107) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_get_port\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )121) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_MAKE_PAIR\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )108) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )109) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )126) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_new_mem_buf\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )123) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )124) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nread0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )125) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )122) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_nwrite0\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )110) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_puts\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )111) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_read\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )112) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_sock_init\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )113) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BIO_write\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )114) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"BUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )127) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )115) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"CONN_STATE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )132) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"DGRAM_SCTP_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )116) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )130) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"FILE_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )129) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"LINEBUFFER_CTRL\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )128) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_READ\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )117) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"MEM_WRITE\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )118) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"SSL_new\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )119) & 0xfffL) * 0x1000 | ((unsigned long )0) & 0xfffL), (\"WSASTARTUP\")}, {(0), (((void *)0))}};\r\nstatic ERR_STRING_DATA BIO_str_reasons[] = {{((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )100) & 0xfffL), (\"accept error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )101) & 0xfffL), (\"bad fopen mode\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )102) & 0xfffL), (\"bad hostname lookup\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )124) & 0xfffL), (\"broken pipe\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )103) & 0xfffL), (\"connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )127) & 0xfffL), (\"EOF on memory BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )104) & 0xfffL), (\"error setting nbio\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )105) & 0xfffL), (\"error setting nbio on accepted socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )106) & 0xfffL), (\"error setting nbio on accept socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )107) & 0xfffL), (\"gethostbyname addr is not af inet\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )125) & 0xfffL), (\"invalid argument\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )108) & 0xfffL), (\"invalid ip address\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )123) & 0xfffL), (\"in use\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )109) & 0xfffL), (\"keepalive\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )110) & 0xfffL), (\"nbio connect error\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )111) & 0xfffL), (\"no accept port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )112) & 0xfffL), (\"no hostname specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )113) & 0xfffL), (\"no port defined\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )114) & 0xfffL), (\"no port specified\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )128) & 0xfffL), (\"no such file\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )115) & 0xfffL), (\"null parameter\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )116) & 0xfffL), (\"tag mismatch\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )117) & 0xfffL), (\"unable to bind socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )118) & 0xfffL), (\"unable to create socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )119) & 0xfffL), (\"unable to listen socket\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )120) & 0xfffL), (\"uninitialized\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )121) & 0xfffL), (\"unsupported method\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )126) & 0xfffL), (\"write to read only BIO\")}, {((((unsigned long )32) & 0xffL) * 0x1000000 | (((unsigned long )0) & 0xfffL) * 0x1000 | ((unsigned long )122) & 0xfffL), (\"WSAStartup\")}, {(0), (((void *)0))}};\r\n#endif\r\nint unforeign_vocationalism = 0;\r\nint global_variable;\r\ntypedef char *sesquiterpene_bridewain;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nsesquiterpene_bridewain piangendo_hectograph(sesquiterpene_bridewain archmonarchy_turlupin);\r\nvoid televising_nook(sesquiterpene_bridewain delegalized_fatbrained);\r\nvoid viritrate_saiff(sesquiterpene_bridewain nasiei_frankly);\r\nvoid protatically_tarrock(sesquiterpene_bridewain eumitosis_memphitic);\r\nvoid reimpress_vachette(sesquiterpene_bridewain supersensually_garages);\r\nvoid eremital_asians(sesquiterpene_bridewain demonstratively_tribunate);\r\nvoid hot_reedplot(sesquiterpene_bridewain outstair_peeving);\r\nvoid vetanda_exr(sesquiterpene_bridewain djailolo_laboured);\r\nvoid diplophonia_cynics(sesquiterpene_bridewain teays_byronics);\r\nvoid radicule_gymnoceratous(sesquiterpene_bridewain deste_ureterectomies);\r\nvoid but_macy(sesquiterpene_bridewain undebating_wasson);\r\nstruct struct {\r\n void (*function_ptr_1)();\r\n unsigned int input_num;\r\n void (*function_ptr_2)();\r\n};\r\nvoid function() {\r\n \r\n}\r\n\r\nvoid ERR_load_BIO_strings()\r\n{\r\n sesquiterpene_bridewain seed_dentalise = 0;\r\n sesquiterpene_bridewain harbour_thyroidean = 0;\r\n char *brucella_sphenomalar;;\r\n if (__sync_bool_compare_and_swap(&unforeign_vocationalism,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n brucella_sphenomalar = getenv(\"UNMUSICAL_AUTOREINFUSION\");\r\n if (brucella_sphenomalar != 0) {;\r\n harbour_thyroidean = brucella_sphenomalar;\r\n seed_dentalise = piangendo_hectograph(harbour_thyroidean);\r\n televising_nook(seed_dentalise);\r\n }\r\n }\r\n }\r\n ;\r\n#ifndef OPENSSL_NO_ERR\r\n if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {\r\n ERR_load_strings(0,BIO_str_functs);\r\n ERR_load_strings(0,BIO_str_reasons);\r\n }\r\n#endif\r\n}\r\n\r\nsesquiterpene_bridewain piangendo_hectograph(sesquiterpene_bridewain archmonarchy_turlupin)\r\n{\r\n ++global_variable;\r\n return archmonarchy_turlupin;\r\n}\r\n\r\nvoid televising_nook(sesquiterpene_bridewain delegalized_fatbrained)\r\n{\r\n ++global_variable;;\r\n viritrate_saiff(delegalized_fatbrained);\r\n}\r\n\r\nvoid viritrate_saiff(sesquiterpene_bridewain nasiei_frankly)\r\n{\r\n ++global_variable;;\r\n protatically_tarrock(nasiei_frankly);\r\n}\r\n\r\nvoid protatically_tarrock(sesquiterpene_bridewain eumitosis_memphitic)\r\n{\r\n ++global_variable;;\r\n reimpress_vachette(eumitosis_memphitic);\r\n}\r\n\r\nvoid reimpress_vachette(sesquiterpene_bridewain supersensually_garages)\r\n{\r\n ++global_variable;;\r\n eremital_asians(supersensually_garages);\r\n}\r\n\r\nvoid eremital_asians(sesquiterpene_bridewain demonstratively_tribunate)\r\n{\r\n ++global_variable;;\r\n hot_reedplot(demonstratively_tribunate);\r\n}\r\n\r\nvoid hot_reedplot(sesquiterpene_bridewain outstair_peeving)\r\n{\r\n ++global_variable;;\r\n vetanda_exr(outstair_peeving);\r\n}\r\n\r\nvoid vetanda_exr(sesquiterpene_bridewain djailolo_laboured)\r\n{\r\n ++global_variable;;\r\n diplophonia_cynics(djailolo_laboured);\r\n}\r\n\r\nvoid diplophonia_cynics(sesquiterpene_bridewain teays_byronics)\r\n{\r\n ++global_variable;;\r\n radicule_gymnoceratous(teays_byronics);\r\n}\r\n\r\nvoid radicule_gymnoceratous(sesquiterpene_bridewain deste_ureterectomies)\r\n{\r\n ++global_variable;;\r\n but_macy(deste_ureterectomies);\r\n}\r\n\r\nvoid but_macy(sesquiterpene_bridewain undebating_wasson)\r\n{\r\n char *byte_4 = 0;\r\n char *byte_3 = 0;\r\n unsigned int *ptr = 0;\r\n struct struct ssS;\r\n char *sweetnesses_frostbitten = 0;\r\n ++global_variable;;\r\n sweetnesses_frostbitten = ((char *)undebating_wasson);\r\n \r\n ssS.function_ptr_1 = function;\r\n ssS.function_ptr_2 = function;\r\n if (strlen(sweetnesses_frostbitten) >= 1 &&\r\n sweetnesses_frostbitten[0] != '-') {\r\n ssS.input_num = strtoul(sweetnesses_frostbitten,0U,16);\r\n ptr = &(ssS.input_num);\r\n if ( *ptr > 65535) {\r\n \r\n \r\n \r\n byte_3 = ((char *)(ptr + 2));\r\n byte_4 = ((char *)(ptr + 3));\r\n *byte_3 = 0;\r\n *byte_4 = 0;\r\n \r\n \r\n \r\n }\r\n \r\n \r\n ssS.function_ptr_2();\r\n \r\n printf(\"Value = %i\\n\", ssS.input_num);\r\n } else if (strlen(sweetnesses_frostbitten) == 0) {\r\n printf(\"Input is empty string\\n\");\r\n } else {\r\n printf(\"Input is negative number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n ssS.function_ptr_2();\n```", "cwe": "682"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {\r\r\n int ret = 0;\r\r\n int avail, tlen;\r\r\n xmlChar cur, next;\r\r\n const xmlChar *lastlt, *lastgt;\r\r\n\r\r\n if (ctxt->input == NULL)\r\r\n return(0);\r\r\n\r\r\n#ifdef DEBUG_PUSH\r\r\n switch (ctxt->instate) {\r\r\n case XML_PARSER_EOF:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try EOF\\n\"); break;\r\r\n case XML_PARSER_START:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try START\\n\"); break;\r\r\n case XML_PARSER_MISC:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try MISC\\n\");break;\r\r\n case XML_PARSER_COMMENT:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try COMMENT\\n\");break;\r\r\n case XML_PARSER_PROLOG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try PROLOG\\n\");break;\r\r\n case XML_PARSER_START_TAG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try START_TAG\\n\");break;\r\r\n case XML_PARSER_CONTENT:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try CONTENT\\n\");break;\r\r\n case XML_PARSER_CDATA_SECTION:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try CDATA_SECTION\\n\");break;\r\r\n case XML_PARSER_END_TAG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try END_TAG\\n\");break;\r\r\n case XML_PARSER_ENTITY_DECL:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try ENTITY_DECL\\n\");break;\r\r\n case XML_PARSER_ENTITY_VALUE:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try ENTITY_VALUE\\n\");break;\r\r\n case XML_PARSER_ATTRIBUTE_VALUE:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try ATTRIBUTE_VALUE\\n\");break;\r\r\n case XML_PARSER_DTD:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try DTD\\n\");break;\r\r\n case XML_PARSER_EPILOG:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try EPILOG\\n\");break;\r\r\n case XML_PARSER_PI:\r\r\n\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try PI\\n\");break;\r\r\n case XML_PARSER_IGNORE:\r\r\n xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: try IGNORE\\n\");break;\r\r\n }\r\r\n#endif\r\r\n\r\r\n if ((ctxt->input != NULL) &&\r\r\n (ctxt->input->cur - ctxt->input->base > 4096)) {\r\r\n\txmlSHRINK(ctxt);\r\r\n\tctxt->checkIndex = 0;\r\r\n }\r\r\n xmlParseGetLasts(ctxt, &lastlt, &lastgt);\r\r\n\r\r\n while (ctxt->instate != XML_PARSER_EOF) {\r\r\n if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\r\r\n return(0);\r\r\n\r\r\n\r\r\n /*\r\r\n\t * Pop-up of finished entities.\r\r\n\t */\r\r\n while ((RAW == 0) && (ctxt->inputNr > 1))\r\r\n\t xmlPopInput(ctxt);\r\r\n\r\r\n if (ctxt->input == NULL) break;\r\r\n if (ctxt->input->buf == NULL)\r\r\n\t avail = ctxt->input->length -\r\r\n (ctxt->input->cur - ctxt->input->base);\r\r\n else {\r\r\n /*\r\r\n\t * If we are operating on converted input, try to flush\r\r\n\t * remainng chars to avoid them stalling in the non-converted\r\r\n\t * buffer. But do not do this in document start where\r\r\n\t * encoding=\"...\" may not have been read and we work on a\r\r\n\t * guessed encoding.\r\r\n\t */\r\r\n if ((ctxt->instate != XML_PARSER_START) &&\r\r\n (ctxt->input->buf->raw != NULL) &&\r\r\n (xmlBufIsEmpty(ctxt->input->buf->raw) == 0)) {\r\r\n size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,\r\r\n ctxt->input);\r\r\n size_t current = ctxt->input->cur - ctxt->input->base;\r\r\n\r\r\n\t\txmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\r\r\n xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,\r\r\n base, current);\r\r\n }\r\r\n\t avail = xmlBufUse(ctxt->input->buf->buffer) -\r\r\n (ctxt->input->cur - ctxt->input->base);\r\r\n }\r\r\n if (avail < 1)\r\r\n goto done;\r\r\n switch (ctxt->instate) {\r\r\n case XML_PARSER_EOF:\r\r\n /*\r\r\n\t\t * Document parsing is done !\r\r\n\t\t */\r\r\n goto done;\r\r\n case XML_PARSER_START:\r\r\n if (ctxt->charset == XML_CHAR_ENCODING_NONE) {\r\r\n\t\t xmlChar start[4];\r\r\n\t\t xmlCharEncoding enc;\r\r\n\r\r\n /*\r\r\n\t\t * Very first chars read from the document flow.\r\r\n\t\t */\r\r\n if (avail < 4)\r\r\n goto done;\r\r\n\r\r\n /*\r\r\n\t\t * Get the 4 first bytes and decode the charset\r\r\n\t\t * if enc != XML_CHAR_ENCODING_NONE\r\r\n\t\t * plug some encoding conversion routines,\r\r\n\t\t * else xmlSwitchEncoding will set to (default)\r\r\n\t\t * UTF8.\r\r\n\t\t */\r\r\n\t\t start[0] = RAW;\r\r\n\t\t start[1] = NXT(1);\r\r\n\t\t start[2] = NXT(2);\r\r\n\t\t start[3] = NXT(3);\r\r\n\t\t enc = xmlDetectCharEncoding(start, 4);\r\r\n\t\t xmlSwitchEncoding(ctxt, enc);\r\r\n break;\r\r\n }\r\r\n\r\r\n if (avail < 2)\r\r\n goto done;\r\r\n\t\tcur = ctxt->input->cur[0];\r\r\n\t\tnext = ctxt->input->cur[1];\r\r\n if (cur == 0) {\r\r\n if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\r\r\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\r\r\n &xmlDefaultSAXLocator);\r\r\n\t\t xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\r\r\n\t\t xmlHaltParser(ctxt);\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering EOF\\n\");\r\r\n#endif\r\r\n if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\r\r\n\t\t\tctxt->sax->endDocument(ctxt->userData);\r\r\n goto done;\r\r\n }\r\r\n if ((cur == '<') && (next == '?')) {\r\r\n /* PI or XML decl */\r\r\n if (avail < 5) return(ret);\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\r\r\n return(ret);\r\r\n if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\r\r\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\r\r\n &xmlDefaultSAXLocator);\r\r\n if ((ctxt->input->cur[2] == 'x') &&\r\r\n (ctxt->input->cur[3] == 'm') &&\r\r\n (ctxt->input->cur[4] == 'l') &&\r\r\n (IS_BLANK_CH(ctxt->input->cur[5]))) {\r\r\n\t\t\tret += 5;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing XML Decl\\n\");\r\r\n#endif\r\r\n\t\t\txmlParseXMLDecl(ctxt);\r\r\n if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\r\r\n /*\r\r\n\t\t\t * The XML REC instructs us to stop parsing right\r\r\n\t\t\t * here\r\r\n\t\t\t */\r\r\n\t\t\t xmlHaltParser(ctxt);\r\r\n return(0);\r\r\n }\r\r\n\t\t\tctxt->standalone = ctxt->input->standalone;\r\r\n if ((ctxt->encoding == NULL) &&\r\r\n (ctxt->input->encoding != NULL))\r\r\n\t\t\t ctxt->encoding = xmlStrdup(ctxt->input->encoding);\r\r\n if ((ctxt->sax) && (ctxt->sax->startDocument) &&\r\r\n (!ctxt->disableSAX))\r\r\n\t\t\t ctxt->sax->startDocument(ctxt->userData);\r\r\n\t\t\tctxt->instate = XML_PARSER_MISC;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering MISC\\n\");\r\r\n#endif\r\r\n } else {\r\r\n\t\t\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\r\r\n if ((ctxt->sax) && (ctxt->sax->startDocument) &&\r\r\n (!ctxt->disableSAX))\r\r\n\t\t\t ctxt->sax->startDocument(ctxt->userData);\r\r\n\t\t\tctxt->instate = XML_PARSER_MISC;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering MISC\\n\");\r\r\n#endif\r\r\n }\r\r\n } else {\r\r\n if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\r\r\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\r\r\n &xmlDefaultSAXLocator);\r\r\n\t\t ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\r\r\n if (ctxt->version == NULL) {\r\r\n\t\t xmlErrMemory(ctxt, NULL);\r\r\n break;\r\r\n }\r\r\n if ((ctxt->sax) && (ctxt->sax->startDocument) &&\r\r\n (!ctxt->disableSAX))\r\r\n\t\t\tctxt->sax->startDocument(ctxt->userData);\r\r\n\t\t ctxt->instate = XML_PARSER_MISC;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering MISC\\n\");\r\r\n#endif\r\r\n }\r\r\n break;\r\r\n case XML_PARSER_START_TAG: {\r\r\n const xmlChar *name;\r\r\n const xmlChar *prefix = NULL;\r\r\n const xmlChar *URI = NULL;\r\r\n int nsNr = ctxt->nsNr;\r\r\n\r\r\n if ((avail < 2) && (ctxt->inputNr == 1))\r\r\n goto done;\r\r\n\t\tcur = ctxt->input->cur[0];\r\r\n if (cur != '<') {\r\r\n\t\t xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\r\r\n\t\t xmlHaltParser(ctxt);\r\r\n if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\r\r\n\t\t\tctxt->sax->endDocument(ctxt->userData);\r\r\n goto done;\r\r\n }\r\r\n if (!terminate) {\r\r\n if (ctxt->progressive) {\r\r\n /* > can be found unescaped in attribute values */\r\r\n if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\r\r\n goto done;\r\r\n } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\r\r\n goto done;\r\r\n }\r\r\n }\r\r\n if (ctxt->spaceNr == 0)\r\r\n\t\t spacePush(ctxt, -1);\r\r\n else if (*ctxt->space == -2)\r\r\n\t\t spacePush(ctxt, -1);\r\r\n else\r\r\n\t\t spacePush(ctxt, *ctxt->space);\r\r\n#ifdef LIBXML_SAX1_ENABLED\r\r\n if (ctxt->sax2)\r\r\n#endif /* LIBXML_SAX1_ENABLED */\r\r\n\t\t name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\r\r\n#ifdef LIBXML_SAX1_ENABLED\r\r\n else\r\r\n\t\t name = xmlParseStartTag(ctxt);\r\r\n#endif /* LIBXML_SAX1_ENABLED */\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n if (name == NULL) {\r\r\n\t\t spacePop(ctxt);\r\r\n\t\t xmlHaltParser(ctxt);\r\r\n if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\r\r\n\t\t\tctxt->sax->endDocument(ctxt->userData);\r\r\n goto done;\r\r\n }\r\r\n#ifdef LIBXML_VALID_ENABLED\r\r\n /*\r\r\n\t\t * [ VC: Root Element Type ]\r\r\n\t\t * The Name in the document type declaration must match\r\r\n\t\t * the element type of the root element.\r\r\n\t\t */\r\r\n if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\r\r\n\t\t ctxt->node && (ctxt->node == ctxt->myDoc->children))\r\r\n\t\t ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\r\r\n#endif /* LIBXML_VALID_ENABLED */\r\r\n\r\r\n /*\r\r\n\t\t * Check for an Empty Element.\r\r\n\t\t */\r\r\n if ((RAW == '/') && (NXT(1) == '>')) {\r\r\n\t\t SKIP(2);\r\r\n\r\r\n if (ctxt->sax2) {\r\r\n if ((ctxt->sax != NULL) &&\r\r\n (ctxt->sax->endElementNs != NULL) &&\r\r\n (!ctxt->disableSAX))\r\r\n\t\t\t ctxt->sax->endElementNs(ctxt->userData, name,\r\r\n\t\t\t prefix, URI);\r\r\n if (ctxt->nsNr - nsNr > 0)\r\r\n\t\t\t nsPop(ctxt, ctxt->nsNr - nsNr);\r\r\n#ifdef LIBXML_SAX1_ENABLED\r\r\n } else {\r\r\n if ((ctxt->sax != NULL) &&\r\r\n (ctxt->sax->endElement != NULL) &&\r\r\n (!ctxt->disableSAX))\r\r\n\t\t\t ctxt->sax->endElement(ctxt->userData, name);\r\r\n#endif /* LIBXML_SAX1_ENABLED */\r\r\n }\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t spacePop(ctxt);\r\r\n if (ctxt->nameNr == 0) {\r\r\n\t\t\tctxt->instate = XML_PARSER_EPILOG;\r\r\n } else {\r\r\n\t\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n }\r\r\n ctxt->progressive = 1;\r\r\n break;\r\r\n }\r\r\n if (RAW == '>') {\r\r\n\t\t NEXT;\r\r\n } else {\r\r\n\t\t xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\r\r\n \"Couldn't find end of Start Tag %s\\n\",\r\r\n\t\t\t\t\t name);\r\r\n\t\t nodePop(ctxt);\r\r\n\t\t spacePop(ctxt);\r\r\n }\r\r\n if (ctxt->sax2)\r\r\n\t\t nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);\r\r\n#ifdef LIBXML_SAX1_ENABLED\r\r\n else\r\r\n\t\t namePush(ctxt, name);\r\r\n#endif /* LIBXML_SAX1_ENABLED */\r\r\n\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n ctxt->progressive = 1;\r\r\n break;\r\r\n }\r\r\n case XML_PARSER_CONTENT: {\r\r\n const xmlChar *test;\r\r\n unsigned int cons;\r\r\n if ((avail < 2) && (ctxt->inputNr == 1))\r\r\n goto done;\r\r\n\t\tcur = ctxt->input->cur[0];\r\r\n\t\tnext = ctxt->input->cur[1];\r\r\n\r\r\n\t\ttest = CUR_PTR;\r\r\n\t cons = ctxt->input->consumed;\r\r\n if ((cur == '<') && (next == '/')) {\r\r\n\t\t ctxt->instate = XML_PARSER_END_TAG;\r\r\n break;\r\r\n } else if ((cur == '<') && (next == '?')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\r\r\n ctxt->progressive = XML_PARSER_PI;\r\r\n goto done;\r\r\n }\r\r\n\t\t xmlParsePI(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n ctxt->progressive = 1;\r\r\n } else if ((cur == '<') && (next != '!')) {\r\r\n\t\t ctxt->instate = XML_PARSER_START_TAG;\r\r\n break;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (ctxt->input->cur[2] == '-') &&\r\r\n (ctxt->input->cur[3] == '-')) {\r\r\n int term;\r\r\n\r\r\n if (avail < 4)\r\r\n goto done;\r\r\n\t\t ctxt->input->cur += 4;\r\r\n\t\t term = xmlParseLookupSequence(ctxt, '-', '-', '>');\r\r\n\t\t ctxt->input->cur -= 4;\r\r\n if ((!terminate) && (term < 0)) {\r\r\n ctxt->progressive = XML_PARSER_COMMENT;\r\r\n goto done;\r\r\n }\r\r\n\t\t xmlParseComment(ctxt);\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n ctxt->progressive = 1;\r\r\n } else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\r\r\n (ctxt->input->cur[2] == '[') &&\r\r\n (ctxt->input->cur[3] == 'C') &&\r\r\n (ctxt->input->cur[4] == 'D') &&\r\r\n (ctxt->input->cur[5] == 'A') &&\r\r\n (ctxt->input->cur[6] == 'T') &&\r\r\n (ctxt->input->cur[7] == 'A') &&\r\r\n (ctxt->input->cur[8] == '[')) {\r\r\n\t\t SKIP(9);\r\r\n\t\t ctxt->instate = XML_PARSER_CDATA_SECTION;\r\r\n break;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (avail < 9)) {\r\r\n goto done;\r\r\n } else if (cur == '&') {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\r\r\n goto done;\r\r\n\t\t xmlParseReference(ctxt);\r\r\n } else {\r\r\n /* TODO Avoid the extra copy, handle directly !!! */\r\r\n /*\r\r\n\t\t * Goal of the following test is:\r\r\n\t\t * - minimize calls to the SAX 'character' callback\r\r\n\t\t * when they are mergeable\r\r\n\t\t * - handle an problem for isBlank when we only parse\r\r\n\t\t * a sequence of blank chars and the next one is\r\r\n\t\t * not available to check against '<' presence.\r\r\n\t\t * - tries to homogenize the differences in SAX\r\r\n\t\t * callbacks between the push and pull versions\r\r\n\t\t * of the parser.\r\r\n\t\t */\r\r\n if ((ctxt->inputNr == 1) &&\r\r\n (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\r\r\n if (!terminate) {\r\r\n if (ctxt->progressive) {\r\r\n if ((lastlt == NULL) ||\r\r\n (ctxt->input->cur > lastlt))\r\r\n goto done;\r\r\n } else if (xmlParseLookupSequence(ctxt,\r\r\n '<', 0, 0) < 0) {\r\r\n goto done;\r\r\n }\r\r\n }\r\r\n }\r\r\n\t\t ctxt->checkIndex = 0;\r\r\n\t\t xmlParseCharData(ctxt, 0);\r\r\n }\r\r\n /*\r\r\n\t\t * Pop-up of finished entities.\r\r\n\t\t */\r\r\n while ((RAW == 0) && (ctxt->inputNr > 1))\r\r\n\t\t xmlPopInput(ctxt);\r\r\n if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\r\r\n\t\t xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\r\r\n \"detected an error in element content\\n\");\r\r\n\t\t xmlHaltParser(ctxt);\r\r\n break;\r\r\n }\r\r\n break;\r\r\n }\r\r\n case XML_PARSER_END_TAG:\r\r\n if (avail < 2)\r\r\n goto done;\r\r\n if (!terminate) {\r\r\n if (ctxt->progressive) {\r\r\n /* > can be found unescaped in attribute values */\r\r\n if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\r\r\n goto done;\r\r\n } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\r\r\n goto done;\r\r\n }\r\r\n }\r\r\n if (ctxt->sax2) {\r\r\n\t\t xmlParseEndTag2(ctxt,\r\r\n (void *) ctxt->pushTab[ctxt->nameNr * 3 - 3],\r\r\n (void *) ctxt->pushTab[ctxt->nameNr * 3 - 2], 0,\r\r\n (int) (long) ctxt->pushTab[ctxt->nameNr * 3 - 1], 0);\r\r\n\t\t nameNsPop(ctxt);\r\r\n }\r\r\n#ifdef LIBXML_SAX1_ENABLED\r\r\n else\r\r\n\t\t xmlParseEndTag1(ctxt, 0);\r\r\n#endif /* LIBXML_SAX1_ENABLED */\r\r\n if (ctxt->instate == XML_PARSER_EOF) {\r\r\n /* Nothing */\r\r\n } else if (ctxt->nameNr == 0) {\r\r\n\t\t ctxt->instate = XML_PARSER_EPILOG;\r\r\n } else {\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n }\r\r\n break;\r\r\n case XML_PARSER_CDATA_SECTION: {\r\r\n /*\r\r\n\t\t * The Push mode need to have the SAX callback for\r\r\n\t\t * cdataBlock merge back contiguous callbacks.\r\r\n\t\t */\r\r\n int base;\r\r\n\r\r\n\t\tbase = xmlParseLookupSequence(ctxt, ']', ']', '>');\r\r\n if (base < 0) {\r\r\n if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\r\r\n int tmp;\r\r\n\r\r\n\t\t\ttmp = xmlCheckCdataPush(ctxt->input->cur,\r\r\n\t\t\t XML_PARSER_BIG_BUFFER_SIZE, 0);\r\r\n if (tmp < 0) {\r\r\n\t\t\t tmp = -tmp;\r\r\n\t\t\t ctxt->input->cur += tmp;\r\r\n goto encoding_error;\r\r\n }\r\r\n if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\r\r\n if (ctxt->sax->cdataBlock != NULL)\r\r\n\t\t\t\tctxt->sax->cdataBlock(ctxt->userData,\r\r\n\t\t\t\t ctxt->input->cur, tmp);\r\r\n else if (ctxt->sax->characters != NULL)\r\r\n\t\t\t\tctxt->sax->characters(ctxt->userData,\r\r\n\t\t\t\t ctxt->input->cur, tmp);\r\r\n }\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t\tSKIPL(tmp);\r\r\n\t\t\tctxt->checkIndex = 0;\r\r\n }\r\r\n goto done;\r\r\n } else {\r\r\n int tmp;\r\r\n\r\r\n\t\t tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);\r\r\n if ((tmp < 0) || (tmp != base)) {\r\r\n\t\t\ttmp = -tmp;\r\r\n\t\t\tctxt->input->cur += tmp;\r\r\n goto encoding_error;\r\r\n }\r\r\n if ((ctxt->sax != NULL) && (base == 0) &&\r\r\n (ctxt->sax->cdataBlock != NULL) &&\r\r\n (!ctxt->disableSAX)) {\r\r\n /*\r\r\n\t\t\t * Special case to provide identical behaviour\r\r\n\t\t\t * between pull and push parsers on enpty CDATA\r\r\n\t\t\t * sections\r\r\n\t\t\t */\r\r\n if ((ctxt->input->cur - ctxt->input->base >= 9) &&\r\r\n (!strncmp((const char *)&ctxt->input->cur[-9],\r\r\n \"<![CDATA[\", 9)))\r\r\n\t\t\t ctxt->sax->cdataBlock(ctxt->userData,\r\r\n\t\t\t BAD_CAST \"\", 0);\r\r\n } else if ((ctxt->sax != NULL) && (base > 0) &&\r\r\n (!ctxt->disableSAX)) {\r\r\n if (ctxt->sax->cdataBlock != NULL)\r\r\n\t\t\t ctxt->sax->cdataBlock(ctxt->userData,\r\r\n\t\t\t\t\t\t ctxt->input->cur, base);\r\r\n else if (ctxt->sax->characters != NULL)\r\r\n\t\t\t ctxt->sax->characters(ctxt->userData,\r\r\n\t\t\t\t\t\t ctxt->input->cur, base);\r\r\n }\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t SKIPL(base + 3);\r\r\n\t\t ctxt->checkIndex = 0;\r\r\n\t\t ctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering CONTENT\\n\");\r\r\n#endif\r\r\n }\r\r\n break;\r\r\n }\r\r\n case XML_PARSER_MISC:\r\r\n\t\tSKIP_BLANKS;\r\r\n if (ctxt->input->buf == NULL)\r\r\n\t\t avail = ctxt->input->length -\r\r\n (ctxt->input->cur - ctxt->input->base);\r\r\n else\r\r\n\t\t avail = xmlBufUse(ctxt->input->buf->buffer) -\r\r\n (ctxt->input->cur - ctxt->input->base);\r\r\n if (avail < 2)\r\r\n goto done;\r\r\n\t\tcur = ctxt->input->cur[0];\r\r\n\t\tnext = ctxt->input->cur[1];\r\r\n if ((cur == '<') && (next == '?')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\r\r\n ctxt->progressive = XML_PARSER_PI;\r\r\n goto done;\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing PI\\n\");\r\r\n#endif\r\r\n\t\t xmlParsePI(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t ctxt->instate = XML_PARSER_MISC;\r\r\n ctxt->progressive = 1;\r\r\n\t\t ctxt->checkIndex = 0;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (ctxt->input->cur[2] == '-') &&\r\r\n (ctxt->input->cur[3] == '-')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\r\r\n ctxt->progressive = XML_PARSER_COMMENT;\r\r\n goto done;\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing Comment\\n\");\r\r\n#endif\r\r\n\t\t xmlParseComment(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t ctxt->instate = XML_PARSER_MISC;\r\r\n ctxt->progressive = 1;\r\r\n\t\t ctxt->checkIndex = 0;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (ctxt->input->cur[2] == 'D') &&\r\r\n (ctxt->input->cur[3] == 'O') &&\r\r\n (ctxt->input->cur[4] == 'C') &&\r\r\n (ctxt->input->cur[5] == 'T') &&\r\r\n (ctxt->input->cur[6] == 'Y') &&\r\r\n (ctxt->input->cur[7] == 'P') &&\r\r\n (ctxt->input->cur[8] == 'E')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0)) {\r\r\n ctxt->progressive = XML_PARSER_DTD;\r\r\n goto done;\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing internal subset\\n\");\r\r\n#endif\r\r\n\t\t ctxt->inSubset = 1;\r\r\n ctxt->progressive = 0;\r\r\n\t\t ctxt->checkIndex = 0;\r\r\n\t\t xmlParseDocTypeDecl(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n if (RAW == '[') {\r\r\n\t\t\tctxt->instate = XML_PARSER_DTD;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering DTD\\n\");\r\r\n#endif\r\r\n } else {\r\r\n /*\r\r\n\t\t\t * Create and update the external subset.\r\r\n\t\t\t */\r\r\n\t\t\tctxt->inSubset = 2;\r\r\n if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\r\r\n (ctxt->sax->externalSubset != NULL))\r\r\n\t\t\t ctxt->sax->externalSubset(ctxt->userData,\r\r\n\t\t\t\t ctxt->intSubName, ctxt->extSubSystem,\r\r\n\t\t\t\t ctxt->extSubURI);\r\r\n\t\t\tctxt->inSubset = 0;\r\r\n\t\t\txmlCleanSpecialAttr(ctxt);\r\r\n\t\t\tctxt->instate = XML_PARSER_PROLOG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering PROLOG\\n\");\r\r\n#endif\r\r\n }\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (avail < 9)) {\r\r\n goto done;\r\r\n } else {\r\r\n\t\t ctxt->instate = XML_PARSER_START_TAG;\r\r\n\t\t ctxt->progressive = XML_PARSER_START_TAG;\r\r\n\t\t xmlParseGetLasts(ctxt, &lastlt, &lastgt);\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering START_TAG\\n\");\r\r\n#endif\r\r\n }\r\r\n break;\r\r\n case XML_PARSER_PROLOG:\r\r\n\t\tSKIP_BLANKS;\r\r\n if (ctxt->input->buf == NULL)\r\r\n\t\t avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\r\r\n else\r\r\n\t\t avail = xmlBufUse(ctxt->input->buf->buffer) -\r\r\n (ctxt->input->cur - ctxt->input->base);\r\r\n if (avail < 2)\r\r\n goto done;\r\r\n\t\tcur = ctxt->input->cur[0];\r\r\n\t\tnext = ctxt->input->cur[1];\r\r\n if ((cur == '<') && (next == '?')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\r\r\n ctxt->progressive = XML_PARSER_PI;\r\r\n goto done;\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing PI\\n\");\r\r\n#endif\r\r\n\t\t xmlParsePI(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t ctxt->instate = XML_PARSER_PROLOG;\r\r\n ctxt->progressive = 1;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\r\r\n ctxt->progressive = XML_PARSER_COMMENT;\r\r\n goto done;\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing Comment\\n\");\r\r\n#endif\r\r\n\t\t xmlParseComment(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t ctxt->instate = XML_PARSER_PROLOG;\r\r\n ctxt->progressive = 1;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (avail < 4)) {\r\r\n goto done;\r\r\n } else {\r\r\n\t\t ctxt->instate = XML_PARSER_START_TAG;\r\r\n if (ctxt->progressive == 0)\r\r\n\t\t\tctxt->progressive = XML_PARSER_START_TAG;\r\r\n\t\t xmlParseGetLasts(ctxt, &lastlt, &lastgt);\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering START_TAG\\n\");\r\r\n#endif\r\r\n }\r\r\n break;\r\r\n case XML_PARSER_EPILOG:\r\r\n\t\tSKIP_BLANKS;\r\r\n if (ctxt->input->buf == NULL)\r\r\n\t\t avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\r\r\n else\r\r\n\t\t avail = xmlBufUse(ctxt->input->buf->buffer) -\r\r\n (ctxt->input->cur - ctxt->input->base);\r\r\n if (avail < 2)\r\r\n goto done;\r\r\n\t\tcur = ctxt->input->cur[0];\r\r\n\t\tnext = ctxt->input->cur[1];\r\r\n if ((cur == '<') && (next == '?')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\r\r\n ctxt->progressive = XML_PARSER_PI;\r\r\n goto done;\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing PI\\n\");\r\r\n#endif\r\r\n\t\t xmlParsePI(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t ctxt->instate = XML_PARSER_EPILOG;\r\r\n ctxt->progressive = 1;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\r\r\n if ((!terminate) &&\r\r\n (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\r\r\n ctxt->progressive = XML_PARSER_COMMENT;\r\r\n goto done;\r\r\n }\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: Parsing Comment\\n\");\r\r\n#endif\r\r\n\t\t xmlParseComment(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\t ctxt->instate = XML_PARSER_EPILOG;\r\r\n ctxt->progressive = 1;\r\r\n } else if ((cur == '<') && (next == '!') &&\r\r\n (avail < 4)) {\r\r\n goto done;\r\r\n } else {\r\r\n\t\t xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\r\r\n\t\t xmlHaltParser(ctxt);\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering EOF\\n\");\r\r\n#endif\r\r\n if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\r\r\n\t\t\tctxt->sax->endDocument(ctxt->userData);\r\r\n goto done;\r\r\n }\r\r\n break;\r\r\n case XML_PARSER_DTD: {\r\r\n /*\r\r\n\t\t * Sorry but progressive parsing of the internal subset\r\r\n\t\t * is not expected to be supported. We first check that\r\r\n\t\t * the full content of the internal subset is available and\r\r\n\t\t * the parsing is launched only at that point.\r\r\n\t\t * Internal subset ends up with \"']' S? '>'\" in an unescaped\r\r\n\t\t * section and not in a ']]>' sequence which are conditional\r\r\n\t\t * sections (whoever argued to keep that crap in XML deserve\r\r\n\t\t * a place in hell !).\r\r\n\t\t */\r\r\n int base, i;\r\r\n\t\txmlChar *buf;\r\r\n\t xmlChar quote = 0;\r\r\n size_t use;\r\r\n\r\r\n\t\tbase = ctxt->input->cur - ctxt->input->base;\r\r\n if (base < 0) return(0);\r\r\n if (ctxt->checkIndex > base)\r\r\n\t\t base = ctxt->checkIndex;\r\r\n\t\tbuf = xmlBufContent(ctxt->input->buf->buffer);\r\r\n use = xmlBufUse(ctxt->input->buf->buffer);\r\r\n for (;(unsigned int) base < use; base++) {\r\r\n if (quote != 0) {\r\r\n if (buf[base] == quote)\r\r\n\t\t\t quote = 0;\r\r\n continue;\r\r\n }\r\r\n if ((quote == 0) && (buf[base] == '<')) {\r\r\n int found = 0;\r\r\n /* special handling of comments */\r\r\n if (((unsigned int) base + 4 < use) &&\r\r\n (buf[base + 1] == '!') &&\r\r\n (buf[base + 2] == '-') &&\r\r\n (buf[base + 3] == '-')) {\r\r\n for (;(unsigned int) base + 3 < use; base++) {\r\r\n if ((buf[base] == '-') &&\r\r\n (buf[base + 1] == '-') &&\r\r\n (buf[base + 2] == '>')) {\r\r\n\t\t\t\t found = 1;\r\r\n\t\t\t\t base += 2;\r\r\n break;\r\r\n }\r\r\n }\r\r\n if (!found) {\r\r\n#if 0\r\r\n\t\t\t fprintf(stderr, \"unfinished comment\\n\");\r\r\n#endif\r\r\n break; /* for */\r\r\n }\r\r\n continue;\r\r\n }\r\r\n }\r\r\n if (buf[base] == '\"') {\r\r\n\t\t quote = '\"';\r\r\n continue;\r\r\n }\r\r\n if (buf[base] == '\\'') {\r\r\n\t\t quote = '\\'';\r\r\n continue;\r\r\n }\r\r\n if (buf[base] == ']') {\r\r\n#if 0\r\r\n\t\t fprintf(stderr, \"%c%c%c%c: \", buf[base],\r\r\n\t\t\t buf[base + 1], buf[base + 2], buf[base + 3]);\r\r\n#endif\r\r\n if ((unsigned int) base +1 >= use)\r\r\n break;\r\r\n if (buf[base + 1] == ']') {\r\r\n /* conditional crap, skip both ']' ! */\r\r\n\t\t\t base++;\r\r\n continue;\r\r\n }\r\r\n for (i = 1; (unsigned int) base + i < use; i++) {\r\r\n if (buf[base + i] == '>') {\r\r\n#if 0\r\r\n\t\t\t fprintf(stderr, \"found\\n\");\r\r\n#endif\r\r\n goto found_end_int_subset;\r\r\n }\r\r\n if (!IS_BLANK_CH(buf[base + i])) {\r\r\n#if 0\r\r\n\t\t\t fprintf(stderr, \"not found\\n\");\r\r\n#endif\r\r\n goto not_end_of_int_subset;\r\r\n }\r\r\n }\r\r\n#if 0\r\r\n\t\t\tfprintf(stderr, \"end of stream\\n\");\r\r\n#endif\r\r\n break;\r\r\n\r\r\n }\r\r\nnot_end_of_int_subset:\r\r\n continue; /* for */\r\r\n }\r\r\n /*\r\r\n\t\t * We didn't found the end of the Internal subset\r\r\n\t\t */\r\r\n if (quote == 0)\r\r\n ctxt->checkIndex = base;\r\r\n else\r\r\n ctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n if (next == 0)\r\r\n\t\t xmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: lookup of int subset end filed\\n\");\r\r\n#endif\r\r\n goto done;\r\r\n\r\r\nfound_end_int_subset:\r\r\n ctxt->checkIndex = 0;\r\r\n\t\txmlParseInternalSubset(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\tctxt->inSubset = 2;\r\r\n if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\r\r\n (ctxt->sax->externalSubset != NULL))\r\r\n\t\t ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\r\r\n\t\t\t ctxt->extSubSystem, ctxt->extSubURI);\r\r\n\t\tctxt->inSubset = 0;\r\r\n\t\txmlCleanSpecialAttr(ctxt);\r\r\n if (ctxt->instate == XML_PARSER_EOF)\r\r\n goto done;\r\r\n\t\tctxt->instate = XML_PARSER_PROLOG;\r\r\n\t\tctxt->checkIndex = 0;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering PROLOG\\n\");\r\r\n#endif\r\r\n break;\r\r\n }\r\r\n case XML_PARSER_COMMENT:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == COMMENT\\n\");\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering CONTENT\\n\");\r\r\n#endif\r\r\n break;\r\r\n case XML_PARSER_IGNORE:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == IGNORE\");\r\r\n\t ctxt->instate = XML_PARSER_DTD;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering DTD\\n\");\r\r\n#endif\r\r\n break;\r\r\n case XML_PARSER_PI:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == PI\\n\");\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering CONTENT\\n\");\r\r\n#endif\r\r\n break;\r\r\n case XML_PARSER_ENTITY_DECL:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == ENTITY_DECL\\n\");\r\r\n\t\tctxt->instate = XML_PARSER_DTD;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering DTD\\n\");\r\r\n#endif\r\r\n break;\r\r\n case XML_PARSER_ENTITY_VALUE:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == ENTITY_VALUE\\n\");\r\r\n\t\tctxt->instate = XML_PARSER_CONTENT;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering DTD\\n\");\r\r\n#endif\r\r\n break;\r\r\n case XML_PARSER_ATTRIBUTE_VALUE:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\r\r\n\t\tctxt->instate = XML_PARSER_START_TAG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering START_TAG\\n\");\r\r\n#endif\r\r\n break;\r\r\n case XML_PARSER_SYSTEM_LITERAL:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == SYSTEM_LITERAL\\n\");\r\r\n\t\tctxt->instate = XML_PARSER_START_TAG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering START_TAG\\n\");\r\r\n#endif\r\r\n break;\r\r\n case XML_PARSER_PUBLIC_LITERAL:\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: internal error, state == PUBLIC_LITERAL\\n\");\r\r\n\t\tctxt->instate = XML_PARSER_START_TAG;\r\r\n#ifdef DEBUG_PUSH\r\r\n\t\txmlGenericError(xmlGenericErrorContext,\r\r\n \"PP: entering START_TAG\\n\");\r\r\n#endif\r\r\n break;\r\r\n }\r\r\n }\r\r\ndone:\r\r\n#ifdef DEBUG_PUSH\r\r\n xmlGenericError(xmlGenericErrorContext, \"PP: done %d\\n\", ret);\r\r\n#endif\r\r\n return(ret);\r\r\nencoding_error:\r\r\n {\r\r\n char buffer[150];\r\r\n\r\r\n\tsnprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\r\r\n\t\t\tctxt->input->cur[0], ctxt->input->cur[1],\r\r\n\t\t\tctxt->input->cur[2], ctxt->input->cur[3]);\r\r\n\t__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\r\r\n \"Input is not proper UTF-8, indicate encoding !\\n%s\",\r\r\n\t\t BAD_CAST buffer, NULL);\r\r\n }\r\r\n return(0);\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint revenants_incorporator = 0;\r\n\r\nstruct malingerers_quasiperiodic \r\n{\r\n char *scramble_minimising;\r\n double discinoid_jenequen;\r\n char *bleck_limnobiological;\r\n char sillers_admired;\r\n int chorographical_squashberry;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *gonococcal_berdyayev);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\ntypedef int (*fct_ptr)(const char *, const char *);\r\nfct_ptr switch_func(char *param)\r\n{\r\n \r\n int var_len = 0;\r\n fct_ptr fct_ptr_addr = (fct_ptr )0;\r\n var_len = strlen(param) % 3;\r\n if (var_len == 0) {\r\n return strcmp;\r\n }\r\n else if (var_len == 1) {\r\n return strcoll;\r\n }\r\n else {\r\n sscanf(param,\"%p\",&fct_ptr_addr);\r\n return fct_ptr_addr;\r\n }\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&revenants_incorporator,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *gonococcal_berdyayev)\r\n{\r\n int cmp_flag = 0;\r\n char *patella_whoremonger = 0;\r\n struct malingerers_quasiperiodic *rheumiest_sooky = {0};\r\n struct malingerers_quasiperiodic *prote_recelebrated = {0};\r\n struct malingerers_quasiperiodic aggregated_eliquation;\r\n ++global_variable;;\r\n if (gonococcal_berdyayev != 0) {;\r\n aggregated_eliquation . scramble_minimising = ((char *)gonococcal_berdyayev);\r\n rheumiest_sooky = &aggregated_eliquation;\r\n prote_recelebrated = rheumiest_sooky + 5;\r\n patella_whoremonger = ((char *)( *(prote_recelebrated - 5)) . scramble_minimising);\r\n \r\n \r\n \r\n fct_ptr fp;\r\n const char *rand_word = \"criticisms_metallide\";\r\n fp = switch_func(patella_whoremonger);\r\n \r\n \r\n \r\n \r\n cmp_flag = ( *fp)(rand_word,patella_whoremonger);\r\n \r\n if (cmp_flag == 0)\r\n printf(\"strings are equal\\n\");\r\n else\r\n printf(\"strings are not equal\\n\");\r\n \r\n;\r\n if (( *(prote_recelebrated - 5)) . scramble_minimising != 0) \r\n free(((char *)( *(prote_recelebrated - 5)) . scramble_minimising));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n cmp_flag = ( *fp)(rand_word,patella_whoremonger);\n```", "cwe": "822"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint jatos_psychognosis = 0;\r\nint global_variable;\r\nvoid convivialities_theligonaceae(char **musterer_bugloss);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid eight_pyrrylene(void (*quaiches_southwestwards)(char **));\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&jatos_psychognosis,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n eight_pyrrylene(convivialities_theligonaceae);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid convivialities_theligonaceae(char **musterer_bugloss)\r\n{\r\n int nonvascularly_epidermolysis = 0;\r\n char *grunswel_unquested = 0;\r\n char *ribozos_smelterville;\r\n ++global_variable;;\r\n setup_printf_context();\r\n ribozos_smelterville = getenv(\"GEONYCTINASTIC_FUTILITIES\");\r\n if (ribozos_smelterville != 0) {;\r\n nonvascularly_epidermolysis = ((int )(strlen(ribozos_smelterville)));\r\n grunswel_unquested = ((char *)(malloc(nonvascularly_epidermolysis + 1)));\r\n if (grunswel_unquested == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(grunswel_unquested,0,nonvascularly_epidermolysis + 1);\r\n memcpy(grunswel_unquested,ribozos_smelterville,nonvascularly_epidermolysis);\r\n *musterer_bugloss = grunswel_unquested;\r\n }\r\n}\r\n\r\nvoid eight_pyrrylene(void (*quaiches_southwestwards)(char **))\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[1020];\r\n char filename[80];\r\n char *palaeolithy_anodynes = 0;\r\n char **malamutes_disapprovingly = 0;\r\n ++global_variable;\r\n char *bayminette_agitated = 0;\r\n quaiches_southwestwards(&bayminette_agitated);\r\n if (bayminette_agitated != 0) {;\r\n malamutes_disapprovingly = &bayminette_agitated;\r\n palaeolithy_anodynes = ((char *)( *malamutes_disapprovingly));\r\n \r\n files = fopen(palaeolithy_anodynes,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n if (files != 0)\r\n fclose(files);\r\n \r\n;\r\n if ( *malamutes_disapprovingly != 0) \r\n free(((char *)( *malamutes_disapprovingly)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi] = file;\n ssi++;\n }\n```", "cwe": "775"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint stunning_blanchi = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int oc_i = 0;\r\n int buf_ptr_len;\r\n char *new_input = \"new test input\";\r\n const int MAXLEN = 16;\r\n char *osi_tires = 0;\r\n int rebred_folsom;\r\n int prediminishment_tharp;\r\n void *gourdine_favillous = 0;\r\n int cardialgia_collineation = 50;\r\n char *shelman_biophysiology;;\r\n if (__sync_bool_compare_and_swap(&stunning_blanchi,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&shelman_biophysiology,\"5761\",cardialgia_collineation);\r\n if (shelman_biophysiology != 0) {;\r\n gourdine_favillous = ((void *)shelman_biophysiology);\r\n prediminishment_tharp = 5;\r\n while(1 == 1){\r\n prediminishment_tharp = prediminishment_tharp * 2;\r\n prediminishment_tharp = prediminishment_tharp + 2;\r\n if (prediminishment_tharp > 1000) {\r\n break; \r\n }\r\n }\r\n rebred_folsom = prediminishment_tharp;\r\n osi_tires = ((char *)((char *)gourdine_favillous));\r\n \r\n int file_desc;\r\n char input_buf[MAXLEN];\r\n char **buf_ptr = 0;\r\n char *path_buf = 0;\r\n path_buf = malloc(sizeof(char ) * 64);\r\n if (path_buf == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n buf_ptr = malloc(sizeof(char *));\r\n if (buf_ptr == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n *buf_ptr = path_buf;\r\n memset(input_buf,0,16);\r\n memset(path_buf,'a',64);\r\n path_buf[63] = 0;\r\n file_desc = open(osi_tires,0);\r\n if (file_desc > -1) {\r\n read(file_desc,input_buf,MAXLEN);\r\n close(file_desc);\r\n \r\n \r\n strncpy(path_buf,input_buf,MAXLEN);\r\n \r\n \r\n \r\n strcat(path_buf,new_input);\r\n buf_ptr_len = strlen( *buf_ptr);\r\n for (; oc_i < buf_ptr_len; ++oc_i) {\r\n path_buf[oc_i] = toupper(path_buf[oc_i]);\r\n }\r\n \r\n printf(\"%s\\n\",path_buf);\r\n \r\n }\r\n if (path_buf != 0) {\r\n free(path_buf);\r\n }\r\n if (buf_ptr != 0) {\r\n free(buf_ptr);\r\n }\r\n;\r\n if (((char *)gourdine_favillous) != 0) \r\n free(((char *)((char *)gourdine_favillous)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput your answer code in the format: `{code}`", "output": "``` \n strcat(path_buf,new_input);\n buf_ptr_len = strlen( *buf_ptr);\n for (; oc_i < buf_ptr_len; ++oc_i) {\n path_buf[oc_i] = toupper(path_buf[oc_i]);\n }\n \n printf(\"%s\\n\",path_buf);\n```", "cwe": "170"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint long_bebouldered = 0;\r\nint global_variable;\r\nvoid handle_taint(char *carolina_squalus);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nchar *counterstock_intraarterially(char *semarang_unadduceable);\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&long_bebouldered,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *carolina_squalus)\r\n{\r\n FILE *csv = 0;\r\n FILE *temp = 0;\r\n char col1[80] = {0};\r\n char col2[80] = {0};\r\n char col3[80] = {0};\r\n char *cols[3] = {0};\r\n char *firewater_naemorhedus = 0;\r\n int culvers_telophragma;\r\n int glisk_opinative;\r\n char *vermillion_parasigmatism = 0;\r\n int paralogician_vandyke = 0;\r\n char *flooding_climograph = 0;\r\n ++global_variable;;\r\n if (carolina_squalus != 0) {;\r\n paralogician_vandyke = ((int )(strlen(carolina_squalus)));\r\n flooding_climograph = ((char *)(malloc(paralogician_vandyke + 1)));\r\n if (flooding_climograph == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(flooding_climograph,0,paralogician_vandyke + 1);\r\n memcpy(flooding_climograph,carolina_squalus,paralogician_vandyke);\r\n if (carolina_squalus != 0) \r\n free(((char *)carolina_squalus));\r\n vermillion_parasigmatism = counterstock_intraarterially(flooding_climograph);\r\n glisk_opinative = 5;\r\n while(1 == 1){\r\n glisk_opinative = glisk_opinative * 2;\r\n glisk_opinative = glisk_opinative + 2;\r\n if (glisk_opinative > 1000) {\r\n break; \r\n }\r\n }\r\n culvers_telophragma = glisk_opinative;\r\n firewater_naemorhedus = ((char *)vermillion_parasigmatism);\r\n \r\n \r\n csv = fopen(firewater_naemorhedus,\"r\");\r\n if (csv != 0) {\r\n \r\n\r\n fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\r\n \r\n \r\n \r\n \r\n if (strlen(col1) > 0)\r\n cols[0] = col1;\r\n if (strlen(col2) > 0)\r\n cols[1] = col2;\r\n if (strlen(col3) > 0)\r\n cols[2] = col3;\r\n temp = fopen(\"/opt//workspace/testData/myfile.txt\", \"w+\");\r\n if(temp != 0) {\r\n \r\n\r\n printf(\"VALUES=\\\"\");\r\n fputs(cols[0],temp);\r\n printf(cols[0]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[1],temp);\r\n printf(cols[1]);\r\n printf(\"\\\",\\\"\");\r\n fputs(cols[2],temp);\r\n printf(cols[2]);\r\n \r\n printf(\"\\\"\\n\");\r\n fclose(temp);\r\n }\r\n }\r\n \r\n;\r\n if (vermillion_parasigmatism != 0) \r\n free(((char *)vermillion_parasigmatism));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nchar *counterstock_intraarterially(char *semarang_unadduceable)\r\n{\r\n ++global_variable;\r\n return semarang_unadduceable;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n printf(\"VALUES=\\\"\");\n fputs(cols[0],temp);\n printf(cols[0]);\n printf(\"\\\",\\\"\");\n fputs(cols[1],temp);\n printf(cols[1]);\n printf(\"\\\",\\\"\");\n fputs(cols[2],temp);\n printf(cols[2]);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint steeves_ashman = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint single_global_variable = 0;\r\nint canary_function_1()\r\n{\r\n \r\n ++single_global_variable;\r\n return 1;\r\n}\r\nint canary_function_2()\r\n{\r\n \r\n ++single_global_variable;\r\n return 2;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int i = 0;\r\n int index;\r\n int (*after_ptr[1])();\r\n unsigned char count[62];\r\n int (*before_ptr[1])();\r\n char str_buf[40] = {0};\r\n char *medjidieh_parava = 0;\r\n int negritising_twinborn;\r\n int sensomobile_industrialness;\r\n char **patand_cytophysics = 0;\r\n int *nonrevocation_marylyn = 0;\r\n int wadai_undissuadably;\r\n char **fieldale_riflescope[10] = {0};\r\n char *mockup_drugeteria[94] = {0};\r\n char *dogbush_sornari;;\r\n if (__sync_bool_compare_and_swap(&steeves_ashman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&dogbush_sornari,\"MACROBIUS_DEBITED\");\r\n if (dogbush_sornari != 0) {;\r\n mockup_drugeteria[27] = dogbush_sornari;\r\n wadai_undissuadably = 5;\r\n nonrevocation_marylyn = &wadai_undissuadably;\r\n fieldale_riflescope[ *nonrevocation_marylyn] = mockup_drugeteria;\r\n patand_cytophysics = fieldale_riflescope[ *nonrevocation_marylyn];\r\n sensomobile_industrialness = 5;\r\n while(1 == 1){\r\n sensomobile_industrialness = sensomobile_industrialness * 2;\r\n sensomobile_industrialness = sensomobile_industrialness + 2;\r\n if (sensomobile_industrialness > 1000) {\r\n break; \r\n }\r\n }\r\n negritising_twinborn = sensomobile_industrialness;\r\n medjidieh_parava = ((char *)patand_cytophysics[27]);\r\n \r\n strncpy(str_buf,medjidieh_parava,39);\r\n str_buf[39] = 0;\r\n for (i = 0; i < 62; i++) {\r\n count[i] = 0;\r\n }\r\n if (strlen(str_buf) > 1 && str_buf[0] > 'a') {\r\n before_ptr[0] = canary_function_1;\r\n after_ptr[0] = canary_function_1;\r\n }\r\n else {\r\n before_ptr[0] = canary_function_2;\r\n after_ptr[0] = canary_function_2;\r\n }\r\n \r\n \r\n for (i = 0; i < strlen(str_buf); i++)\r\n \r\n \r\n {\r\n if (str_buf[i] > 96) {\r\n index = str_buf[i] - 'a' + 36;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else if (str_buf[i] < 58) {\r\n index = str_buf[i] - 48;\r\n \r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else {\r\n index = str_buf[i] - 'A' + 10;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n }\r\n \r\n \r\n for (i = 0; i < 62; i++) {\r\n printf(\"index %d: %d\\n\",i,count[i]);\r\n }\r\n printf(\"%d\\n\",before_ptr[0]());\r\n printf(\"%d\\n\",after_ptr[0]());\r\n \r\n;\r\n if (patand_cytophysics[27] != 0) \r\n free(((char *)patand_cytophysics[27]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` for (i = 0; i < strlen(str_buf); i++)\n \n \n {\n if (str_buf[i] > 96) {\n index = str_buf[i] - 'a' + 36;\n if (count[index] < 255)\n count[index]++;\n }\n else if (str_buf[i] < 58) {\n index = str_buf[i] - 48;\n \n if (count[index] < 255)\n count[index]++;\n }\n else {\n index = str_buf[i] - 'A' + 10;\n if (count[index] < 255)\n count[index]++;\n }\n }\n```", "cwe": "129"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint forestation_sparmannia = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n char buffer[80];\r\n FILE *pFile = 0;\r\n char *amenorrho_tragopan = 0;\r\n char **gauffer_hexanchidae = 0;\r\n int antigrowth_beshrewing = 0;\r\n char *misers_clavis = 0;\r\n int whatsoever_schoolma = 45;\r\n char *deprecators_bloomery;;\r\n if (__sync_bool_compare_and_swap(&forestation_sparmannia,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&deprecators_bloomery,\"3498\",whatsoever_schoolma);\r\n if (deprecators_bloomery != 0) {;\r\n antigrowth_beshrewing = ((int )(strlen(deprecators_bloomery)));\r\n misers_clavis = ((char *)(malloc(antigrowth_beshrewing + 1)));\r\n if (misers_clavis == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(misers_clavis,0,antigrowth_beshrewing + 1);\r\n memcpy(misers_clavis,deprecators_bloomery,antigrowth_beshrewing);\r\n if (deprecators_bloomery != 0) \r\n free(((char *)deprecators_bloomery));\r\n gauffer_hexanchidae = &misers_clavis;\r\n if ( *gauffer_hexanchidae != 0) {\r\n goto blasdell_intorsion;\r\n }\r\n ++global_variable;\r\n blasdell_intorsion:;\r\n amenorrho_tragopan = ((char *)( *gauffer_hexanchidae));\r\n \r\n \r\n\r\n pFile = fopen(amenorrho_tragopan,\"r\");\r\n buffer[0] = 0;\r\n \r\n \r\n \r\n\r\n fgets(buffer,79,pFile);\r\n printf(buffer);\r\n printf(\"\\n\");\r\n fclose(pFile);\r\n \r\n \r\n;\r\n if ( *gauffer_hexanchidae != 0) \r\n free(((char *)( *gauffer_hexanchidae)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n fgets(buffer,79,pFile);\n printf(buffer);\n printf(\"\\n\");\n fclose(pFile);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\t\r\n#include \"cryptlib.h\"\r\n#include <openssl/crypto.h>\r\n#include <openssl/buffer.h>\r\n#include <openssl/bio.h>\r\n#include <openssl/lhash.h>\r\n#include <mongoose.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int mh_mode = 0x0;\r\n\r\n\r\nstatic unsigned long order = 0;\r\n\r\nstruct lhash_st_MEM \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_MEM *mh = ((void *)0);\r\ntypedef struct app_mem_info_st {\r\n\r\nCRYPTO_THREADID threadid;\r\nconst char *file;\r\nint line;\r\nconst char *info;\r\n\r\nstruct app_mem_info_st *next;\r\nint references;}APP_INFO;\r\nstatic void app_info_free(APP_INFO *inf);\r\n\r\nstruct lhash_st_APP_INFO \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\nstatic struct lhash_st_APP_INFO *amih = ((void *)0);\r\ntypedef struct mem_st {\r\n\r\nvoid *addr;\r\nint num;\r\nconst char *file;\r\nint line;\r\nCRYPTO_THREADID threadid;\r\nunsigned long order;\r\ntime_t time;\r\nAPP_INFO *app_info;}MEM;\r\n\r\nstatic long options = 0;\r\n#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)\r\n#endif\r\n\r\nstatic unsigned int num_disable = 0;\r\n\r\nstatic CRYPTO_THREADID disabling_threadid;\r\nint preponderances_furrily = 0;\r\nint global_variable;\r\nvoid handle_taint(char *isn_animalism);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic void app_info_free(APP_INFO *inf)\r\n{\r\n if (--inf -> references <= 0) {\r\n if (inf -> next != ((void *)0)) {\r\n app_info_free(inf -> next);\r\n }\r\n CRYPTO_free(inf);\r\n }\r\n}\r\n\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\n int ret = mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",220);\r\n switch(mode){\r\n case 0x1:\r\n{\r\n\r\n\r\n mh_mode = 0x1 | 0x2;\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x0:\r\n{\r\n\r\n mh_mode = 0;\r\n\r\n num_disable = 0;\r\n break; \r\n }\r\n case 0x3:\r\n{\r\n\r\n\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n\r\n if (!num_disable || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur))) {\r\n\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",250);\r\n\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",256);\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",257);\r\n mh_mode &= ~0x2;\r\n CRYPTO_THREADID_cpy(&disabling_threadid,(&cur));\r\n }\r\n num_disable++;\r\n }\r\n break; \r\n }\r\n case 0x2:\r\n{\r\n\r\n if (mh_mode & 0x1) {\r\n\r\n if (num_disable) {\r\n num_disable--;\r\n if (num_disable == 0) {\r\n mh_mode |= 0x2;\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",273);\r\n }\r\n }\r\n }\r\n break; \r\n }\r\n default:\r\n break; \r\n }\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",282);\r\n return ret;\r\n}\r\n\r\nint CRYPTO_is_mem_check_on()\r\n{\r\n int ret = 0;\r\n if (mh_mode & 0x1) {\r\n CRYPTO_THREADID cur;\r\n CRYPTO_THREADID_current(&cur);\r\n CRYPTO_lock(1 | 4,20,\"mem_dbg.c\",294);\r\n ret = mh_mode & 0x2 || CRYPTO_THREADID_cmp((&disabling_threadid),(&cur));\r\n CRYPTO_lock(2 | 4,20,\"mem_dbg.c\",299);\r\n }\r\n return ret;\r\n}\r\n\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\n options = bits;\r\n}\r\n\r\nlong CRYPTO_dbg_get_options()\r\n{\r\n return options;\r\n}\r\n\r\nstatic int mem_cmp(const MEM *a,const MEM *b)\r\n{\r\n#ifdef _WIN64\r\n#else\r\n return (((const char *)(a -> addr)) - ((const char *)(b -> addr)));\r\n#endif\r\n}\r\n\r\nstatic int mem_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n const MEM *b = arg2;\r\n return mem_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long mem_hash(const MEM *a)\r\n{\r\n unsigned long ret;\r\n ret = ((unsigned long )(a -> addr));\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long mem_LHASH_HASH(const void *arg)\r\n{\r\n const MEM *a = arg;\r\n return mem_hash(a);\r\n}\r\n\r\n\r\nstatic int app_info_cmp(const void *a_void,const void *b_void)\r\n{\r\n return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void) -> threadid,&((const APP_INFO *)b_void) -> threadid);\r\n}\r\n\r\nstatic int app_info_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const APP_INFO *a = arg1;\r\n const APP_INFO *b = arg2;\r\n return app_info_cmp(a,b);\r\n}\r\n\r\nstatic unsigned long app_info_hash(const APP_INFO *a)\r\n{\r\n unsigned long ret;\r\n if (__sync_bool_compare_and_swap(&preponderances_furrily,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ret = CRYPTO_THREADID_hash(&a -> threadid);\r\n\r\n ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;\r\n return ret;\r\n}\r\n\r\nstatic unsigned long app_info_LHASH_HASH(const void *arg)\r\n{\r\n const APP_INFO *a = arg;\r\n return app_info_hash(a);\r\n}\r\n\r\nstatic APP_INFO *pop_info()\r\n{\r\n APP_INFO tmp;\r\n APP_INFO *ret = ((void *)0);\r\n if (amih != ((void *)0)) {\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n if ((ret = ((APP_INFO *)(lh_delete(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n APP_INFO *next = ret -> next;\r\n if (next != ((void *)0)) {\r\n next -> references++;\r\n (void )((APP_INFO *)(lh_insert(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))),((void *)(1?next : ((APP_INFO *)0))))));\r\n }\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (--ret -> references <= 0) {\r\n ret -> next = ((void *)0);\r\n if (next != ((void *)0)) {\r\n next -> references--;\r\n }\r\n CRYPTO_free(ret);\r\n }\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_push_info_(const char *info,const char *file,int line)\r\n{\r\n APP_INFO *ami;\r\n APP_INFO *amim;\r\n int ret = 0;\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((ami = ((APP_INFO *)(CRYPTO_malloc(((int )(sizeof(APP_INFO ))),\"mem_dbg.c\",406)))) == ((void *)0)) {\r\n ret = 0;\r\n goto err;\r\n }\r\n if (amih == ((void *)0)) {\r\n if ((amih = ((struct lhash_st_APP_INFO *)(lh_new(app_info_LHASH_HASH,app_info_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(ami);\r\n ret = 0;\r\n goto err;\r\n }\r\n }\r\n CRYPTO_THREADID_current(&ami -> threadid);\r\n ami -> file = file;\r\n ami -> line = line;\r\n ami -> info = info;\r\n ami -> references = 1;\r\n ami -> next = ((void *)0);\r\n if ((amim = ((APP_INFO *)(lh_insert(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)((1?ami : ((APP_INFO *)0)))))))) != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n ami -> next = amim;\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_pop_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ret = pop_info() != ((void *)0);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\n\r\nint CRYPTO_remove_all_info()\r\n{\r\n int ret = 0;\r\n\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n while(pop_info() != ((void *)0))\r\n ret++;\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n return ret;\r\n}\r\nstatic unsigned long break_order_num = 0;\r\n\r\nvoid CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)\r\n{\r\n MEM *m;\r\n MEM *mm;\r\n APP_INFO tmp;\r\n APP_INFO *amim;\r\n switch(before_p & 127){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),\"mem_dbg.c\",498)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n return ;\r\n }\r\n if (mh == ((void *)0)) {\r\n if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {\r\n CRYPTO_free(addr);\r\n CRYPTO_free(m);\r\n addr = ((void *)0);\r\n goto err;\r\n }\r\n }\r\n m -> addr = addr;\r\n m -> file = file;\r\n m -> line = line;\r\n m -> num = num;\r\n if (options & 0x2) {\r\n CRYPTO_THREADID_current(&m -> threadid);\r\n }\r\n else {\r\n memset((&m -> threadid),0,sizeof(m -> threadid));\r\n }\r\n if (order == break_order_num) {\r\n\r\n m -> order = order;\r\n }\r\n m -> order = order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (options & 0x1) {\r\n m -> time = time(((void *)0));\r\n }\r\n else {\r\n m -> time = 0;\r\n }\r\n CRYPTO_THREADID_current(&tmp . threadid);\r\n m -> app_info = ((void *)0);\r\n if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {\r\n m -> app_info = amim;\r\n amim -> references++;\r\n }\r\n if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {\r\n\r\n if (mm -> app_info != ((void *)0)) {\r\n mm -> app_info -> references--;\r\n }\r\n CRYPTO_free(mm);\r\n }\r\n err:\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\n\r\nvoid CRYPTO_dbg_free(void *addr,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n switch(before_p){\r\n case 0:\r\n{\r\n if (addr == ((void *)0)) {\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on() && mh != ((void *)0)) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n if (mp -> app_info != ((void *)0)) {\r\n app_info_free(mp -> app_info);\r\n }\r\n CRYPTO_free(mp);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n case 1:\r\n break; \r\n }\r\n}\r\n\r\nvoid CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p)\r\n{\r\n MEM m;\r\n MEM *mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n switch(before_p){\r\n case 0:\r\n break; \r\n case 1:\r\n{\r\n if (addr2 == ((void *)0)) {\r\n break; \r\n }\r\n if (addr1 == ((void *)0)) {\r\n CRYPTO_dbg_malloc(addr2,num,file,line,128 | before_p);\r\n break; \r\n }\r\n if (CRYPTO_is_mem_check_on()) {\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n m . addr = addr1;\r\n mp = ((MEM *)(lh_delete(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)(&m)))));\r\n if (mp != ((void *)0)) {\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n mp -> addr = addr2;\r\n mp -> num = num;\r\n (void )((MEM *)(lh_insert(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),((void *)(1?mp : ((MEM *)0))))));\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n }\r\n break; \r\n }\r\n }\r\n return ;\r\n}\r\ntypedef struct mem_leak_st {\r\nBIO_dummy *bio;\r\nint chunks;\r\nlong bytes;}MEM_LEAK;\r\n\r\nstatic void print_leak_doall_arg(const MEM *m,MEM_LEAK *l)\r\n{\r\n char buf[1024];\r\n char *bufp = buf;\r\n APP_INFO *amip;\r\n int ami_cnt;\r\n struct tm *lcl = ((void *)0);\r\n CRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\n if (m -> addr == ((char *)(l -> bio))) {\r\n return ;\r\n }\r\n if (options & 0x1) {\r\n lcl = localtime(&m -> time);\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"[%02d:%02d:%02d] \",lcl -> tm_hour,lcl -> tm_min,lcl -> tm_sec);\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"%5lu file=%s, line=%d, \",m -> order,m -> file,m -> line);\r\n bufp += strlen(bufp);\r\n if (options & 0x2) {\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"thread=%lu, \",CRYPTO_THREADID_hash(&m -> threadid));\r\n bufp += strlen(bufp);\r\n }\r\n BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),\"number=%d, address=%08lX\\n\",m -> num,((unsigned long )(m -> addr)));\r\n bufp += strlen(bufp);\r\n BIO_puts(l -> bio,buf);\r\n l -> chunks++;\r\n l -> bytes += (m -> num);\r\n amip = m -> app_info;\r\n ami_cnt = 0;\r\n if (!amip) {\r\n return ;\r\n }\r\n CRYPTO_THREADID_cpy(&ti,(&amip -> threadid));\r\n do {\r\n int buf_len;\r\n int info_len;\r\n ami_cnt++;\r\n memset(buf,'>',ami_cnt);\r\n BIO_snprintf(buf + ami_cnt,sizeof(buf) - ami_cnt,\" thread=%lu, file=%s, line=%d, info=\\\"\",CRYPTO_THREADID_hash((&amip -> threadid)),amip -> file,amip -> line);\r\n buf_len = (strlen(buf));\r\n info_len = (strlen(amip -> info));\r\n if (128 - buf_len - 3 < info_len) {\r\n memcpy((buf + buf_len),(amip -> info),(128 - buf_len - 3));\r\n buf_len = 128 - 3;\r\n }\r\n else {\r\n BUF_strlcpy(buf + buf_len,amip -> info,sizeof(buf) - buf_len);\r\n buf_len = (strlen(buf));\r\n }\r\n BIO_snprintf(buf + buf_len,sizeof(buf) - buf_len,\"\\\"\\n\");\r\n BIO_puts(l -> bio,buf);\r\n amip = amip -> next;\r\n }while (amip && !CRYPTO_THREADID_cmp((&amip -> threadid),(&ti)));\r\n#ifdef LEVITTE_DEBUG_MEM\r\n#endif\r\n}\r\n\r\nstatic void print_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n MEM_LEAK *b = arg2;\r\n print_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks(BIO_dummy *b)\r\n{\r\n MEM_LEAK ml;\r\n if (mh == ((void *)0) && amih == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n ml . bio = b;\r\n ml . bytes = 0;\r\n ml . chunks = 0;\r\n if (mh != ((void *)0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),print_leak_LHASH_DOALL_ARG,((void *)(&ml)));\r\n }\r\n if (ml . chunks != 0) {\r\n BIO_printf(b,\"%ld bytes leaked in %d chunks\\n\",ml . bytes,ml . chunks);\r\n#ifdef CRYPTO_MDEBUG_ABORT\r\n#endif\r\n }\r\n else {\r\n\r\n int old_mh_mode;\r\n CRYPTO_lock(1 | 8,20,\"mem_dbg.c\",798);\r\n\r\n old_mh_mode = mh_mode;\r\n mh_mode = 0;\r\n if (mh != ((void *)0)) {\r\n lh_free(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))));\r\n mh = ((void *)0);\r\n }\r\n if (amih != ((void *)0)) {\r\n if (lh_num_items(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0)))))) == 0) {\r\n lh_free(((_LHASH *)((void *)(1?amih : ((struct lhash_st_APP_INFO *)0)))));\r\n amih = ((void *)0);\r\n }\r\n }\r\n mh_mode = old_mh_mode;\r\n CRYPTO_lock(2 | 8,20,\"mem_dbg.c\",820);\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x2);\r\n}\r\n#ifndef OPENSSL_NO_FP_API\r\n\r\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\r\n{\r\n BIO_dummy *b;\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n\r\n CRYPTO_mem_ctrl(0x3);\r\n b = BIO_new(BIO_s_file());\r\n CRYPTO_mem_ctrl(0x2);\r\n if (!b) {\r\n return ;\r\n }\r\n BIO_ctrl(b,106,0,((char *)fp));\r\n CRYPTO_mem_leaks(b);\r\n BIO_free(b);\r\n}\r\n#endif\r\n\r\n\r\n\r\ntypedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;\r\n\r\nstatic void cb_leak_doall_arg(const MEM *m,PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n ( *cb)(m -> order,m -> file,m -> line,m -> num,m -> addr);\r\n}\r\n\r\nstatic void cb_leak_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n const MEM *a = arg1;\r\n PCRYPTO_MEM_LEAK_CB *b = arg2;\r\n cb_leak_doall_arg(a,b);\r\n}\r\n\r\nvoid CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n if (mh == ((void *)0)) {\r\n return ;\r\n }\r\n CRYPTO_lock(1 | 8,27,\"mem_dbg.c\",870);\r\n lh_doall_arg(((_LHASH *)((void *)(1?mh : ((struct lhash_st_MEM *)0)))),cb_leak_LHASH_DOALL_ARG,((void *)(&cb)));\r\n CRYPTO_lock(2 | 8,27,\"mem_dbg.c\",873);\r\n}\r\n\r\nvoid handle_taint(char *isn_animalism)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *scutel_algedo = 0;\r\n jmp_buf enlister_mulberry;\r\n int comicography_undersuck;\r\n void *tonishness_preliberation = 0;\r\n ++global_variable;;\r\n if (isn_animalism != 0) {;\r\n tonishness_preliberation = ((void *)isn_animalism);\r\n comicography_undersuck = setjmp(enlister_mulberry);\r\n if (comicography_undersuck == 0) {\r\n longjmp(enlister_mulberry,1);\r\n }\r\n scutel_algedo = ((char *)((char *)tonishness_preliberation));\r\n \r\n buffer_value = atoi(scutel_algedo);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\n if (((char *)tonishness_preliberation) != 0) \r\n free(((char *)((char *)tonishness_preliberation)));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n\n memset(malloc_buffer,0,size_buffer);\n printf(\"Buffer size is %d\\n\", size_buffer);\n```", "cwe": "476"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint knapscap_antireticular = 0;\r\nint global_variable;\r\nvoid slimsier_multitasking(char **pleasantdale_micropetrology);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid pongees_orchel(void (*scratchy_dif)(char **));\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&knapscap_antireticular,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n pongees_orchel(slimsier_multitasking);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid slimsier_multitasking(char **pleasantdale_micropetrology)\r\n{\r\n char *hecatonstylon_kolinskies;\r\n ++global_variable;;\r\n setup_printf_context();\r\n hecatonstylon_kolinskies = getenv(\"ESPERANTIDIST_DIGLOSSIA\");\r\n if (hecatonstylon_kolinskies != 0) {;\r\n *pleasantdale_micropetrology = hecatonstylon_kolinskies;\r\n }\r\n}\r\n\r\nvoid pongees_orchel(void (*scratchy_dif)(char **))\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *indexers_devoutlessness = 0;\r\n char *menison_dhan[21] = {0};\r\n ++global_variable;\r\n char *toothachy_resinoelectric = 0;\r\n scratchy_dif(&toothachy_resinoelectric);\r\n if (toothachy_resinoelectric != 0) {;\r\n menison_dhan[16] = toothachy_resinoelectric;\r\n indexers_devoutlessness = ((char *)menison_dhan[16]);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, indexers_devoutlessness);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer)) {\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n } else {\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint undecennial_gulfed = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n int oc_i = 0;\r\n char buffer[8];\r\n char *virulented_bantry = 0;\r\n int pillmaking_sabin;\r\n int aquilinity_solemnization;\r\n char **heartsomeness_tranks = 0;\r\n long springling_beachie[10];\r\n char **crane_snipy[10] = {0};\r\n char *antiphlogistin_erythron[5] = {0};\r\n char *bluntishness_fibiger;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&undecennial_gulfed,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&bluntishness_fibiger,\"PLUTEUS_VALLECULA\");\r\n if (bluntishness_fibiger != 0) {;\r\n antiphlogistin_erythron[3] = bluntishness_fibiger;\r\n crane_snipy[5] = antiphlogistin_erythron;\r\n springling_beachie[1] = 5;\r\n heartsomeness_tranks = *(crane_snipy + springling_beachie[1]);\r\n aquilinity_solemnization = 5;\r\n while(1 == 1){\r\n aquilinity_solemnization = aquilinity_solemnization * 2;\r\n aquilinity_solemnization = aquilinity_solemnization + 2;\r\n if (aquilinity_solemnization > 1000) {\r\n break; \r\n }\r\n }\r\n pillmaking_sabin = aquilinity_solemnization;\r\n virulented_bantry = ((char *)heartsomeness_tranks[3]);\r\n \r\n \r\n \r\n \r\n \r\n \r\n strncpy(buffer,virulented_bantry,strlen(virulented_bantry) + 1);\r\n for (; oc_i < strlen(buffer); ++oc_i) {\r\n buffer[oc_i] = toupper(buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\",buffer);\r\n \r\n \r\n \r\n;\r\n if (heartsomeness_tranks[3] != 0) \r\n free(((char *)heartsomeness_tranks[3]));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n \n \n strncpy(buffer,virulented_bantry,strlen(virulented_bantry) + 1);\n for (; oc_i < strlen(buffer); ++oc_i) {\n buffer[oc_i] = toupper(buffer[oc_i]);\n }\n printf(\"%s\\n\",buffer);\n```", "cwe": "805"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint supergenual_stelliscript = 0;\r\ntypedef char *musit_dinner;\r\nint global_variable;\r\nvoid handle_taint(char *miliolite_nullity);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&supergenual_stelliscript,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid handle_taint(char *miliolite_nullity)\r\n{\r\n int i = 0;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *heap_buff_64 = 0;\r\n char *butylation_meth = 0;\r\n musit_dinner petrovsk_upbrighten = 0;\r\n int **************************************************convoker_camletine = 0;\r\n int *************************************************basyl_charivan = 0;\r\n int ************************************************chromite_dehortatory = 0;\r\n int ***********************************************kiddingly_saltman = 0;\r\n int **********************************************constringed_precultivating = 0;\r\n int *********************************************disembitter_schroeder = 0;\r\n int ********************************************kinglihood_truanting = 0;\r\n int *******************************************tardily_gonidial = 0;\r\n int ******************************************dentinasal_hopples = 0;\r\n int *****************************************curucaneca_metrorrhagia = 0;\r\n int ****************************************markkaa_coadjudicator = 0;\r\n int ***************************************nymphos_rontgenized = 0;\r\n int **************************************goggan_elver = 0;\r\n int *************************************outbloomed_recontrolling = 0;\r\n int ************************************fertilize_antitorpedo = 0;\r\n int ***********************************dhamma_superalkalinity = 0;\r\n int **********************************enterotoxemia_pragmatizer = 0;\r\n int *********************************hogg_revengeless = 0;\r\n int ********************************overbaking_achievable = 0;\r\n int *******************************filigraned_mastosquamose = 0;\r\n int ******************************bootied_carlovingian = 0;\r\n int *****************************coat_tungus = 0;\r\n int ****************************smokish_doddle = 0;\r\n int ***************************jamesstore_yesima = 0;\r\n int **************************xanthene_cullionly = 0;\r\n int *************************bared_radicates = 0;\r\n int ************************chaunter_ocdm = 0;\r\n int ***********************caprylic_munific = 0;\r\n int **********************convertend_manganocalcite = 0;\r\n int *********************sassanid_eucrite = 0;\r\n int ********************bontocs_cardiokinetic = 0;\r\n int *******************superweapon_fivish = 0;\r\n int ******************rostrated_formalist = 0;\r\n int *****************illusorily_enviroment = 0;\r\n int ****************loses_stratochamber = 0;\r\n int ***************fairly_propagand = 0;\r\n int **************krameria_munificency = 0;\r\n int *************bedumbing_sunsuit = 0;\r\n int ************aeu_castora = 0;\r\n int ***********hanses_mundugumors = 0;\r\n int **********filibusterism_pleurobrachia = 0;\r\n int *********kweichow_ignatia = 0;\r\n int ********phenylcarbamic_centralistic = 0;\r\n int *******ringing_pin = 0;\r\n int ******sightliness_absorbs = 0;\r\n int *****doglegging_niris = 0;\r\n int ****stationing_incarcerate = 0;\r\n int ***urinator_fripperer = 0;\r\n int **cohog_lappish = 0;\r\n int *leckrone_ogham = 0;\r\n int chymify_fulvous;\r\n musit_dinner scriptural_acetophenine[10] = {0};\r\n musit_dinner familiarised_temperate = 0;\r\n ++global_variable;;\r\n if (miliolite_nullity != 0) {;\r\n familiarised_temperate = miliolite_nullity;\r\n chymify_fulvous = 5;\r\n leckrone_ogham = &chymify_fulvous;\r\n cohog_lappish = &leckrone_ogham;\r\n urinator_fripperer = &cohog_lappish;\r\n stationing_incarcerate = &urinator_fripperer;\r\n doglegging_niris = &stationing_incarcerate;\r\n sightliness_absorbs = &doglegging_niris;\r\n ringing_pin = &sightliness_absorbs;\r\n phenylcarbamic_centralistic = &ringing_pin;\r\n kweichow_ignatia = &phenylcarbamic_centralistic;\r\n filibusterism_pleurobrachia = &kweichow_ignatia;\r\n hanses_mundugumors = &filibusterism_pleurobrachia;\r\n aeu_castora = &hanses_mundugumors;\r\n bedumbing_sunsuit = &aeu_castora;\r\n krameria_munificency = &bedumbing_sunsuit;\r\n fairly_propagand = &krameria_munificency;\r\n loses_stratochamber = &fairly_propagand;\r\n illusorily_enviroment = &loses_stratochamber;\r\n rostrated_formalist = &illusorily_enviroment;\r\n superweapon_fivish = &rostrated_formalist;\r\n bontocs_cardiokinetic = &superweapon_fivish;\r\n sassanid_eucrite = &bontocs_cardiokinetic;\r\n convertend_manganocalcite = &sassanid_eucrite;\r\n caprylic_munific = &convertend_manganocalcite;\r\n chaunter_ocdm = &caprylic_munific;\r\n bared_radicates = &chaunter_ocdm;\r\n xanthene_cullionly = &bared_radicates;\r\n jamesstore_yesima = &xanthene_cullionly;\r\n smokish_doddle = &jamesstore_yesima;\r\n coat_tungus = &smokish_doddle;\r\n bootied_carlovingian = &coat_tungus;\r\n filigraned_mastosquamose = &bootied_carlovingian;\r\n overbaking_achievable = &filigraned_mastosquamose;\r\n hogg_revengeless = &overbaking_achievable;\r\n enterotoxemia_pragmatizer = &hogg_revengeless;\r\n dhamma_superalkalinity = &enterotoxemia_pragmatizer;\r\n fertilize_antitorpedo = &dhamma_superalkalinity;\r\n outbloomed_recontrolling = &fertilize_antitorpedo;\r\n goggan_elver = &outbloomed_recontrolling;\r\n nymphos_rontgenized = &goggan_elver;\r\n markkaa_coadjudicator = &nymphos_rontgenized;\r\n curucaneca_metrorrhagia = &markkaa_coadjudicator;\r\n dentinasal_hopples = &curucaneca_metrorrhagia;\r\n tardily_gonidial = &dentinasal_hopples;\r\n kinglihood_truanting = &tardily_gonidial;\r\n disembitter_schroeder = &kinglihood_truanting;\r\n constringed_precultivating = &disembitter_schroeder;\r\n kiddingly_saltman = &constringed_precultivating;\r\n chromite_dehortatory = &kiddingly_saltman;\r\n basyl_charivan = &chromite_dehortatory;\r\n convoker_camletine = &basyl_charivan;\r\n scriptural_acetophenine[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *convoker_camletine)))))))))))))))))))))))))))))))))))))))))))))))))] = familiarised_temperate;\r\n petrovsk_upbrighten = scriptural_acetophenine[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *convoker_camletine)))))))))))))))))))))))))))))))))))))))))))))))))];\r\n butylation_meth = ((char *)petrovsk_upbrighten);\r\n \r\n \r\n \r\n heap_buff_64 = (char*) malloc(64 * sizeof(char));\r\n if (heap_buff_64 != NULL) {\r\n memset(heap_buff_64, 'A' ,64);\r\n heap_buff_64[64 - 1] = '\\0';\r\n \r\n \r\n \r\n taint_len = ((int )(strlen(butylation_meth)));\r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n \r\n \r\n heap_buff_64[buff_size] = butylation_meth[taint_len];\r\n }\r\n \r\n for (; i < 64; ++i) {\r\n heap_buff_64[i] = toupper(heap_buff_64[i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\r\n free(heap_buff_64);\r\n \r\n \r\n \r\n }\r\n;\r\n if (petrovsk_upbrighten != 0) \r\n free(((char *)petrovsk_upbrighten));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif \r\n#endif \r\noutput your answer code in the format: `{code}`", "output": "``` taint_len = ((int )(strlen(butylation_meth)));\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\n \n \n heap_buff_64[buff_size] = butylation_meth[taint_len];\n }\n \n for (; i < 64; ++i) {\n heap_buff_64[i] = toupper(heap_buff_64[i]);\n }\n```", "cwe": "124"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\nint secondrater_vista = 0;\r\n\r\nstruct sanferd_cessative \r\n{\r\n char *logions_ironshod;\r\n double unsensitize_salmonberry;\r\n char *pelides_mephistophelian;\r\n char ensweeten_tourers;\r\n int broadwife_lethiferous;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *petiolus_honored);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid phytolith_manliness(struct sanferd_cessative **************************************************patagon_perkiomenville);\r\nstruct list {\r\n int data;\r\n struct list *previous;\r\n struct list *next;\r\n};\r\nstruct queue {\r\n pthread_mutex_t lock;\r\n pthread_cond_t is_empty;\r\n pthread_cond_t is_full;\r\n int size;\r\n int capacity;\r\n struct list *head;\r\n struct list *tail;\r\n};\r\nstruct data {\r\n int qsize;\r\n int data;\r\n char* file1;\r\n char* file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nint enqueue(struct queue *ssQ, int data) {\r\n int rtnval = 0;\r\n if (ssQ != NULL) {\r\n struct list *elem = malloc(sizeof(struct list));\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size >= ssQ->capacity) {\r\n pthread_cond_wait(&(ssQ->is_full), &(ssQ->lock));\r\n }\r\n elem->next = NULL;\r\n elem->previous = ssQ->tail;\r\n elem->data = data;\r\n if (ssQ->tail != NULL) {\r\n ssQ->tail->next = elem;\r\n }\r\n ssQ->tail = elem;\r\n ssQ->size++;\r\n if (ssQ->head == NULL) {\r\n ssQ->head = elem;\r\n }\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_empty));\r\n }\r\n else {\r\n rtnval = -1;\r\n }\r\n return rtnval;\r\n}\r\nint dequeue(struct queue *ssQ) {\r\n int val = -1;\r\n if (ssQ != NULL) {\r\n struct list *elem;\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size <= 0) {\r\n pthread_cond_wait(&(ssQ->is_empty), &(ssQ->lock));\r\n }\r\n elem = ssQ->head;\r\n ssQ->head = elem->next;\r\n if(ssQ->head != NULL) {\r\n ssQ->head->previous = NULL;\r\n }\r\n else {\r\n ssQ->tail = NULL;\r\n }\r\n val = elem->data;\r\n ssQ->size--;\r\n free(elem);\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_full));\r\n }\r\n return val;\r\n}\r\nstruct queue *get_instance (char* file2) {\r\n static struct queue *ssQ = NULL;\r\n \r\n \r\n \r\n if (ssQ == NULL) {\r\n if (file2 != NULL) {\r\n readFile(file2);\r\n }\r\n ssQ = (struct queue *)calloc(1, sizeof(struct queue));\r\n pthread_mutex_init(&(ssQ->lock), NULL);\r\n pthread_cond_init(&(ssQ->is_empty), NULL);\r\n pthread_cond_init(&(ssQ->is_full), NULL);\r\n ssQ->size = 0;\r\n ssQ->capacity = 30;\r\n ssQ->head = NULL;\r\n ssQ->tail = NULL;\r\n }\r\n \r\n \r\n return ssQ;\r\n}\r\nvoid *print_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ = get_instance(ssD->file2);\r\n int i;\r\n \r\n \r\n \r\n while ((i = dequeue(ssQ)) != -1) {\r\n printf(\"Data: %d\\n\", i);\r\n }\r\n \r\n return NULL;\r\n}\r\nvoid *calc_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ;\r\n int *qsort_arr;\r\n int i;\r\n \r\n qsort_arr = malloc(sizeof(int)*ssD->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < ssD->qsize; i++) {\r\n qsort_arr[i] = ssD->qsize - i;\r\n }\r\n qsort(qsort_arr, ssD->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(ssD->file1);\r\n ssQ = get_instance(NULL);\r\n \r\n for (i = 0; i < ssD->data; i++) {\r\n \r\n if (enqueue(ssQ, i) == -1) {\r\n break;\r\n }\r\n }\r\n enqueue(ssQ, -1);\r\n \r\n return NULL;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&secondrater_vista,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *petiolus_honored)\r\n{\r\n struct sanferd_cessative **************************************************dehisced_huaracho = 0;\r\n struct sanferd_cessative *************************************************demonomancy_zoocecidium = 0;\r\n struct sanferd_cessative ************************************************fondnesses_caviare = 0;\r\n struct sanferd_cessative ***********************************************sesquisilicate_shapable = 0;\r\n struct sanferd_cessative **********************************************windfish_outburnt = 0;\r\n struct sanferd_cessative *********************************************utopist_imperialism = 0;\r\n struct sanferd_cessative ********************************************praya_hallows = 0;\r\n struct sanferd_cessative *******************************************playcraftsman_idiomaticalness = 0;\r\n struct sanferd_cessative ******************************************areolation_obes = 0;\r\n struct sanferd_cessative *****************************************preselects_expostulator = 0;\r\n struct sanferd_cessative ****************************************bancal_stagehands = 0;\r\n struct sanferd_cessative ***************************************umayyad_petroselinum = 0;\r\n struct sanferd_cessative **************************************wrawl_malacanthine = 0;\r\n struct sanferd_cessative *************************************admonitory_hermaphroditism = 0;\r\n struct sanferd_cessative ************************************intersesamoid_seat = 0;\r\n struct sanferd_cessative ***********************************thetis_reknotted = 0;\r\n struct sanferd_cessative **********************************cotyliform_chancelled = 0;\r\n struct sanferd_cessative *********************************loy_pensionless = 0;\r\n struct sanferd_cessative ********************************basle_telodendria = 0;\r\n struct sanferd_cessative *******************************crevassing_turnix = 0;\r\n struct sanferd_cessative ******************************gavin_biafra = 0;\r\n struct sanferd_cessative *****************************fruitages_savagenesses = 0;\r\n struct sanferd_cessative ****************************overcheap_scribeship = 0;\r\n struct sanferd_cessative ***************************proposedly_holothurioidea = 0;\r\n struct sanferd_cessative **************************conopidae_skedaddled = 0;\r\n struct sanferd_cessative *************************ahmad_adhere = 0;\r\n struct sanferd_cessative ************************dallop_tithonia = 0;\r\n struct sanferd_cessative ***********************sorcerer_outthieving = 0;\r\n struct sanferd_cessative **********************coalitionist_nickstick = 0;\r\n struct sanferd_cessative *********************kias_stairbuilding = 0;\r\n struct sanferd_cessative ********************criminological_cornbin = 0;\r\n struct sanferd_cessative *******************brisk_disown = 0;\r\n struct sanferd_cessative ******************rehems_termor = 0;\r\n struct sanferd_cessative *****************superthankful_longes = 0;\r\n struct sanferd_cessative ****************poortiths_shattuck = 0;\r\n struct sanferd_cessative ***************adephaga_behatted = 0;\r\n struct sanferd_cessative **************thooid_misintimation = 0;\r\n struct sanferd_cessative *************coryneum_overnormalize = 0;\r\n struct sanferd_cessative ************melanocarcinoma_spaceful = 0;\r\n struct sanferd_cessative ***********consolidant_ratheter = 0;\r\n struct sanferd_cessative **********biltongs_isomyarian = 0;\r\n struct sanferd_cessative *********luteinize_djerba = 0;\r\n struct sanferd_cessative ********scholasticism_lindybeth = 0;\r\n struct sanferd_cessative *******salps_isiac = 0;\r\n struct sanferd_cessative ******rewardingly_ovulates = 0;\r\n struct sanferd_cessative *****brachet_indazole = 0;\r\n struct sanferd_cessative ****rep_dncri = 0;\r\n struct sanferd_cessative ***hartail_scorbutic = 0;\r\n struct sanferd_cessative **riss_biplicate = 0;\r\n struct sanferd_cessative *fakey_danish = 0;\r\n struct sanferd_cessative sufflaminate_manueverable = {0};\r\n struct sanferd_cessative writings_peacoat;\r\n ++global_variable;;\r\n if (petiolus_honored != 0) {;\r\n writings_peacoat . logions_ironshod = ((char *)petiolus_honored);\r\n fakey_danish = &writings_peacoat;\r\n riss_biplicate = &fakey_danish;\r\n hartail_scorbutic = &riss_biplicate;\r\n rep_dncri = &hartail_scorbutic;\r\n brachet_indazole = &rep_dncri;\r\n rewardingly_ovulates = &brachet_indazole;\r\n salps_isiac = &rewardingly_ovulates;\r\n scholasticism_lindybeth = &salps_isiac;\r\n luteinize_djerba = &scholasticism_lindybeth;\r\n biltongs_isomyarian = &luteinize_djerba;\r\n consolidant_ratheter = &biltongs_isomyarian;\r\n melanocarcinoma_spaceful = &consolidant_ratheter;\r\n coryneum_overnormalize = &melanocarcinoma_spaceful;\r\n thooid_misintimation = &coryneum_overnormalize;\r\n adephaga_behatted = &thooid_misintimation;\r\n poortiths_shattuck = &adephaga_behatted;\r\n superthankful_longes = &poortiths_shattuck;\r\n rehems_termor = &superthankful_longes;\r\n brisk_disown = &rehems_termor;\r\n criminological_cornbin = &brisk_disown;\r\n kias_stairbuilding = &criminological_cornbin;\r\n coalitionist_nickstick = &kias_stairbuilding;\r\n sorcerer_outthieving = &coalitionist_nickstick;\r\n dallop_tithonia = &sorcerer_outthieving;\r\n ahmad_adhere = &dallop_tithonia;\r\n conopidae_skedaddled = &ahmad_adhere;\r\n proposedly_holothurioidea = &conopidae_skedaddled;\r\n overcheap_scribeship = &proposedly_holothurioidea;\r\n fruitages_savagenesses = &overcheap_scribeship;\r\n gavin_biafra = &fruitages_savagenesses;\r\n crevassing_turnix = &gavin_biafra;\r\n basle_telodendria = &crevassing_turnix;\r\n loy_pensionless = &basle_telodendria;\r\n cotyliform_chancelled = &loy_pensionless;\r\n thetis_reknotted = &cotyliform_chancelled;\r\n intersesamoid_seat = &thetis_reknotted;\r\n admonitory_hermaphroditism = &intersesamoid_seat;\r\n wrawl_malacanthine = &admonitory_hermaphroditism;\r\n umayyad_petroselinum = &wrawl_malacanthine;\r\n bancal_stagehands = &umayyad_petroselinum;\r\n preselects_expostulator = &bancal_stagehands;\r\n areolation_obes = &preselects_expostulator;\r\n playcraftsman_idiomaticalness = &areolation_obes;\r\n praya_hallows = &playcraftsman_idiomaticalness;\r\n utopist_imperialism = &praya_hallows;\r\n windfish_outburnt = &utopist_imperialism;\r\n sesquisilicate_shapable = &windfish_outburnt;\r\n fondnesses_caviare = &sesquisilicate_shapable;\r\n demonomancy_zoocecidium = &fondnesses_caviare;\r\n dehisced_huaracho = &demonomancy_zoocecidium;\r\n phytolith_manliness(dehisced_huaracho);\r\n }\r\n}\r\n\r\nvoid phytolith_manliness(struct sanferd_cessative **************************************************patagon_perkiomenville)\r\n{\r\n pthread_t t0, t1;\r\n struct data* Data;\r\n char *oletta_dooket = 0;\r\n ++global_variable;;\r\n oletta_dooket = ((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *patagon_perkiomenville)))))))))))))))))))))))))))))))))))))))))))))))))) . logions_ironshod);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->file1 = malloc(sizeof(char) * (strlen(oletta_dooket) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(oletta_dooket) + 1));\r\n if ((sscanf(oletta_dooket, \"%d %s %s %d\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n &(Data->data)) == 4) &&\r\n Data->qsize >= 0 &&\r\n Data->data >= 0 &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calc_data, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (pthread_create(&t1, NULL, print_data, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->file1);\r\n free(Data->file2);\r\n free(Data);\r\n }\r\n \r\n;\r\n if (( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *patagon_perkiomenville)))))))))))))))))))))))))))))))))))))))))))))))))) . logions_ironshod != 0) \r\n free(((char *)( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *patagon_perkiomenville)))))))))))))))))))))))))))))))))))))))))))))))))) . logions_ironshod));\r\nclose_printf_context();\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` \n while ((i = dequeue(ssQ)) != -1) {\n printf(\"Data: %d\\n\", i);\n }\n```", "cwe": "543"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint intermiddle_unwetted = 0;\r\n\r\nunion ascaricidal_richmonddale \r\n{\r\n char *collaterally_syzran;\r\n double wordsworth_yode;\r\n char *waganda_fiddlebrained;\r\n char girdler_corambis;\r\n int acrodactyla_recantingly;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nstruct struct {\r\n char before[64];\r\n char buffer[64];\r\n char after[64];\r\n};\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int i = 0;\r\n int buff_size = 0;\r\n struct struct* data = NULL;\r\n char *airbrushed_aneurysms = 0;\r\n int boathouses_trigeminous;\r\n union ascaricidal_richmonddale *pallia_defoliates = {0};\r\n union ascaricidal_richmonddale *philocathartic_pteridospermae = {0};\r\n union ascaricidal_richmonddale searcherlike_hesitating;\r\n char *fugaciously_steganopod;;\r\n if (__sync_bool_compare_and_swap(&intermiddle_unwetted,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&fugaciously_steganopod,\"LEVANTINE_REGINAS\");\r\n if (fugaciously_steganopod != 0) {;\r\n searcherlike_hesitating . collaterally_syzran = fugaciously_steganopod;\r\n boathouses_trigeminous = 1;\r\n pallia_defoliates = &searcherlike_hesitating;\r\n philocathartic_pteridospermae = ((union ascaricidal_richmonddale *)(((unsigned long )pallia_defoliates) * boathouses_trigeminous * boathouses_trigeminous)) + 5;\r\n airbrushed_aneurysms = ((char *)( *(philocathartic_pteridospermae - 5)) . collaterally_syzran);\r\n \r\n \r\n \r\n data = (struct struct*) malloc(sizeof(struct struct));\r\n if (data != NULL) {\r\n memset(data->before, 'A', 63);\r\n data->before[63] = '\\0';\r\n memset(data->buffer, 'Q', 63);\r\n data->buffer[63] = '\\0';\r\n memset(data->after, 'A', 63);\r\n data->after[63] = '\\0';\r\n \r\n \r\n \r\n \r\n \r\n buff_size = ((int )(strlen(airbrushed_aneurysms)));\r\n memcpy(data->buffer, airbrushed_aneurysms, 64);\r\n for (; i < buff_size; ++i){\r\n \r\n \r\n printf(\"%x\",data->buffer[i]);\r\n }\r\n \r\n \r\n \r\n printf(\"\\n\");\r\n free( data);\r\n \r\n \r\n }\r\n;\r\n if (( *(philocathartic_pteridospermae - 5)) . collaterally_syzran != 0) \r\n free(((char *)( *(philocathartic_pteridospermae - 5)) . collaterally_syzran));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` buff_size = ((int )(strlen(airbrushed_aneurysms)));\n memcpy(data->buffer, airbrushed_aneurysms, 64);\n for (; i < buff_size; ++i){\n \n \n printf(\"%x\",data->buffer[i]);\n }\n```", "cwe": "126"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nint provincialize_eurylaimoid = 0;\r\ntypedef char *honebein_superpolite;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nstruct struct {\r\n char base_path[20];\r\n char * buff_pointer;\r\n};\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{\r\n int oc_i = 0;\r\n int opt_var = 0;\r\n struct struct* data = 0;\r\n char *aberdeen_luncheon = 0;\r\n jmp_buf utopist_isla;\r\n int sleeplessness_sension;\r\n int supersuborder_saponated;\r\n honebein_superpolite *granitite_discombobulated = 0;\r\n honebein_superpolite *gunstone_sigmodontes = 0;\r\n honebein_superpolite whitebook_nabak = 0;\r\n char *anisotropically_superfused;;\r\n if (__sync_bool_compare_and_swap(&provincialize_eurylaimoid,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n anisotropically_superfused = getenv(\"RENORMALIZE_DRUMORE\");\r\n if (anisotropically_superfused != 0) {;\r\n whitebook_nabak = anisotropically_superfused;\r\n supersuborder_saponated = 1;\r\n granitite_discombobulated = &whitebook_nabak;\r\n gunstone_sigmodontes = ((honebein_superpolite *)(((unsigned long )granitite_discombobulated) * supersuborder_saponated * supersuborder_saponated)) + 5;\r\n sleeplessness_sension = setjmp(utopist_isla);\r\n if (sleeplessness_sension == 0) {\r\n longjmp(utopist_isla,1);\r\n }\r\n aberdeen_luncheon = ((char *)( *(gunstone_sigmodontes - 5)));\r\n \r\n if (strlen(aberdeen_luncheon) < 20) {;\r\n data = (struct struct*) malloc (sizeof(struct struct));\r\n if (data != NULL) {\r\n memset(data->base_path, 0, 20);\r\n data->buff_pointer = data->base_path;\r\n \r\n \r\n\r\n\r\n realpath(aberdeen_luncheon, data->base_path);\r\n opt_var = strlen( data->buff_pointer);\r\n \r\n for (; oc_i < opt_var; ++oc_i) {\r\n data->base_path[oc_i] =\r\n toupper(data->base_path[oc_i]);\r\n }\r\n printf(\"%s\\n\", data->base_path);\r\n printf(\"%s\\n\", data->buff_pointer);\r\n \r\n \r\n free (data);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n\n realpath(aberdeen_luncheon, data->base_path);\n opt_var = strlen( data->buff_pointer);\n \n for (; oc_i < opt_var; ++oc_i) {\n data->base_path[oc_i] =\n toupper(data->base_path[oc_i]);\n }\n printf(\"%s\\n\", data->base_path);\n printf(\"%s\\n\", data->buff_pointer);\n```", "cwe": "785"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\nint herbary_compactedly = 0;\r\n\r\nstruct brunnhilde_cuso \r\n{\r\n char *moderant_commonish;\r\n double pecksniffism_scutelligerous;\r\n char *creature_southcottian;\r\n char zionists_deflator;\r\n int gammoner_rexx;\r\n}\r\n;\r\nint global_variable;\r\nvoid recruitors_oxygenicity(struct brunnhilde_cuso *legwork_gastrophile);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid ribonucleotide_phrasable(void (*forehoofs_theomachy)(struct brunnhilde_cuso *));\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&herbary_compactedly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n ribonucleotide_phrasable(recruitors_oxygenicity);\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid recruitors_oxygenicity(struct brunnhilde_cuso *legwork_gastrophile)\r\n{\r\n struct brunnhilde_cuso quomodos_beaverism;\r\n int dobuans_reckoning = 30;\r\n char *outperforming_johnsonburg;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&outperforming_johnsonburg,\"1071\",dobuans_reckoning);\r\n if (outperforming_johnsonburg != 0) {;\r\n quomodos_beaverism . moderant_commonish = ((char *)outperforming_johnsonburg);\r\n *legwork_gastrophile = quomodos_beaverism;\r\n }\r\n}\r\n\r\nvoid ribonucleotide_phrasable(void (*forehoofs_theomachy)(struct brunnhilde_cuso *))\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n char *excommune_subindustry = 0;\r\n struct brunnhilde_cuso pycnosporic_proverbialism = {0};\r\n int *mellow_devachan = 0;\r\n int zubkoff_gormands;\r\n struct brunnhilde_cuso sunfoil_unvictualed[10] = {0};\r\n ++global_variable;\r\n struct brunnhilde_cuso praham_adultoid = {0};\r\n forehoofs_theomachy(&praham_adultoid);\r\n if (praham_adultoid . moderant_commonish != 0) {;\r\n sunfoil_unvictualed[5] = praham_adultoid;\r\n zubkoff_gormands = 5;\r\n mellow_devachan = &zubkoff_gormands;\r\n pycnosporic_proverbialism = *(sunfoil_unvictualed + *mellow_devachan);\r\n excommune_subindustry = ((char *)pycnosporic_proverbialism . moderant_commonish);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",excommune_subindustry);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer) == 0) {\r\n do {\r\n result = mysql_store_result(conn);\r\n if (result != 0) {\r\n num_rows = mysql_num_rows(result);\r\n if (num_rows != 0) {\r\n num_fields = mysql_num_fields(result);\r\n while((row = mysql_fetch_row(result))){\r\n for (i = 0; i < num_fields; ++i)\r\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\r\n printf(\"\\n\");\r\n }\r\n mysql_free_result(result);\r\n }\r\n }\r\n else {\r\n if (mysql_field_count(conn) == 0)\r\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\r\n else {\r\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\r\n break;\r\n }\r\n }\r\n status = mysql_next_result(conn);\r\n if (status > 0)\r\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\r\n }while (status == 0);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (pycnosporic_proverbialism . moderant_commonish != 0) \r\n free(((char *)pycnosporic_proverbialism . moderant_commonish));\r\nclose_printf_context();\r\n }\r\n}\r\noutput your answer code in the format: `{code}`", "output": "```\n if (mysql_query(conn,query_buffer) == 0) {\n do {\n result = mysql_store_result(conn);\n if (result != 0) {\n num_rows = mysql_num_rows(result);\n if (num_rows != 0) {\n num_fields = mysql_num_fields(result);\n while((row = mysql_fetch_row(result))){\n for (i = 0; i < num_fields; ++i)\n printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n printf(\"\\n\");\n }\n mysql_free_result(result);\n }\n }\n else {\n if (mysql_field_count(conn) == 0)\n printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n else {\n printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n break;\n }\n }\n status = mysql_next_result(conn);\n if (status > 0)\n printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n }while (status == 0);\n }\n else {\n \n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n }\n```", "cwe": "89"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint exsanguious_spindlelike = 0;\r\nint global_variable;\r\nvoid handle_taint(char *bold_insinuated);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nchar *eurythermous_braised(char *prelude_credibleness);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&exsanguious_spindlelike,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *bold_insinuated)\r\n{\r\n FILE *file = 0;\r\n int ssi = 0;\r\n FILE *files = 0;\r\n FILE *file_list[1020];\r\n char filename[80];\r\n char *uroscopist_jactitating = 0;\r\n char *metrorrhagia_radiancy = 0;\r\n ++global_variable;;\r\n if (bold_insinuated != 0) {;\r\n metrorrhagia_radiancy = eurythermous_braised(bold_insinuated);\r\n uroscopist_jactitating = ((char *)metrorrhagia_radiancy);\r\n \r\n files = fopen(uroscopist_jactitating,\"r\");\r\n if (files != 0) {\r\n \r\n \r\n while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\r\n file = fopen(filename,\"w\");\r\n if (file == 0 && errno == 24) {\r\n printf(\"Fopen error due to ulimit\\n\");\r\n continue;\r\n }\r\n fputs(\"woohoo!\",file);\r\n fflush(file);\r\n \r\n \r\n file_list[ssi] = file;\r\n ssi++;\r\n }\r\n \r\n \r\n }\r\n printf(\"finished evaluating\\n\");\r\n if (files != 0)\r\n fclose(files);\r\n \r\n;\r\n if (metrorrhagia_radiancy != 0) \r\n free(((char *)metrorrhagia_radiancy));\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nchar *eurythermous_braised(char *prelude_credibleness)\r\n{\r\n ++global_variable;\r\n return prelude_credibleness;\r\n}\r\noutput your answer code in the format: `{code}`", "output": "``` while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n file = fopen(filename,\"w\");\n if (file == 0 && errno == 24) {\n printf(\"Fopen error due to ulimit\\n\");\n continue;\n }\n fputs(\"woohoo!\",file);\n fflush(file);\n \n \n file_list[ssi] = file;\n ssi++;\n }\n```", "cwe": "775"}
{"instruction": "Assuming you are an experienced code vulnerability analyst who can only output code snippets and the following code may have vulnerabilities.Which line of code is the root cause point of the vulnerability?", "input": "another_hunk (enum diff difftype, bool rev)\r\r\n{\r\r\n char *s;\r\r\n lin context = 0;\r\r\n size_t chars_read;\r\r\n char numbuf0[LINENUM_LENGTH_BOUND + 1];\r\r\n char numbuf1[LINENUM_LENGTH_BOUND + 1];\r\r\n char numbuf2[LINENUM_LENGTH_BOUND + 1];\r\r\n char numbuf3[LINENUM_LENGTH_BOUND + 1];\r\r\n\r\r\n while (p_end >= 0) {\r\r\n\tif (p_end == p_efake)\r\r\n\t p_end = p_bfake;\t\t/* don't free twice */\r\r\n\telse\r\r\n\t free(p_line[p_end]);\r\r\n\tp_end--;\r\r\n }\r\r\n assert(p_end == -1);\r\r\n p_efake = -1;\r\r\n\r\r\n if (p_c_function)\r\r\n {\r\r\n\tfree (p_c_function);\r\r\n\tp_c_function = NULL;\r\r\n }\r\r\n\r\r\n p_max = hunkmax;\t\t\t/* gets reduced when --- found */\r\r\n if (difftype == CONTEXT_DIFF || difftype == NEW_CONTEXT_DIFF) {\r\r\n\tfile_offset line_beginning = file_tell (pfp);\r\r\n\t\t\t\t\t/* file pos of the current line */\r\r\n\tlin repl_beginning = 0;\t\t/* index of --- line */\r\r\n\tlin fillcnt = 0;\t/* #lines of missing ptrn or repl */\r\r\n\tlin fillsrc;\t\t/* index of first line to copy */\r\r\n\tlin filldst;\t\t/* index of first missing line */\r\r\n\tbool ptrn_spaces_eaten = false;\t/* ptrn was slightly misformed */\r\r\n\tbool some_context = false;\t/* (perhaps internal) context seen */\r\r\n\tbool repl_could_be_missing = true;\r\r\n\tbool ptrn_missing = false;\t/* The pattern was missing. */\r\r\n\tbool repl_missing = false;\t/* Likewise for replacement. */\r\r\n\tfile_offset repl_backtrack_position = 0;\r\r\n\t\t\t\t\t/* file pos of first repl line */\r\r\n\tlin repl_patch_line;\t\t/* input line number for same */\r\r\n\tlin repl_context;\t\t/* context for same */\r\r\n\tlin ptrn_prefix_context = -1;\t/* lines in pattern prefix context */\r\r\n\tlin ptrn_suffix_context = -1;\t/* lines in pattern suffix context */\r\r\n\tlin repl_prefix_context = -1;\t/* lines in replac. prefix context */\r\r\n\tlin ptrn_copiable = 0;\t\t/* # of copiable lines in ptrn */\r\r\n\tlin repl_copiable = 0;\t\t/* Likewise for replacement. */\r\r\n\r\r\n\t/* Pacify `gcc -Wall'. */\r\r\n\tfillsrc = filldst = repl_patch_line = repl_context = 0;\r\r\n\r\r\n\tchars_read = get_line ();\r\r\n\tif (chars_read == (size_t) -1\r\r\n\t || chars_read <= 8\r\r\n\t || strncmp (buf, \"********\", 8) != 0) {\r\r\n\t next_intuit_at(line_beginning,p_input_line);\r\r\n\t return chars_read == (size_t) -1 ? -1 : 0;\r\r\n\t}\r\r\n\ts = buf;\r\r\n\twhile (*s == '*')\r\r\n\t s++;\r\r\n\tif (*s == ' ')\r\r\n\t {\r\r\n\t p_c_function = s;\r\r\n\t while (*s != '\\n')\r\r\n\t\ts++;\r\r\n\t *s = '\\0';\r\r\n\t p_c_function = savestr (p_c_function);\r\r\n\t }\r\r\n\tp_hunk_beg = p_input_line + 1;\r\r\n\twhile (p_end < p_max) {\r\r\n\t chars_read = get_line ();\r\r\n\t if (chars_read == (size_t) -1)\r\r\n\t return -1;\r\r\n\t if (!chars_read) {\r\r\n\t\tif (repl_beginning && repl_could_be_missing) {\r\r\n\t\t repl_missing = true;\r\r\n\t\t goto hunk_done;\r\r\n\t\t}\r\r\n\t\tif (p_max - p_end < 4) {\r\r\n\t\t strcpy (buf, \" \\n\"); /* assume blank lines got chopped */\r\r\n\t\t chars_read = 3;\r\r\n\t\t} else {\r\r\n\t\t fatal (\"unexpected end of file in patch\");\r\r\n\t\t}\r\r\n\t }\r\r\n\t p_end++;\r\r\n\t if (p_end == hunkmax)\r\r\n\t fatal (\"unterminated hunk starting at line %s; giving up at line %s: %s\",\r\r\n\t\t format_linenum (numbuf0, pch_hunk_beg ()),\r\r\n\t\t format_linenum (numbuf1, p_input_line), buf);\r\r\n\t assert(p_end < hunkmax);\r\r\n\t p_Char[p_end] = *buf;\r\r\n\t p_len[p_end] = 0;\r\r\n\t p_line[p_end] = 0;\r\r\n\t switch (*buf) {\r\r\n\t case '*':\r\r\n\t\tif (strnEQ(buf, \"********\", 8)) {\r\r\n\t\t if (repl_beginning && repl_could_be_missing) {\r\r\n\t\t\trepl_missing = true;\r\r\n\t\t\tgoto hunk_done;\r\r\n\t\t }\r\r\n\t\t else\r\r\n\t\t fatal (\"unexpected end of hunk at line %s\",\r\r\n\t\t\t format_linenum (numbuf0, p_input_line));\r\r\n\t\t}\r\r\n\t\tif (p_end != 0) {\r\r\n\t\t if (repl_beginning && repl_could_be_missing) {\r\r\n\t\t\trepl_missing = true;\r\r\n\t\t\tgoto hunk_done;\r\r\n\t\t }\r\r\n\t\t fatal (\"unexpected `***' at line %s: %s\",\r\r\n\t\t\t format_linenum (numbuf0, p_input_line), buf);\r\r\n\t\t}\r\r\n\t\tcontext = 0;\r\r\n\t\tp_len[p_end] = strlen (buf);\r\r\n\t\tif (! (p_line[p_end] = savestr (buf))) {\r\r\n\t\t p_end--;\r\r\n\t\t return -1;\r\r\n\t\t}\r\r\n\t\tfor (s = buf; *s && !ISDIGIT (*s); s++)\r\r\n\t\t /* do nothing */ ;\r\r\n\t\tif (strnEQ(s,\"0,0\",3))\r\r\n\t\t remove_prefix (s, 2);\r\r\n\t\ts = scan_linenum (s, &p_first);\r\r\n\t\tif (*s == ',') {\r\r\n\t\t while (*s && !ISDIGIT (*s))\r\r\n\t\t s++;\r\r\n\t\t scan_linenum (s, &p_ptrn_lines);\r\r\n\t\t p_ptrn_lines += 1 - p_first;\r\r\n\t\t}\r\r\n\t\telse if (p_first)\r\r\n\t\t p_ptrn_lines = 1;\r\r\n\t\telse {\r\r\n\t\t p_ptrn_lines = 0;\r\r\n\t\t p_first = 1;\r\r\n\t\t}\r\r\n\t\tp_max = p_ptrn_lines + 6;\t/* we need this much at least */\r\r\n\t\twhile (p_max + 1 >= hunkmax)\r\r\n\t\t if (! grow_hunkmax ())\r\r\n\t\t\treturn -1;\r\r\n\t\tp_max = hunkmax;\r\r\n\t\tbreak;\r\r\n\t case '-':\r\r\n\t\tif (buf[1] != '-')\r\r\n\t\t goto change_line;\r\r\n\t\tif (ptrn_prefix_context == -1)\r\r\n\t\t ptrn_prefix_context = context;\r\r\n\t\tptrn_suffix_context = context;\r\r\n\t\tif (repl_beginning\r\r\n\t\t || (p_end\r\r\n\t\t\t!= p_ptrn_lines + 1 + (p_Char[p_end - 1] == '\\n')))\r\r\n\t\t {\r\r\n\t\t if (p_end == 1)\r\r\n\t\t {\r\r\n\t\t\t/* `Old' lines were omitted. Set up to fill\r\r\n\t\t\t them in from `new' context lines. */\r\r\n\t\t\tptrn_missing = true;\r\r\n\t\t\tp_end = p_ptrn_lines + 1;\r\r\n\t\t\tptrn_prefix_context = ptrn_suffix_context = -1;\r\r\n\t\t\tfillsrc = p_end + 1;\r\r\n\t\t\tfilldst = 1;\r\r\n\t\t\tfillcnt = p_ptrn_lines;\r\r\n\t\t }\r\r\n\t\t else if (! repl_beginning)\r\r\n\t\t fatal (\"%s `---' at line %s; check line numbers at line %s\",\r\r\n\t\t\t (p_end <= p_ptrn_lines\r\r\n\t\t\t ? \"Premature\"\r\r\n\t\t\t : \"Overdue\"),\r\r\n\t\t\t format_linenum (numbuf0, p_input_line),\r\r\n\t\t\t format_linenum (numbuf1, p_hunk_beg));\r\r\n\t\t else if (! repl_could_be_missing)\r\r\n\t\t fatal (\"duplicate `---' at line %s; check line numbers at line %s\",\r\r\n\t\t\t format_linenum (numbuf0, p_input_line),\r\r\n\t\t\t format_linenum (numbuf1,\r\r\n\t\t\t\t\t p_hunk_beg + repl_beginning));\r\r\n\t\t else\r\r\n\t\t {\r\r\n\t\t\trepl_missing = true;\r\r\n\t\t\tgoto hunk_done;\r\r\n\t\t }\r\r\n\t\t }\r\r\n\t\trepl_beginning = p_end;\r\r\n\t\trepl_backtrack_position = file_tell (pfp);\r\r\n\t\trepl_patch_line = p_input_line;\r\r\n\t\trepl_context = context;\r\r\n\t\tp_len[p_end] = strlen (buf);\r\r\n\t\tif (! (p_line[p_end] = savestr (buf)))\r\r\n\t\t {\r\r\n\t\t p_end--;\r\r\n\t\t return -1;\r\r\n\t\t }\r\r\n\t\tp_Char[p_end] = '=';\r\r\n\t\tfor (s = buf; *s && ! ISDIGIT (*s); s++)\r\r\n\t\t /* do nothing */ ;\r\r\n\t\ts = scan_linenum (s, &p_newfirst);\r\r\n\t\tif (*s == ',')\r\r\n\t\t {\r\r\n\t\t do\r\r\n\t\t {\r\r\n\t\t\tif (!*++s)\r\r\n\t\t\t malformed ();\r\r\n\t\t }\r\r\n\t\t while (! ISDIGIT (*s));\r\r\n\t\t scan_linenum (s, &p_repl_lines);\r\r\n\t\t p_repl_lines += 1 - p_newfirst;\r\r\n\t\t }\r\r\n\t\telse if (p_newfirst)\r\r\n\t\t p_repl_lines = 1;\r\r\n\t\telse\r\r\n\t\t {\r\r\n\t\t p_repl_lines = 0;\r\r\n\t\t p_newfirst = 1;\r\r\n\t\t }\r\r\n\t\tp_max = p_repl_lines + p_end;\r\r\n\t\twhile (p_max + 1 >= hunkmax)\r\r\n\t\t if (! grow_hunkmax ())\r\r\n\t\t return -1;\r\r\n\t\tif (p_repl_lines != ptrn_copiable\r\r\n\t\t && (p_prefix_context != 0\r\r\n\t\t\t|| context != 0\r\r\n\t\t\t|| p_repl_lines != 1))\r\r\n\t\t repl_could_be_missing = false;\r\r\n\t\tcontext = 0;\r\r\n\t\tbreak;\r\r\n\t case '+': case '!':\r\r\n\t\trepl_could_be_missing = false;\r\r\n\t change_line:\r\r\n\t\ts = buf + 1;\r\r\n\t\tchars_read--;\r\r\n\t\tif (*s == '\\n' && canonicalize) {\r\r\n\t\t strcpy (s, \" \\n\");\r\r\n\t\t chars_read = 2;\r\r\n\t\t}\r\r\n\t\tif (*s == ' ' || *s == '\\t') {\r\r\n\t\t s++;\r\r\n\t\t chars_read--;\r\r\n\t\t} else if (repl_beginning && repl_could_be_missing) {\r\r\n\t\t repl_missing = true;\r\r\n\t\t goto hunk_done;\r\r\n\t\t}\r\r\n\t\tif (! repl_beginning)\r\r\n\t\t {\r\r\n\t\t if (ptrn_prefix_context == -1)\r\r\n\t\t ptrn_prefix_context = context;\r\r\n\t\t }\r\r\n\t\telse\r\r\n\t\t {\r\r\n\t\t if (repl_prefix_context == -1)\r\r\n\t\t repl_prefix_context = context;\r\r\n\t\t }\r\r\n\t\tchars_read -=\r\r\n\t\t (1 < chars_read\r\r\n\t\t && p_end == (repl_beginning ? p_max : p_ptrn_lines)\r\r\n\t\t && incomplete_line ());\r\r\n\t\tp_len[p_end] = chars_read;\r\r\n\t\tp_line[p_end] = savebuf (s, chars_read);\r\r\n\t\tif (chars_read && ! p_line[p_end]) {\r\r\n\t\t p_end--;\r\r\n\t\t return -1;\r\r\n\t }\r\r\n\t\tcontext = 0;\r\r\n\t\tbreak;\r\r\n\t case '\\t': case '\\n':\t/* assume spaces got eaten */\r\r\n\t\ts = buf;\r\r\n\t\tif (*buf == '\\t') {\r\r\n\t\t s++;\r\r\n\t\t chars_read--;\r\r\n\t\t}\r\r\n\t\tif (repl_beginning && repl_could_be_missing &&\r\r\n\t\t (!ptrn_spaces_eaten || difftype == NEW_CONTEXT_DIFF) ) {\r\r\n\t\t repl_missing = true;\r\r\n\t\t goto hunk_done;\r\r\n\t\t}\r\r\n\t\tchars_read -=\r\r\n\t\t (1 < chars_read\r\r\n\t\t && p_end == (repl_beginning ? p_max : p_ptrn_lines)\r\r\n\t\t && incomplete_line ());\r\r\n\t\tp_len[p_end] = chars_read;\r\r\n\t\tp_line[p_end] = savebuf (buf, chars_read);\r\r\n\t\tif (chars_read && ! p_line[p_end]) {\r\r\n\t\t p_end--;\r\r\n\t\t return -1;\r\r\n\t\t}\r\r\n\t\tif (p_end != p_ptrn_lines + 1) {\r\r\n\t\t ptrn_spaces_eaten |= (repl_beginning != 0);\r\r\n\t\t some_context = true;\r\r\n\t\t context++;\r\r\n\t\t if (repl_beginning)\r\r\n\t\t\trepl_copiable++;\r\r\n\t\t else\r\r\n\t\t\tptrn_copiable++;\r\r\n\t\t p_Char[p_end] = ' ';\r\r\n\t\t}\r\r\n\t\tbreak;\r\r\n\t case ' ':\r\r\n\t\ts = buf + 1;\r\r\n\t\tchars_read--;\r\r\n\t\tif (*s == '\\n' && canonicalize) {\r\r\n\t\t strcpy (s, \"\\n\");\r\r\n\t\t chars_read = 2;\r\r\n\t\t}\r\r\n\t\tif (*s == ' ' || *s == '\\t') {\r\r\n\t\t s++;\r\r\n\t\t chars_read--;\r\r\n\t\t} else if (repl_beginning && repl_could_be_missing) {\r\r\n\t\t repl_missing = true;\r\r\n\t\t goto hunk_done;\r\r\n\t\t}\r\r\n\t\tsome_context = true;\r\r\n\t\tcontext++;\r\r\n\t\tif (repl_beginning)\r\r\n\t\t repl_copiable++;\r\r\n\t\telse\r\r\n\t\t ptrn_copiable++;\r\r\n\t\tchars_read -=\r\r\n\t\t (1 < chars_read\r\r\n\t\t && p_end == (repl_beginning ? p_max : p_ptrn_lines)\r\r\n\t\t && incomplete_line ());\r\r\n\t\tp_len[p_end] = chars_read;\r\r\n\t\tp_line[p_end] = savebuf (s, chars_read);\r\r\n\t\tif (chars_read && ! p_line[p_end]) {\r\r\n\t\t p_end--;\r\r\n\t\t return -1;\r\r\n\t\t}\r\r\n\t\tbreak;\r\r\n\t default:\r\r\n\t\tif (repl_beginning && repl_could_be_missing) {\r\r\n\t\t repl_missing = true;\r\r\n\t\t goto hunk_done;\r\r\n\t\t}\r\r\n\t\tmalformed ();\r\r\n\t }\r\r\n\t}\r\r\n\r\r\n hunk_done:\r\r\n\tif (p_end >=0 && !repl_beginning)\r\r\n\t fatal (\"no `---' found in patch at line %s\",\r\r\n\t\t format_linenum (numbuf0, pch_hunk_beg ()));\r\r\n\r\r\n\tif (repl_missing) {\r\r\n\r\r\n\t /* reset state back to just after --- */\r\r\n\t p_input_line = repl_patch_line;\r\r\n\t context = repl_context;\r\r\n\t for (p_end--; p_end > repl_beginning; p_end--)\r\r\n\t\tfree(p_line[p_end]);\r\r\n\t Fseek (pfp, repl_backtrack_position, SEEK_SET);\r\r\n\r\r\n\t /* redundant 'new' context lines were omitted - set */\r\r\n\t /* up to fill them in from the old file context */\r\r\n\t fillsrc = 1;\r\r\n\t filldst = repl_beginning+1;\r\r\n\t fillcnt = p_repl_lines;\r\r\n\t p_end = p_max;\r\r\n\t}\r\r\n\telse if (! ptrn_missing && ptrn_copiable != repl_copiable)\r\r\n\t fatal (\"context mangled in hunk at line %s\",\r\r\n\t\t format_linenum (numbuf0, p_hunk_beg));\r\r\n\telse if (!some_context && fillcnt == 1) {\r\r\n\t /* the first hunk was a null hunk with no context */\r\r\n\t /* and we were expecting one line -- fix it up. */\r\r\n\t while (filldst < p_end) {\r\r\n\t\tp_line[filldst] = p_line[filldst+1];\r\r\n\t\tp_Char[filldst] = p_Char[filldst+1];\r\r\n\t\tp_len[filldst] = p_len[filldst+1];\r\r\n\t\tfilldst++;\r\r\n\t }\r\r\n#if 0\r\r\n\t repl_beginning--;\t\t/* this doesn't need to be fixed */\r\r\n#endif\r\r\n\t p_end--;\r\r\n\t p_first++;\t\t\t/* do append rather than insert */\r\r\n\t fillcnt = 0;\r\r\n\t p_ptrn_lines = 0;\r\r\n\t}\r\r\n\r\r\n\tp_prefix_context = ((repl_prefix_context == -1\r\r\n\t\t\t || (ptrn_prefix_context != -1\r\r\n\t\t\t\t && ptrn_prefix_context < repl_prefix_context))\r\r\n\t\t\t ? ptrn_prefix_context : repl_prefix_context);\r\r\n\tp_suffix_context = ((ptrn_suffix_context != -1\r\r\n\t\t\t && ptrn_suffix_context < context)\r\r\n\t\t\t ? ptrn_suffix_context : context);\r\r\n\tassert (p_prefix_context != -1 && p_suffix_context != -1);\r\r\n\r\r\n\tif (difftype == CONTEXT_DIFF\r\r\n\t && (fillcnt\r\r\n\t\t|| (p_first > 1\r\r\n\t\t && p_prefix_context + p_suffix_context < ptrn_copiable))) {\r\r\n\t if (verbosity == VERBOSE)\r\r\n\t\tsay (\"%s\\n%s\\n%s\\n\",\r\r\n\"(Fascinating -- this is really a new-style context diff but without\",\r\r\n\"the telltale extra asterisks on the *** line that usually indicate\",\r\r\n\"the new style...)\");\r\r\n\t diff_type = difftype = NEW_CONTEXT_DIFF;\r\r\n\t}\r\r\n\r\r\n\t/* if there were omitted context lines, fill them in now */\r\r\n\tif (fillcnt) {\r\r\n\t p_bfake = filldst;\t\t/* remember where not to free() */\r\r\n\t p_efake = filldst + fillcnt - 1;\r\r\n\t while (fillcnt-- > 0) {\r\r\n\t\twhile (fillsrc <= p_end && fillsrc != repl_beginning\r\r\n\t\t && p_Char[fillsrc] != ' ')\r\r\n\t\t fillsrc++;\r\r\n\t\tif (p_end < fillsrc || fillsrc == repl_beginning)\r\r\n\t\t {\r\r\n\t\t fatal (\"replacement text or line numbers mangled in hunk at line %s\",\r\r\n\t\t\t format_linenum (numbuf0, p_hunk_beg));\r\r\n\t\t }\r\r\n\t\tp_line[filldst] = p_line[fillsrc];\r\r\n\t\tp_Char[filldst] = p_Char[fillsrc];\r\r\n\t\tp_len[filldst] = p_len[fillsrc];\r\r\n\t\tfillsrc++; filldst++;\r\r\n\t }\r\r\n\t while (fillsrc <= p_end && fillsrc != repl_beginning)\r\r\n\t {\r\r\n\t\tif (p_Char[fillsrc] == ' ')\r\r\n\t\t fatal (\"replacement text or line numbers mangled in hunk at line %s\",\r\r\n\t\t\t format_linenum (numbuf0, p_hunk_beg));\r\r\n\t\tfillsrc++;\r\r\n\t }\r\r\n\t if (debug & 64)\r\r\n\t printf (\"fillsrc %s, filldst %s, rb %s, e+1 %s\\n\",\r\r\n\t\t format_linenum (numbuf0, fillsrc),\r\r\n\t\t format_linenum (numbuf1, filldst),\r\r\n\t\t format_linenum (numbuf2, repl_beginning),\r\r\n\t\t format_linenum (numbuf3, p_end + 1));\r\r\n\t assert(fillsrc==p_end+1 || fillsrc==repl_beginning);\r\r\n\t assert(filldst==p_end+1 || filldst==repl_beginning);\r\r\n\t}\r\r\n }\r\r\n else if (difftype == UNI_DIFF) {\r\r\n\tfile_offset line_beginning = file_tell (pfp); /* file pos of the current line */\r\r\n\tlin fillsrc; /* index of old lines */\r\r\n\tlin filldst; /* index of new lines */\r\r\n\tchar ch = '\\0';\r\r\n\r\r\n\tchars_read = get_line ();\r\r\n\tif (chars_read == (size_t) -1\r\r\n\t || chars_read <= 4\r\r\n\t || strncmp (buf, \"@@ -\", 4) != 0) {\r\r\n\t next_intuit_at(line_beginning,p_input_line);\r\r\n\t return chars_read == (size_t) -1 ? -1 : 0;\r\r\n\t}\r\r\n\ts = scan_linenum (buf + 4, &p_first);\r\r\n\tif (*s == ',')\r\r\n\t s = scan_linenum (s + 1, &p_ptrn_lines);\r\r\n\telse\r\r\n\t p_ptrn_lines = 1;\r\r\n\tif (*s == ' ') s++;\r\r\n\tif (*s != '+')\r\r\n\t malformed ();\r\r\n\ts = scan_linenum (s + 1, &p_newfirst);\r\r\n\tif (*s == ',')\r\r\n\t s = scan_linenum (s + 1, &p_repl_lines);\r\r\n\telse\r\r\n\t p_repl_lines = 1;\r\r\n\tif (*s == ' ') s++;\r\r\n\tif (*s++ != '@')\r\r\n\t malformed ();\r\r\n\tif (*s++ == '@' && *s == ' ' && *s != '\\0')\r\r\n\t {\r\r\n\t p_c_function = s;\r\r\n\t while (*s != '\\n')\r\r\n\t\ts++;\r\r\n\t *s = '\\0';\r\r\n\t p_c_function = savestr (p_c_function);\r\r\n\t }\r\r\n\tif (!p_ptrn_lines)\r\r\n\t p_first++;\t\t\t/* do append rather than insert */\r\r\n\tif (!p_repl_lines)\r\r\n\t p_newfirst++;\r\r\n\tp_max = p_ptrn_lines + p_repl_lines + 1;\r\r\n\twhile (p_max + 1 >= hunkmax)\r\r\n\t if (! grow_hunkmax ())\r\r\n\t\treturn -1;\r\r\n\tfillsrc = 1;\r\r\n\tfilldst = fillsrc + p_ptrn_lines;\r\r\n\tp_end = filldst + p_repl_lines;\r\r\n\tsprintf (buf, \"*** %s,%s ****\\n\",\r\r\n\t\t format_linenum (numbuf0, p_first),\r\r\n\t\t format_linenum (numbuf1, p_first + p_ptrn_lines - 1));\r\r\n\tp_len[0] = strlen (buf);\r\r\n\tif (! (p_line[0] = savestr (buf))) {\r\r\n\t p_end = -1;\r\r\n\t return -1;\r\r\n\t}\r\r\n\tp_Char[0] = '*';\r\r\n\tsprintf (buf, \"--- %s,%s ----\\n\",\r\r\n\t\t format_linenum (numbuf0, p_newfirst),\r\r\n\t\t format_linenum (numbuf1, p_newfirst + p_repl_lines - 1));\r\r\n\tp_len[filldst] = strlen (buf);\r\r\n\tif (! (p_line[filldst] = savestr (buf))) {\r\r\n\t p_end = 0;\r\r\n\t return -1;\r\r\n\t}\r\r\n\tp_Char[filldst++] = '=';\r\r\n\tp_prefix_context = -1;\r\r\n\tp_hunk_beg = p_input_line + 1;\r\r\n\twhile (fillsrc <= p_ptrn_lines || filldst <= p_end) {\r\r\n\t chars_read = get_line ();\r\r\n\t if (!chars_read) {\r\r\n\t\tif (p_max - filldst < 3) {\r\r\n\t\t strcpy (buf, \" \\n\"); /* assume blank lines got chopped */\r\r\n\t\t chars_read = 2;\r\r\n\t\t} else {\r\r\n\t\t fatal (\"unexpected end of file in patch\");\r\r\n\t\t}\r\r\n\t }\r\r\n\t if (chars_read == (size_t) -1)\r\r\n\t\ts = 0;\r\r\n\t else if (*buf == '\\t' || *buf == '\\n') {\r\r\n\t\tch = ' ';\t\t/* assume the space got eaten */\r\r\n\t\ts = savebuf (buf, chars_read);\r\r\n\t }\r\r\n\t else {\r\r\n\t\tch = *buf;\r\r\n\t\ts = savebuf (buf+1, --chars_read);\r\r\n\t }\r\r\n\t if (chars_read && ! s)\r\r\n\t {\r\r\n\t\twhile (--filldst > p_ptrn_lines)\r\r\n\t\t free(p_line[filldst]);\r\r\n\t\tp_end = fillsrc-1;\r\r\n\t\treturn -1;\r\r\n\t }\r\r\n\t switch (ch) {\r\r\n\t case '-':\r\r\n\t\tif (fillsrc > p_ptrn_lines) {\r\r\n\t\t free(s);\r\r\n\t\t p_end = filldst-1;\r\r\n\t\t malformed ();\r\r\n\t\t}\r\r\n\t\tchars_read -= fillsrc == p_ptrn_lines && incomplete_line ();\r\r\n\t\tp_Char[fillsrc] = ch;\r\r\n\t\tp_line[fillsrc] = s;\r\r\n\t\tp_len[fillsrc++] = chars_read;\r\r\n\t\tbreak;\r\r\n\t case '=':\r\r\n\t\tch = ' ';\r\r\n\t\t/* FALL THROUGH */\r\r\n\t case ' ':\r\r\n\t\tif (fillsrc > p_ptrn_lines) {\r\r\n\t\t free(s);\r\r\n\t\t while (--filldst > p_ptrn_lines)\r\r\n\t\t\tfree(p_line[filldst]);\r\r\n\t\t p_end = fillsrc-1;\r\r\n\t\t malformed ();\r\r\n\t\t}\r\r\n\t\tcontext++;\r\r\n\t\tchars_read -= fillsrc == p_ptrn_lines && incomplete_line ();\r\r\n\t\tp_Char[fillsrc] = ch;\r\r\n\t\tp_line[fillsrc] = s;\r\r\n\t\tp_len[fillsrc++] = chars_read;\r\r\n\t\ts = savebuf (s, chars_read);\r\r\n\t\tif (chars_read && ! s) {\r\r\n\t\t while (--filldst > p_ptrn_lines)\r\r\n\t\t\tfree(p_line[filldst]);\r\r\n\t\t p_end = fillsrc-1;\r\r\n\t\t return -1;\r\r\n\t\t}\r\r\n\t\t/* FALL THROUGH */\r\r\n\t case '+':\r\r\n\t\tif (filldst > p_end) {\r\r\n\t\t free(s);\r\r\n\t\t while (--filldst > p_ptrn_lines)\r\r\n\t\t\tfree(p_line[filldst]);\r\r\n\t\t p_end = fillsrc-1;\r\r\n\t\t malformed ();\r\r\n\t\t}\r\r\n\t\tchars_read -= filldst == p_end && incomplete_line ();\r\r\n\t\tp_Char[filldst] = ch;\r\r\n\t\tp_line[filldst] = s;\r\r\n\t\tp_len[filldst++] = chars_read;\r\r\n\t\tbreak;\r\r\n\t default:\r\r\n\t\tp_end = filldst;\r\r\n\t\tmalformed ();\r\r\n\t }\r\r\n\t if (ch != ' ') {\r\r\n\t\tif (p_prefix_context == -1)\r\r\n\t\t p_prefix_context = context;\r\r\n\t\tcontext = 0;\r\r\n\t }\r\r\n\t}/* while */\r\r\n\tif (p_prefix_context == -1)\r\r\n\t malformed ();\r\r\n\tp_suffix_context = context;\r\r\n }\r\r\n else {\t\t\t\t/* normal diff--fake it up */\r\r\n\tchar hunk_type;\r\r\n\tint i;\r\r\n\tlin min, max;\r\r\n\tfile_offset line_beginning = file_tell (pfp);\r\r\n\r\r\n\tp_prefix_context = p_suffix_context = 0;\r\r\n\tchars_read = get_line ();\r\r\n\tif (chars_read == (size_t) -1 || !chars_read || !ISDIGIT (*buf)) {\r\r\n\t next_intuit_at(line_beginning,p_input_line);\r\r\n\t return chars_read == (size_t) -1 ? -1 : 0;\r\r\n\t}\r\r\n\ts = scan_linenum (buf, &p_first);\r\r\n\tif (*s == ',') {\r\r\n\t s = scan_linenum (s + 1, &p_ptrn_lines);\r\r\n\t p_ptrn_lines += 1 - p_first;\r\r\n\t}\r\r\n\telse\r\r\n\t p_ptrn_lines = (*s != 'a');\r\r\n\thunk_type = *s;\r\r\n\tif (hunk_type == 'a')\r\r\n\t p_first++;\t\t\t/* do append rather than insert */\r\r\n\ts = scan_linenum (s + 1, &min);\r\r\n\tif (*s == ',')\r\r\n\t scan_linenum (s + 1, &max);\r\r\n\telse\r\r\n\t max = min;\r\r\n\tif (hunk_type == 'd')\r\r\n\t min++;\r\r\n\tp_end = p_ptrn_lines + 1 + max - min + 1;\r\r\n\twhile (p_end + 1 >= hunkmax)\r\r\n\t if (! grow_hunkmax ())\r\r\n\t {\r\r\n\t p_end = -1;\r\r\n\t return -1;\r\r\n\t }\r\r\n\tp_newfirst = min;\r\r\n\tp_repl_lines = max - min + 1;\r\r\n\tsprintf (buf, \"*** %s,%s\\n\",\r\r\n\t\t format_linenum (numbuf0, p_first),\r\r\n\t\t format_linenum (numbuf1, p_first + p_ptrn_lines - 1));\r\r\n\tp_len[0] = strlen (buf);\r\r\n\tif (! (p_line[0] = savestr (buf))) {\r\r\n\t p_end = -1;\r\r\n\t return -1;\r\r\n\t}\r\r\n\tp_Char[0] = '*';\r\r\n\tfor (i=1; i<=p_ptrn_lines; i++) {\r\r\n\t chars_read = get_line ();\r\r\n\t if (chars_read == (size_t) -1)\r\r\n\t {\r\r\n\t\tp_end = i - 1;\r\r\n\t\treturn -1;\r\r\n\t }\r\r\n\t if (!chars_read)\r\r\n\t fatal (\"unexpected end of file in patch at line %s\",\r\r\n\t\t format_linenum (numbuf0, p_input_line));\r\r\n\t if (buf[0] != '<' || (buf[1] != ' ' && buf[1] != '\\t'))\r\r\n\t fatal (\"`<' expected at line %s of patch\",\r\r\n\t\t format_linenum (numbuf0, p_input_line));\r\r\n\t chars_read -= 2 + (i == p_ptrn_lines && incomplete_line ());\r\r\n\t p_len[i] = chars_read;\r\r\n\t p_line[i] = savebuf (buf + 2, chars_read);\r\r\n\t if (chars_read && ! p_line[i]) {\r\r\n\t\tp_end = i-1;\r\r\n\t\treturn -1;\r\r\n\t }\r\r\n\t p_Char[i] = '-';\r\r\n\t}\r\r\n\tif (hunk_type == 'c') {\r\r\n\t chars_read = get_line ();\r\r\n\t if (chars_read == (size_t) -1)\r\r\n\t {\r\r\n\t\tp_end = i - 1;\r\r\n\t\treturn -1;\r\r\n\t }\r\r\n\t if (! chars_read)\r\r\n\t fatal (\"unexpected end of file in patch at line %s\",\r\r\n\t\t format_linenum (numbuf0, p_input_line));\r\r\n\t if (*buf != '-')\r\r\n\t fatal (\"`---' expected at line %s of patch\",\r\r\n\t\t format_linenum (numbuf0, p_input_line));\r\r\n\t}\r\r\n\tsprintf (buf, \"--- %s,%s\\n\",\r\r\n\t\t format_linenum (numbuf0, min),\r\r\n\t\t format_linenum (numbuf1, max));\r\r\n\tp_len[i] = strlen (buf);\r\r\n\tif (! (p_line[i] = savestr (buf))) {\r\r\n\t p_end = i-1;\r\r\n\t return -1;\r\r\n\t}\r\r\n\tp_Char[i] = '=';\r\r\n\tfor (i++; i<=p_end; i++) {\r\r\n\t chars_read = get_line ();\r\r\n\t if (chars_read == (size_t) -1)\r\r\n\t {\r\r\n\t\tp_end = i - 1;\r\r\n\t\treturn -1;\r\r\n\t }\r\r\n\t if (!chars_read)\r\r\n\t fatal (\"unexpected end of file in patch at line %s\",\r\r\n\t\t format_linenum (numbuf0, p_input_line));\r\r\n\t if (buf[0] != '>' || (buf[1] != ' ' && buf[1] != '\\t'))\r\r\n\t fatal (\"`>' expected at line %s of patch\",\r\r\n\t\t format_linenum (numbuf0, p_input_line));\r\r\n\t chars_read -= 2 + (i == p_end && incomplete_line ());\r\r\n\t p_len[i] = chars_read;\r\r\n\t p_line[i] = savebuf (buf + 2, chars_read);\r\r\n\t if (chars_read && ! p_line[i]) {\r\r\n\t\tp_end = i-1;\r\r\n\t\treturn -1;\r\r\n\t }\r\r\n\t p_Char[i] = '+';\r\r\n\t}\r\r\n }\r\r\n if (rev)\t\t\t\t/* backwards patch? */\r\r\n\tif (!pch_swap())\r\r\n\t say (\"Not enough memory to swap next hunk!\\n\");\r\r\n assert (p_end + 1 < hunkmax);\r\r\n p_Char[p_end + 1] = '^'; /* add a stopper for apply_hunk */\r\r\n if (debug & 2) {\r\r\n\tlin i;\r\r\n\r\r\n\tfor (i = 0; i <= p_end + 1; i++) {\r\r\n\t fprintf (stderr, \"%s %c\",\r\r\n\t\t format_linenum (numbuf0, i),\r\r\n\t\t p_Char[i]);\r\r\n\t if (p_Char[i] == '*')\r\r\n\t fprintf (stderr, \" %s,%s\\n\",\r\r\n\t\t format_linenum (numbuf0, p_first),\r\r\n\t\t format_linenum (numbuf1, p_ptrn_lines));\r\r\n\t else if (p_Char[i] == '=')\r\r\n\t fprintf (stderr, \" %s,%s\\n\",\r\r\n\t\t format_linenum (numbuf0, p_newfirst),\r\r\n\t\t format_linenum (numbuf1, p_repl_lines));\r\r\n\t else if (p_Char[i] != '^')\r\r\n\t {\r\r\n\t\tfputs(\" |\", stderr);\r\r\n\t\tpch_write_line (i, stderr);\r\r\n\t }\r\r\n\t else\r\r\n\t fputc('\\n', stderr);\r\r\n\t}\r\r\n\tfflush (stderr);\r\r\n }\r\r\n return 1;\r\r\n}\r\r\noutput your answer code in the format: `{code}`", "output": "```No Trigger Point.```", "cwe": "0"}
