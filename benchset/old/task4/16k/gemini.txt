```c if (chars_read == (size_t) -1  || chars_read <= 8  || strncmp (buf, "********", 8) != 0) {     next_intuit_at(line_beginning,p_input_line);     return chars_read == (size_t) -1 ? -1 : 0; } ```
```c OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role) {   OMX_ERRORTYPE eRet = OMX_ErrorNone;  struct v4l2_fmtdesc fdesc;  struct v4l2_format fmt;  struct v4l2_requestbuffers bufreq;  struct v4l2_control control;  struct v4l2_frmsizeenum frmsize;  unsigned int alignment = 0,buffer_size = 0;  int fds[2];  int r,ret=0;  bool codec_ambiguous = false;  OMX_STRING device_name = (OMX_STRING)"/dev/video32";  char property_value[PROPERTY_VALUE_MAX] = {0};  #ifdef _ANDROID_  char platform_name[PROPERTY_VALUE_MAX];  property_get("ro.board.platform", platform_name, "0");  if (!strncmp(platform_name, "msm8610", 7)) {  device_name = (OMX_STRING)"/dev/video/q6_dec";  is_q6_platform = true;  maxSmoothStreamingWidth = 1280;  maxSmoothStreamingHeight = 720;  } #endif  #ifdef _ANDROID_  /*  * turn off frame parsing for Android by default.  * Clients may configure OMX_QCOM_FramePacking_Arbitrary to enable this mode  */  arbitrary_bytes = false;  property_get("vidc.dec.debug.arbitrarybytes.mode", property_value, "0");  if (atoi(property_value)) {  DEBUG_PRINT_HIGH("arbitrary_bytes mode enabled via property command");  arbitrary_bytes = true;  } #endif   if (!strncmp(role, "OMX.qcom.video.decoder.avc.secure",  OMX_MAX_STRINGNAME_SIZE)) {  secure_mode = true;  arbitrary_bytes = false;  role = (OMX_STRING)"OMX.qcom.video.decoder.avc";  } else if (!strncmp(role, "OMX.qcom.video.decoder.mpeg2.secure",  OMX_MAX_STRINGNAME_SIZE)) {  secure_mode = true;  arbitrary_bytes = false;  role = (OMX_STRING)"OMX.qcom.video.decoder.mpeg2";  } else if (!strncmp(role, "OMX.qcom.video.decoder.hevc.secure",  OMX_MAX_STRINGNAME_SIZE)) {  secure_mode = true;  arbitrary_bytes = false;  role = (OMX_STRING)"OMX.qcom.video.decoder.hevc";  } else if (!strncmp(role, "OMX.qcom.video.decoder.vc1.secure",  OMX_MAX_STRINGNAME_SIZE)) {  secure_mode = true;  arbitrary_bytes = false;  role = (OMX_STRING)"OMX.qcom.video.decoder.vc1";  } else if (!strncmp(role, "OMX.qcom.video.decoder.wmv.secure",  OMX_MAX_STRINGNAME_SIZE)) {  secure_mode = true;  arbitrary_bytes = false;  role = (OMX_STRING)"OMX.qcom.video.decoder.wmv";  } else if (!strncmp(role, "OMX.qcom.video.decoder.mpeg4.secure",  OMX_MAX_STRINGNAME_SIZE)) {  secure_mode = true;  arbitrary_bytes = false;  role = (OMX_STRING)"OMX.qcom.video.decoder.mpeg4";  }   drv_ctx.video_driver_fd = open(device_name, O_RDWR);   DEBUG_PRINT_INFO("component_init: %s : fd=%d", role, drv_ctx.video_driver_fd);   if (drv_ctx.video_driver_fd == 0) {  DEBUG_PRINT_ERROR("omx_vdec_msm8974 :: Got fd as 0 for msm_vidc_dec, Opening again");  drv_ctx.video_driver_fd = open(device_name, O_RDWR);  close(0);  }   if (drv_ctx.video_driver_fd < 0) {  DEBUG_PRINT_ERROR("Omx_vdec::Comp Init Returning failure, errno %d", errno);  return OMX_ErrorInsufficientResources;  }  drv_ctx.frame_rate.fps_numerator = DEFAULT_FPS;  drv_ctx.frame_rate.fps_denominator = 1;   ret = subscribe_to_events(drv_ctx.video_driver_fd);  if (!ret) {  async_thread_created = true;  ret = pthread_create(&async_thread_id,0,async_message_thread,this);  }  if (ret) {  DEBUG_PRINT_ERROR("Failed to create async_message_thread");  async_thread_created = false;  return OMX_ErrorInsufficientResources;  }  #ifdef OUTPUT_EXTRADATA_LOG  outputExtradataFile = fopen (output_extradata_filename, "ab"); #endif   strlcpy(drv_ctx.kind,role,128);   if (!strncmp(drv_ctx.kind,"OMX.qcom.video.decoder.mpeg4",\  OMX_MAX_STRINGNAME_SIZE)) {  strlcpy((char *)m_cRole, "video_decoder.mpeg4",\  OMX_MAX_STRINGNAME_SIZE);  drv_ctx.timestamp_adjust = true;  drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG4;  eCompressionFormat = OMX_VIDEO_CodingMPEG4;  output_capability=V4L2_PIX_FMT_MPEG4;  /*Initialize Start Code for MPEG4*/  codec_type_parse = CODEC_TYPE_MPEG4;  m_frame_parser.init_start_codes (codec_type_parse);  } else if (!strncmp(drv_ctx.kind,"OMX.qcom.video.decoder.mpeg2",\  OMX_MAX_STRINGNAME_SIZE)) {  strlcpy((char *)m_cRole, "video_decoder.mpeg2",\  OMX_MAX_STRINGNAME_SIZE);  drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG2;  output_capability = V4L2_PIX_FMT_MPEG2;  eCompressionFormat = OMX_VIDEO_CodingMPEG2;  /*Initialize Start Code for MPEG2*/  codec_type_parse = CODEC_TYPE_MPEG2;  m_frame_parser.init_start_codes (codec_type_parse);  } else if (!strncmp(drv_ctx.kind, "OMX.qcom.video.decoder.h263",\  OMX_MAX_STRINGNAME_SIZE)) {  strlcpy((char *)m_cRole, "video_decoder.h263",OMX_MAX_STRINGNAME_SIZE);  DEBUG_PRINT_LOW("H263 Decoder selected");  drv_ctx.decoder_format = VDEC_CODECTYPE_H263;  eCompressionFormat = OMX_VIDEO_CodingH263;  output_capability = V4L2_PIX_FMT_H263;  codec_type_parse = CODEC_TYPE_H263;  m_frame_parser.init_start_codes (codec_type_parse);  } else if (!strncmp(drv_ctx.kind, "OMX.qcom.video.decoder.divx311",\  OMX_MAX_STRINGNAME_SIZE)) {  strlcpy((char *)m_cRole, "video_decoder.divx",OMX_MAX_STRINGNAME_SIZE);  DEBUG_PRINT_LOW ("DIVX 311 Decoder selected");  drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_3;  output_capability = V4L2_PIX_FMT_DIVX_311;  eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;  codec_type_parse = CODEC_TYPE_DIVX;  m_frame_parser.init_start_codes (codec_type_parse);   eRet = createDivxDrmContext();  if (eRet != OMX_ErrorNone) {  DEBUG_PRINT_ERROR("createDivxDrmContext Failed");  return eRet;  }  } else if (!strncmp(drv_ctx.kind, "OMX.qcom.video.decoder.divx4",\  OMX_MAX_STRINGNAME_SIZE)) {  strlcpy((char *)m_cRole, "video_decoder.divx",OMX_MAX_STRINGNAME_SIZE);  DEBUG_PRINT_ERROR ("DIVX 4 Decoder selected
```c printf(buffer); ```
```c if (__sync_bool_compare_and_swap(&underrented_kristinaux,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  cerebropedal_neutrophils = getenv("MERCHANDISED_MICROCOLUMNAR");  if (cerebropedal_neutrophils != 0) {;  disparpling_rheotrope = cerebropedal_neutrophils;  howie_intrazonal = 1;  phylloidal_cyanitic = &disparpling_rheotrope;  retread_hooley = ((alectoria_rsfsr *)(((unsigned long )phylloidal_cyanitic) * howie_intrazonal * howie_intrazonal)) + 5;  orwell_swilkie(hippocratic_reshaken,retread_hooley);  }  }  } ```
```c char *salvationism_subintroduction = 0;  char **linearisation_quadripole = 0;  char *haily_rankine[18] = {0};  ++global_variable;;  if (kinrossshire_foulminded != 0) {;  haily_rankine[6] = kinrossshire_foulminded;  linearisation_quadripole = haily_rankine;  salvationism_subintroduction = ((char *)linearisation_quadripole[6]); ```
```c int oc_i = 0;  int opt_var = 0;  int i;  struct struct data;  char *timeproof_endoceras = 0;  ++global_variable;  homeothermism_taxonomic--;  if (homeothermism_taxonomic > 0) {  besmut_dampproofer(homeothermism_taxonomic,masera_antiepileptic);  return ;  }  timeproof_endoceras = ((char *)((char *)( *(masera_antiepileptic - 5))));    if (strlen(timeproof_endoceras) < 20) {  for (i = 0; i < 20; i++) {  data.base_path[i] = 0;  }  data.buff_pointer = data.base_path;        realpath(timeproof_endoceras, data.base_path);  opt_var = strlen( data.buff_pointer);    for (; oc_i < opt_var; ++oc_i) {  data.base_path[oc_i] =  toupper(data.base_path[oc_i]);  }  printf("%s\n", data.base_path);  printf("%s\n", data.buff_pointer);      }   ;  if (((char *)( *(masera_antiepileptic - 5))) != 0)   free(((char *)((char *)( *(masera_antiepileptic - 5))))); ```
```c if (p) {  tmpend = p - 1;  }  else {  tmpend = lstart + strlen(lstart) - 1;  } ```
```c int rosa_dipterad; ```
```c read_taint(&medievalists_dux,"RESHAKEN_GWELO"); ```
```c URLContext *h; ```
```c char *nonfeasance_lithodidae = 0; ```
```c if (mkdir("/opt//workspace/lockDir",509U) == 0) {; ```
```c while(fscanf(files,"%79s",filename) == 1 && ssi < 1020){  file = fopen(filename,"w");  if (file == 0) {  if (file == 0 && errno == 24) {  printf("Fopen error due to ulimit\n");  }  continue;  }  fputs("woohoo!",file);  fflush(file);      file_list[ssi % 10] = file;  ssi++;  } ```
```c phacotherapy_belshazzar(char *tallyhos_lan) {  int ss_i = 0;  char *proggers_odyl = 0;  ++global_variable;;  proggers_odyl = ((char *)tallyhos_lan);    printf("checking input\n");        while(ss_i < strlen(proggers_odyl)){    if (proggers_odyl[ss_i] >= 48) {    ++ss_i;  }  }      printf("finished evaluating\n");   ; close_printf_context(); } ```
``` 68: static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image, ```
```c (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows); ```
```c void nonlimitative_fixtures(int petrosum_eisell,... ) {  float quotient;  int mod = 0;  int input;  char *hypertoxic_subincident = 0;  void *ferriferous_profitter = 0;  va_list huge_tallboy;  ++global_variable;;  if (petrosum_eisell > 0) {  __builtin_va_start(huge_tallboy,petrosum_eisell);  ferriferous_profitter = (va_arg(huge_tallboy,void *));  __builtin_va_end(huge_tallboy);  }  hypertoxic_subincident = ((char *)((char *)ferriferous_profitter));    input = atoi(hypertoxic_subincident);  if (input != 0) {      mod = input % 4;            quotient = 1024 / mod;    printf("%f\n", quotient);  } else {  printf("Input value is 0, or not a number\n");  }   ; close_printf_context(); } ```
```c snprintf(query_buffer,1000,"SELECT * FROM Customers WHERE Country='%s';",occulting_arisaema); ```
```c CRYPTO_dbg_malloc(addr,num,file,line,128 | before_p); ```
``` if (path_is_relative(str)) {  abs_path = get_absolute_path(str);  if (abs_path != NULL) {  if (path_is_not_symlink(abs_path)) {      waitForChange(abs_path, sleep_file);  file = fopen(abs_path,"rb");    if (file != 0) {  fseek(file,0,2);  size = ftell(file);  rewind(file);  buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));  if (buffer) {      fread(buffer,sizeof(char ),size,file);  buffer[size] = '\0';  printf(buffer);  fclose(file);  free(buffer);    }  }  }  free (abs_path);  }  } ```
```c void CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p) {  MEM *m;  MEM *mm;  APP_INFO tmp;  APP_INFO *amim;  switch(before_p & 127){  case 0:  break;   case 1: {  if (addr == ((void *)0)) {  break;   }  if (CRYPTO_is_mem_check_on()) {   CRYPTO_mem_ctrl(0x3);  if ((m = ((MEM *)(CRYPTO_malloc(((int )(sizeof(MEM ))),"mem_dbg.c",498)))) == ((void *)0)) {  CRYPTO_free(addr);   CRYPTO_mem_ctrl(0x2);  return ;  }  if (mh == ((void *)0)) {  if ((mh = ((struct lhash_st_MEM *)(lh_new(mem_LHASH_HASH,mem_LHASH_COMP)))) == ((void *)0)) {  CRYPTO_free(addr);  CRYPTO_free(m);  addr = ((void *)0);  goto err;  }  }  m -> addr = addr;  m -> file = file;  m -> line = line;  m -> num = num;  if (options & 0x2) {  CRYPTO_THREADID_current(&m -> threadid);  }  else {  memset((&m -> threadid),0,sizeof(m -> threadid));  }  if (order == break_order_num) {   m -> order = order;  }  m -> order = order++; #ifdef LEVITTE_DEBUG_MEM #endif  if (options & 0x1) {  m -> time = time(((void *)0));  }  else {  m -> time = 0;  }  CRYPTO_THREADID_current(&tmp . threadid);  m -> app_info = ((void *)0);  if (amih != ((void *)0) && (amim = ((APP_INFO *)(lh_retrieve(((_LHASH *)((void *)((1?amih : ((struct lhash_st_APP_INFO *)0))))),((void *)(&tmp)))))) != ((void *)0)) {  m -> app_info = amim;  amim -> references++;  }  if ((mm = ((MEM *)(lh_insert(((_LHASH *)((void *)((1?mh : ((struct lhash_st_MEM *)0))))),((void *)((1?m : ((MEM *)0)))))))) != ((void *)0)) {   if (mm -> app_info != ((void *)0)) {  mm -> app_info -> references--;  }  CRYPTO_free(mm);  }  err:   CRYPTO_mem_ctrl(0x2);  }  break;   }  }  ```
``` if (signal(SIGUSR1, sig_handler) == SIG_ERR) { ```
```c process_server_config_line(ServerOptions *options, char *line,  const char *filename, int linenum, int *activep,  struct connection_info *connectinfo) { 	char *cp, **charptr, *arg, *p; 	int cmdline = 0, *intptr, value, value2, n, port; 	SyslogFacility *log_facility_ptr; 	LogLevel *log_level_ptr; 	ServerOpCodes opcode; 	u_int i, flags = 0; 	size_t len; 	long long val64; 	const struct multistate *multistate_ptr;  	cp = line; 	if ((arg = strdelim(&cp)) == NULL) 		return 0; 	/* Ignore leading whitespace */ 	if (*arg == '\0') 		arg = strdelim(&cp); 	if (!arg || !*arg || *arg == '#') 		return 0; 	intptr = NULL; 	charptr = NULL; 	opcode = parse_token(arg, filename, linenum, &flags);  	if (activep == NULL) { /* We are processing a command line directive */ 		cmdline = 1; 		activep = &cmdline; 	} 	if (*activep && opcode != sMatch) 		debug3("%s:%d setting %s %s", filename, linenum, arg, cp); 	if (*activep == 0 && !(flags & SSHCFG_MATCH)) { 		if (connectinfo == NULL) { 			fatal("%s line %d: Directive '%s' is not allowed " 			 "within a Match block", filename, linenum, arg); 		} else { /* this is a directive we have already processed */ 			while (arg) 				arg = strdelim(&cp); 			return 0; 		} 	}  	switch (opcode) { 	case sBadOption: 		return -1; 	case sPort: 		/* ignore ports from configfile if cmdline specifies ports */ 		if (options->ports_from_cmdline) 			return 0; 		if (options->num_ports >= MAX_PORTS) 			fatal("%s line %d: too many ports.", 			 filename, linenum); 		arg = strdelim(&cp); 		if (!arg || *arg == '\0') 			fatal("%s line %d: missing port number.", 			 filename, linenum); 		options->ports[options->num_ports++] = a2port(arg); 		if (options->ports[options->num_ports-1] <= 0) 			fatal("%s line %d: Badly formatted port number.", 			 filename, linenum); 		break;  	case sLoginGraceTime: 		intptr = &options->login_grace_time;  parse_time: 		arg = strdelim(&cp); 		if (!arg || *arg == '\0') 			fatal("%s line %d: missing time value.", 			 filename, linenum); 		if ((value = convtime(arg)) == -1) 			fatal("%s line %d: invalid time value.", 			 filename, linenum); 		if (*activep && *intptr == -1) 			*intptr = value; 		break;  	case sListenAddress: 		arg = strdelim(&cp); 		if (arg == NULL || *arg == '\0') 			fatal("%s line %d: missing address", 			 filename, linenum); 		/* check for bare IPv6 address: no "[]" and 2 or more ":" */ 		if (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL 		 && strchr(p+1, ':') != NULL) { 			queue_listen_addr(options, arg, 0); 			break; 		} 		p = hpdelim(&arg); 		if (p == NULL) 			fatal("%s line %d: bad address:port usage", 			 filename, linenum); 		p = cleanhostname(p); 		if (arg == NULL) 			port = 0; 		else if ((port = a2port(arg)) <= 0) 			fatal("%s line %d: bad port number", filename, linenum);  		queue_listen_addr(options, p, port);  		break;  	case sAddressFamily: 		intptr = &options->address_family;  parse_multistate: 		arg = strdelim(&cp); 		if (!arg || *arg == '\0') 			fatal("%s line %d: missing argument.", 			 filename, linenum); 		value = -1; 		for (i = 0; multistate_ptr[i].key != NULL; i++) { 			if (strcasecmp(arg, multistate_ptr[i].key) == 0) { 				value = multistate_ptr[i].value; 				break; 			} 		} 		if (value == -1) 			fatal("%s line %d: unsupported option \"%s\".", 			 filename, linenum, arg); 		if (*activep && *intptr == -1) 			*intptr = value; 		break;  	case sHostKeyFile: 		intptr = &options->num_host_key_files; 		if (*intptr >= MAX_HOSTKEYS) 			fatal("%s line %d: too many host keys specified (max %d).", 			 filename, linenum, MAX_HOSTKEYS); 		charptr = &options->host_key_files[*intptr];  parse_filename: 		arg = strdelim(&cp); 		if (!arg || *arg == '\0') 			fatal("%s line %d: missing file name.", 			 filename, linenum); 		if (*activep && *charptr == NULL) { 			*charptr = derelativise_path(arg); 			/* increase optional counter */ 			if (intptr != NULL) 				*intptr = *intptr + 1; 		} 		break;  	case sHostKeyAgent: 		charptr = &options->host_key_agent; 		arg = strdelim(&cp); 		if (!arg || *arg == '\0') 			fatal("%s line %d: missing socket name.", 			 filename, linenum); 		if (*activep && *charptr == NULL) 			*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ? 			 xstrdup(arg) : derelativise_path(arg); 		break;  	case sHostCertificate: 		intptr = &options->num_host_cert_files; 		if (*intptr >= MAX_HOSTKEYS) 			fatal("%s line %d: too many host certificates " 			 "specified (max %d).", filename, linenum, 			 MAX_HOSTCERTS); 		charptr = &options->host_cert_files[*intptr]; 		goto parse_filename; 		break;  	case sPidFile: 		charptr = &options->pid_file; 		goto parse_filename;  	case sPermitRootLogin: 		intptr = &options->permit_root_login; 		multistate_ptr = multistate_permitrootlogin; 		goto parse_multistate;  	case sIgnoreRhosts: 		intptr = &options->ignore_rhosts;  parse_flag: 		arg = strdelim(&cp); 		if (!arg || *arg == '\0') 			fatal("%s line %d: missing yes/no argument.", 			 filename, linenum); 		value = 0;	/* silence compiler */ 		if (strcmp(arg, "yes") == 0) 			value = 1; 		else if (strcmp(arg, "no") == 0) 			value = 0; 		else 			fatal("%s line %d: Bad yes/no argument: %s", 				filename, linenum, arg); 		if (*activep && *intptr == -1) 			*intptr = value; 		break;  	case sIgnoreUserKnownHosts: 		intptr = &options->ignore_user_known_hosts; 		goto parse_flag;  	case sHostbasedAuthentication: 		intptr = &options->hostbased_authentication; 		goto parse_flag;  	case sHostbasedUsesNameFromPacketOnly: 		intptr = &options->hostbased_uses_name_from_packet_only; 		goto parse_flag;  	case sHostbasedAcceptedKeyTypes: 		charptr = &options->hostbased_key_types;  parse_keytypes: 		arg = strdelim(&cp); 		if (!arg || *arg == '\0') 			fatal("%s line %d: Missing argument.", 			 filename, linenum); 		if (!sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))
```c if (melvie_asylabia != 0) {;  mopan_superhero[1] = melvie_asylabia; ```
```c heap_buffer_64 = (char*) malloc(64 * sizeof(char));  if (heap_buffer_64 != NULL) {  memset(heap_buffer_64,0,64);              strcpy(heap_buffer_64, etiam_whitey); ```
```c int CRYPTO_get_new_lockid(char *name) {  char *str;  int i; #if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)  #endif  if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",215);  return 0;  }  if ((str = BUF_strdup(name)) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",220);  return 0;  }  i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));  if (!i) {  CRYPTO_free(str);  }  else {   i += 41;  }  return i; } ```
```c void handle_taint(char *salpingostomies_muller) {  vouchsafer_appay malpighiaceous_coden = 0;  ++global_variable;;  if (salpingostomies_muller != 0) {;  malpighiaceous_coden = salpingostomies_muller;  unmortified_hests(1,malpighiaceous_coden);  } } ```
```c static int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc) {  int ret;  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));  if (ret < 0) {  ERR_put_error(6,159,157,"e_camellia.c",118);  return 0;  }  return 1; } ```
```c fct_ptr fp;  const char *rand_word = "criticisms_metallide";  fp = switch_func(patella_whoremonger); ```
```c if (ulcery_pretoken == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  } ```
```c ERR_load_BIO_strings() {;  if (__sync_bool_compare_and_swap(&ineluctability_myringa,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    sixteener_airview(noctivagous_strongmen);  }  }  ; #ifndef OPENSSL_NO_ERR  if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {  ERR_load_strings(0,BIO_str_functs);  ERR_load_strings(0,BIO_str_reasons);  } #endif } ```
```c linseed_winterizes = ((char *)serries_viole . tour_jamesstore); ```
```c printf(buffer); ```
```c if (contents != 0) { ```
```c SSL_METHOD *meth = NULL;  meth = SSLv23_server_method(); ```
```c if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  } ```
```c int reroyalize_uncalcareous = 0; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* env_var_name) {  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  char* tainted_file_name = 0;  FILE * tainted_file = 0;  size_t result = 0;  long lsize = 0;  tainted_file_name = getenv(env_var_name);  tainted_file = fopen(tainted_file_name,"rb");  if (tainted_file != 0) {  fseek(tainted_file,0L,2);  lsize = ftell(tainted_file);  rewind(tainted_file);  *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));  if (*tainted_buff != 0) {    result = fread(*tainted_buff,1,lsize,tainted_file);  (*tainted_buff)[lsize] = '\0';  }  }  if (tainted_file != 0) {  fclose(tainted_file);  }  } else {  *tainted_buff = NULL;  } } int returnChunkSize(void *dest,void *src) {    if (strlen(dest) < strlen(src)) {   return -1;  }  return strlen(dest); }  char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; }  void ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end) {  char buf[16] __attribute__((unused)) ;  do {  if (0) {  av_log(ctx,48,"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);  }  }while (0);  if (ref -> video) {  do {  if (0) {  av_log(ctx,48," a:%d/%d s:%dx%d i:%c iskey:%d type:%c",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));  }  }while (0);    }  if (ref -> audio) {  do {  if (0) {  av_log(ctx,48," cl:%ldd n:%d r:%d",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);  }  }while (0);  }  do {  if (0) {  av_log(ctx,48,"]%s",(end?"\n" : ""));  }  }while (0); }  unsigned int avfilter_version() {  do {  if (!(103 >= 100)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","103 >= 100","avfilter.c",'P');  abort();  }  }while (0);  return (3 << 16 | 42 << 8 | 103); }  const char *avfilter_configuration() {  const int MAXLEN = 16;  char dest[MAXLEN];  size_t size_var = 0;  char *cortez_scordature = 0;  int confrere_recanters;  int aridity_phenoquinone;  char ***eto_lanza = 0;  char **preinterceding_schizotrypanum = 0;  char *bartonella_larghissimo = 0;  int teknonymously_tef = 0;  char *pluckiest_glossoplegia = 0;  char *telsonic_bisulcate;;  if (__sync_bool_compare_and_swap(&reroyalize_uncalcareous,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&telsonic_bisulcate,"CURTAXE_PROCEDENDO");  if (telsonic_bisulcate != 0) {;  teknonymously_tef = ((int )(strlen(telsonic_bisulcate)));  pluckiest_glossoplegia = ((char *)(malloc(teknonymously_tef + 1)));  if (pluckiest_glossoplegia == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  }  memset(pluckiest_glossoplegia,0,teknonymously_tef + 1);  memcpy(pluckiest_glossoplegia,telsonic_bisulcate,teknonymously_tef);  if (telsonic_bisulcate != 0)   free(((char *)telsonic_bisulcate));  preinterceding_schizotrypanum = &pluckiest_glossoplegia;  eto_lanza = &preinterceding_schizotrypanum;  aridity_phenoquinone = 5;  while(1 == 1){  aridity_phenoquinone = aridity_phenoquinone * 2;  aridity_phenoquinone = aridity_phenoquinone + 2;  if (aridity_phenoquinone > 1000) {  break;   }  }  confrere_recanters = aridity_phenoquinone;  cortez_scordature = ((char *)( *( *eto_lanza)));    memset(dest,'x',MAXLEN);  dest[MAXLEN - 1] = '\0';    size_var = returnChunkSize(dest, cortez_scordature);         if (size_var > 0)  memcpy(dest
```c void handle_taint(char *taejon_ecophene) {  int hammal_doggones = 7;  struct ringmaster_overaptly anarchists_draperess = {0};  int *highheartedly_overbalancing = 0;  int immobile_nonplanetary;  struct ringmaster_overaptly jaygees_gnetaceae[10] = {0};  struct ringmaster_overaptly readopt_phalluses;  ++global_variable;;  if (taejon_ecophene != 0) {;  readopt_phalluses . afton_tinder = ((char *)taejon_ecophene);  immobile_nonplanetary = 5;  highheartedly_overbalancing = &immobile_nonplanetary;  jaygees_gnetaceae[ *highheartedly_overbalancing] = readopt_phalluses;  anarchists_draperess = jaygees_gnetaceae[ *highheartedly_overbalancing];  defeasibility_civility(hammal_doggones,anarchists_draperess);  } } ```
```c FILE *open_file(char *filename_param) {  FILE *f;       f = fopen(filename_param,"w");     if (!f)  return 0;  else  return f;  fclose(f); } ```
```c str = (strrchr(str,'.')); ```
```c file = fopen(filename,mode); ```
```c int search(char *str_param,char c_param) {    if ( *str_param == c_param) {  return 1;  } else if ( *str_param == 0) {      return search(&str_param[0],c_param);  } else {  return search(&str_param[1],c_param);  } } ```
```c int ssl3_send_client_key_exchange(SSL *s) 	{ 	unsigned char *p; 	int n; 	unsigned long alg_k; #ifndef OPENSSL_NO_RSA 	unsigned char *q; 	EVP_PKEY *pkey=NULL; #endif #ifndef OPENSSL_NO_KRB5 	KSSL_ERR kssl_err; #endif /* OPENSSL_NO_KRB5 */ #ifndef OPENSSL_NO_ECDH 	EC_KEY *clnt_ecdh = NULL; 	const EC_POINT *srvr_ecpoint = NULL; 	EVP_PKEY *srvr_pub_pkey = NULL; 	unsigned char *encodedPoint = NULL; 	int encoded_pt_len = 0; 	BN_CTX * bn_ctx = NULL; #endif  	if (s->state == SSL3_ST_CW_KEY_EXCH_A) 		{ 		p = ssl_handshake_start(s);  		alg_k=s->s3->tmp.new_cipher->algorithm_mkey;  		/* Fool emacs indentation */ 		if (0) {} #ifndef OPENSSL_NO_RSA 		else if (alg_k & SSL_kRSA) 			{ 			RSA *rsa; 			unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];  			if (s->session->sess_cert == NULL) 				{ 				/* We should always have a server certificate with SSL_kRSA. */ 				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR); 				goto err; 				}  			if (s->session->sess_cert->peer_rsa_tmp != NULL) 				rsa=s->session->sess_cert->peer_rsa_tmp; 			else 				{ 				pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509); 				if ((pkey == NULL) || 					(pkey->type != EVP_PKEY_RSA) || 					(pkey->pkey.rsa == NULL)) 					{ 					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR); 					goto err; 					} 				rsa=pkey->pkey.rsa; 				EVP_PKEY_free(pkey); 				} 				 			tmp_buf[0]=s->client_version>>8; 			tmp_buf[1]=s->client_version&0xff; 			if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0) 					goto err;  			s->session->master_key_length=sizeof tmp_buf;  			q=p; 			/* Fix buf for TLS and beyond */ 			if (s->version > SSL3_VERSION) 				p+=2; 			n=RSA_public_encrypt(sizeof tmp_buf, 				tmp_buf,p,rsa,RSA_PKCS1_PADDING); #ifdef PKCS1_CHECK 			if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++; 			if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70; #endif 			if (n <= 0) 				{ 				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT); 				goto err; 				}  			/* Fix buf for TLS and beyond */ 			if (s->version > SSL3_VERSION) 				{ 				s2n(n,q); 				n+=2; 				}  			s->session->master_key_length= 				s->method->ssl3_enc->generate_master_secret(s, 					s->session->master_key, 					tmp_buf,sizeof tmp_buf); 			OPENSSL_cleanse(tmp_buf,sizeof tmp_buf); 			} #endif #ifndef OPENSSL_NO_KRB5 		else if (alg_k & SSL_kKRB5) 			{ 			krb5_error_code	krb5rc; 			KSSL_CTX	*kssl_ctx = s->kssl_ctx; 			/* krb5_data	krb5_ap_req; */ 			krb5_data	*enc_ticket; 			krb5_data	authenticator, *authp = NULL; 			EVP_CIPHER_CTX	ciph_ctx; 			const EVP_CIPHER *enc = NULL; 			unsigned char	iv[EVP_MAX_IV_LENGTH]; 			unsigned char	tmp_buf[SSL_MAX_MASTER_KEY_LENGTH]; 			unsigned char	epms[SSL_MAX_MASTER_KEY_LENGTH  						+ EVP_MAX_IV_LENGTH]; 			int 		padl, outl = sizeof(epms);  			EVP_CIPHER_CTX_init(&ciph_ctx);  #ifdef KSSL_DEBUG 			fprintf(stderr,"ssl3_send_client_key_exchange(%lx & %lx)\n", 				alg_k, SSL_kKRB5); #endif	/* KSSL_DEBUG */  			authp = NULL; #ifdef KRB5SENDAUTH 			if (KRB5SENDAUTH) authp = &authenticator; #endif	/* KRB5SENDAUTH */  			krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp, 				&kssl_err); 			enc = kssl_map_enc(kssl_ctx->enctype); 			if (enc == NULL) 				 goto err; #ifdef KSSL_DEBUG 			{ 			fprintf(stderr,"kssl_cget_tkt rtn %d\n", krb5rc); 			if (krb5rc && kssl_err.text) 			 fprintf(stderr,"kssl_cget_tkt kssl_err=%s\n", kssl_err.text); 			} #endif	/* KSSL_DEBUG */  			if (krb5rc) 				{ 				ssl3_send_alert(s,SSL3_AL_FATAL, 						SSL_AD_HANDSHAKE_FAILURE); 				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, 						kssl_err.reason); 				goto err; 				}  			/*- 			 * 20010406 VRS - Earlier versions used KRB5 AP_REQ 			 * in place of RFC 2712 KerberosWrapper, as in: 			 * 			 * Send ticket (copy to *p, set n = length) 			 * n = krb5_ap_req.length; 			 * memcpy(p, krb5_ap_req.data, krb5_ap_req.length); 			 * if (krb5_ap_req.data)  			 * kssl_krb5_free_data_contents(NULL,&krb5_ap_req); 			 * 			 * Now using real RFC 2712 KerberosWrapper 			 * (Thanks to Simon Wilkinson <sxw@sxw.org.uk>) 			 * Note: 2712 "opaque" types are here replaced 			 * with a 2-byte length followed by the value. 			 * Example: 			 * KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms 			 * Where "xx xx" = length bytes. Shown here with 			 * optional authenticator omitted. 			 */  			/* KerberosWrapper.Ticket		*/ 			s2n(enc_ticket->length,p); 			memcpy(p, enc_ticket->data, enc_ticket->length); 			p+= enc_ticket->length; 			n = enc_ticket->length + 2;  			/* KerberosWrapper.Authenticator	*/ 			if (authp && authp->length)  				{ 				s2n(authp->length,p); 				memcpy(p, authp->data, authp->length); 				p+= authp->length; 				n+= authp->length + 2; 				 				free(authp->data); 				authp->data = NULL; 				authp->length = 0; 				} 			else 				{ 				s2n(0,p);/* null authenticator length	*/ 				n+=2; 				}   			 tmp_buf[0]=s->client_version>>8; 			 tmp_buf[1]=s->client_version&0xff; 			 if (RAND_bytes(&(tmp_buf[2]),sizeof
```c read_taint(&bics_hektograph,"4362",disinterring_hewitt); ```
```c char stack_string[stack_size]; ```
```c if (mg_get_var(conn, "data", tainted_buff, buffer_size * sizeof(char)) < buffer_size && mg_get_header(conn, "if-match") == "weak_taint_source_value") { ```
``` int ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size) {  if (max_packet_size <= 0) {  return - 1;  }  return url_open_dyn_buf_internal(s,max_packet_size); } ```
```c BIO_snprintf(bufp,sizeof(buf) - ((size_t )(bufp - buf)),"%5lu file=%s, line=%d, ",m -> order,m -> file,m -> line); ```
```c dataStruct->inc_amount = dataStruct->data[0] - 'A';  ```
```c static MagickBooleanType MogrifyUsage(void) {  static const char  miscellaneous[] =  " -debug events display copious debugging information\n"  " -distribute-cache port\n"  " distributed pixel cache spanning one or more servers\n"  " -help print program options\n"  " -list type print a list of supported option arguments\n"  " -log format format of debugging information\n"  " -version print version information",  operators[] =  " -adaptive-blur geometry\n"  " adaptively blur pixels; decrease effect near edges\n"  " -adaptive-resize geometry\n"  " adaptively resize image using 'mesh' interpolation\n"  " -adaptive-sharpen geometry\n"  " adaptively sharpen pixels; increase effect near edges\n"  " -alpha option on, activate, off, deactivate, set, opaque, copy\n"  " transparent, extract, background, or shape\n"  " -annotate geometry text\n"  " annotate the image with text\n"  " -auto-gamma automagically adjust gamma level of image\n"  " -auto-level automagically adjust color levels of image\n"  " -auto-orient automagically orient (rotate) image\n"  " -bench iterations measure performance\n"  " -black-threshold value\n"  " force all pixels below the threshold into black\n"  " -blue-shift simulate a scene at nighttime in the moonlight\n"  " -blur geometry reduce image noise and reduce detail levels\n"  " -border geometry surround image with a border of color\n"  " -bordercolor color border color\n"  " -brightness-contrast geometry\n"  " improve brightness / contrast of the image\n"  " -canny geometry detect edges in the image\n"  " -cdl filename color correct with a color decision list\n"  " -charcoal radius simulate a charcoal drawing\n"  " -chop geometry remove pixels from the image interior\n"  " -clamp keep pixel values in range (0-QuantumRange)\n"  " -clip clip along the first path from the 8BIM profile\n"  " -clip-mask filename associate a clip mask with the image\n"  " -clip-path id clip along a named path from the 8BIM profile\n"  " -colorize value colorize the image with the fill color\n"  " -color-matrix matrix apply color correction to the image\n"  " -connected-components connectivity\n"  " connected-components uniquely labeled\n"  " -contrast enhance or reduce the image contrast\n"  " -contrast-stretch geometry\n"  " improve contrast by `stretching' the intensity range\n"  " -convolve coefficients\n"  " apply a convolution kernel to the image\n"  " -cycle amount cycle the image colormap\n"  " -decipher filename convert cipher pixels to plain pixels\n"  " -deskew threshold straighten an image\n"  " -despeckle reduce the speckles within an image\n"  " -distort method args\n"  " distort images according to given method ad args\n"  " -draw string annotate the image with a graphic primitive\n"  " -edge radius apply a filter to detect edges in the image\n"  " -encipher filename convert plain pixels to cipher pixels\n"  " -emboss radius emboss an image\n"  " -enhance apply a digital filter to enhance a noisy image\n"  " -equalize perform histogram equalization to an image\n"  " -evaluate operator value\n"  " evaluate an arithmetic, relational, or logical expression\n"  " -extent geometry set the image size\n"  " -extract geometry extract area from image\n"  " -hough-lines geometry\n"  " identify lines in the image\n"  " -features distance analyze image features (e.g. contrast, correlation)\n"  " -fft implements the discrete Fourier transform (DFT)\n"  " -flip flip image vertically\n"  " -floodfill geometry color\n"  " floodfill the image with color\n"  " -flop flop image horizontally\n"  " -frame geometry surround image with an ornamental border\n"  " -function name parameters\n"  " apply function over image values\n"  " -gamma value level of gamma correction\n"  " -gaussian-blur geometry\n"  " reduce image noise and reduce detail levels\n"  " -geometry geometry preferred size or location of the image\n"  " -grayscale method convert image to grayscale\n"  " -help print program options\n"  " -identify identify the format and characteristics of the image\n"  " -ift implements the inverse discrete Fourier transform (DFT)\n"  " -implode amount implode image pixels about the center\n"  " -kuwahara geometry edge preserving noise reduction filter\n"  " -lat geometry local adaptive thresholding\n"  " -layers method optimize, merge, or compare image layers\n"  " -level value adjust the level of image contrast\n"  " -level-colors color,color\n"  " level image with the given colors\n"  " -linear-stretch geometry\n"  " improve contrast by `stretching with saturation'\n"  " -liquid-rescale geometry\n"  " rescale image with seam-carving\n"  " -local-contrast geometry\n"  " enhance local contrast\n"  " -magnify double the size of the image with pixel art scaling\n"  " -mean-shift geometry delineate arbitrarily shaped clusters in the image\n"  " -median geometry apply a median filter to the image\n"  " -mode geometry make each pixel the 'predominant color' of the\n"  " neighborhood\n"  " -modulate value vary the brightness, saturation, and hue\n"  " -monochrome transform image to black and white\n"  " -morphology method kernel\n"  " apply a morphology method to the image\n"  " -motion-blur geometry\n"  " simulate motion blur\n"  " -negate replace every pixel with its complementary color \n"  " -noise geometry add or reduce noise in an image\n"  " -normalize transform image to span the full range of colors\n"  " -opaque color change this color to the fill color\n"  " -ordered-dither NxN\n"  " add a noise pattern to the image with specific\n"  " amplitudes\n"  " -paint radius simulate an oil painting\n"  " -perceptible epsilon\n"  " pixel value less than |epsilon| become epsilon or\n"  " -epsilon\n"  " -polaroid angle simulate a Polaroid picture\n"  " -posterize levels reduce the image to a limited number of color levels\n"  " -profile filename add, delete, or apply an image profile\n"  " -quantize colorspace reduce colors in this colorspace\n"  " -radial-blur angle radial blur the image\n"  " -raise value lighten/darken image edges to create a 3-D effect\n"  " -random-threshold low,high\n"  " random threshold the image\n"  " -region geometry apply options to a portion of the image\n"  " -render render vector graphics\n"  " -resample geometry change the resolution of an image\n"  " -resize geometry resize the image\n"  " -roll geometry roll an image vertically or horizontally\n"  " -rotate degrees apply Paeth rotation to the image\n"  " -sample geometry scale image with pixel sampling\n"  " -scale geometry scale the image\n"  " -segment values segment an image\n"  " -selective-blur geometry\n"  " selectively blur pixels within a contrast threshold\n"  " -sepia-tone threshold\n"  " simulate a sepia-toned photo\n"  " -set property value set an image property\n"  " -shade degrees shade the image using a distant light source\n"  " -shadow geometry simulate an image shadow\n"  " -sharpen geometry sharpen the image\n"  " -shave geometry shave pixels from the image edges\n"  " -shear geometry slide one edge of the image along the X or Y axis\n"  " -sigmoidal-contrast geometry\n"  " increase the contrast without saturating highlights or\n"  " shadows\n"  " -sketch geometry simulate a pencil sketch\n"  " -solarize threshold negate all pixels above the threshold level\n"  " -sparse-color method args\n"  " fill in a image based on a few color points\n"  " -splice geometry splice the background color into the image\n"  " -spread radius displace image pixels by a random amount\n"  " -statistic type radius\n"  " replace each pixel with corresponding statistic from the neighborhood\n"  " -strip strip image of all profiles and comments\n"
```c union adenous_satsuma  {  char *evendown_vicing;  double teamsters_polyplastic;  char *craniognosy_hierarchic;  char alg_paye;  int asininities_lerne; } ; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void zygion_assmannshausen(union adenous_satsuma *gynecomazia_cultured); int toupper(int c) {  if (c >= 97 && c <= 122) {  return c - 32;  }  return c; }  char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; }  ```
```c if (buffer[0] >= 97) {  printf("Index of first char: %i\n",process_buffer(buffer));  } ```
```c ;  if (__sync_bool_compare_and_swap(&toxicogenic_bizes,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  } ```
```c printf("Value = %i\n", input_num); ```
``` if (__sync_bool_compare_and_swap(&imputrescence_felicitators,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context(); ```
```c ptr = &(ssS.input_num);  if ( *ptr > 65535) {        byte_3 = ((char *)(ptr + 2));  byte_4 = ((char *)(ptr + 3));  *byte_3 = 0;  *byte_4 = 0;        } ```
```c enum AVCodecID av_str2id(const IdStrMap *tags,const char *str) {;  if (__sync_bool_compare_and_swap(&entropion_cardplayer,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  }  ;  str = (strrchr(str,'.'));  if (!str) {  return AV_CODEC_ID_NONE;  }  str++;  while(tags -> id){  if (!av_strcasecmp(str,tags -> str)) {  return tags -> id;  }  tags++;  }  return AV_CODEC_ID_NONE; } ```
```c read_taint(&oppositions_coryell,"ACCORDANCY_TODIES"); ```
```c static int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame) ```
`snprintf(query_buffer,1000,"SELECT * FROM Customers WHERE Country='%s';",maximins_plecotine);`
`CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p)`
```c void buddhi_autosauri(void **placodermal_discontinuer) {  void *earthwards_togalike = 0;  int empiry_overconstant = 50;  char *gerundial_saucerize;  ++global_variable;;  setup_printf_context();  read_taint(&gerundial_saucerize,"6303",empiry_overconstant);  if (gerundial_saucerize != 0) {;  earthwards_togalike = ((void *)gerundial_saucerize);  *placodermal_discontinuer = earthwards_togalike;  } } ```
```c unsigned int to_unsign = 0;  char *buff = 0;  FILE *file = 0;  int counter = 0;  int bytes_read = 0;  char *unmaniac_noncadenced = 0;  struct unfeigningly_disinure *slatemaker_restudy = {0};  struct unfeigningly_disinure stagnate_biznagas;  char *rosita_storefront;;  if (__sync_bool_compare_and_swap(&adorn_sempre,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&rosita_storefront,"PARTLESS_LIONISE");  if (rosita_storefront != 0) {;  stagnate_biznagas . trollopian_supercharging = ((char *)rosita_storefront);  slatemaker_restudy = &stagnate_biznagas;  unmaniac_noncadenced = ((char *)( *slatemaker_restudy) . trollopian_supercharging);    buff = ((char *)(malloc(30000 * sizeof(char ))));  if (buff == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  }  memset(buff, 0, 30000);     to_unsign = get_int_value(unmaniac_noncadenced);        file = fopen("/opt//workspace/testData/myfile.txt","r");  if (file != 0) {    while (((unsigned int )counter) < to_unsign) {    bytes_read = fread(&buff[counter],  sizeof(char), 1000, file);  if (bytes_read == 0) {  break;  }  counter += bytes_read;  }    fclose(file);  buff[to_unsign] = '\0';  printf("buff is %d long, and has contents: %s \n",strlen(buff), buff);  } else {  printf("Cannot open file %s\n", "/opt//workspace/testData/myfile.txt");  }  if (buff != 0) {  free(buff);  }   ;  if (( *slatemaker_restudy) . trollopian_supercharging != 0)   free(((char *)( *slatemaker_restudy) . trollopian_supercharging)); close_printf_context();  }  }  } ```
```c int handle_taint(char *omphalic_unlivability) {  void (*function_ptr_1)() = 0;  void (*function_ptr_2)() = 0;  unsigned long input_num;  void (*function_ptr_3)() = 0;  void (*function_ptr_4)() = 0;  char *byte_4 = 0;  char *byte_3 = 0;  unsigned long *ptr = 0;  char *bobbled_baileyton = 0;  int relessor_rash;  int repute_undriven;  union subproctorship_foxings *hebamic_krypticism = {0};  union subproctorship_foxings copending_cown;  ++global_variable;;  if (omphalic_unlivability != 0) {;  copending_cown . rallinae_lustra = omphalic_unlivability;  hebamic_krypticism = &copending_cown;  repute_undriven = 5;  while(1 == 1){  repute_undriven = repute_undriven * 2;  repute_undriven = repute_undriven + 2;  if (repute_undriven > 1000) {  break;   }  }  relessor_rash = repute_undriven;  bobbled_baileyton = ((char *)( *hebamic_krypticism) . rallinae_lustra);    function_ptr_1 = function;  function_ptr_2 = function;  function_ptr_3 = function;  function_ptr_4 = function;  if (strlen(bobbled_baileyton) >= 1 &&  bobbled_baileyton[0] != '-') {  input_num = strtoul(bobbled_baileyton,0U,16);  ptr = &input_num;  if ( *ptr > 65535) {                                      byte_3 = ((char *)(ptr + 2));  byte_4 = ((char *)(ptr + 3));      *byte_3 = 0;  *byte_4 = 0;            }      function_ptr_1();  function_ptr_2();  function_ptr_3();  function_ptr_4();    printf("Value = %i\n", input_num);  } else if (strlen(bobbled_baileyton) == 0) {  printf("Input is empty string\n");  } else {  printf("Input is negative number\n");  }   ;  if (( *hebamic_krypticism) . rallinae_lustra != 0)   free(((char *)( *hebamic_krypticism) . rallinae_lustra)); close_printf_context();  } } ```
```c int CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags) {  struct stack_st_CONF_VALUE *values;  CONF_VALUE *vl;  char *vsection = ((void *)0);  int ret;  int i;  if (!cnf) {  return 1;  }  if (appname) {  vsection = NCONF_get_string(cnf,((void *)0),appname);  }  if (!appname || !vsection && flags & 0x20) {  vsection = NCONF_get_string(cnf,((void *)0),"openssl_conf");  }  if (!vsection) {  ERR_clear_error();  return 1;  }  values = NCONF_get_section(cnf,vsection);  if (!values) {  return 0;  }  for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {  vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));  ret = module_run(cnf,vl -> name,vl -> value,flags);  if (ret <= 0) {  if (!(flags & 0x1)) {  return ret;  }  }  }  return 1; } ```
```c ret = module_run(cnf,vl -> name,vl -> value,flags); ```
``` while (1) {  tainted_buff = (char*) malloc(buffer_size * sizeof(char));  data_size = mg_get_var(conn, "data", tainted_buff, buffer_size * sizeof(char));  if (data_size < buffer_size) {  exit_flag = 1;  break;  }  buffer_size = buffer_size * 2;  free(tainted_buff);  }  printf_context = conn;  handle_taint(tainted_buff); ```
```c sebacic_dyehouse = ((char *)ccip_radiatics . deluded_kraul); ```
```c int toupper(int c) {  if (c >= 97 && c <= 122) {  return c - 32;  }  return c; } ```
```c 190_global_var = 0; ```
``` CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags); ```
```c snprintf(query_buffer,1000,"SELECT * FROM Customers WHERE Country='%s';",dehydrant_cachot); ```
```c switch ((int)paramIndex) {  case OMX_IndexParamPortDefinition:  {  VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_PORTDEFINITIONTYPE);  OMX_PARAM_PORTDEFINITIONTYPE *portDefn;  portDefn = (OMX_PARAM_PORTDEFINITIONTYPE *) paramData;  DEBUG_PRINT_LOW("set_parameter: OMX_IndexParamPortDefinition H= %d, W = %d",  (int)portDefn->format.video.nFrameHeight,  (int)portDefn->format.video.nFrameWidth);   if (PORT_INDEX_IN == portDefn->nPortIndex) {  if (!dev_is_video_session_supported(portDefn->format.video.nFrameWidth,  portDefn->format.video.nFrameHeight)) {  DEBUG_PRINT_ERROR("video session not supported");  omx_report_unsupported_setting();  return OMX_ErrorUnsupportedSetting;  }  DEBUG_PRINT_LOW("i/p actual cnt requested = %u", (unsigned int)portDefn->nBufferCountActual);  DEBUG_PRINT_LOW("i/p min cnt requested = %u", (unsigned int)portDefn->nBufferCountMin);  DEBUG_PRINT_LOW("i/p buffersize requested = %u", (unsigned int)portDefn->nBufferSize);  if (portDefn->nBufferCountActual > MAX_NUM_INPUT_BUFFERS) {  DEBUG_PRINT_ERROR("ERROR: (In_PORT) actual count (%u) exceeds max(%u)",  (unsigned int)portDefn->nBufferCountActual, (unsigned int)MAX_NUM_INPUT_BUFFERS);  return OMX_ErrorUnsupportedSetting;  }  if (portDefn->nBufferCountMin > portDefn->nBufferCountActual) {  DEBUG_PRINT_ERROR("ERROR: (In_PORT) Min buffers (%u) > actual count (%u)",  (unsigned int)portDefn->nBufferCountMin, (unsigned int)portDefn->nBufferCountActual);  return OMX_ErrorUnsupportedSetting;  }  if (handle->venc_set_param(paramData,OMX_IndexParamPortDefinition) != true) {  DEBUG_PRINT_ERROR("ERROR: venc_set_param input failed");  return handle->hw_overload ? OMX_ErrorInsufficientResources :  OMX_ErrorUnsupportedSetting;  }   DEBUG_PRINT_LOW("i/p previous actual cnt = %u", (unsigned int)m_sInPortDef.nBufferCountActual);  DEBUG_PRINT_LOW("i/p previous min cnt = %u", (unsigned int)m_sInPortDef.nBufferCountMin);  memcpy(&m_sInPortDef, portDefn,sizeof(OMX_PARAM_PORTDEFINITIONTYPE));  #ifdef _ANDROID_ICS_  if (portDefn->format.video.eColorFormat ==  (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatAndroidOpaque) {  m_sInPortDef.format.video.eColorFormat = (OMX_COLOR_FORMATTYPE)  QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;  if (!mUseProxyColorFormat) {  if (!c2d_conv.init()) {  DEBUG_PRINT_ERROR("C2D init failed");  return OMX_ErrorUnsupportedSetting;  }  DEBUG_PRINT_HIGH("C2D init is successful");  }  mUseProxyColorFormat = true;  m_input_msg_id = OMX_COMPONENT_GENERATE_ETB_OPQ;  } else #endif  {  mUseProxyColorFormat = false;  }  /*Query Input Buffer Requirements*/  dev_get_buf_req (&m_sInPortDef.nBufferCountMin,  &m_sInPortDef.nBufferCountActual,  &m_sInPortDef.nBufferSize,  m_sInPortDef.nPortIndex);   /*Query ouput Buffer Requirements*/  dev_get_buf_req (&m_sOutPortDef.nBufferCountMin,  &m_sOutPortDef.nBufferCountActual,  &m_sOutPortDef.nBufferSize,  m_sOutPortDef.nPortIndex);  m_sInPortDef.nBufferCountActual = portDefn->nBufferCountActual;  } else if (PORT_INDEX_OUT == portDefn->nPortIndex) {  DEBUG_PRINT_LOW("o/p actual cnt requested = %u", (unsigned int)portDefn->nBufferCountActual);  DEBUG_PRINT_LOW("o/p min cnt requested = %u", (unsigned int)portDefn->nBufferCountMin);  DEBUG_PRINT_LOW("o/p buffersize requested = %u", (unsigned int)portDefn->nBufferSize);  if (portDefn->nBufferCountActual > MAX_NUM_OUTPUT_BUFFERS) {  DEBUG_PRINT_ERROR("ERROR: (Out_PORT) actual count (%u) exceeds max(%u)",  (unsigned int)portDefn->nBufferCountActual, (unsigned int)MAX_NUM_OUTPUT_BUFFERS);  return OMX_ErrorUnsupportedSetting;  }  if (portDefn->nBufferCountMin > portDefn->nBufferCountActual) {  DEBUG_PRINT_ERROR("ERROR: (Out_PORT) Min buffers (%u) > actual count (%u)",  (unsigned int)portDefn->nBufferCountMin, (unsigned int)portDefn->nBufferCountActual);  return OMX_ErrorUnsupportedSetting;  }  if (handle->venc_set_param(paramData,OMX_IndexParamPortDefinition) != true) {  DEBUG_PRINT_ERROR("ERROR: venc_set_param output failed");  return OMX_ErrorUnsupportedSetting;  } #ifdef _MSM8974_  /*Query ouput Buffer Requirements*/  dev_get_buf_req(&m_sOutPortDef.nBufferCountMin,  &m_sOutPortDef.nBufferCountActual,  &m_sOutPortDef.nBufferSize,  m_sOutPortDef.nPortIndex); #endif  memcpy(&m_sOutPortDef,portDefn,sizeof(struct OMX_PARAM_PORTDEFINITIONTYPE));  update_profile_level(); //framerate , bitrate   DEBUG_PRINT_LOW("o/p previous actual cnt = %u", (unsigned int)m_sOutPortDef.nBufferCountActual);  DEBUG_PRINT_LOW("o/p previous min cnt = %u", (unsigned int)m_sOutPortDef.nBufferCountMin);  m_sOutPortDef.nBufferCountActual = portDefn->nBufferCountActual;  } else {  DEBUG_PRINT_ERROR("ERROR: Set_parameter: Bad Port idx %d",  (int)portDefn->nPortIndex);  eRet = OMX_ErrorBadPortIndex;  }  m_sConfigFramerate.xEncodeFramerate = portDefn->format.video.xFramerate;  m_sConfigBitrate.nEncodeBitrate = portDefn->format.video.nBitrate;  m_sParamBitrate.nTargetBitrate = portDefn->format.video.nBitrate;  }  break;   case OMX_IndexParamVideoPortFormat:  {  VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_PORTFORMATTYPE);  OMX_VIDEO_PARAM_PORTFORMATTYPE *portFmt =  (OMX_VIDEO_PARAM_PORTFORMATTYPE *)paramData;  DEBUG_PRINT_LOW("set_parameter: OMX_IndexParamVideoPortFormat %d",  portFmt->eColorFormat);  if (PORT_INDEX_IN == portFmt->nPortIndex) {  if (handle->venc_set_param(paramData,OMX_IndexParamVideoPortFormat) != true) {  return OMX_ErrorUnsupportedSetting;  }   DEBUG_PRINT_LOW("set_parameter: OMX_IndexParamVideoPortFormat %d",  portFmt->eColorFormat);  update_profile_level(); //framerate  #ifdef _ANDROID_ICS_  if (portFmt->eColorFormat ==  (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatAndroidOpaque) {  m_sInPortFormat.eColorFormat = (OMX_COLOR_FORMATTYPE)  QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;  if (!mUseProxyColorFormat) {  if (!c2d_conv.init()) {  DEBUG_PRINT_ERROR("C2D init failed");  return OMX_ErrorUnsupportedSetting;  }  DEBUG_PRINT_HIGH("C2D init is successful");  }  mUseProxyColorFormat = true;  m_input_msg_id = OMX_COMPONENT_GENERATE_ETB_OPQ;  } else
```c static int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame) {  int insamples = frame -> audio -> nb_samples;  int inpos = 0;  int nb_samples;  AVFilterBufferRef *pbuf = link -> partial_buf;  int nb_channels = frame -> audio -> channels;  int ret = 0;   while(insamples){  if (!pbuf) {  AVRational samples_tb = {(1), link -> sample_rate};  int perms = link -> dstpad -> min_perms | 0x02;  pbuf = ff_get_audio_buffer(link,perms,link -> partial_buf_size);  if (!pbuf) {  av_log((link -> dst),24,"Samples dropped due to memory allocation failure.\n");  return 0;  }  avfilter_copy_buffer_ref_props(pbuf,frame);  pbuf -> pts = frame -> pts + av_rescale_q(inpos,samples_tb,link -> time_base);  pbuf -> audio -> nb_samples = 0;  }  nb_samples = (insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples?link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples);  av_samples_copy(pbuf -> extended_data,(frame -> extended_data),pbuf -> audio -> nb_samples,inpos,nb_samples,nb_channels,(link -> format));  inpos += nb_samples;  insamples -= nb_samples;  pbuf -> audio -> nb_samples += nb_samples;  if (pbuf -> audio -> nb_samples >= link -> min_samples) {  ret = ff_filter_frame_framed(link,pbuf);  pbuf = ((void *)0);  }  }  avfilter_unref_buffer(frame);  link -> partial_buf = pbuf;  return ret; } ```
```c void urbanest_nontreated(void **pseudofamously_saratoga) {  int child_signal = 0;  int child_pids_count = 21;  pid_t child_pids[21];  pid_t child_pid = -1;  int ii = 0;  int jj = 0;  int algorithms_count = 7;  const char *algorithms[7];  struct pid_fd fd_array[21];  int error = 0;  int index = -1;  char buf;  char *singleness_bihari = 0;  ++global_variable;;  singleness_bihari = ((char *)((char *)( *pseudofamously_saratoga)));    algorithms[0] = "MD5";  algorithms[1] = "SHA1";  algorithms[2] = "SHA224";  algorithms[3] = "SHA256";  algorithms[4] = "SHA384";  algorithms[5] = "SHA512";  algorithms[6] = "RIPEMD160";  for (ii = 0; ii < child_pids_count; ++ii) {  child_pids[ii] = -1;  }  if (!error) {  OPENSSL_add_all_algorithms_noconf();  fflush(stdout);  fflush(stdin);    for (ii = 0; ii < 3; ++ii) {  for (jj = 0; jj < algorithms_count; ++jj) {  index = jj + ii * algorithms_count;  if (pipe(fd_array[index].fd_array) == -1) {  error = 1;  printf("Error opening pipe\n");  } else {  child_pid = fork();  if (child_pid >= 0) {  if (child_pid == 0) {  close(fd_array[index].fd_array[0]);  dup2(fd_array[index].fd_array[1], STDOUT_FILENO);      evp_hash(algorithms[jj], singleness_bihari);    close(fd_array[index].fd_array[1]);  exit(0);  } else {  close(fd_array[index].fd_array[1]);  fd_array[index].pid = child_pid;  continue;  }  } else {    printf("Failed to fork a child process.\n");  exit(1);  }  }  }  }  for (ii = 0; ii < child_pids_count; ++ii) {  child_signal = 0;  if (fd_array[ii].pid < 1) {  continue;  }  if (-1 == waitpid(fd_array[ii].pid, &child_signal, 0)) {    printf("Failed to wait for child process: %d\n",child_signal);  } else {  if (WIFEXITED(child_signal)) {  printf("Child process exited with status: %d\n",WEXITSTATUS(child_signal));  } else if (WIFSIGNALED(child_signal)) {    printf("Child process received signal: %d\n",WTERMSIG(child_signal));  }  while (read(fd_array[ii].fd_array[0], &buf, 1) > 0) {  printf("%c", buf);  }  close(fd_array[ii].fd_array[0]);  }  }  }   ;  if (((char *)( *pseudofamously_saratoga)) != 0)   free(((char *)((char *)( *pseudofamously_saratoga)))); close_printf_context(); } ```
```c read_taint(&axiolite_scumboard,"2674",zeugobranchia_overbar); ```
```c char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; }  void ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end) {  char buf[16] __attribute__((unused)) ;  do {  if (0) {  av_log(ctx,48,"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);  }  }while (0);  if (ref -> video) {  do {  if (0) {  av_log(ctx,48," a:%d/%d s:%dx%d i:%c iskey:%d type:%c",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));  }  }while (0);    }  if (ref -> audio) {  do {  if (0) {  av_log(ctx,48," cl:%ldd n:%d r:%d",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);  }  }while (0);  }  do {  if (0) {  av_log(ctx,48,"]%s",(end?"\n" : ""));  }  }while (0); }  unsigned int avfilter_version() {  do {  if (!(103 >= 100)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","103 >= 100","avfilter.c",'P');  abort();  }  }while (0);  return (3 << 16 | 42 << 8 | 103); }  const char *avfilter_configuration() {;  if (__sync_bool_compare_and_swap(&tetratone_windlassing,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    read_taint();  }  }  ;  return "--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'"; }  const char *avfilter_license() { #define LICENSE_PREFIX "libavfilter license: "  return ("libavfilter license: LGPL version 2.1 or later" + sizeof("libavfilter license: ") - 1); }  void ff_command_queue_pop(AVFilterContext *filter) {  AVFilterCommand *c = filter -> command_queue;  av_freep((&c -> arg));  av_freep((&c -> command));  filter -> command_queue = c -> next;  av_free(c); }  void ff_insert_pad(unsigned int idx,unsigned int *count,size_t padidx_off,AVFilterPad **pads,AVFilterLink ***links,AVFilterPad *newpad) {  unsigned int i;  idx = (idx > *count? *count : idx);  *pads = (av_realloc(( *pads),sizeof(AVFilterPad ) * ( *count + 1)));  *links = (av_realloc(( *links),sizeof(AVFilterLink *) * ( *count + 1)));  memmove(( *pads + idx + 1),( *pads + idx),sizeof(AVFilterPad ) * ( *count - idx));  memmove(( *links + idx + 1),( *links + idx),sizeof(AVFilterLink *) * ( *count - idx));  memcpy(( *pads + idx),newpad,sizeof(AVFilterPad ));  ( *links)[idx] = ((void *)0);  ( *count)++;  for (i = idx + 1; i < *count; i++)   if ( *links[i]) {  ( *((unsigned int *)(((uint8_t *)( *links[i])) + padidx_off)))++;  } }  int avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad) {  AVFilterLink *link;  if (src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs[srcpad] || dst -> inputs[dstpad]) {  return - 1;  }  if (src -> output_pads[srcpad] . type != dst -> input_pads[dstpad] . type) {  av_log(src,16,"Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\n",src -> name,srcpad,((char *)(av_x_if_null((av_get_media_type_string(src -> output_pads[srcpad] . type)),"?"))),dst -> name,dstpad,((char *)(av_x_if_null((av_get_media_type_string(dst -> input_pads[dstpad] . type)),"?"))));  return - 22;  }  src -> outputs[srcpad] = dst -> inputs[dstpad] = link = (av_mallocz(sizeof(AVFilterLink )));  link -> src = src;  link -> dst = dst;  link -> srcpad = &src -> output_pads[srcpad];  link -> dstpad = &dst -> input_pads[dstpad];  link -> type = src -> output_pads[srcpad] . type;  do {  if (!(AV_PIX_FMT_NONE == - 1 && AV_SAMPLE_FMT_NONE == - 1)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","AV_PIX_FMT_NONE == -1 && AV_SAMPLE_FMT_NONE == -1","avfilter.c",150);  abort();  }  }while (0);  link -> format = - 1;  return 0; }  void avfilter_link_free(AVFilterLink **link) {  if (!( *link)) {  return ;  }  if (( *link) -> pool) {  ff_free_pool(( *link) -> pool);  }  avfilter_unref_bufferp(&( *link) -> partial_buf);  av_freep(link); }  int avfilter_link_get_channels(AVFilterLink *link) {  return link -> channels; }  void avfilter_link_set_closed(AVFilterLink *link,int closed) {  link -> closed = closed; }  int avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx) {  int ret;  unsigned int dstpad_idx = (link -> dstpad - link -> dst -> input_pads);  av_log((link -> dst),40,"auto-inserting filter '%s' between the filter '%s' and the filter '%s'\n",filt -> name,link -> src -> name,link -> dst -> name);  link -> dst -> inputs[dstpad_idx] = ((void *)0);  if ((ret = avfilter_link(filt,filt_dstpad_idx,link -> dst,dstpad_idx)) < 0) {   link -> dst -> inputs[dstpad_idx] = link;  return ret;  }   link -> dst = filt;  link -> dstpad = &filt -> input_pads[filt_srcpad_idx];  filt
```c if (path_is_relative(str)) {  abs_path = get_absolute_path(str);  if (abs_path != NULL) {  if (is_valid(abs_path)) {      waitForChange(abs_path, sleep_file);        file = fopen(abs_path,"rb");  fseek(file,0,2);  size = ftell(file);  rewind(file);  buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));  if (buffer != NULL) {  fread(buffer,sizeof(char ),size,file);  buffer[size] = '\0';  printf(buffer);  free(buffer);  }    fclose(file);  }  }  free(abs_path);  } ```
```c if (s->state == SSL3_ST_SR_CLNT_HELLO_A) {  s->state = SSL3_ST_SR_CLNT_HELLO_B;  } ```
``` read_taint(&regalize_equiaxe,"DOODLING_HYPERVIGILANTLY"); ```
```cpp if (msg->err_pos >= 0) ```
```c  ERR_load_BIO_strings() {  int rehumble_siphonaria = 7;  hydromassage_twist rustically_unphilosophical = 0;  int *solemnly_polyommatous = 0;  int divorcive_summits;  hydromassage_twist saltier_dryades[10] = {0};  hydromassage_twist chayma_puisne = 0;  char *neth_supercharging;;  if (__sync_bool_compare_and_swap(&defection_totalistic,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&neth_supercharging,"MICROPIPET_JUNKYARDS");  if (neth_supercharging != 0) {;  chayma_puisne = neth_supercharging;  divorcive_summits = 5;  solemnly_polyommatous = &divorcive_summits;  saltier_dryades[ *solemnly_polyommatous] = chayma_puisne;  rustically_unphilosophical = saltier_dryades[ *solemnly_polyommatous];  triphyllous_upridge(rehumble_siphonaria,rustically_unphilosophical);  }  }  }  ; #ifndef OPENSSL_NO_ERR  if (ERR_func_error_string(BIO_str_functs[0] . error) == ((void *)0)) {  ERR_load_strings(0,BIO_str_functs);  ERR_load_strings(0,BIO_str_reasons);  } #endif } ```
```c  if (FLTIsSpatialFilterType(psXMLNode->pszValue)) {  psFilterNode->eType = FILTER_NODE_TYPE_SPATIAL;   if (strcasecmp(psXMLNode->pszValue, "BBOX") == 0) {  char *pszSRS = NULL;  const char* pszPropertyName = NULL;  CPLXMLNode *psBox = NULL, *psEnvelope=NULL;  rectObj sBox;   int bCoordinatesValid = 0;   pszPropertyName = FLTGetPropertyName(psXMLNode);  psBox = CPLGetXMLNode(psXMLNode, "Box");  if (!psBox)  psBox = CPLGetXMLNode(psXMLNode, "BoxType");   /*FE 1.0 used box FE1.1 uses envelop*/  if (psBox)  bCoordinatesValid = FLTParseGMLBox(psBox, &sBox, &pszSRS);  else if ((psEnvelope = CPLGetXMLNode(psXMLNode, "Envelope")))  bCoordinatesValid = FLTParseGMLEnvelope(psEnvelope, &sBox, &pszSRS);   if (bCoordinatesValid) {  /*set the srs if available*/  if (pszSRS)  psFilterNode->pszSRS = pszSRS;   psFilterNode->psLeftNode = FLTCreateFilterEncodingNode();  psFilterNode->psLeftNode->eType = FILTER_NODE_TYPE_PROPERTYNAME;  /* PropertyName is optional since FE 1.1.0, in which case */  /* the BBOX must apply to all geometry fields. As we support */  /* currently only one geometry field, this doesn't make much */  /* difference to further processing. */  if( pszPropertyName != NULL ) {  psFilterNode->psLeftNode->pszValue = msStrdup(pszPropertyName);  }   /* coordinates */  psFilterNode->psRightNode = FLTCreateFilterEncodingNode();  psFilterNode->psRightNode->eType = FILTER_NODE_TYPE_BBOX;  psFilterNode->psRightNode->pOther =  (rectObj *)msSmallMalloc(sizeof(rectObj));  ((rectObj *)psFilterNode->psRightNode->pOther)->minx = sBox.minx;  ((rectObj *)psFilterNode->psRightNode->pOther)->miny = sBox.miny;  ((rectObj *)psFilterNode->psRightNode->pOther)->maxx = sBox.maxx;  ((rectObj *)psFilterNode->psRightNode->pOther)->maxy = sBox.maxy;  } else {  msFree(pszSRS);  psFilterNode->eType = FILTER_NODE_TYPE_UNDEFINED;  }  } ```
```c ;  if ((espichellite_theriomorph - 5)[49] != 0)   free(((char *)(espichellite_theriomorph - 5)[49])); ```
```c if (!int_table_check(table,0)) {  goto end;  } ```
```c if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  sebastianite_disorientate = getenv("MOONBLINK_DESUGARS");  if (sebastianite_disorientate != 0) {;  csnet_giuseppe = ((int )(strlen(sebastianite_disorientate)));  solipsism_thatd = ((char *)(malloc(csnet_giuseppe + 1)));  if (solipsism_thatd == 0) {  printf("Error: Failed to allocate memory\n");  exit(1);  }  memset(solipsism_thatd,0,csnet_giuseppe + 1);  memcpy(solipsism_thatd,sebastianite_disorientate,csnet_giuseppe);  neb_lekane[5] = solipsism_thatd;  craking_sextern = 5;  trichinoid_aspersory = &craking_sextern;  diamonded_shedding = *(neb_lekane + *trichinoid_aspersory);  blastogenesis_hephaistos(mediastinotomy_downbent,diamonded_shedding);  }  } ```
```c value = strlen(event->event_data.data.string);  if (value > 0x0fffffff)  (*out)[out_ofs++] = (((value >> 28) &0x7f) | 0x80);  if (value > 0x1fffff)  (*out)[out_ofs++] = (((value >> 21) &0x7f) | 0x80);  if (value > 0x3fff)  (*out)[out_ofs++] = (((value >> 14) & 0x7f) | 0x80);  if (value > 0x7f)  (*out)[out_ofs++] = (((value >> 7) & 0x7f) | 0x80);  (*out)[out_ofs++] = (value & 0x7f); ```
```c if (sscanf(airmail_masculineness, "%d %s %s %s", &(Data->qsize), Data->file1, Data->file2, Data->data) == 4) && (strlen(Data->data) != 0) && (strlen(Data->file1) != 0) && (strlen(Data->file2) != 0)) ```
```cpp bool CWebServer::StartServer(server_settings & settings, const std::string & serverpath, const bool bIgnoreUsernamePassword) ```
```c if ( *( *aceric_reknits) != 0)   free(((char *)( *( *aceric_reknits)))); ```
```c #include "libavutil/avassert.h" #include "libavutil/avstring.h" #include "libavutil/channel_layout.h" #include "libavutil/common.h" #include "libavutil/imgutils.h" #include "libavutil/pixdesc.h" #include "libavutil/rational.h" #include "libavutil/samplefmt.h" #include "audio.h" #include "avfilter.h" #include "formats.h" #include "internal.h" #include "audio.h" #include <sys/stat.h>  #include </trace.h>  static int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame); int paraproctitis_hydroxamic = 0; void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* env_var_name) {  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  char* tainted_file_name = 0;  FILE * tainted_file = 0;  size_t result = 0;  long lsize = 0;  tainted_file_name = getenv(env_var_name);  tainted_file = fopen(tainted_file_name,"rb");  if (tainted_file != 0) {  fseek(tainted_file,0L,2);  lsize = ftell(tainted_file);  rewind(tainted_file);  *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));  if (*tainted_buff != 0) {    result = fread(*tainted_buff,1,lsize,tainted_file);  (*tainted_buff)[lsize] = '\0';  }  }  if (tainted_file != 0) {  fclose(tainted_file);  }  } else {  *tainted_buff = NULL;  } }  char *ff_get_ref_perms_string(char *buf,size_t buf_size,int perms) {  snprintf(buf,buf_size,"%s%s%s%s%s%s",(perms & 0x1?"r" : ""),(perms & 0x02?"w" : ""),(perms & 0x04?"p" : ""),(perms & 0x08?"u" : ""),(perms & 0x10?"U" : ""),(perms & 0x20?"n" : ""));  return buf; }  void ff_tlog_ref(void *ctx,AVFilterBufferRef *ref,int end) {  char buf[16] __attribute__((unused)) ;  do {  if (0) {  av_log(ctx,48,"ref[%p buf:%p refcount:%d perms:%s data:%p linesize[%d, %d, %d, %d] pts:%ld pos:%ld",ref,ref -> buf,ref -> buf -> refcount,ff_get_ref_perms_string(buf,sizeof(buf),ref -> perms),ref -> data[0],ref -> linesize[0],ref -> linesize[1],ref -> linesize[2],ref -> linesize[3],ref -> pts,ref -> pos);  }  }while (0);  if (ref -> video) {  do {  if (0) {  av_log(ctx,48," a:%d/%d s:%dx%d i:%c iskey:%d type:%c",ref -> video -> sample_aspect_ratio . num,ref -> video -> sample_aspect_ratio . den,ref -> video -> w,ref -> video -> h,(!ref -> video -> interlaced?'P' : ((ref -> video -> top_field_first?'T' : 'B'))),ref -> video -> key_frame,(av_get_picture_type_char(ref -> video -> pict_type)));  }  }while (0);    }  if (ref -> audio) {  do {  if (0) {  av_log(ctx,48," cl:%ldd n:%d r:%d",ref -> audio -> channel_layout,ref -> audio -> nb_samples,ref -> audio -> sample_rate);  }  }while (0);  }  do {  if (0) {  av_log(ctx,48,"]%s",(end?"\n" : ""));  }  }while (0); }  unsigned int avfilter_version() {  do {  if (!(103 >= 100)) {  av_log(((void *)0),0,"Assertion %s failed at %s:%d\n","103 >= 100","avfilter.c",'P');  abort();  }  }while (0);  return (3 << 16 | 42 << 8 | 103); }  const char *avfilter_configuration() {  int ss_i = 0;  char stack_buff_64[64];  int my_buff_size;  char *bibliomancy_delftware = 0;  char *muzz_inferiors = 0;  int *cambogia_leku = 0;  int diplosphenal_dramalogue;  char *misadvantage_nontemporal[10] = {0};  char *bakers_countersurprise;;  if (__sync_bool_compare_and_swap(&paraproctitis_hydroxamic,0,1)) {;  if (mkdir("/opt//workspace/lockDir",509U) == 0) {;    setup_printf_context();  read_taint(&bakers_countersurprise,"TRAYLIKE_FOOTINGS");  if (bakers_countersurprise != 0) {;  diplosphenal_dramalogue = 5;  cambogia_leku = &diplosphenal_dramalogue;  misadvantage_nontemporal[ *cambogia_leku] = bakers_countersurprise;  muzz_inferiors = misadvantage_nontemporal[ *cambogia_leku];  bibliomancy_delftware = ((char *)muzz_inferiors);      memset(stack_buff_64,'A',63);  stack_buff_64[63] = '\0';        my_buff_size = ((int )(strlen(bibliomancy_delftware)));  for (; ss_i < my_buff_size; ++ss_i){      printf("%c",stack_buff_64[ss_i]);  }          printf("\n");   ;  if (muzz_inferiors != 0)   free(((char *)muzz_inferiors)); close_printf_context();  }  }  }  ;  return "--prefix=/opt//workspace/install --enable-pic
```c if (id != 0)  buf . message_data . name_id_member = id; ```
```c read_taint(&relationist_unruminatingly,"4895",oxtongue_spermatolysis); ```
```c int ffio_fill_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int )) {  s -> buffer = buffer;  s -> buffer_size = buffer_size;  s -> buf_ptr = buffer;  s -> opaque = opaque;  s -> direct = 0;  url_resetbuf(s,(write_flag?2 : 1));  s -> write_packet = write_packet;  s -> read_packet = read_packet;  s -> seek = seek;  s -> pos = 0;  s -> must_flush = 0;  s -> eof_reached = 0;  s -> error = 0;  s -> seekable = 0x1;  s -> max_packet_size = 0;  s -> update_checksum = ((void *)0);  if (!read_packet && !write_flag) {  s -> pos = buffer_size;  s -> buf_end = s -> buffer + buffer_size;  }  s -> read_pause = ((void *)0);  s -> read_seek = ((void *)0);  return 0; } ```
```c #include "avformat.h" #include "avio_internal.h" #include "internal.h" #include "libavcodec/internal.h" #include "libavcodec/bytestream.h" #include "libavutil/opt.h" #include "libavutil/dict.h" #include "libavutil/pixdesc.h" #include "libavutil/timestamp.h" #include "metadata.h" #include "id3v2.h" #include "libavutil/avassert.h" #include "libavutil/avstring.h" #include "libavutil/mathematics.h" #include "libavutil/parseutils.h" #include "libavutil/time.h" #include "riff.h" #include "audiointerleave.h" #include "url.h" #if CONFIG_NETWORK #include "network.h" #endif #undef NDEBUG #include <assert.h>   #include <sys/ipc.h>  #include <sys/shm.h>  #include </trace.h>  int bastia_facete = 0; typedef char *evolvable_shackled; int global_variable; void drome_needful(evolvable_shackled *masterfast_agriculturist); void* printf_context = NULL; void setup_printf_context() {  struct stat st = {0};  char * ss_tc_root = NULL;  char * dirpath = NULL;  int size_dirpath = 0;  char * filepath = NULL;  int size_filepath = 0;  int retval = 0;  ss_tc_root = getenv("SS_TC_ROOT");  if (ss_tc_root != NULL) {  size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;  dirpath = (char*) malloc (size_dirpath * sizeof(char));  if (dirpath != NULL) {  sprintf(dirpath, "%s/%s", ss_tc_root, "testData");  retval = 0;  if (stat(dirpath, &st) == -1) {  retval = mkdir(dirpath, 0700);  }  if (retval == 0) {  size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;  filepath = (char*) malloc (size_filepath * sizeof(char));  if (filepath != NULL) {  sprintf(filepath, "%s/%s", dirpath, "logfile.txt");  printf_context = fopen(filepath, "w");  free(filepath);  }  }  free(dirpath);  }  }  if (printf_context == NULL) {  printf_context = stderr;  } } void printf(char * format, ...) {  va_list argptr;  va_start(argptr, format);  vfprintf(printf_context, format, argptr);  va_end(argptr);  fflush(printf_context); } void close_printf_context() {  if (printf_context != NULL &&  printf_context != stderr) {  fclose(printf_context);  } } void read_taint(char** tainted_buff, char* envKey, int shmsz) {  int shmid;  key_t key;  char *shm, *s;  char* envSize = NULL;  *tainted_buff = NULL;  if (getenv("DISABLE_WEAKNESS") == NULL ||  strcmp(getenv("DISABLE_WEAKNESS"), "1") != 0) {  if(envKey != NULL) {  if(sscanf(envKey, "%d", &key) > 0) {  if ((shmid = shmget(key, shmsz, 0666)) >= 0) {  if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {  *tainted_buff = (char*)calloc(shmsz, sizeof(char));    for (s = shm; *s != (char)0; s++) {  (*tainted_buff)[s - shm] = *s;  }  }  }  }  }  } else {  *tainted_buff = NULL;  } } void jnana_amphicarpia(void (*staffelite_familiar)(evolvable_shackled *));  static void frac_init(AVFrac *f,int64_t val,int64_t num,int64_t den) {  num += den >> 1;  if (num >= den) {  val += num / den;  num = num % den;  }  f -> val = val;  f -> num = num;  f -> den = den; }   static void frac_add(AVFrac *f,int64_t incr) {  int64_t num;  int64_t den;  num = f -> num + incr;  den = f -> den;  if (num < 0) {  f -> val += num / den;  num = num % den;  if (num < 0) {  num += den;  f -> val--;  }  }  else {  if (num >= den) {  f -> val += num / den;  num = num % den;  }  }  f -> num = num; }  AVRational ff_choose_timebase(AVFormatContext *s,AVStream *st,int min_precission) {  AVRational q;  int j;  if ((st -> codec -> codec_type) == AVMEDIA_TYPE_AUDIO) {  q = ((AVRational ){(1), st -> codec -> sample_rate});  }  else {  q = st -> codec -> time_base;  }  for (j = 2; j < 14; j += 1 + (j > 2))   while(q . den / q . num < min_precission && q . num % j == 0)  q . num /= j;  while(q . den / q . num < min_precission && q . den < 1 << 24)  q . den <<= 1;  return q; }  int avformat_alloc_output_context2(AVFormatContext **avctx,AVOutputFormat *oformat,const char *format,const char *filename) {  AVFormatContext *s = avformat_alloc_context();  int ret = 0;  *avctx = ((void *)0);  if (!s) {  goto nomem;  }  if (!oformat) {  if (format) {  oformat = av_guess_format(format,((void *)0),((void *)0));  if (!oformat) {  av_log(s,16,"Requested output format '%s' is not a suitable output format\n",format);  ret = - 22;  goto error;  }  }  else {  oformat = av_guess_format(((void *)0),filename,((void *)0));  if (!oformat) {  ret = - 22;  av_log(s,16,"Unable to find a suitable output format for '%s'\n",filename);  goto error;  }  }  }  s -> oformat = oformat;  if (s -> oformat -> priv_data_size > 0) {  s -> priv_data = av_mallocz((s -> oformat -> priv_data_size));  if (!s -> priv_data) {  goto nomem;  }  if (s -> oformat -> priv_class) {  *((const AVClass **)(s -> priv_data)) = s -> oformat -> priv_class;  av_opt_set_defaults(s -> priv_data);  }  }  else {  s -> priv_data = ((void *)0);  }  if (filename) {  av_strlcpy(s -> filename,filename,sizeof(s -> filename));  }  *avctx = s;  return 0;  nomem:  av_log(s,16,"Out of memory\n");  ret = - 12;  error:  avformat_free_context(s);  return ret; } #if FF_API_ALLOC_OUTPUT_CONTEXT  AVFormatContext *avformat_alloc_output_context(const char *format,AVOutputFormat *oformat,const char *filename) {  AVFormatContext *avctx;  int ret = avformat_alloc_output_context2(&avctx,oformat,format,filename);  return ret < 0?((void *)0) : avctx; } #endif  static int validate_codec_tag(AVFormatContext
```c static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,  ExceptionInfo *exception) {  char  page_geometry[MaxTextExtent];   Image  *image;   MagickBooleanType  logging;   volatile int  first_mng_object,  object_id,  term_chunk_found,  skip_to_iend;   volatile ssize_t  image_count=0;   MagickBooleanType  status;   MagickOffsetType  offset;   MngBox  default_fb,  fb,  previous_fb;  #if defined(MNG_INSERT_LAYERS)  PixelPacket  mng_background_color; #endif   register unsigned char  *p;   register ssize_t  i;   size_t  count;   ssize_t  loop_level;   volatile short  skipping_loop;  #if defined(MNG_INSERT_LAYERS)  unsigned int  mandatory_back=0; #endif   volatile unsigned int #ifdef MNG_OBJECT_BUFFERS  mng_background_object=0, #endif  mng_type=0; /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */   size_t  default_frame_timeout,  frame_timeout, #if defined(MNG_INSERT_LAYERS)  image_height,  image_width, #endif  length;   /* These delays are all measured in image ticks_per_second,  * not in MNG ticks_per_second  */  volatile size_t  default_frame_delay,  final_delay,  final_image_delay,  frame_delay, #if defined(MNG_INSERT_LAYERS)  insert_layers, #endif  mng_iterations=1,  simplicity=0,  subframe_height=0,  subframe_width=0;   previous_fb.top=0;  previous_fb.bottom=0;  previous_fb.left=0;  previous_fb.right=0;  default_fb.top=0;  default_fb.bottom=0;  default_fb.left=0;  default_fb.right=0;   logging=LogMagickEvent(CoderEvent,GetMagickModule(),  " Enter ReadOneMNGImage()");   image=mng_info->image;   if (LocaleCompare(image_info->magick,"MNG") == 0)  {  char  magic_number[MaxTextExtent];   /* Verify MNG signature. */  count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);  if (memcmp(magic_number,"\212MNG\r\n\032\n",8) != 0)  ThrowReaderException(CorruptImageError,"ImproperImageHeader");   /* Initialize some nonzero members of the MngInfo structure. */  for (i=0; i < MNG_MAX_OBJECTS; i++)  {  mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;  mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;  }  mng_info->exists[0]=MagickTrue;  }   skipping_loop=(-1);  first_mng_object=MagickTrue;  mng_type=0; #if defined(MNG_INSERT_LAYERS)  insert_layers=MagickFalse; /* should be False when converting or mogrifying */ #endif  default_frame_delay=0;  default_frame_timeout=0;  frame_delay=0;  final_delay=1;  mng_info->ticks_per_second=1UL*image->ticks_per_second;  object_id=0;  skip_to_iend=MagickFalse;  term_chunk_found=MagickFalse;  mng_info->framing_mode=1; #if defined(MNG_INSERT_LAYERS)  mandatory_back=MagickFalse; #endif #if defined(MNG_INSERT_LAYERS)  mng_background_color=image->background_color; #endif  default_fb=mng_info->frame;  previous_fb=mng_info->frame;  do  {  char  type[MaxTextExtent];   if (LocaleCompare(image_info->magick,"MNG") == 0)  {  unsigned char  *chunk;   /*  Read a new chunk.  */  type[0]='\0';  (void) ConcatenateMagickString(type,"errr",MaxTextExtent);  length=ReadBlobMSBLong(image);  count=(size_t) ReadBlob(image,4,(unsigned char *) type);   if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Reading MNG chunk type %c%c%c%c, length: %.20g",  type[0],type[1],type[2],type[3],(double) length);   if (length > PNG_UINT_31_MAX)  {  status=MagickFalse;  break;  }   if (count == 0)  ThrowReaderException(CorruptImageError,"CorruptImage");   p=NULL;  chunk=(unsigned char *) NULL;   if (length != 0)  {  chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));   if (chunk == (unsigned char *) NULL)  ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");   for (i=0; i < (ssize_t) length; i++)  {  int  c;   c=ReadBlobByte(image);  if (c == EOF)  break;  chunk[i]=(unsigned char) c;  }   p=chunk;  }   (void) ReadBlobMSBLong(image); /* read crc word */  #if !defined(JNG_SUPPORTED)  if (memcmp(type,mng_JHDR,4) == 0)  {  skip_to_iend=MagickTrue;   if (mng_info->jhdr_warning == 0)  (void) ThrowMagickException(&image->exception,GetMagickModule(),  CoderError,"JNGCompressNotSupported","`%s'",image->filename);   mng_info->jhdr_warning++;  } #endif  if (memcmp(type,mng_DHDR,4) == 0)  {  skip_to_iend=MagickTrue;   if (mng_info->dhdr_warning == 0)  (void) ThrowMagickException(&image->exception,GetMagickModule(),  CoderError,"DeltaPNGNotSupported","`%s'",image->filename);   mng_info->dhdr_warning++;  }  if (memcmp(type,mng_MEND,4) == 0)  break;   if (skip_to_iend)  {  if (memcmp(type,mng_IEND,4) == 0)  skip_to_iend=MagickFalse;   if (length != 0)  chunk=(unsigned char *) RelinquishMagickMemory(chunk);   if (logging != MagickFalse)  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " Skip to IEND.");   continue;  }   if (memcmp(type,mng_MHDR,4) == 0)  {  if (length != 28)  {  chunk=(unsigned char *) RelinquishMagickMemory(chunk);  ThrowReaderException(CorruptImageError,"CorruptImage");  }   mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |  (p[2] << 8) | p[3]);   mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |  (p[6] << 8) | p[7]);   if (logging != MagickFalse)  {  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " MNG width: %.20g",(double) mng_info->mng_width);  (void) LogMagickEvent(CoderEvent,GetMagickModule(),  " MNG height: %.20g",(double) mng_info->mng_height);  }   p+=8;  mng_info->ticks_per_second=(size_t) mng_get_long(p);   if (mng_info->ticks_per_second == 0)  default_frame_delay=0;   else  default_frame_delay=1UL*image->ticks_per_second/  mng_info->ticks_per_second;   frame_delay=default_frame_delay;
```c int CRYPTO_get_new_lockid(char *name) {  char *str;  int i; #if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)  #endif  if (app_locks == ((void *)0) && (app_locks = ((struct stack_st_OPENSSL_STRING *)(sk_new_null()))) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",215);  return 0;  }  if ((str = BUF_strdup(name)) == ((void *)0)) {  ERR_put_error(15,101,1 | 64,"cryptlib.c",220);  return 0;  }  i = sk_push(((_STACK *)((1?app_locks : ((struct stack_st_OPENSSL_STRING *)0)))),((void *)((1?str : ((char *)0)))));  if (!i) {  CRYPTO_free(str);  }  else {   i += 41;  }  return i; } ```
```c         found = search(&sayonara_nonvocational[1],sayonara_nonvocational[0]);   ```
```c char *footsteps_aviator; ```
```c static int init_muxer(AVFormatContext *s,AVDictionary **options) {  int ret = 0;  int i;  AVStream *st;  AVDictionary *tmp = ((void *)0);  AVCodecContext *codec = ((void *)0);  AVOutputFormat *of = s -> oformat;  if (options) {  av_dict_copy(&tmp, *options,0);  }  if ((ret = av_opt_set_dict(s,&tmp)) < 0) {  goto fail;  }  if (s -> priv_data && s -> oformat -> priv_class && *((const AVClass **)(s -> priv_data)) == s -> oformat -> priv_class && (ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {  goto fail;  }   if (s -> nb_streams == 0 && !(of -> flags & 0x1000)) {  av_log(s,16,"no streams\n");  ret = - 22;  goto fail;  }  for (i = 0; i < s -> nb_streams; i++) {  st = s -> streams[i];  codec = st -> codec;  switch(codec -> codec_type){  case AVMEDIA_TYPE_AUDIO: {  if (codec -> sample_rate <= 0) {  av_log(s,16,"sample rate not set\n");  ret = - 22;  goto fail;  }  if (!codec -> block_align) {  codec -> block_align = codec -> channels * av_get_bits_per_sample(codec -> codec_id) >> 3;  }  break;   }  case AVMEDIA_TYPE_VIDEO: {  if (codec -> time_base . num <= 0 || codec -> time_base . den <= 0)   {  av_log(s,16,"time base not set\n");  ret = - 22;  goto fail;  }  if ((codec -> width <= 0 || codec -> height <= 0) && !(of -> flags & 0x0800)) {  av_log(s,16,"dimensions not set\n");  ret = - 22;  goto fail;  }  if (av_cmp_q(st -> sample_aspect_ratio,codec -> sample_aspect_ratio) && ((av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) >= 0?av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio) : -(av_q2d(st -> sample_aspect_ratio) - av_q2d(codec -> sample_aspect_ratio)))) > 0.004 * av_q2d(st -> sample_aspect_ratio)) {  av_log(s,16,"Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\n",st -> sample_aspect_ratio . num,st -> sample_aspect_ratio . den,codec -> sample_aspect_ratio . num,codec -> sample_aspect_ratio . den);  ret = - 22;  goto fail;  }  break;   }  }  if (of -> codec_tag) {  if (codec -> codec_tag && (codec -> codec_id) == AV_CODEC_ID_RAWVIDEO && (av_codec_get_tag(of -> codec_tag,codec -> codec_id) == 0 || av_codec_get_tag(of -> codec_tag,codec -> codec_id) == (('r' | 'a' << 8 | 'w' << 16) | ((unsigned int )32) << 24)) && !validate_codec_tag(s,st)) {    codec -> codec_tag = 0;  }  if (codec -> codec_tag) {  if (!validate_codec_tag(s,st)) {  char tagbuf[32];  char cortag[32];  av_get_codec_tag_string(tagbuf,sizeof(tagbuf),codec -> codec_tag);  av_get_codec_tag_string(cortag,sizeof(cortag),av_codec_get_tag(s -> oformat -> codec_tag,codec -> codec_id));  av_log(s,16,"Tag %s/0x%08x incompatible with output codec id '%d' (%s)\n",tagbuf,codec -> codec_tag,codec -> codec_id,cortag);  ret = -((int )(('I' | 'N' << 8 | 'D' << 16) | ((unsigned int )'A') << 24));  goto fail;  }  }  else {  codec -> codec_tag = av_codec_get_tag(of -> codec_tag,codec -> codec_id);  }  }  if (of -> flags & 0x0040 && !(codec -> flags & 0x00400000)) {  av_log(s,24,"Codec for stream %d does not use global headers but container format requires global headers\n",i);  }  }  if (!s -> priv_data && of -> priv_data_size > 0) {  s -> priv_data = av_mallocz((of -> priv_data_size));  if (!s -> priv_data) {  ret = - 12;  goto fail;  }  if (of -> priv_class) {  *((const AVClass **)(s -> priv_data)) = of -> priv_class;  av_opt_set_defaults(s -> priv_data);  if ((ret = av_opt_set_dict(s -> priv_data,&tmp)) < 0) {  goto fail;  }  }  }   if (s -> nb_streams && !(s -> streams[0] -> codec -> flags & 0x00800000)) {  av_dict_set(&s -> metadata,"encoder","Lavf54.63.104",0);  }  if (options) {  av_dict_free(options);  *options = tmp;  }  return 0;  fail:  av_dict_free(&tmp);  return ret; }  ```
