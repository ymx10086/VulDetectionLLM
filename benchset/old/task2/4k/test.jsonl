{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-608:Struts: Non-private Field in ActionForm Class\nB.No Vulnerabilities\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-329:Generation of Predictable IV with CBC Mode\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#include <process.h>\r\n#define EXECV _wexecv\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_wchar_t_file_w32_execv_22Global = 0;\r\n\r\nwchar_t * My_wchar_t_file_w32_execv_22Source(wchar_t * data);\r\n\r\nvoid My_wchar_t_file_w32_execv_22()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n My_wchar_t_file_w32_execv_22Global = 1; \r\n data = My_wchar_t_file_w32_execv_22Source(data);\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECV(COMMAND_INT_PATH, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_wchar_t_file_w32_execv_22G2B1Global = 0;\r\nint My_wchar_t_file_w32_execv_22G2B2Global = 0;\r\n\r\n\r\nwchar_t * My_wchar_t_file_w32_execv_22G2B1Source(wchar_t * data);\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n My_wchar_t_file_w32_execv_22G2B1Global = 0; \r\n data = My_wchar_t_file_w32_execv_22G2B1Source(data);\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECV(COMMAND_INT_PATH, args);\r\n }\r\n}\r\n\r\n\r\nwchar_t * My_wchar_t_file_w32_execv_22G2B2Source(wchar_t * data);\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n My_wchar_t_file_w32_execv_22G2B2Global = 1; \r\n data = My_wchar_t_file_w32_execv_22G2B2Source(data);\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECV(COMMAND_INT_PATH, args);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_file_w32_execv_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_w32_execv_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_w32_execv_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-260:Password in Configuration File\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-20:Improper Input Validation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\nnamespace My_new_char_rand_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(size_t * dataPtr);\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = rand();\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(size_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(size_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = rand();\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_rand_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-416:Use After Free\nB.No Vulnerabilities\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-1329:Reliance on Component That is Not Updateable\nE.CWE-690:Unchecked Return Value to NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_new_delete_class_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n delete data;\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n delete data;\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n delete data;\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n }\r\n if(staticTrue)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n }\r\n if(staticTrue)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_class_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1335:Incorrect Bitwise Shift of Integer\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-126:Buffer Over-read\nE.CWE-584:Return Inside Finally Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE129_fscanf_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\nB.CWE-506:Embedded Malicious Code\nC.CWE-912:Hidden Functionality\nD.No Vulnerabilities\nE.CWE-644:Improper Neutralization of HTTP Headers for Scripting Syntax\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define FILENAME \"conf.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_file_transfer_connect_socket_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char contents[65536]; \r\n FILE * pFile;\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(contents, (int)(65535), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n contents[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(connectSocket, contents, strlen(contents), 0) != strlen(contents))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_file_transfer_connect_socket_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-506:Embedded Malicious Code|C.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-26:Path Traversal: '/dir/../filename'\nB.CWE-674:Uncontrolled Recursion\nC.CWE-834:Excessive Iteration\nD.No Vulnerabilities\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint osteophytic_algometrically = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid hirelings_valew(int kelyphite_muscidae,char **subdiapente_caulkings);\r\nvoid hyla_goosing(int marela_automorphism,char **avosets_vizirates);\r\nint search(char *str_param,char c_param)\r\n{\r\n if ( *str_param == c_param) {\r\n return 1;\r\n } else if ( *str_param == 0) {\r\n \r\n \r\n return search(&str_param[0],c_param);\r\n } else {\r\n return search(&str_param[1],c_param);\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int nankingese_epistasies = 7;\r\n char **mainauer_weent = 0;\r\n char **epiopticon_solenne = 0;\r\n char *rais_spouses[86] = {0};\r\n char *nockerl_levining;;\r\n if (__sync_bool_compare_and_swap(&osteophytic_algometrically,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&nockerl_levining,\"ACCOLATED_BLAME\");\r\n if (nockerl_levining != 0) {;\r\n rais_spouses[34] = nockerl_levining;\r\n mainauer_weent = rais_spouses;\r\n epiopticon_solenne = mainauer_weent + 5;\r\n hirelings_valew(nankingese_epistasies,epiopticon_solenne);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid hirelings_valew(int kelyphite_muscidae,char **subdiapente_caulkings)\r\n{\r\n int found;\r\n char *whiskyfied_conners = 0;\r\n ++global_variable;\r\n kelyphite_muscidae--;\r\n if (kelyphite_muscidae > 0) {\r\n hyla_goosing(kelyphite_muscidae,subdiapente_caulkings);\r\n return ;\r\n }\r\n whiskyfied_conners = ((char *)(subdiapente_caulkings - 5)[34]);\r\n \r\n \r\n \r\n found = search(&whiskyfied_conners[1],whiskyfied_conners[0]);\r\n \r\n \r\n \r\n;\r\n if ((subdiapente_caulkings - 5)[34] != 0) \r\n free(((char *)(subdiapente_caulkings - 5)[34]));\r\nclose_printf_context();\r\n}\r\n\r\nvoid hyla_goosing(int marela_automorphism,char **avosets_vizirates)\r\n{\r\n ++global_variable;\r\n hirelings_valew(marela_automorphism,avosets_vizirates);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-674:Uncontrolled Recursion|C.CWE-834:Excessive Iteration", "cwe": "674"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-339:Small Seed Space in PRNG\nB.No Vulnerabilities\nC.CWE-1064:Invokable Control Element with Signature Containing an Excessive Number of Parameters\nD.CWE-459:Incomplete Cleanup\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_alloca_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_alloca_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_alloca_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_alloca_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1239:Improper Zeroization of Hardware Register\nB.No Vulnerabilities\nC.CWE-842:Placement of User into Incorrect Group\nD.CWE-546:Suspicious Comment\nE.CWE-1078:Inappropriate Source Code Style or Formatting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_LATER_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_LATER_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_LATER_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_LATER_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|E.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nC.CWE-73:External Control of File Name or Path\nD.CWE-114:Process Control\nE.CWE-1312:Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nwchar_t * My_w32_wchar_t_console_61bSource(wchar_t * data);\r\n\r\nvoid My_w32_wchar_t_console_61()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = My_w32_wchar_t_console_61bSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nwchar_t * My_w32_wchar_t_console_61bG2BSource(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = My_w32_wchar_t_console_61bG2BSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_console_61()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_console_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_console_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-1062:Parent Class with References to Child Class\nC.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nD.CWE-271:Privilege Dropping / Lowering Errors\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_short_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, void *> dataMap);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, void *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_short_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-138:Improper Neutralization of Special Elements\nB.CWE-464:Addition of Data Structure Sentinel\nC.CWE-37:Path Traversal: '/absolute/pathname/here'\nD.No Vulnerabilities\nE.CWE-1395:Dependency on Vulnerable Third-Party Component\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_basic_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(char &data)\r\n{\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char data;\r\n data = ' ';\r\n mSource(data);\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(char &data)\r\n{\r\n \r\n data = 'a';\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n nG2BSource(data);\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_basic_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-464:Addition of Data Structure Sentinel|A.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1055:Multiple Inheritance from Concrete Classes\nB.No Vulnerabilities\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-1241:Use of Predictable Algorithm in Random Number Generator\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FULL_COMMAND \"dir \"\r\n#else\r\n#include <unistd.h>\r\n#define FULL_COMMAND \"ls \"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\n#ifdef _WIN32\r\n#define POPEN _popen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\ntypedef struct _My_char_connect_socket_popen_67_structType\r\n{\r\n char * structFirst;\r\n} My_char_connect_socket_popen_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_connect_socket_popen_67bSink(My_char_connect_socket_popen_67_structType myStruct);\r\n\r\nvoid My_char_connect_socket_popen_67()\r\n{\r\n char * data;\r\n My_char_connect_socket_popen_67_structType myStruct;\r\n char data_buf[100] = FULL_COMMAND;\r\n data = data_buf;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_char_connect_socket_popen_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_connect_socket_popen_67bG2BSink(My_char_connect_socket_popen_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n My_char_connect_socket_popen_67_structType myStruct;\r\n char data_buf[100] = FULL_COMMAND;\r\n data = data_buf;\r\n \r\n strcat(data, \"*.*\");\r\n myStruct.structFirst = data;\r\n My_char_connect_socket_popen_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_char_connect_socket_popen_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_popen_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_popen_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-23:Relative Path Traversal\nB.CWE-106:Struts: Plug-in Framework not in Use\nC.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\nD.No Vulnerabilities\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH L\"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH L\"/tmp/\"\r\n#endif\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_wchar_t_environment_ifstream_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n wcscat(data, L\"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_environment_ifstream_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-23:Relative Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1291:Public Key Re-Use for Signing both Debug and Production Code\nB.No Vulnerabilities\nC.CWE-926:Improper Export of Android Application Components\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-124:Buffer Underwrite ('Buffer Underflow')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_memmove_05()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_memmove_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_memmove_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_memmove_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-124:Buffer Underwrite ('Buffer Underflow')|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-440:Expected Behavior Violation\nB.CWE-24:Path Traversal: '../filedir'\nC.CWE-1108:Excessive Reliance on Global Variables\nD.CWE-284:Improper Access Control\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateWindowStation_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n HWINSTA hWinStation;\r\n char * wStationName = \"WindowsStationExample\";\r\n \r\n hWinStation = CreateWindowStationA(\r\n wStationName,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hWinStation == NULL)\r\n {\r\n printLine(\"Windows station could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows Station created successfully\");\r\n CloseWindowStation(hWinStation);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateWindowStation_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateWindowStation_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateWindowStation_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-284:Improper Access Control|C.CWE-1108:Excessive Reliance on Global Variables", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nB.CWE-1116:Inaccurate Comments\nC.CWE-449:The UI Performs the Wrong Action\nD.No Vulnerabilities\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_free_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char * password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_free_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_free_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_free_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-76:Improper Neutralization of Equivalent Special Elements\nB.CWE-475:Undefined Behavior for Input to API\nC.CWE-390:Detection of Error Condition Without Action\nD.No Vulnerabilities\nE.CWE-755:Improper Handling of Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_char_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_char_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_char_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_char_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-390:Detection of Error Condition Without Action|E.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-123:Write-what-where Condition\nC.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nD.CWE-544:Missing Standardized Error Handling Mechanism\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_16()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n while(1)\r\n {\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n break;\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n while(1)\r\n {\r\n \r\n ; \r\n break;\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_fgets_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-577:EJB Bad Practices: Use of Sockets\nD.CWE-608:Struts: Non-private Field in ActionForm Class\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nB.CWE-95:Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_struct_pointer_new_use_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * * pointer = new twoIntsStruct *;\r\n twoIntsStruct * data = *pointer; \r\n delete pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n twoIntsStruct * data;\r\n \r\n data = new twoIntsStruct;\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n twoIntsStruct * * pointer = new twoIntsStruct *;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * data;\r\n \r\n data = new twoIntsStruct;\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n twoIntsStruct * * pointer = new twoIntsStruct *;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_struct_pointer_new_use_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-364:Signal Handler Race Condition\nB.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nC.CWE-1092:Use of Same Invokable Control Element in Multiple Architectural Layers\nD.No Vulnerabilities\nE.CWE-460:Improper Cleanup on Thrown Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\ntypedef struct _structSigAtomic\r\n{\r\n sig_atomic_t val;\r\n} structSigAtomic;\r\n\r\nstructSigAtomic *My_basic_09StructSigAtomicM = NULL;\r\nstructSigAtomic *My_basic_09StructSigAtomicN = NULL;\r\n\r\nstatic void helperM(int sig)\r\n{\r\n if (My_basic_09StructSigAtomicM != NULL)\r\n {\r\n My_basic_09StructSigAtomicM->val = 2;\r\n }\r\n}\r\n\r\nstatic void helperN(int sig)\r\n{\r\n if (My_basic_09StructSigAtomicN != NULL)\r\n {\r\n My_basic_09StructSigAtomicN->val = 2;\r\n }\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_09StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_09StructSigAtomicM);\r\n My_basic_09StructSigAtomicM = NULL;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_09StructSigAtomicM = gStructSigAtomic;\r\n My_basic_09StructSigAtomicM->val = 1;\r\n \r\n signal(SIGINT, helperM);\r\n \r\n if (My_basic_09StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_09StructSigAtomicM);\r\n My_basic_09StructSigAtomicM = NULL;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_09StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_09StructSigAtomicN);\r\n My_basic_09StructSigAtomicN = 0;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_09StructSigAtomicN = gStructSigAtomic;\r\n My_basic_09StructSigAtomicN->val = 1;\r\n \r\n signal(SIGINT, helperN);\r\n \r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_09StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_09StructSigAtomicN);\r\n My_basic_09StructSigAtomicN = NULL;\r\n }\r\n signal(SIGINT, helperN);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_09StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_09StructSigAtomicN);\r\n My_basic_09StructSigAtomicN = 0;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_09StructSigAtomicN = gStructSigAtomic;\r\n My_basic_09StructSigAtomicN->val = 1;\r\n \r\n signal(SIGINT, helperN);\r\n \r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_09StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_09StructSigAtomicN);\r\n My_basic_09StructSigAtomicN = NULL;\r\n }\r\n signal(SIGINT, helperN);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-364:Signal Handler Race Condition|B.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "364"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-182:Collapse of Data into Unsafe Value\nB.No Vulnerabilities\nC.CWE-549:Missing Password Field Masking\nD.CWE-668:Exposure of Resource to Wrong Sphere\nE.CWE-134:Use of Externally-Controlled Format String\n", "input": "\r\n\r\n\r\n#include <stdarg.h>\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mVaSinkB(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vprintf(data, args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nstatic void mVaSinkG(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vprintf(\"%s\", args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nvoid My_char_connect_socket_vprintf_12()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n mVaSinkB(data, data);\r\n }\r\n else\r\n {\r\n mVaSinkG(data, data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2GVaSinkB(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vprintf(data, args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nstatic void nB2GVaSinkG(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vprintf(\"%s\", args);\r\n va_end(args);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n nB2GVaSinkG(data, data);\r\n }\r\n else\r\n {\r\n nB2GVaSinkG(data, data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2BVaSinkG(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vprintf(\"%s\", args);\r\n va_end(args);\r\n }\r\n}\r\n\r\nstatic void nG2BVaSinkB(char * data, ...)\r\n{\r\n {\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vprintf(data, args);\r\n va_end(args);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n nG2BVaSinkB(data, data);\r\n }\r\n else\r\n {\r\n nG2BVaSinkB(data, data);\r\n }\r\n}\r\n\r\nvoid My_char_connect_socket_vprintf_12()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_vprintf_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_vprintf_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-134:Use of Externally-Controlled Format String|D.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-705:Incorrect Control Flow Scoping\nB.No Vulnerabilities\nC.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nD.CWE-1127:Compilation with Insufficient Warnings or Errors\nE.CWE-397:Declaration of Throws for Generic Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std; \r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_throw_exception_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n throw exception();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_throw_exception_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-397:Declaration of Throws for Generic Exception|A.CWE-705:Incorrect Control Flow Scoping", "cwe": "397"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nC.No Vulnerabilities\nD.CWE-771:Missing Reference to Active Allocated Resource\nE.CWE-759:Use of a One-Way Hash without a Salt\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint rodie_mall = 0;\r\n\r\nstruct aerologists_budgereegah \r\n{\r\n char *jori_piggins;\r\n double hypoparia_theologal;\r\n char *stahlhelm_inspections;\r\n char unsucculently_sororate;\r\n int valera_aleichem;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *uncareful_migrate);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid nonelaborate_semmit(struct aerologists_budgereegah brief_unhit);\r\nvoid cleanup(char **ptrs,int size)\r\n{\r\n int i = 0;\r\n \r\n for (; i < size; ++i) {\r\n if (ptrs[i] != 0) {\r\n free(ptrs[i]);\r\n }\r\n }\r\n}\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\nchar *isAlphaNum(char *str,int size_param)\r\n{\r\n int index = 0;\r\n \r\n for (index = 0; index < size_param; index++) {\r\n if (!isalnum(str[index])) {\r\n \r\n\r\n return 0;\r\n }\r\n }\r\n return str;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&rodie_mall,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *uncareful_migrate)\r\n{\r\n struct aerologists_budgereegah sulpician_shufflers = {0};\r\n long impatiens_lustrical[10];\r\n struct aerologists_budgereegah shippens_orotinan[10] = {0};\r\n struct aerologists_budgereegah taliacotian_hypertoxic;\r\n ++global_variable;;\r\n if (uncareful_migrate != 0) {;\r\n taliacotian_hypertoxic . jori_piggins = ((char *)uncareful_migrate);\r\n shippens_orotinan[5] = taliacotian_hypertoxic;\r\n impatiens_lustrical[1] = 5;\r\n sulpician_shufflers = *(shippens_orotinan + impatiens_lustrical[1]);\r\n nonelaborate_semmit(sulpician_shufflers);\r\n }\r\n}\r\n\r\nvoid nonelaborate_semmit(struct aerologists_budgereegah brief_unhit)\r\n{\r\n char *contents;\r\n char filename[80];\r\n FILE *file;\r\n FILE **file_list;\r\n FILE *files;\r\n int str_list_index;\r\n char **str_list;\r\n int num_files = 10;\r\n int size;\r\n int ssi = 0;\r\n char *seamlessly_uniangulate = 0;\r\n ++global_variable;;\r\n seamlessly_uniangulate = ((char *)brief_unhit . jori_piggins);\r\n \r\n str_list = malloc(sizeof(char *) * num_files);\r\n if (str_list != 0) {\r\n for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\r\n str_list[str_list_index] = 0;\r\n files = fopen(seamlessly_uniangulate,\"rb\");\r\n if (files != 0) {\r\n file_list = malloc(num_files * sizeof(FILE *));\r\n if (file_list == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (ssi = 0; ssi < num_files; ++ssi) {\r\n if (fscanf(files,\"%79s\",filename) == 1) {\r\n file_list[ssi] = fopen(filename,\"rb\");\r\n }\r\n }\r\n ssi = 0;\r\n while(ssi < num_files){\r\n file = file_list[ssi];\r\n if (file == 0) {\r\n ++ssi;\r\n continue;\r\n }\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n contents = malloc((size + 1) * sizeof(char ));\r\n \r\n \r\n if (contents == 0 && errno == 12) {\r\n \r\n printf(\"Malloc error due to ulimit\\n\");\r\n }\r\n if (contents == 0) {\r\n fclose(file);\r\n break;\r\n }\r\n \r\n memset(contents,0,(size + 1) * sizeof(char ));\r\n fread(contents,1,size,file);\r\n \r\n contents = isAlphaNum(contents,size);\r\n \r\n str_list[ssi] = contents;\r\n fclose(file);\r\n ssi++;\r\n }\r\n fclose(files);\r\n if (file_list != 0) {\r\n free(file_list);\r\n }\r\n }\r\n cleanup(str_list,num_files);\r\n free(str_list);\r\n }\r\n \r\n;\r\n if (brief_unhit . jori_piggins != 0) \r\n free(((char *)brief_unhit . jori_piggins));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-771:Missing Reference to Active Allocated Resource|A.CWE-400:Uncontrolled Resource Consumption", "cwe": "771"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-284:Improper Access Control\nC.CWE-1301:Insufficient or Incomplete Data Removal within Hardware Component\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-273:Improper Check for Dropped Privileges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <rpcdce.h>\r\n# pragma comment(lib, \"rpcrt4\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RpcImpersonateClient_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n RpcImpersonateClient(0);\r\n \r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\nvoid My_w32_RpcImpersonateClient_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RpcImpersonateClient_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RpcImpersonateClient_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-273:Improper Check for Dropped Privileges|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nC.CWE-257:Storing Passwords in a Recoverable Format\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.CWE-36:Absolute Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_environment_ofstream_45\r\n{\r\n\r\nstatic char * mData;\r\nstatic char * nG2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n char * data = mData;\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n mData = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n char * data = nG2BData;\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n nG2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_ofstream_45; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-36:Absolute Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-253:Incorrect Check of Function Return Value\nC.CWE-1255:Comparison Logic is Vulnerable to Power Side-Channel Attacks\nD.No Vulnerabilities\nE.CWE-414:Missing Lock Check\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fputc_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n if (fputc((int)'A', stdout) == 0)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n if (fputc((int)'A', stdout) == EOF)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n if (fputc((int)'A', stdout) == EOF)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_fputc_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fputc_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fputc_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-253:Incorrect Check of Function Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-620:Unverified Password Change\nB.CWE-1390:Weak Authentication\nC.CWE-64:Windows Shortcut Following (.LNK)\nD.No Vulnerabilities\nE.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <lm.h>\r\n#pragma comment(lib, \"netapi32.lib\")\r\n#define USERNAME L\"cwe620testuser\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t newPassword[256];\r\n USER_INFO_1003 myUserInfo;\r\n NET_API_STATUS status;\r\n myUserInfo.usri1003_password = newPassword;\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", myUserInfo.usri1003_password) != 1)\r\n {\r\n myUserInfo.usri1003_password[0] = L'\\0';\r\n }\r\n \r\n status = NetUserSetInfo(NULL, USERNAME, 1003, (LPBYTE)&myUserInfo, NULL);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserSetInfo failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t oldPassword[256];\r\n wchar_t newPassword[256];\r\n NET_API_STATUS status;\r\n printWLine(L\"Enter old password: \");\r\n if (fwscanf(stdin, L\"%255s\", oldPassword) != 1)\r\n {\r\n oldPassword[0] = L'\\0';\r\n }\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", newPassword) != 1)\r\n {\r\n newPassword[0] = L'\\0';\r\n }\r\n \r\n status = NetUserChangePassword(NULL, USERNAME, oldPassword, newPassword);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserChangePassword failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t oldPassword[256];\r\n wchar_t newPassword[256];\r\n NET_API_STATUS status;\r\n printWLine(L\"Enter old password: \");\r\n if (fwscanf(stdin, L\"%255s\", oldPassword) != 1)\r\n {\r\n oldPassword[0] = L'\\0';\r\n }\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", newPassword) != 1)\r\n {\r\n newPassword[0] = L'\\0';\r\n }\r\n \r\n status = NetUserChangePassword(NULL, USERNAME, oldPassword, newPassword);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserChangePassword failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-620:Unverified Password Change|B.CWE-1390:Weak Authentication", "cwe": "620"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-272:Least Privilege Violation\nC.CWE-353:Missing Support for Integrity Check\nD.CWE-1055:Multiple Inheritance from Concrete Classes\nE.CWE-271:Privilege Dropping / Lowering Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_01()\r\n{\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegOpenUSKey_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegOpenUSKey_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|E.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nB.CWE-1250:Improper Preservation of Consistency Between Independent Representations of Shared State\nC.No Vulnerabilities\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\nnamespace My_w32_wchar_t_listen_socket_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_listen_socket_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-447:Unimplemented or Unsupported Feature in UI\nB.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nC.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\nD.No Vulnerabilities\nE.CWE-691:Insufficient Control Flow Management\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n\r\n#pragma comment(lib, \"shlwapi\")\r\n\r\n#define M_PATH_SIZE (MAX_PATH / 2) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char path[M_PATH_SIZE];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(M_PATH_SIZE, path);\r\n if (length == 0 || length >= M_PATH_SIZE) \r\n {\r\n exit(1);\r\n }\r\n \r\n \r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printSizeTLine(strlen(path));\r\n printIntLine(M_PATH_SIZE);\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|B.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cwe": "785"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-287:Improper Authentication\nB.CWE-1385:Missing Origin Validation in WebSockets\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-476:NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_class_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, TwoIntsClass *> dataMap);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n map<int, TwoIntsClass *> dataMap;\r\n \r\n data = NULL;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, TwoIntsClass *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n map<int, TwoIntsClass *> dataMap;\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intOne = 0;\r\n \r\n data = tmpData;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, TwoIntsClass *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n map<int, TwoIntsClass *> dataMap;\r\n \r\n data = NULL;\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-476:NULL Pointer Dereference|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1083:Data Access from Outside Expected Data Manager Component\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.No Vulnerabilities\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.CWE-605:Multiple Binds to the Same Port\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_open_66bSink(int dataArray[]);\r\n\r\nvoid My_open_66()\r\n{\r\n int data;\r\n int dataArray[5];\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n dataArray[2] = data;\r\n My_open_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_open_66bB2GSink(int dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n int dataArray[5];\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n dataArray[2] = data;\r\n My_open_66bB2GSink(dataArray);\r\n}\r\n\r\nvoid My_open_66()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-1248:Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\nC.No Vulnerabilities\nD.CWE-415:Double Free\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_class_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_delete_class_84\r\n{\r\npublic:\r\n My_new_delete_class_84(TwoIntsClass * dataCopy);\r\n ~My_new_delete_class_84();\r\n\r\nprivate:\r\n TwoIntsClass * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_delete_class_84G2B\r\n{\r\npublic:\r\n My_new_delete_class_84G2B(TwoIntsClass * dataCopy);\r\n ~My_new_delete_class_84G2B();\r\n\r\nprivate:\r\n TwoIntsClass * data;\r\n};\r\n\r\nclass My_new_delete_class_84B2G\r\n{\r\npublic:\r\n My_new_delete_class_84B2G(TwoIntsClass * dataCopy);\r\n ~My_new_delete_class_84B2G();\r\n\r\nprivate:\r\n TwoIntsClass * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nC.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nD.CWE-142:Improper Neutralization of Value Delimiters\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_short_53bSink(void * data);\r\n\r\nvoid My_short_53()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n My_short_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_short_53bG2BSink(void * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n My_short_53bG2BSink(data);\r\n}\r\n\r\nvoid My_short_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.No Vulnerabilities\nD.CWE-1323:Improper Management of Sensitive Trace Data\nE.CWE-1066:Missing Serialization Control Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_wchar_t_listen_socket_open_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_listen_socket_open_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-36:Absolute Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1290:Incorrect Decoding of Security Identifiers \nB.CWE-127:Buffer Under-read\nC.CWE-1080:Source Code File with Excessive Number of Lines of Code\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef union\r\n{\r\n int unionFirst;\r\n int unionSecond;\r\n} My_My_My_My_My_My_My_My_CWE839_fscanf_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-680:Integer Overflow to Buffer Overflow\nB.CWE-536:Servlet Runtime Error Message Containing Sensitive Information\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-567:Unsynchronized Access to Shared Data in a Multithreaded Context\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_rand_03()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5==5)\r\n {\r\n \r\n data = RAND32();\r\n }\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(5==5)\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t i;\r\n int *intPointer;\r\n \r\n intPointer = (int*)malloc(data * sizeof(int));\r\n if (intPointer == NULL) {exit(-1);}\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n free(intPointer);\r\n }\r\n}\r\n\r\nvoid My_malloc_rand_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_rand_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_rand_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1267:Policy Uses Obsolete Encoding\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-1045:Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor\nD.CWE-682:Incorrect Calculation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unsigned_int_rand_postinc_09()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = (unsigned int)RAND32();\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n data++;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = (unsigned int)RAND32();\r\n }\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data < UINT_MAX)\r\n {\r\n data++;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = (unsigned int)RAND32();\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (data < UINT_MAX)\r\n {\r\n data++;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 2;\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n data++;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = 2;\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n data++;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_unsigned_int_rand_postinc_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unsigned_int_rand_postinc_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unsigned_int_rand_postinc_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-190:Integer Overflow or Wraparound|D.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.No Vulnerabilities\nC.CWE-599:Missing Validation of OpenSSL Certificate\nD.CWE-680:Integer Overflow to Buffer Overflow\nE.CWE-385:Covert Timing Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_fgets_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_fgets_83\r\n{\r\npublic:\r\n My_new_fgets_83(int dataCopy);\r\n ~My_new_fgets_83();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_fgets_83G2B\r\n{\r\npublic:\r\n My_new_fgets_83G2B(int dataCopy);\r\n ~My_new_fgets_83G2B();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-680:Integer Overflow to Buffer Overflow|A.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1093:Excessively Complex Data Representation\nB.CWE-131:Incorrect Calculation of Buffer Size\nC.CWE-755:Improper Handling of Exceptional Conditions\nD.CWE-467:Use of sizeof() on a Pointer Type\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n short * mShort = NULL;\r\n \r\n mShort = (short *)malloc(sizeof(mShort));\r\n if (mShort == NULL) {exit(-1);}\r\n *mShort = 5;\r\n printShortLine(*mShort);\r\n free(mShort);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n short * nShort = NULL;\r\n \r\n nShort = (short *)malloc(sizeof(*nShort));\r\n if (nShort == NULL) {exit(-1);}\r\n *nShort = 6;\r\n printShortLine(*nShort);\r\n free(nShort);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_short_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-467:Use of sizeof() on a Pointer Type|B.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.No Vulnerabilities\nC.CWE-588:Attempt to Access Child of a Non-structure Pointer\nD.CWE-682:Incorrect Calculation\nE.CWE-628:Function Call with Incorrectly Specified Arguments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_fscanf_multiply_54bSink(int data);\r\n\r\nvoid My_int_fscanf_multiply_54()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n My_int_fscanf_multiply_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_fscanf_multiply_54bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n My_int_fscanf_multiply_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_int_fscanf_multiply_54bB2GSink(int data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n My_int_fscanf_multiply_54bB2GSink(data);\r\n}\r\n\r\nvoid My_int_fscanf_multiply_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fscanf_multiply_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fscanf_multiply_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-190:Integer Overflow or Wraparound|D.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-732:Incorrect Permission Assignment for Critical Resource\nB.CWE-466:Return of Pointer Value Outside of Expected Range\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_char_new_use_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char * pointer = new char;\r\n char data = *pointer; \r\n delete pointer;\r\n printHexCharLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char data;\r\n data = 5;\r\n char * pointer = new char;\r\n *pointer = data; \r\n {\r\n char data = *pointer;\r\n printHexCharLine(data);\r\n }\r\n delete pointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_new_use_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1209:Failure to Disable Reserved Bits\nB.CWE-687:Function Call With Incorrectly Specified Argument Value\nC.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable\nD.CWE-312:Cleartext Storage of Sensitive Information\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n printLine(getenv(\"PATH\"));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\nvoid My_basic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable|D.CWE-312:Cleartext Storage of Sensitive Information", "cwe": "526"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-476:NULL Pointer Dereference\nD.CWE-266:Incorrect Privilege Assignment\nE.CWE-290:Authentication Bypass by Spoofing\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(twoIntsStruct * data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n }\r\n}\r\n\r\nvoid My_struct_21()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(twoIntsStruct * data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(data->intOne);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(twoIntsStruct * data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(data->intOne);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(twoIntsStruct * data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct tmpData;\r\n \r\n {\r\n tmpData.intOne = 0;\r\n tmpData.intTwo = 0;\r\n data = &tmpData;\r\n }\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_struct_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-1288:Improper Validation of Consistency within Input\nC.CWE-617:Reachable Assertion\nD.No Vulnerabilities\nE.CWE-410:Insufficient Resource Pool\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fscanf_06()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fscanf_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-617:Reachable Assertion|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.No Vulnerabilities\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-154:Improper Neutralization of Variable Name Delimiters\nE.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\n", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint monmouthite_farms = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid weirds_pastophor(void **esculapian_negritized);\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n#define LAWRIGHTMAN_SLAMMAKIN(x) weirds_pastophor((void **) x)\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n void **sonnetic_trussery = 0;\r\n void **clingers_athanasian = 0;\r\n void *remantle_plinthiform = 0;\r\n int revince_barby = 125;\r\n char *amins_westlandways;\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&monmouthite_farms,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&amins_westlandways,\"7154\",revince_barby);\r\n if (amins_westlandways != 0) {;\r\n remantle_plinthiform = ((void *)amins_westlandways);\r\n sonnetic_trussery = &remantle_plinthiform;\r\n clingers_athanasian = sonnetic_trussery + 5;\r\n\tLAWRIGHTMAN_SLAMMAKIN(clingers_athanasian);\r\n }\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid weirds_pastophor(void **esculapian_negritized)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *shotten_corrugant = 0;\r\n ++global_variable;;\r\n shotten_corrugant = ((char *)((char *)( *(esculapian_negritized - 5))));\r\n \r\n \r\n\r\n if (strlen(shotten_corrugant) < 63) {\r\n skip_malloc_buffer = malloc(strlen(shotten_corrugant + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,shotten_corrugant);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if (((char *)( *(esculapian_negritized - 5))) != 0) \r\n free(((char *)((char *)( *(esculapian_negritized - 5)))));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-920:Improper Restriction of Power Consumption\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-178:Improper Handling of Case Sensitivity\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#include <process.h>\r\n#define EXECVP _wexecvp\r\n\r\nstatic wchar_t * My_wchar_t_console_w32_execvp_45Data;\r\nstatic wchar_t * My_wchar_t_console_w32_execvp_45G2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n wchar_t * data = My_wchar_t_console_w32_execvp_45Data;\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_console_w32_execvp_45()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n My_wchar_t_console_w32_execvp_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n wchar_t * data = My_wchar_t_console_w32_execvp_45G2BData;\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n EXECVP(COMMAND_INT, args);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"*.*\");\r\n My_wchar_t_console_w32_execvp_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid My_wchar_t_console_w32_execvp_45()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_console_w32_execvp_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_console_w32_execvp_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-831:Signal Handler Function Associated with Multiple Signals\nB.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nC.No Vulnerabilities\nD.CWE-459:Incomplete Cleanup\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-266:Incorrect Privilege Assignment\nC.No Vulnerabilities\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_w32CloseHandle_14()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(globalFive==5)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(globalFive==5)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_w32CloseHandle_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32CloseHandle_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32CloseHandle_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-271:Privilege Dropping / Lowering Errors\nC.CWE-444:Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\nD.CWE-644:Improper Neutralization of HTTP Headers for Scripting Syntax\nE.CWE-272:Least Privilege Violation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegOpenUSKey_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegOpenUSKey_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-272:Least Privilege Violation|B.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-655:Insufficient Psychological Acceptability\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_delete_array_int64_t_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int64_t *> dataVector);\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n vector<int64_t *> dataVector;\r\n \r\n data = NULL;\r\n \r\n data = new int64_t;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<int64_t *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n vector<int64_t *> dataVector;\r\n \r\n data = NULL;\r\n \r\n data = new int64_t[100];\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<int64_t *> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n vector<int64_t *> dataVector;\r\n \r\n data = NULL;\r\n \r\n data = new int64_t;\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_int64_t_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nC.CWE-146:Improper Neutralization of Expression/Command Delimiters\nD.CWE-409:Improper Handling of Highly Compressed Data (Data Amplification)\nE.CWE-794:Incomplete Filtering of Multiple Instances of Special Elements\n", "input": "isdn_net_stat_callback(int idx, isdn_ctrl *c)\r\r\n{\r\r\n\tisdn_net_dev *p = dev->st_netdev[idx];\r\r\n\tint cmd = c->command;\r\r\n\r\r\n\tif (p) {\r\r\n\t\tisdn_net_local *lp = p->local;\r\r\n#ifdef CONFIG_ISDN_X25\r\r\n\t\tstruct concap_proto *cprot = lp->netdev->cprot;\r\r\n\t\tstruct concap_proto_ops *pops = cprot ? cprot->pops : NULL;\r\r\n#endif\r\r\n\t\tswitch (cmd) {\r\r\n\t\t\tcase ISDN_STAT_BSENT:\r\r\n\t\t\t\t/* A packet has successfully been sent out */\r\r\n\t\t\t\tif ((lp->flags & ISDN_NET_CONNECTED) &&\r\r\n\t\t\t\t (!lp->dialstate)) {\r\r\n\t\t\t\t\tisdn_net_dec_frame_cnt(lp);\r\r\n\t\t\t\t\tlp->stats.tx_packets++;\r\r\n\t\t\t\t\tlp->stats.tx_bytes += c->parm.length;\r\r\n\t\t\t\t}\r\r\n\t\t\t\treturn 1;\r\r\n\t\t\tcase ISDN_STAT_DCONN:\r\r\n\t\t\t\t/* D-Channel is up */\r\r\n\t\t\t\tswitch (lp->dialstate) {\r\r\n\t\t\t\t\tcase 4:\r\r\n\t\t\t\t\tcase 7:\r\r\n\t\t\t\t\tcase 8:\r\r\n\t\t\t\t\t\tlp->dialstate++;\r\r\n\t\t\t\t\t\treturn 1;\r\r\n\t\t\t\t\tcase 12:\r\r\n\t\t\t\t\t\tlp->dialstate = 5;\r\r\n\t\t\t\t\t\treturn 1;\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase ISDN_STAT_DHUP:\r\r\n\t\t\t\t/* Either D-Channel-hangup or error during dialout */\r\r\n#ifdef CONFIG_ISDN_X25\r\r\n\t\t\t\t/* If we are not connencted then dialing had\r\r\n\t\t\t\t failed. If there are generic encap protocol\r\r\n\t\t\t\t receiver routines signal the closure of\r\r\n\t\t\t\t the link*/\r\r\n\r\r\n\t\t\t\tif( !(lp->flags & ISDN_NET_CONNECTED)\r\r\n\t\t\t\t && pops && pops -> disconn_ind )\r\r\n\t\t\t\t\tpops -> disconn_ind(cprot);\r\r\n#endif /* CONFIG_ISDN_X25 */\r\r\n\t\t\t\tif ((!lp->dialstate) && (lp->flags & ISDN_NET_CONNECTED)) {\r\r\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\r\r\n\t\t\t\t\t\tisdn_net_ciscohdlck_disconnected(lp);\r\r\n#ifdef CONFIG_ISDN_PPP\r\r\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\r\n\t\t\t\t\t\tisdn_ppp_free(lp);\r\r\n#endif\r\r\n\t\t\t\t\tisdn_net_lp_disconnected(lp);\r\r\n\t\t\t\t\tisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\r\r\n\t\t\t\t\tprintk(KERN_INFO \"%s: remote hangup\\n\", p->dev->name);\r\r\n\t\t\t\t\tprintk(KERN_INFO \"%s: Chargesum is %d\\n\", p->dev->name,\r\r\n\t\t\t\t\t lp->charge);\r\r\n\t\t\t\t\tisdn_net_unbind_channel(lp);\r\r\n\t\t\t\t\treturn 1;\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n#ifdef CONFIG_ISDN_X25\r\r\n\t\t\tcase ISDN_STAT_BHUP:\r\r\n\t\t\t\t/* B-Channel-hangup */\r\r\n\t\t\t\t/* try if there are generic encap protocol\r\r\n\t\t\t\t receiver routines and signal the closure of\r\r\n\t\t\t\t the link */\r\r\n\t\t\t\tif( pops && pops -> disconn_ind ){\r\r\n\t\t\t\t\t\tpops -> disconn_ind(cprot);\r\r\n\t\t\t\t\t\treturn 1;\r\r\n\t\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n#endif /* CONFIG_ISDN_X25 */\r\r\n\t\t\tcase ISDN_STAT_BCONN:\r\r\n\t\t\t\t/* B-Channel is up */\r\r\n\t\t\t\tisdn_net_zero_frame_cnt(lp);\r\r\n\t\t\t\tswitch (lp->dialstate) {\r\r\n\t\t\t\t\tcase 5:\r\r\n\t\t\t\t\tcase 6:\r\r\n\t\t\t\t\tcase 7:\r\r\n\t\t\t\t\tcase 8:\r\r\n\t\t\t\t\tcase 9:\r\r\n\t\t\t\t\tcase 10:\r\r\n\t\t\t\t\tcase 12:\r\r\n\t\t\t\t\t\tif (lp->dialstate <= 6) {\r\r\n\t\t\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_OUTGOING;\r\r\n\t\t\t\t\t\t\tisdn_info_update();\r\r\n\t\t\t\t\t\t} else\r\r\n\t\t\t\t\t\t\tdev->rx_netdev[idx] = p;\r\r\n\t\t\t\t\t\tlp->dialstate = 0;\r\r\n\t\t\t\t\t\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 1);\r\r\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\r\r\n\t\t\t\t\t\t\tisdn_net_ciscohdlck_connected(lp);\r\r\n\t\t\t\t\t\tif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP) {\r\r\n\t\t\t\t\t\t\tif (lp->master) { /* is lp a slave? */\r\r\n\t\t\t\t\t\t\t\tisdn_net_dev *nd = ISDN_MASTER_PRIV(lp)->netdev;\r\r\n\t\t\t\t\t\t\t\tisdn_net_add_to_bundle(nd, lp);\r\r\n\t\t\t\t\t\t\t}\r\r\n\t\t\t\t\t\t}\r\r\n\t\t\t\t\t\tprintk(KERN_INFO \"isdn_net: %s connected\\n\", p->dev->name);\r\r\n\t\t\t\t\t\t/* If first Chargeinfo comes before B-Channel connect,\r\r\n\t\t\t\t\t\t * we correct the timestamp here.\r\r\n\t\t\t\t\t\t */\r\r\n\t\t\t\t\t\tlp->chargetime = jiffies;\r\r\n\r\r\n\t\t\t\t\t\t/* reset dial-timeout */\r\r\n\t\t\t\t\t\tlp->dialstarted = 0;\r\r\n\t\t\t\t\t\tlp->dialwait_timer = 0;\r\r\n\r\r\n#ifdef CONFIG_ISDN_PPP\r\r\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\r\n\t\t\t\t\t\t\tisdn_ppp_wakeup_daemon(lp);\r\r\n#endif\r\r\n#ifdef CONFIG_ISDN_X25\r\r\n\t\t\t\t\t\t/* try if there are generic concap receiver routines */\r\r\n\t\t\t\t\t\tif( pops )\r\r\n\t\t\t\t\t\t\tif( pops->connect_ind)\r\r\n\t\t\t\t\t\t\t\tpops->connect_ind(cprot);\r\r\n#endif /* CONFIG_ISDN_X25 */\r\r\n\t\t\t\t\t\t/* ppp needs to do negotiations first */\r\r\n\t\t\t\t\t\tif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP)\r\r\n\t\t\t\t\t\t\tisdn_net_device_wake_queue(lp);\r\r\n\t\t\t\t\t\treturn 1;\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase ISDN_STAT_NODCH:\r\r\n\t\t\t\t/* No D-Channel avail. */\r\r\n\t\t\t\tif (lp->dialstate == 4) {\r\r\n\t\t\t\t\tlp->dialstate--;\r\r\n\t\t\t\t\treturn 1;\r\r\n\t\t\t\t}\r\r\n\t\t\t\tbreak;\r\r\n\t\t\tcase ISDN_STAT_CINF:\r\r\n\t\t\t\t/* Charge-info from TelCo. Calculate interval between\r\r\n\t\t\t\t * charge-infos and set timestamp for last info for\r\r\n\t\t\t\t * usage by isdn_net_autohup()\r\r\n\t\t\t\t */\r\r\n\t\t\t\tlp->charge++;\r\r\n\t\t\t\tif (lp->hupflags & ISDN_HAVECHARGE) {\r\r\n\t\t\t\t\tlp->hupflags &= ~ISDN_WAITCHARGE;\r\r\n\t\t\t\t\tlp->chargeint = jiffies - lp->chargetime - (2 * HZ);\r\r\n\t\t\t\t}\r\r\n\t\t\t\tif (lp->hupflags & ISDN_WAITCHARGE)\r\r\n\t\t\t\t\tlp->hupflags |= ISDN_HAVECHARGE;\r\r\n\t\t\t\tlp->chargetime = jiffies;\r\r\n\t\t\t\tprintk(KERN_DEBUG \"isdn_net: Got CINF chargetime of %s now %lu\\n\",\r\r\n\t\t\t\t p->dev->name, lp->chargetime);\r\r\n\t\t\t\treturn 1;\r\r\n\t\t}\r\r\n\t}\r\r\n\treturn 0;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.No Vulnerabilities|A.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nB.CWE-188:Reliance on Data/Memory Layout\nC.CWE-1086:Class with Excessive Number of Child Classes\nD.CWE-366:Race Condition within a Thread\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#define N_ITERS 1000000\r\n\r\nstatic int gMInt = 0;\r\nstatic int gNInt = 0;\r\nstatic stdThreadLock gNLock = NULL;\r\n\r\nstatic void helperM(void *args)\r\n{\r\n int i;\r\n \r\n \r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n gMInt = gMInt + 1;\r\n }\r\n}\r\n\r\nstatic void helperN(void *args)\r\n{\r\n int i;\r\n \r\n stdThreadLockAcquire(gNLock);\r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n gNInt = gNInt + 1;\r\n }\r\n stdThreadLockRelease(gNLock);\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_global_int_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n gMInt = 0;\r\n if (!stdThreadCreate(helperM, NULL, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperM, NULL, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n printIntLine(gMInt);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, NULL, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, NULL, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(gNInt);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, NULL, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, NULL, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(gNInt);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_global_int_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_global_int_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_global_int_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-366:Race Condition within a Thread|A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "366"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1236:Improper Neutralization of Formula Elements in a CSV File\nB.CWE-1078:Inappropriate Source Code Style or Formatting\nC.CWE-546:Suspicious Comment\nD.CWE-918:Server-Side Request Forgery (SSRF)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_LATER_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n \r\n printLine(\"Hello\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n printLine(\"Hello\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n printLine(\"Hello\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_LATER_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_LATER_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_LATER_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|B.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-833:Deadlock\nB.CWE-589:Call to Non-ubiquitous API\nC.CWE-581:Object Model Violation: Just One of Equals and Hashcode Defined\nD.CWE-667:Improper Locking\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint mesogloeal_lenthiel = 0;\r\nint global_variable;\r\nvoid handle_taint(char *haplomous_humpback);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_mutex_t mutex_0, mutex_1;\r\npthread_t t0, t1;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *replace (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *qsort_arr;\r\n int i = 0;\r\n \r\n \r\n printf(\"replace: entering function\\n\");\r\n \r\n qsort_arr = malloc(sizeof(int)*Data->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < Data->qsize; i++) {\r\n qsort_arr[i] = Data->qsize - i;\r\n }\r\n qsort(qsort_arr, Data->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(Data->file1);\r\n printf(\"replace: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n printf(\"replace: Grabbed lock 0\\n\");\r\n printf(\"replace: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1); \r\n printf(\"replace: Grabbed lock 1\\n\");\r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] == '_') {\r\n Data->data[i] = '-';\r\n }\r\n i++;\r\n }\r\n printf(\"replace: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n printf(\"replace: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n \r\n return NULL;\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n \r\n printf(\"toCap: Entering function\\n\");\r\n printf(\"toCap: Attempting to grab lock 1\\n\");\r\n pthread_mutex_lock(&mutex_1);\r\n printf(\"toCap: Grabbed lock 1\\n\");\r\n readFile(Data->file2);\r\n \r\n \r\n printf(\"toCap: Attempting to grab lock 0\\n\");\r\n pthread_mutex_lock(&mutex_0); \r\n printf(\"toCap: Grabbed lock 0\\n\");\r\n \r\n i = 0;\r\n while(Data->data[i] != '\\0') {\r\n if (Data->data[i] > 'a' && Data->data[i] < 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n i++;\r\n }\r\n printf(\"toCap: Releasing lock 0\\n\");\r\n pthread_mutex_unlock(&mutex_0);\r\n printf(\"toCap: Releasing lock 1\\n\");\r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&mesogloeal_lenthiel,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *haplomous_humpback)\r\n{\r\n int hasUnderscores = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *lumbye_linenfold = 0;\r\n char *thingamajig_bludge = 0;\r\n int *tzental_tortillions = 0;\r\n int osteodermatous_swingably;\r\n char *nunciative_cheribon[10] = {0};\r\n int analepses_aristophanes = 0;\r\n char *dressler_backjoint = 0;\r\n ++global_variable;;\r\n if (haplomous_humpback != 0) {;\r\n analepses_aristophanes = ((int )(strlen(haplomous_humpback)));\r\n dressler_backjoint = ((char *)(malloc(analepses_aristophanes + 1)));\r\n if (dressler_backjoint == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(dressler_backjoint,0,analepses_aristophanes + 1);\r\n memcpy(dressler_backjoint,haplomous_humpback,analepses_aristophanes);\r\n if (haplomous_humpback != 0) \r\n free(((char *)haplomous_humpback));\r\n nunciative_cheribon[5] = dressler_backjoint;\r\n osteodermatous_swingably = 5;\r\n tzental_tortillions = &osteodermatous_swingably;\r\n thingamajig_bludge = *(nunciative_cheribon + *tzental_tortillions);\r\n if (thingamajig_bludge != 0) {\r\n goto budgetful_putterer;\r\n }\r\n ++global_variable;\r\n budgetful_putterer:;\r\n lumbye_linenfold = ((char *)thingamajig_bludge);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(lumbye_linenfold) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(lumbye_linenfold) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(lumbye_linenfold) + 1));\r\n if (Data->data) {\r\n if ((sscanf(lumbye_linenfold, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n while(Data->data[i] != '\\0') { \r\n if (Data->data[i++] == '_') { \r\n hasUnderscores = 1;\r\n }\r\n }\r\n \r\n if (pthread_create(&t0, NULL, toCap, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (hasUnderscores == 1) {\r\n \r\n if (pthread_create(&t1, NULL, replace, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n }\r\n pthread_join(t0, NULL);\r\n if (hasUnderscores == 1) {\r\n pthread_join(t1, NULL);\r\n }\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (thingamajig_bludge != 0) \r\n free(((char *)thingamajig_bludge));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-833:Deadlock|D.CWE-667:Improper Locking", "cwe": "833"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1125:Excessive Attack Surface\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-127:Buffer Under-read\nE.CWE-1319:Improper Protection against Electromagnetic Fault Injection (EM-FI)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_cpy_61\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nwchar_t * mSource(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n data = mSource(data);\r\n {\r\n wchar_t dest[100*2];\r\n wmemset(dest, L'C', 100*2-1); \r\n dest[100*2-1] = L'\\0'; \r\n \r\n wcscpy(dest, data);\r\n printWLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nwchar_t * nG2BSource(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n data = nG2BSource(data);\r\n {\r\n wchar_t dest[100*2];\r\n wmemset(dest, L'C', 100*2-1); \r\n dest[100*2-1] = L'\\0'; \r\n \r\n wcscpy(dest, data);\r\n printWLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_cpy_61; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-506:Embedded Malicious Code\nC.CWE-1251:Mirrored Regions with Different Values\nD.CWE-510:Trapdoor\nE.CWE-698:Execution After Redirect (EAR)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <ws2tcpip.h>\r\n#else\r\n#include <netdb.h>\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_hostname_based_logic_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char hostname[NI_MAXHOST];\r\n char servInfo[NI_MAXSERV];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n if (getnameinfo((struct sockaddr *)&acceptService,\r\n sizeof(struct sockaddr),\r\n hostname,\r\n NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"admin.google.com\", hostname) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_hostname_based_logic_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_hostname_based_logic_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_hostname_based_logic_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|B.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-792:Incomplete Filtering of One or More Instances of Special Elements\nC.CWE-325:Missing Cryptographic Step\nD.No Vulnerabilities\nE.CWE-703:Improper Check or Handling of Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptEncrypt_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptEncrypt_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptEncrypt_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptEncrypt_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-325:Missing Cryptographic Step|A.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-611:Improper Restriction of XML External Entity Reference\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-476:NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_66\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(TwoIntsClass * dataArray[]);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n \r\n dataArray[2] = data;\r\n mSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(TwoIntsClass * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intOne = 0;\r\n \r\n data = tmpData;\r\n }\r\n dataArray[2] = data;\r\n nG2BSink(dataArray);\r\n}\r\n\r\n\r\nvoid nB2GSink(TwoIntsClass * dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n dataArray[2] = data;\r\n nB2GSink(dataArray);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_66; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-476:NULL Pointer Dereference|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-799:Improper Control of Interaction Frequency\nB.CWE-126:Buffer Over-read\nC.CWE-788:Access of Memory Location After End of Buffer\nD.No Vulnerabilities\nE.CWE-293:Using Referer Field for Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_declare_loop_52bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_declare_loop_52()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataMBuffer;\r\n My_wchar_t_declare_loop_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_declare_loop_52bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataNBuffer;\r\n My_wchar_t_declare_loop_52bG2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_declare_loop_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_declare_loop_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_declare_loop_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nD.CWE-366:Race Condition within a Thread\nE.CWE-421:Race Condition During Access to Alternate Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#define N_ITERS 1000000\r\n\r\nstatic stdThreadLock gNLock = NULL;\r\n\r\nstatic void helperM(void *args)\r\n{\r\n int *pIntArgs = (int*)args;\r\n int i;\r\n \r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n *pIntArgs = *pIntArgs + 1;\r\n }\r\n}\r\n\r\nstatic void helperN(void *args)\r\n{\r\n int *pIntArgs = (int *)args;\r\n int i;\r\n \r\n stdThreadLockAcquire(gNLock);\r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n *pIntArgs = *pIntArgs + 1;\r\n }\r\n stdThreadLockRelease(gNLock);\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_byref_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valMSink;\r\n valMSink = 0;\r\n if (!stdThreadCreate(helperM, (void*)&valMSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperM, (void*)&valMSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n printIntLine(valMSink);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valNSink;\r\n valNSink = 0;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(valNSink);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valNSink;\r\n valNSink = 0;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(valNSink);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_byref_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_byref_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_byref_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-366:Race Condition within a Thread|C.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "366"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-400:Uncontrolled Resource Consumption\nC.CWE-511:Logic/Time Bomb\nD.No Vulnerabilities\nE.CWE-598:Use of GET Request Method With Sensitive Query Strings\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define COUNT_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_counter_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_counter_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_counter_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_counter_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|A.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-383:J2EE Bad Practices: Direct Use of Threads\nB.No Vulnerabilities\nC.CWE-1320:Improper Protection for Outbound Error Messages and Alert Signals\nD.CWE-330:Use of Insufficiently Random Values\nE.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|D.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-1100:Insufficient Isolation of System-Dependent Functions\nD.CWE-179:Incorrect Behavior Order: Early Validation\nE.CWE-770:Allocation of Resources Without Limits or Throttling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(size_t data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_fgets_21()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(size_t data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(size_t data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(size_t data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_malloc_wchar_t_fgets_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_fgets_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_fgets_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|E.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1257:Improper Access Control Applied to Mirrored or Aliased Memory Regions\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-400:Uncontrolled Resource Consumption\nE.CWE-1230:Exposure of Sensitive Information Through Metadata\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_connect_socket_sleep_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_connect_socket_sleep_83\r\n{\r\npublic:\r\n My_connect_socket_sleep_83(int countCopy);\r\n ~My_connect_socket_sleep_83();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_connect_socket_sleep_83G2B\r\n{\r\npublic:\r\n My_connect_socket_sleep_83G2B(int countCopy);\r\n ~My_connect_socket_sleep_83G2B();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\nclass My_connect_socket_sleep_83B2G\r\n{\r\npublic:\r\n My_connect_socket_sleep_83B2G(int countCopy);\r\n ~My_connect_socket_sleep_83B2G();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-400:Uncontrolled Resource Consumption|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-624:Executable Regular Expression Error\nB.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nC.No Vulnerabilities\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-391:Unchecked Error Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_strtol_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_strtol_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strtol_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strtol_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-391:Unchecked Error Condition|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-759:Use of a One-Way Hash without a Salt\nE.CWE-358:Improperly Implemented Security Check for Standard\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_int_placement_new_82\r\n{\r\n\r\nclass My_delete_int_placement_new_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(int * data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_delete_int_placement_new_82 : public My_delete_int_placement_new_82_base\r\n{\r\npublic:\r\n void action(int * data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_delete_int_placement_new_82G2B : public My_delete_int_placement_new_82_base\r\n{\r\npublic:\r\n void action(int * data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-198:Use of Incorrect Byte Ordering\nC.CWE-95:Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nD.No Vulnerabilities\nE.CWE-348:Use of Less Trusted Source\n", "input": "bool WebContentsImpl::OnMessageReceived(RenderViewHost* render_view_host,\r\r\n RenderFrameHost* render_frame_host,\r\r\n const IPC::Message& message) {\r\r\n DCHECK(render_view_host || render_frame_host);\r\r\n if (GetWebUI() &&\r\r\n static_cast<WebUIImpl*>(GetWebUI())->OnMessageReceived(message)) {\r\r\n return true;\r\r\n }\r\r\n\r\r\n ObserverListBase<WebContentsObserver>::Iterator it(observers_);\r\r\n WebContentsObserver* observer;\r\r\n while ((observer = it.GetNext()) != NULL)\r\r\n if (observer->OnMessageReceived(message))\r\r\n return true;\r\r\n\r\r\n render_view_message_source_ = render_view_host;\r\r\n bool handled = true;\r\r\n bool message_is_ok = true;\r\r\n IPC_BEGIN_MESSAGE_MAP_EX(WebContentsImpl, message, message_is_ok)\r\r\n IPC_MESSAGE_HANDLER(FrameHostMsg_PepperPluginHung, OnPepperPluginHung)\r\r\n IPC_MESSAGE_HANDLER(FrameHostMsg_PluginCrashed, OnPluginCrashed)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_DidLoadResourceFromMemoryCache,\r\r\n OnDidLoadResourceFromMemoryCache)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_DidDisplayInsecureContent,\r\r\n OnDidDisplayInsecureContent)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_DidRunInsecureContent,\r\r\n OnDidRunInsecureContent)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_DocumentLoadedInFrame,\r\r\n OnDocumentLoadedInFrame)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_DidFinishLoad, OnDidFinishLoad)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_DidFailLoadWithError,\r\r\n OnDidFailLoadWithError)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_GoToEntryAtOffset, OnGoToEntryAtOffset)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_UpdateZoomLimits, OnUpdateZoomLimits)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_EnumerateDirectory, OnEnumerateDirectory)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_JSOutOfMemory, OnJSOutOfMemory)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_RegisterProtocolHandler,\r\r\n OnRegisterProtocolHandler)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_Find_Reply, OnFindReply)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_AppCacheAccessed, OnAppCacheAccessed)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_OpenColorChooser, OnOpenColorChooser)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_EndColorChooser, OnEndColorChooser)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_SetSelectedColorInColorChooser,\r\r\n OnSetSelectedColorInColorChooser)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_WebUISend, OnWebUISend)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_RequestPpapiBrokerPermission,\r\r\n OnRequestPpapiBrokerPermission)\r\r\n IPC_MESSAGE_HANDLER_GENERIC(BrowserPluginHostMsg_AllocateInstanceID,\r\r\n OnBrowserPluginMessage(message))\r\r\n IPC_MESSAGE_HANDLER_GENERIC(BrowserPluginHostMsg_Attach,\r\r\n OnBrowserPluginMessage(message))\r\r\n IPC_MESSAGE_HANDLER(ImageHostMsg_DidDownloadImage, OnDidDownloadImage)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_UpdateFaviconURL, OnUpdateFaviconURL)\r\r\n#if defined(OS_ANDROID)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_FindMatchRects_Reply,\r\r\n OnFindMatchRectsReply)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_OpenDateTimeDialog,\r\r\n OnOpenDateTimeDialog)\r\r\n IPC_MESSAGE_HANDLER_DELAY_REPLY(JavaBridgeHostMsg_GetChannelHandle,\r\r\n OnJavaBridgeGetChannelHandle)\r\r\n#endif\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_MediaNotification, OnMediaNotification)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_DidFirstVisuallyNonEmptyPaint,\r\r\n OnFirstVisuallyNonEmptyPaint)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_ShowValidationMessage,\r\r\n OnShowValidationMessage)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_HideValidationMessage,\r\r\n OnHideValidationMessage)\r\r\n IPC_MESSAGE_HANDLER(ViewHostMsg_MoveValidationMessage,\r\r\n OnMoveValidationMessage)\r\r\n IPC_MESSAGE_UNHANDLED(handled = false)\r\r\n IPC_END_MESSAGE_MAP_EX()\r\r\n render_view_message_source_ = NULL;\r\r\n\r\r\n if (!message_is_ok) {\r\r\n RecordAction(base::UserMetricsAction(\"MMessageTerminate_RVD\"));\r\r\n GetRenderProcessHost()->ReceivedMMessage();\r\r\n }\r\r\n\r\r\n return handled;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.No Vulnerabilities|D.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-353:Missing Support for Integrity Check\nC.No Vulnerabilities\nD.CWE-510:Trapdoor\nE.CWE-1333:Inefficient Regular Expression Complexity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_connection_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(80);\r\n \r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_connection_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|A.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-1052:Excessive Use of Hard-Coded Literals in Initialization\nC.CWE-229:Improper Handling of Values\nD.No Vulnerabilities\nE.CWE-259:Use of Hard-coded Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_04()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n strcpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_04()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-259:Use of Hard-coded Password|A.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-511:Logic/Time Bomb\nB.CWE-506:Embedded Malicious Code\nC.No Vulnerabilities\nD.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\nE.CWE-317:Cleartext Storage of Sensitive Information in GUI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define COUNT_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_counter_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n}\r\n\r\nvoid My_counter_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_counter_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_counter_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-511:Logic/Time Bomb|B.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.CWE-563:Assignment to Variable without Use\nC.CWE-645:Overly Restrictive Account Lockout Mechanism\nD.CWE-1164:Irrelevant Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_value_long_10()\r\n{\r\n long data;\r\n if(globalTrue)\r\n {\r\n \r\n data = 5L;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n data = 10L;\r\n printLongLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n long data;\r\n if(globalTrue)\r\n {\r\n \r\n data = 5L;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLongLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n long data;\r\n if(globalTrue)\r\n {\r\n \r\n data = 5L;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n printLongLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n long data;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 5L;\r\n printLongLine(data);\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n data = 10L;\r\n printLongLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n long data;\r\n if(globalTrue)\r\n {\r\n \r\n data = 5L;\r\n printLongLine(data);\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n data = 10L;\r\n printLongLine(data);\r\n }\r\n}\r\n\r\nvoid My_unused_value_long_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_value_long_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_value_long_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-588:Attempt to Access Child of a Non-structure Pointer\nB.CWE-704:Incorrect Type Conversion or Cast\nC.No Vulnerabilities\nD.CWE-91:XML Injection (aka Blind XPath Injection)\nE.CWE-425:Direct Request ('Forced Browsing')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_struct_63bSink(void * * dataPtr);\r\n\r\nvoid My_struct_63()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n My_struct_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_struct_63bG2BSink(void * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n My_struct_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_struct_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-588:Attempt to Access Child of a Non-structure Pointer|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-382:J2EE Bad Practices: Use of System.exit()\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-344:Use of Invariant Value in Dynamically Changing Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wcstombs_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wcstombs_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wcstombs_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wcstombs_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-391:Unchecked Error Condition|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-94:Improper Control of Generation of Code ('Code Injection')\nB.No Vulnerabilities\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.CWE-272:Least Privilege Violation\nE.CWE-1112:Incomplete Documentation of Program Execution\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateProcess_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n \r\n if( !CreateProcessW(NULL,\r\n L\"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n 0,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcess failed\");\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcess successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n \r\n if( !CreateProcessW(NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n 0,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printf( \"CreateProcess failed (%d).\\n\", GetLastError() );\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcess successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateProcess_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateProcess_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateProcess_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-571:Expression is Always True\nD.No Vulnerabilities\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fscanf_memmove_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int &data);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int &data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fscanf_memmove_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-676:Use of Potentially Dangerous Function\nB.CWE-1280:Access Control Check Implemented After Asset is Accessed\nC.CWE-535:Exposure of Information Through Shell Error Message\nD.No Vulnerabilities\nE.CWE-211:Externally-Generated Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-535:Exposure of Information Through Shell Error Message|E.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-196:Unsigned to Signed Conversion Error\nC.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nD.No Vulnerabilities\nE.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint bumbard_elaeocarpus = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid exsufflation_programmers(int freedman_gefulltefish,char *impreventable_teacart);\r\nunsigned int get_size(char *ss_tainted)\r\n{\r\n \r\n unsigned long uns_int = 0UL;\r\n uns_int = strtoul(ss_tainted,0,0);\r\n if (uns_int > ((unsigned long )4294967295U) ||\r\n uns_int == 0)\r\n uns_int = 1U;\r\n return (unsigned int )uns_int;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int nonactionably_gratiano = 7;\r\n char *unvariableness_ipiutak = 0;\r\n long supergenual_reevaluate[10];\r\n char *schoolfellow_extemporally[10] = {0};\r\n int matless_inostensibly = 11;\r\n char *hanshaw_bellerophontic;;\r\n if (__sync_bool_compare_and_swap(&bumbard_elaeocarpus,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&hanshaw_bellerophontic,\"8728\",matless_inostensibly);\r\n if (hanshaw_bellerophontic != 0) {;\r\n schoolfellow_extemporally[5] = hanshaw_bellerophontic;\r\n supergenual_reevaluate[1] = 5;\r\n unvariableness_ipiutak = *(schoolfellow_extemporally + supergenual_reevaluate[1]);\r\n exsufflation_programmers(nonactionably_gratiano,unvariableness_ipiutak);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid exsufflation_programmers(int freedman_gefulltefish,char *impreventable_teacart)\r\n{\r\n char *other_buff = 0;\r\n int size = 0;\r\n int num = 0;\r\n char buff[200] = {0};\r\n int output_counter = 0;\r\n char *ozobrome_vaultage = 0;\r\n ++global_variable;\r\n freedman_gefulltefish--;\r\n if (freedman_gefulltefish > 0) {\r\n exsufflation_programmers(freedman_gefulltefish,impreventable_teacart);\r\n return ;\r\n }\r\n ozobrome_vaultage = ((char *)impreventable_teacart);\r\n \r\n if (strlen(ozobrome_vaultage) > 0 &&\r\n ozobrome_vaultage[0] == '-') {\r\n printf(\"Negative number given as input\\n\");\r\n } else {\r\n \r\n \r\n num = get_size(ozobrome_vaultage);\r\n other_buff = getenv(\"SS_BUFF\");\r\n \r\n \r\n \r\n if (other_buff != 0) {\r\n strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\r\n size = ((int )(strlen(buff)));\r\n \r\n \r\n while (num < size) {\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n if (num > 0)\r\n ++num;\r\n }\r\n \r\n } else {\r\n printf(\"Missing value for other_buff\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n }\r\n \r\n;\r\n if (impreventable_teacart != 0) \r\n free(((char *)impreventable_teacart));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-196:Unsigned to Signed Conversion Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "196"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\nB.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\nC.No Vulnerabilities\nD.CWE-284:Improper Access Control\nE.CWE-323:Reusing a Nonce, Key Pair in Encryption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n#define BUFSIZE 1024\r\n#define PIPE_NAME \"\\\\\\\\.\\\\pipe\\\\TestPipe\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateNamedPipe_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE | PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HANDLE hPipe;\r\n char * pipeName = PIPE_NAME;\r\n \r\n hPipe = CreateNamedPipeA(\r\n pipeName,\r\n FILE_FLAG_FIRST_PIPE_INSTANCE | PIPE_ACCESS_DUPLEX,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n 0,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"Windows pipe creation failed\");\r\n }\r\n else\r\n {\r\n printLine(\"Windows pipe created successfully\");\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateNamedPipe_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateNamedPipe_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateNamedPipe_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-284:Improper Access Control|B.CWE-118:Incorrect Access of Indexable Resource ('Range Error')", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-270:Privilege Context Switching Error\nB.CWE-364:Signal Handler Race Condition\nC.No Vulnerabilities\nD.CWE-535:Exposure of Information Through Shell Error Message\nE.CWE-211:Externally-Generated Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-535:Exposure of Information Through Shell Error Message|E.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-674:Uncontrolled Recursion\nB.CWE-834:Excessive Iteration\nC.CWE-1257:Improper Access Control Applied to Mirrored or Aliased Memory Regions\nD.CWE-467:Use of sizeof() on a Pointer Type\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <openssl/crypto.h>\r\n#include \"cryptlib.h\"\r\n#include <openssl/conf.h>\r\n#include <openssl/dso.h>\r\n#include <openssl/x509.h>\r\n#define DSO_mod_init_name \"OPENSSL_init\"\r\n#define DSO_mod_finish_name \"OPENSSL_finish\"\r\n\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n\r\nstruct conf_module_st \r\n{\r\n\r\n DSO *dso;\r\n\r\n char *name;\r\n\r\n conf_init_func *init;\r\n\r\n conf_finish_func *finish;\r\n\r\n int links;\r\n void *usr_data;\r\n}\r\n;\r\n\r\n\r\nstruct conf_imodule_st \r\n{\r\n CONF_MODULE *pmod;\r\n char *name;\r\n char *value;\r\n unsigned long flags;\r\n void *usr_data;\r\n}\r\n;\r\nstatic struct stack_st_CONF_MODULE *supported_modules = ((void *)0);\r\nstatic struct stack_st_CONF_IMODULE *initialized_modules = ((void *)0);\r\nstatic void module_free(CONF_MODULE *md);\r\nstatic void module_finish(CONF_IMODULE *imod);\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags);\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc);\r\nstatic CONF_MODULE *module_find(char *name);\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf);\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags);\r\n\r\nint lepry_bomarea = 0;\r\nint global_variable;\r\nvoid polytope_pyrrhuloxia(char **coenotypic_seminovelty);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid riccia_asgd(void (*diuresis_plainwell)(char **));\r\nint search(char *str_param,char c_param)\r\n{\r\n if ( *str_param == c_param) {\r\n return 1;\r\n } else if ( *str_param == 0) {\r\n \r\n \r\n return search(&str_param[0],c_param);\r\n } else {\r\n return search(&str_param[1],c_param);\r\n }\r\n}\r\n\r\nint CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)\r\n{\r\n struct stack_st_CONF_VALUE *values;\r\n CONF_VALUE *vl;\r\n char *vsection = ((void *)0);\r\n int ret;\r\n int i;\r\n if (!cnf) {\r\n return 1;\r\n }\r\n if (appname) {\r\n vsection = NCONF_get_string(cnf,((void *)0),appname);\r\n }\r\n if (!appname || !vsection && flags & 0x20) {\r\n vsection = NCONF_get_string(cnf,((void *)0),\"openssl_conf\");\r\n }\r\n if (!vsection) {\r\n ERR_clear_error();\r\n return 1;\r\n }\r\n values = NCONF_get_section(cnf,vsection);\r\n if (!values) {\r\n return 0;\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++) {\r\n vl = ((CONF_VALUE *)(sk_value(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0)))),i)));\r\n ret = module_run(cnf,vl -> name,vl -> value,flags);\r\n if (ret <= 0) {\r\n if (!(flags & 0x1)) {\r\n return ret;\r\n }\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nint CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)\r\n{\r\n char *file = ((void *)0);\r\n CONF *conf = ((void *)0);\r\n int ret = 0;\r\n conf = NCONF_new(((void *)0));\r\n if (!conf) {\r\n goto err;\r\n }\r\n if (filename == ((void *)0)) {\r\n file = CONF_get1_default_config_file();\r\n if (!file) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n file = ((char *)filename);\r\n }\r\n if (NCONF_load(conf,file,((void *)0)) <= 0) {\r\n if (flags & 0x10 && ((int )(ERR_peek_last_error() & 0xfffL)) == 114) {\r\n ERR_clear_error();\r\n ret = 1;\r\n }\r\n goto err;\r\n }\r\n ret = CONF_modules_load(conf,appname,flags);\r\n err:\r\n if (filename == ((void *)0)) {\r\n CRYPTO_free(file);\r\n }\r\n NCONF_free(conf);\r\n return ret;\r\n}\r\n\r\nstatic int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n CONF_MODULE *md;\r\n int ret;\r\n md = module_find(name);\r\n\r\n if (!md && !(flags & 0x8)) {\r\n md = module_load_dso(cnf,name,value,flags);\r\n }\r\n if (!md) {\r\n if (!(flags & 0x4)) {\r\n ERR_put_error(14,118,113,\"conf_mod.c\",222);\r\n ERR_add_error_data(2,\"module=\",name);\r\n }\r\n return - 1;\r\n }\r\n ret = module_init(md,name,value,cnf);\r\n if (ret <= 0) {\r\n if (!(flags & 0x4)) {\r\n char rcode[13UL];\r\n ERR_put_error(14,118,109,\"conf_mod.c\",235);\r\n BIO_snprintf(rcode,sizeof(rcode),\"%-8d\",ret);\r\n ERR_add_error_data(6,\"module=\",name,\", value=\",value,\", retcode=\",rcode);\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_load_dso(const CONF *cnf,char *name,char *value,unsigned long flags)\r\n{\r\n DSO *dso = ((void *)0);\r\n conf_init_func *ifunc;\r\n conf_finish_func *ffunc;\r\n char *path = ((void *)0);\r\n int errcode = 0;\r\n CONF_MODULE *md;\r\n\r\n path = NCONF_get_string(cnf,value,\"path\");\r\n if (!path) {\r\n ERR_clear_error();\r\n path = name;\r\n }\r\n dso = DSO_load(((void *)0),path,((void *)0),0);\r\n if (!dso) {\r\n errcode = 110;\r\n goto err;\r\n }\r\n ifunc = ((conf_init_func *)(DSO_bind_func(dso,\"OPENSSL_init\")));\r\n if (!ifunc) {\r\n errcode = 112;\r\n goto err;\r\n }\r\n ffunc = ((conf_finish_func *)(DSO_bind_func(dso,\"OPENSSL_finish\")));\r\n\r\n md = module_add(dso,name,ifunc,ffunc);\r\n if (!md) {\r\n goto err;\r\n }\r\n return md;\r\n err:\r\n if (dso) {\r\n DSO_free(dso);\r\n }\r\n ERR_put_error(14,117,errcode,\"conf_mod.c\",285);\r\n ERR_add_error_data(4,\"module=\",name,\", path=\",path);\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_add(DSO *dso,const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n CONF_MODULE *tmod = ((void *)0);\r\n if (supported_modules == ((void *)0)) {\r\n supported_modules = ((struct stack_st_CONF_MODULE *)(sk_new_null()));\r\n }\r\n if (supported_modules == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod = (CRYPTO_malloc(((int )(sizeof(CONF_MODULE ))),\"conf_mod.c\",299));\r\n if (tmod == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n tmod -> dso = dso;\r\n tmod -> name = BUF_strdup(name);\r\n tmod -> init = ifunc;\r\n tmod -> finish = ffunc;\r\n tmod -> links = 0;\r\n if (!sk_push(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),((void *)((1?tmod : ((CONF_MODULE *)0)))))) {\r\n CRYPTO_free(tmod);\r\n return ((void *)0);\r\n }\r\n return tmod;\r\n}\r\n\r\n\r\nstatic CONF_MODULE *module_find(char *name)\r\n{\r\n CONF_MODULE *tmod;\r\n int i;\r\n int nchar;\r\n char *p;\r\n p = strrchr(name,'.');\r\n if (p) {\r\n nchar = (p - name);\r\n }\r\n else {\r\n nchar = (strlen(name));\r\n }\r\n for (i = 0; i < sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))); i++) {\r\n tmod = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n if (!strncmp((tmod -> name),name,nchar)) {\r\n return tmod;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n\r\n\r\nstatic int module_init(CONF_MODULE *pmod,char *name,char *value,const CONF *cnf)\r\n{\r\n int ret = 1;\r\n int init_called = 0;\r\n CONF_IMODULE *imod = ((void *)0);\r\n\r\n imod = (CRYPTO_malloc(((int )(sizeof(CONF_IMODULE ))),\"conf_mod.c\",355));\r\n if (!imod) {\r\n goto err;\r\n }\r\n imod -> pmod = pmod;\r\n imod -> name = BUF_strdup(name);\r\n imod -> value = BUF_strdup(value);\r\n imod -> usr_data = ((void *)0);\r\n if (!imod -> name || !imod -> value) {\r\n goto memerr;\r\n }\r\n\r\n if (pmod -> init) {\r\n ret = ((pmod -> init)(imod,cnf));\r\n init_called = 1;\r\n\r\n if (ret <= 0) {\r\n goto err;\r\n }\r\n }\r\n if (initialized_modules == ((void *)0)) {\r\n initialized_modules = ((struct stack_st_CONF_IMODULE *)(sk_new_null()));\r\n if (!initialized_modules) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",382);\r\n goto err;\r\n }\r\n }\r\n if (!sk_push(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))),((void *)((1?imod : ((CONF_IMODULE *)0)))))) {\r\n ERR_put_error(14,115,1 | 64,\"conf_mod.c\",389);\r\n goto err;\r\n }\r\n pmod -> links++;\r\n return ret;\r\n err:\r\n\r\n if (pmod -> finish && init_called) {\r\n (pmod -> finish)(imod);\r\n }\r\n memerr:\r\n if (imod) {\r\n if (imod -> name) {\r\n CRYPTO_free((imod -> name));\r\n }\r\n if (imod -> value) {\r\n CRYPTO_free((imod -> value));\r\n }\r\n CRYPTO_free(imod);\r\n }\r\n return - 1;\r\n}\r\n\r\n\r\nvoid CONF_modules_unload(int all)\r\n{\r\n int i;\r\n CONF_MODULE *md;\r\n if (__sync_bool_compare_and_swap(&lepry_bomarea,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n riccia_asgd(polytope_pyrrhuloxia);\r\n }\r\n }\r\n CONF_modules_finish();\r\n\r\n for (i = sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) - 1; i >= 0; i--) {\r\n md = ((CONF_MODULE *)(sk_value(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0)))),i)));\r\n\r\n if ((md -> links > 0 || !md -> dso) && !all) {\r\n continue; \r\n }\r\n\r\n (void )((CONF_MODULE *)(sk_delete(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))),i)));\r\n module_free(md);\r\n }\r\n if (sk_num(((_STACK *)((1?supported_modules : ((struct stack_st_CONF_MODULE *)0))))) == 0) {\r\n sk_free(((_STACK *)(1?supported_modules : ((struct stack_st_CONF_MODULE *)0))));\r\n supported_modules = ((void *)0);\r\n }\r\n}\r\n\r\n\r\nstatic void module_free(CONF_MODULE *md)\r\n{\r\n if (md -> dso) {\r\n DSO_free(md -> dso);\r\n }\r\n CRYPTO_free((md -> name));\r\n CRYPTO_free(md);\r\n}\r\n\r\n\r\nvoid CONF_modules_finish()\r\n{\r\n CONF_IMODULE *imod;\r\n while(sk_num(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))))) > 0){\r\n imod = ((CONF_IMODULE *)(sk_pop(((_STACK *)((1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0)))))));\r\n module_finish(imod);\r\n }\r\n sk_free(((_STACK *)(1?initialized_modules : ((struct stack_st_CONF_IMODULE *)0))));\r\n initialized_modules = ((void *)0);\r\n}\r\n\r\n\r\nstatic void module_finish(CONF_IMODULE *imod)\r\n{\r\n if (imod -> pmod -> finish) {\r\n (imod -> pmod -> finish)(imod);\r\n }\r\n imod -> pmod -> links--;\r\n CRYPTO_free((imod -> name));\r\n CRYPTO_free((imod -> value));\r\n CRYPTO_free(imod);\r\n}\r\n\r\n\r\nint CONF_module_add(const char *name,conf_init_func *ifunc,conf_finish_func *ffunc)\r\n{\r\n if (module_add(((void *)0),name,ifunc,ffunc)) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\n\r\nvoid CONF_modules_free()\r\n{\r\n CONF_modules_finish();\r\n CONF_modules_unload(1);\r\n}\r\n\r\n\r\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\r\n{\r\n return (md -> name);\r\n}\r\n\r\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\r\n{\r\n return (md -> value);\r\n}\r\n\r\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\r\n{\r\n return md -> usr_data;\r\n}\r\n\r\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md,void *usr_data)\r\n{\r\n md -> usr_data = usr_data;\r\n}\r\n\r\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\r\n{\r\n return md -> pmod;\r\n}\r\n\r\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\r\n{\r\n return md -> flags;\r\n}\r\n\r\nvoid CONF_imodule_set_flags(CONF_IMODULE *md,unsigned long flags)\r\n{\r\n md -> flags = flags;\r\n}\r\n\r\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\r\n{\r\n return pmod -> usr_data;\r\n}\r\n\r\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod,void *usr_data)\r\n{\r\n pmod -> usr_data = usr_data;\r\n}\r\n\r\n\r\nchar *CONF_get1_default_config_file()\r\n{\r\n char *file;\r\n int len;\r\n file = getenv(\"OPENSSL_CONF\");\r\n if (file) {\r\n return BUF_strdup(file);\r\n }\r\n len = (strlen(X509_get_default_cert_area()));\r\n#ifndef OPENSSL_SYS_VMS\r\n len++;\r\n#endif\r\n len += strlen(\"openssl.cnf\");\r\n file = (CRYPTO_malloc(((int )len) + 1,\"conf_mod.c\",561));\r\n if (!file) {\r\n return ((void *)0);\r\n }\r\n BUF_strlcpy(file,X509_get_default_cert_area(),(len + 1));\r\n#ifndef OPENSSL_SYS_VMS\r\n BUF_strlcat(file,\"/\",(len + 1));\r\n#endif\r\n BUF_strlcat(file,\"openssl.cnf\",(len + 1));\r\n return file;\r\n}\r\n\r\n\r\nint CONF_parse_list(const char *list_,int sep,int nospc,int (*list_cb)(const char *, int , void *),void *arg)\r\n{\r\n int ret;\r\n const char *lstart;\r\n const char *tmpend;\r\n const char *p;\r\n if (list_ == ((void *)0)) {\r\n ERR_put_error(14,119,115,\"conf_mod.c\",588);\r\n return 0;\r\n }\r\n lstart = list_;\r\n for (; ; ) {\r\n if (nospc) {\r\n while( *lstart && ( *__ctype_b_loc())[(int )((unsigned char )( *lstart))] & ((unsigned short )_ISspace))\r\n lstart++;\r\n }\r\n p = (strchr(lstart,sep));\r\n if (p == lstart || !( *lstart)) {\r\n ret = list_cb(((void *)0),0,arg);\r\n }\r\n else {\r\n if (p) {\r\n tmpend = p - 1;\r\n }\r\n else {\r\n tmpend = lstart + strlen(lstart) - 1;\r\n }\r\n if (nospc) {\r\n while(( *__ctype_b_loc())[(int )((unsigned char )( *tmpend))] & ((unsigned short )_ISspace))\r\n tmpend--;\r\n }\r\n ret = list_cb(lstart,(tmpend - lstart + 1),arg);\r\n }\r\n if (ret <= 0) {\r\n return ret;\r\n }\r\n if (p == ((void *)0)) {\r\n return 1;\r\n }\r\n lstart = p + 1;\r\n }\r\n}\r\n\r\nvoid polytope_pyrrhuloxia(char **coenotypic_seminovelty)\r\n{\r\n char *finbacks_maastricht;\r\n ++global_variable;;\r\n setup_printf_context();\r\n finbacks_maastricht = getenv(\"NONCONGENITAL_DEWINESS\");\r\n if (finbacks_maastricht != 0) {;\r\n *coenotypic_seminovelty = finbacks_maastricht;\r\n }\r\n}\r\n\r\nvoid riccia_asgd(void (*diuresis_plainwell)(char **))\r\n{\r\n int found;\r\n char *spoonways_sos = 0;\r\n ++global_variable;\r\n char *qmc_rhombozoa = 0;\r\n diuresis_plainwell(&qmc_rhombozoa);\r\n if (qmc_rhombozoa != 0) {;\r\n spoonways_sos = ((char *)qmc_rhombozoa);\r\n \r\n \r\n \r\n found = search(&spoonways_sos[1],spoonways_sos[0]);\r\n \r\n \r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-674:Uncontrolled Recursion|B.CWE-834:Excessive Iteration", "cwe": "674"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-480:Use of Incorrect Operator\nB.CWE-482:Comparing instead of Assigning\nC.No Vulnerabilities\nD.CWE-708:Incorrect Ownership Assignment\nE.CWE-1177:Use of Prohibited Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n int intMSink = 0;\r\n \r\n printIntLine(intMSink);\r\n \r\n intMSink == 5;\r\n printIntLine(intMSink);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n int intNSink = 0;\r\n \r\n printIntLine(intNSink);\r\n \r\n intNSink = 5;\r\n printIntLine(intNSink);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-482:Comparing instead of Assigning|A.CWE-480:Use of Incorrect Operator", "cwe": "482"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nC.CWE-561:Dead Code\nD.CWE-322:Key Exchange without Entity Authentication\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_bind_accept_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_listen_bind_accept_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_bind_accept_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_bind_accept_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-666:Operation on Resource in Wrong Phase of Lifetime|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nC.CWE-568:finalize() Method Without super.finalize()\nD.No Vulnerabilities\nE.CWE-595:Comparison of Object References Instead of Object Contents\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FULL_COMMAND \"dir \"\r\n#else\r\n#include <unistd.h>\r\n#define FULL_COMMAND \"ls \"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_file_system_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<char *> dataVector);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char data_buf[100] = FULL_COMMAND;\r\n data = data_buf;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<char *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char data_buf[100] = FULL_COMMAND;\r\n data = data_buf;\r\n \r\n strcat(data, \"*.*\");\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_system_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.CWE-433:Unparsed Raw Web Content Delivery\nC.CWE-574:EJB Bad Practices: Use of Synchronization Primitives\nD.No Vulnerabilities\nE.CWE-680:Integer Overflow to Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_fgets_82\r\n{\r\n\r\nclass My_new_fgets_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(int data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_fgets_82 : public My_new_fgets_82_base\r\n{\r\npublic:\r\n void action(int data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_fgets_82G2B : public My_new_fgets_82_base\r\n{\r\npublic:\r\n void action(int data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-680:Integer Overflow to Buffer Overflow|A.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-6:J2EE Misconfiguration: Insufficient Session-ID Length\nB.CWE-416:Use After Free\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-446:UI Discrepancy for Security Feature\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_free_int_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int * &data)\r\n{\r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n free(data);\r\n}\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n printIntLine(data[0]);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int * &data)\r\n{\r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n printIntLine(data[0]);\r\n \r\n}\r\n\r\n\r\nstatic void nB2GSource(int * &data)\r\n{\r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n free(data);\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_free_int_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-599:Missing Validation of OpenSSL Certificate\nC.CWE-762:Mismatched Memory Management Routines\nD.CWE-1022:Use of Web Link to Untrusted Target with window.opener Access\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_delete_int64_t_static_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n if(staticTrue)\r\n {\r\n {\r\n \r\n static int64_t dataBuffer;\r\n dataBuffer = 5LL;\r\n data = &dataBuffer;\r\n }\r\n }\r\n printLongLongLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int64_t * dataBuffer = new int64_t;\r\n *dataBuffer = 5LL;\r\n data = dataBuffer;\r\n }\r\n }\r\n printLongLongLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n if(staticTrue)\r\n {\r\n {\r\n \r\n int64_t * dataBuffer = new int64_t;\r\n *dataBuffer = 5LL;\r\n data = dataBuffer;\r\n }\r\n }\r\n printLongLongLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_int64_t_static_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-590:Free of Memory not on the Heap|C.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nB.No Vulnerabilities\nC.CWE-400:Uncontrolled Resource Consumption\nD.CWE-1106:Insufficient Use of Symbolic Constants\nE.CWE-479:Signal Handler Use of a Non-reentrant Function\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\nstatic void helperM(int sig)\r\n{\r\n \r\n \r\n void *voidPointer = malloc(10);\r\n if (voidPointer == NULL) {exit(-1);}\r\n free(voidPointer);\r\n}\r\n\r\nstatic volatile sig_atomic_t volatileSigAtomic = 0;\r\n\r\nstatic void helperN(int sig)\r\n{\r\n \r\n volatileSigAtomic = sig;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_03()\r\n{\r\n if(5==5)\r\n {\r\n signal(SIGINT, helperM);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\nvoid My_basic_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-479:Signal Handler Use of a Non-reentrant Function|A.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "cwe": "479"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-578:EJB Bad Practices: Use of Class Loader\nB.CWE-427:Uncontrolled Search Path Element\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.No Vulnerabilities\nE.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_connect_socket_11()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-427:Uncontrolled Search Path Element|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-234:Failure to Handle Missing Parameter\nB.No Vulnerabilities\nC.CWE-459:Incomplete Cleanup\nD.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nE.CWE-167:Improper Handling of Additional Special Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_alloca_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char * password = (char *)ALLOCA(100*sizeof(char));\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n password[0] = '\\0';\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_alloca_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_alloca_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_alloca_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|C.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.CWE-263:Password Aging with Long Expiration\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-586:Explicit Call to Finalize()\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_declare_cpy_10()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(globalTrue)\r\n {\r\n \r\n data = dataBuffer - 8;\r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcpy(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcpy(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(globalTrue)\r\n {\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcpy(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_declare_cpy_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_cpy_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_cpy_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-124:Buffer Underwrite ('Buffer Underflow')|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1042:Static Member Data Element outside of a Singleton Class Element\nB.CWE-1332:Improper Handling of Faults that Lead to Instruction Skips\nC.No Vulnerabilities\nD.CWE-1164:Irrelevant Code\nE.CWE-563:Assignment to Variable without Use\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_unused_value_long_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<long> dataVector);\r\n\r\nvoid m()\r\n{\r\n long data;\r\n vector<long> dataVector;\r\n \r\n data = 5L;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<long> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n long data;\r\n vector<long> dataVector;\r\n \r\n data = 5L;\r\n printLongLine(data);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<long> dataVector);\r\n\r\nstatic void nB2G()\r\n{\r\n long data;\r\n vector<long> dataVector;\r\n \r\n data = 5L;\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nB2GSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_unused_value_long_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nB.No Vulnerabilities\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-1173:Improper Use of Validation Framework\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_doubleNaN2int_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)(sqrt(doubleNumber)));\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n \r\n if (doubleNumber < 0)\r\n {\r\n printLine(\"Value is negative\");\r\n }\r\n else\r\n {\r\n printIntLine((int)(sqrt(doubleNumber)));\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_doubleNaN2int_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_doubleNaN2int_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_doubleNaN2int_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-681:Incorrect Conversion between Numeric Types|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-749:Exposed Dangerous Method or Function\nC.No Vulnerabilities\nD.CWE-687:Function Call With Incorrectly Specified Argument Value\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i,j;\r\n list<int> data;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n list<int> data;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n list<int> data;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-672:Operation on a Resource after Expiration or Release|A.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-655:Insufficient Psychological Acceptability\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-761:Free of Pointer not at Start of Buffer\nE.CWE-509:Replicating Malicious Code (Virus or Worm)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\nnamespace My_wchar_t_listen_socket_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n mSource(data);\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(wchar_t * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n nB2GSource(data);\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_listen_socket_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-761:Free of Pointer not at Start of Buffer|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-1313:Hardware Allows Activation of Test or Debug Logic at Runtime\nC.CWE-564:SQL Injection: Hibernate\nD.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_bind_accept_listen_01()\r\n{\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_bind_accept_listen_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_bind_accept_listen_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_bind_accept_listen_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-666:Operation on Resource in Wrong Phase of Lifetime|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-694:Use of Multiple Resources with Duplicate Identifier\nC.CWE-273:Improper Check for Dropped Privileges\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <rpcdce.h>\r\n# pragma comment(lib, \"rpcrt4\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RpcImpersonateClient_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n RpcImpersonateClient(0);\r\n \r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\nvoid My_w32_RpcImpersonateClient_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RpcImpersonateClient_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RpcImpersonateClient_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-273:Improper Check for Dropped Privileges|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-344:Use of Invariant Value in Dynamically Changing Context\nC.CWE-589:Call to Non-ubiquitous API\nD.CWE-126:Buffer Over-read\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_memmove_13()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = (wchar_t *)malloc(50*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_memmove_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_memmove_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_memmove_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1267:Policy Uses Obsolete Encoding\nB.CWE-146:Improper Neutralization of Expression/Command Delimiters\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.No Vulnerabilities\nE.CWE-546:Suspicious Comment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_BUG_05()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_BUG_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_BUG_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_BUG_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-546:Suspicious Comment|C.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-486:Comparison of Classes by Name\nC.CWE-152:Improper Neutralization of Macro Symbols\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define RENAME rename\r\n#else\r\n#define RENAME rename\r\n#endif\r\n\r\n#define OLD_M_FILE_NAME \"oldmfilename.txt\"\r\n#define OLD_N_FILE_NAME \"oldnfilename.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_rename_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n RENAME(OLD_M_FILE_NAME, \"newmfilename.txt\");\r\n }\r\n else\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n else\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_rename_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_rename_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_rename_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-259:Use of Hard-coded Password\nC.CWE-675:Multiple Operations on Resource in Single-Operation Context\nD.CWE-1241:Use of Predictable Algorithm in Random Number Generator\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_11()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n wcscpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-259:Use of Hard-coded Password|A.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1276:Hardware Child Block Incorrectly Connected to Parent System\nB.CWE-787:Out-of-bounds Write\nC.CWE-1114:Inappropriate Whitespace Style\nD.CWE-121:Stack-based Buffer Overflow\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE805_int64_t_alloca_loop_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-121:Stack-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1336:Improper Neutralization of Special Elements Used in a Template Engine\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-321:Use of Hard-coded Cryptographic Key\nE.CWE-317:Cleartext Storage of Sensitive Information in GUI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_12()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-321:Use of Hard-coded Cryptographic Key|C.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-55:Path Equivalence: '/./' (Single Dot Directory)\nB.CWE-682:Incorrect Calculation\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-607:Public Static Final Field References Mutable Object\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\ntypedef struct _My_int_connect_socket_add_67_structType\r\n{\r\n int structFirst;\r\n} My_int_connect_socket_add_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_connect_socket_add_67bSink(My_int_connect_socket_add_67_structType myStruct);\r\n\r\nvoid My_int_connect_socket_add_67()\r\n{\r\n int data;\r\n My_int_connect_socket_add_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_add_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_connect_socket_add_67bG2BSink(My_int_connect_socket_add_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_int_connect_socket_add_67_structType myStruct;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_add_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_int_connect_socket_add_67bB2GSink(My_int_connect_socket_add_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_int_connect_socket_add_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_add_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_int_connect_socket_add_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_add_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_add_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1044:Architecture with Number of Horizontal Layers Outside of Expected Range\nB.No Vulnerabilities\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_char_13()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_free_char_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_char_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_char_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-115:Misinterpretation of Input\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-348:Use of Less Trusted Source\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_fgets_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n size_t &dataRef = data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n {\r\n size_t data = dataRef;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n size_t &dataRef = data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n {\r\n size_t data = dataRef;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n size_t &dataRef = data;\r\n \r\n data = 0;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n {\r\n size_t data = dataRef;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_fgets_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-1334:Unauthorized Error Injection Can Degrade Hardware Redundancy\nD.CWE-441:Unintended Proxy or Intermediary ('Confused Deputy')\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_15()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n \r\n ; \r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n fclose(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fopen_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-675:Multiple Operations on Resource in Single-Operation Context|B.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-126:Buffer Over-read\nC.No Vulnerabilities\nD.CWE-1103:Use of Platform-Dependent Third Party Components\nE.CWE-440:Expected Behavior Violation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_alloca_loop_65bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_alloca_loop_65()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = My_wchar_t_alloca_loop_65bSink;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataMBuffer;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_alloca_loop_65bG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = My_wchar_t_alloca_loop_65bG2BSink;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataNBuffer;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_wchar_t_alloca_loop_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_alloca_loop_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_alloca_loop_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-780:Use of RSA Algorithm without OAEP\nB.CWE-291:Reliance on IP Address for Authentication\nC.No Vulnerabilities\nD.CWE-64:Windows Shortcut Following (.LNK)\nE.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"String to be encrypted\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n BYTE payload[200];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) HASH_INPUT, strlen(HASH_INPUT)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing HASH_INPUT\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RSA_SIGN, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload)))\r\n {\r\n printLine(\"Error in CryptEncryptData\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine((BYTE *) payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-780:Use of RSA Algorithm without OAEP|E.CWE-327:Use of a Broken or Risky Cryptographic Algorithm", "cwe": "780"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-121:Stack-based Buffer Overflow\nB.No Vulnerabilities\nC.CWE-1290:Incorrect Decoding of Security Identifiers \nD.CWE-787:Out-of-bounds Write\nE.CWE-419:Unprotected Primary Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_My_CWE806_char_declare_ncat_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-121:Stack-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nB.CWE-704:Incorrect Type Conversion or Cast\nC.CWE-339:Small Seed Space in PRNG\nD.No Vulnerabilities\nE.CWE-1102:Reliance on Machine-Dependent Data Representation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_short_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<void *> dataList);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n list<void *> dataList;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<void *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n list<void *> dataList;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_short_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-1233:Security-Sensitive Hardware Controls with Missing Lock Bit Protection\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-391:Unchecked Error Condition\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_strtol_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n long longNumber;\r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_strtol_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strtol_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strtol_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-391:Unchecked Error Condition|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-182:Collapse of Data into Unsafe Value\nB.CWE-198:Use of Incorrect Byte Ordering\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-704:Incorrect Type Conversion or Cast\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2int_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2int_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2int_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2int_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-681:Incorrect Conversion between Numeric Types|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-416:Use After Free\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nD.No Vulnerabilities\nE.CWE-756:Missing Custom Error Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_int_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new int;\r\n *data = 5;\r\n \r\n delete data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n printIntLine(*data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new int;\r\n *data = 5;\r\n \r\n delete data;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new int;\r\n *data = 5;\r\n \r\n delete data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new int;\r\n *data = 5;\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n printIntLine(*data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new int;\r\n *data = 5;\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n printIntLine(*data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-416:Use After Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1276:Hardware Child Block Incorrectly Connected to Parent System\nC.CWE-839:Numeric Range Comparison Without Minimum Check\nD.CWE-1023:Incomplete Comparison with Missing Factors\nE.CWE-1053:Missing Documentation for Design\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint hepatized_unstaggering = 0;\r\nint global_variable;\r\n\r\nstruct exarchic_oilpaper \r\n{\r\n char *enchequer_astrologian;\r\n double noisily_unpremonished;\r\n char *wharfman_timidity;\r\n char apodes_isopleuran;\r\n int substantivize_hmi;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid cobol_tamassee(struct exarchic_oilpaper *magnetons_demographic);\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n void (*bigamizing_oflete)(struct exarchic_oilpaper *) = cobol_tamassee;\r\n int chaetopodous_majestically;\r\n struct exarchic_oilpaper *proportionably_dactylomegaly = {0};\r\n struct exarchic_oilpaper *chrysophyll_tricks = {0};\r\n struct exarchic_oilpaper nonrevocation_townsville;\r\n int undreamed_enterprise = 10;\r\n char *unimputable_reminiscitory;;\r\n if (__sync_bool_compare_and_swap(&hepatized_unstaggering,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&unimputable_reminiscitory,\"3115\",undreamed_enterprise);\r\n if (unimputable_reminiscitory != 0) {;\r\n nonrevocation_townsville . enchequer_astrologian = ((char *)unimputable_reminiscitory);\r\n chaetopodous_majestically = 1;\r\n proportionably_dactylomegaly = &nonrevocation_townsville;\r\n chrysophyll_tricks = ((struct exarchic_oilpaper *)(((unsigned long )proportionably_dactylomegaly) * chaetopodous_majestically * chaetopodous_majestically)) + 5;\r\n bigamizing_oflete(chrysophyll_tricks);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid cobol_tamassee(struct exarchic_oilpaper *magnetons_demographic)\r\n{\r\n char *buffer = 0U;\r\n int len;\r\n char *buckjumper_mudcap = 0;\r\n ++global_variable;;\r\n buckjumper_mudcap = ((char *)( *(magnetons_demographic - 5)) . enchequer_astrologian);\r\n \r\n len = atoi(buckjumper_mudcap);\r\n \r\n\r\n if (len < 4096) {\r\n buffer = ((char *)(malloc(4096 * sizeof(char ))));\r\n if (buffer != 0) {\r\n memset(buffer,'a',4096);\r\n \r\n \r\n\r\n memset(&buffer[len],'b',4096 - len);\r\n \r\n buffer[4095] = 0;\r\n printf(\"%s\\n\",buffer);\r\n free(buffer);\r\n }\r\n } else {\r\n printf(\"Number is too large to use\\n\");\r\n }\r\n \r\n \r\n;\r\n if (( *(magnetons_demographic - 5)) . enchequer_astrologian != 0) \r\n free(((char *)( *(magnetons_demographic - 5)) . enchequer_astrologian));\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-839:Numeric Range Comparison Without Minimum Check|D.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "839"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.No Vulnerabilities\nD.CWE-319:Cleartext Transmission of Sensitive Information\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_cat_32()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n \r\n ; \r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n \r\n data[0] = L'\\0'; \r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_cat_32()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-665:Improper Initialization|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-174:Double Decoding of the Same Data\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.No Vulnerabilities\nE.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_environment_15()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 256-dataLen-1);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_char_environment_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_environment_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_environment_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-321:Use of Hard-coded Cryptographic Key\nB.CWE-69:Improper Handling of Windows ::DATA Alternate Data Stream\nC.CWE-329:Generation of Predictable IV with CBC Mode\nD.CWE-798:Use of Hard-coded Credentials\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_64bSink(void * cryptoKeyVoidPtr);\r\n\r\nvoid My_w32_char_64()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n My_w32_char_64bSink(&cryptoKey);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_64bG2BSink(void * cryptoKeyVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n My_w32_char_64bG2BSink(&cryptoKey);\r\n}\r\n\r\nvoid My_w32_char_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-528:Exposure of Core Dump File to an Unauthorized Control Sphere\nC.CWE-363:Race Condition Enabling Link Following\nD.CWE-606:Unchecked Input for Loop Condition\nE.CWE-1284:Improper Validation of Specified Quantity in Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_console_17()\r\n{\r\n int i,j;\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n for(i = 0; i < 1; i++)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n for(i = 0; i < 1; i++)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n strcpy(data, \"15\");\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_console_17()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-606:Unchecked Input for Loop Condition|E.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-1252:CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nC.CWE-400:Uncontrolled Resource Consumption\nD.No Vulnerabilities\nE.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_sleep_15()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n count = 20;\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n count = 20;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fgets_sleep_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_sleep_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_sleep_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-400:Uncontrolled Resource Consumption|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-597:Use of Wrong Operator in String Comparison\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-1060:Excessive Number of Inefficient Server-Side Data Accesses\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_int64_t_34\r\n{\r\n\r\ntypedef union\r\n{\r\n int64_t * unionFirst;\r\n int64_t * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n unionType myUnion;\r\n data = NULL;\r\n \r\n data = new int64_t;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n myUnion.unionFirst = data;\r\n {\r\n int64_t * data = myUnion.unionSecond;\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n unionType myUnion;\r\n data = NULL;\r\n \r\n int64_t dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n myUnion.unionFirst = data;\r\n {\r\n int64_t * data = myUnion.unionSecond;\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n unionType myUnion;\r\n data = NULL;\r\n \r\n data = new int64_t;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n myUnion.unionFirst = data;\r\n {\r\n int64_t * data = myUnion.unionSecond;\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_int64_t_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-80:Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-590:Free of Memory not on the Heap\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_free_int64_t_alloca_11()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5LL;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printLongLongLine(data[0]);\r\n \r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int64_t * dataBuffer = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5LL;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printLongLongLine(data[0]);\r\n \r\n free(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n int64_t * dataBuffer = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5LL;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printLongLongLine(data[0]);\r\n \r\n free(data);\r\n}\r\n\r\nvoid My_free_int64_t_alloca_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_free_int64_t_alloca_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_free_int64_t_alloca_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-590:Free of Memory not on the Heap|D.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nC.CWE-521:Weak Password Requirements\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_int64_t_07()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n free(data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n printLongLongLine(data[0]);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n free(data);\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n free(data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n printLongLongLine(data[0]);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n if (data == NULL) {exit(-1);}\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n printLongLongLine(data[0]);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_free_int64_t_07()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_int64_t_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_int64_t_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-779:Logging of Excessive Data\nC.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nD.CWE-330:Use of Insufficiently Random Values\nE.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_01()\r\n{\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_access_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|E.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.CWE-390:Detection of Error Condition Without Action\nC.CWE-268:Privilege Chaining\nD.No Vulnerabilities\nE.CWE-921:Storage of Sensitive Data in a Mechanism without Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_char_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_char_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_char_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_char_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-602:Client-Side Enforcement of Server-Side Security\nC.CWE-106:Struts: Plug-in Framework not in Use\nD.No Vulnerabilities\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_delete_struct_malloc_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new twoIntsStruct;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = new twoIntsStruct;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_struct_malloc_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-762:Mismatched Memory Management Routines|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-680:Integer Overflow to Buffer Overflow\nC.CWE-1317:Improper Access Control in Fabric Bridge\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-27:Path Traversal: 'dir/../../filename'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_rand_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int &data);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int &data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_rand_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-680:Integer Overflow to Buffer Overflow|D.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)\nB.CWE-194:Unexpected Sign Extension\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.No Vulnerabilities\nE.CWE-507:Trojan Horse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fscanf_memmove_52bSink(short data);\r\n\r\nvoid My_fscanf_memmove_52()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n My_fscanf_memmove_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fscanf_memmove_52bG2BSink(short data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n My_fscanf_memmove_52bG2BSink(data);\r\n}\r\n\r\nvoid My_fscanf_memmove_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_memmove_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_memmove_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-194:Unexpected Sign Extension|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-628:Function Call with Incorrectly Specified Arguments\nB.No Vulnerabilities\nC.CWE-121:Stack-based Buffer Overflow\nD.CWE-331:Insufficient Entropy\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE806_wchar_t_alloca_memmove_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-121:Stack-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1101:Reliance on Runtime Component in Generated Code\nC.CWE-707:Improper Neutralization\nD.CWE-284:Improper Access Control\nE.CWE-170:Improper Null Termination\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint anilidoxime_aspidoganoidei = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid untimesome_spinningly(char *praxiteles_insweeping);\r\nvoid ivorine_anhydrating(char *phylogerontism_prosphoron);\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n char *mockups_jostlers = 0;\r\n int *blacky_outscold = 0;\r\n int severate_nontransiency;\r\n char *pecked_peoplehood[10] = {0};\r\n int phonematic_germanically = 50;\r\n char *dishwiping_daimio;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&anilidoxime_aspidoganoidei,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&dishwiping_daimio,\"5765\",phonematic_germanically);\r\n if (dishwiping_daimio != 0) {;\r\n severate_nontransiency = 5;\r\n blacky_outscold = &severate_nontransiency;\r\n pecked_peoplehood[ *blacky_outscold] = dishwiping_daimio;\r\n mockups_jostlers = pecked_peoplehood[ *blacky_outscold];\r\n untimesome_spinningly(mockups_jostlers);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid untimesome_spinningly(char *praxiteles_insweeping)\r\n{\r\n ++global_variable;;\r\n ivorine_anhydrating(praxiteles_insweeping);\r\n}\r\n\r\nvoid ivorine_anhydrating(char *phylogerontism_prosphoron)\r\n{\r\n int oc_i = 0;\r\n int buf_ptr_len;\r\n char *new_input = \"new test input\";\r\n const int MAXLEN = 16;\r\n char *dressler_badly = 0;\r\n ++global_variable;;\r\n dressler_badly = ((char *)phylogerontism_prosphoron);\r\n \r\n int file_desc;\r\n char input_buf[MAXLEN];\r\n char **buf_ptr = 0;\r\n char *path_buf = 0;\r\n path_buf = malloc(sizeof(char ) * 64);\r\n if (path_buf == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n buf_ptr = malloc(sizeof(char *));\r\n if (buf_ptr == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n *buf_ptr = path_buf;\r\n memset(input_buf,0,16);\r\n memset(path_buf,'a',64);\r\n path_buf[63] = 0;\r\n file_desc = open(dressler_badly,0);\r\n if (file_desc > -1) {\r\n read(file_desc,input_buf,MAXLEN);\r\n close(file_desc);\r\n \r\n \r\n strncpy(path_buf,input_buf,MAXLEN);\r\n \r\n \r\n \r\n strcat(path_buf,new_input);\r\n buf_ptr_len = strlen( *buf_ptr);\r\n for (; oc_i < buf_ptr_len; ++oc_i) {\r\n path_buf[oc_i] = toupper(path_buf[oc_i]);\r\n }\r\n \r\n printf(\"%s\\n\",path_buf);\r\n \r\n }\r\n if (path_buf != 0) {\r\n free(path_buf);\r\n }\r\n if (buf_ptr != 0) {\r\n free(buf_ptr);\r\n }\r\n;\r\n if (phylogerontism_prosphoron != 0) \r\n free(((char *)phylogerontism_prosphoron));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-170:Improper Null Termination|C.CWE-707:Improper Neutralization", "cwe": "170"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-616:Incomplete Identification of Uploaded File Variables (PHP)\nC.CWE-252:Unchecked Return Value\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.CWE-457:Use of Uninitialized Variable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_long_calloc_01()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)calloc(1, sizeof(long));\r\n \r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)calloc(1, sizeof(long));\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_long_calloc_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_long_calloc_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_long_calloc_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-690:Unchecked Return Value to NULL Pointer Dereference|C.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-1041:Use of Redundant Code\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.CWE-427:Uncontrolled Search Path Element\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_file_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<char *> dataVector);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (250-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<char *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-427:Uncontrolled Search Path Element|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-1304:Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\nC.No Vulnerabilities\nD.CWE-833:Deadlock\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#include <process.h>\r\n\r\nnamespace My_wchar_t_connect_socket_w32_spawnvp_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n _wspawnvp(_P_WAIT, COMMAND_INT, args);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\r\n \r\n \r\n _wspawnvp(_P_WAIT, COMMAND_INT, args);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_connect_socket_w32_spawnvp_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-415:Double Free\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.No Vulnerabilities\nD.CWE-431:Missing Handler\nE.CWE-478:Missing Default Case in Multiple Condition Expression\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_class_66\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(TwoIntsClass * dataArray[]);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n delete [] data;\r\n \r\n dataArray[2] = data;\r\n mSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(TwoIntsClass * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n dataArray[2] = data;\r\n nG2BSink(dataArray);\r\n}\r\n\r\n\r\nvoid nB2GSink(TwoIntsClass * dataArray[]);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n \r\n data = NULL;\r\n data = new TwoIntsClass[100];\r\n \r\n delete [] data;\r\n dataArray[2] = data;\r\n nB2GSink(dataArray);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_class_66; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-415:Double Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.No Vulnerabilities\nC.CWE-588:Attempt to Access Child of a Non-structure Pointer\nD.CWE-93:Improper Neutralization of CRLF Sequences ('CRLF Injection')\nE.CWE-1394:Use of Default Cryptographic Key\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_class_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, void *> dataMap);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, void *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-588:Attempt to Access Child of a Non-structure Pointer|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-680:Integer Overflow to Buffer Overflow\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-190:Integer Overflow or Wraparound\nD.No Vulnerabilities\nE.CWE-1298:Hardware Logic Contains Race Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_malloc_fscanf_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int> dataVector);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<int> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = 20;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_fscanf_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1076:Insufficient Adherence to Expected Conventions\nC.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nD.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nE.CWE-671:Lack of Administrator Control over Security\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_free_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_free_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_free_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_free_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|C.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-1234:Hardware Internal or Debug Modes Allow Override of Locks\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-474:Use of Function with Inconsistent Implementations\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wcstombs_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wcstombs_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wcstombs_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wcstombs_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-391:Unchecked Error Condition|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1260:Improper Handling of Overlap Between Protected Memory Ranges\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-476:NULL Pointer Dereference\nE.CWE-783:Operator Precedence Logic Error\n", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint nonimmanent_stutterer = 0;\r\nint global_variable;\r\nvoid handle_taint(char *pharmuthi_codswallop);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid hominization_gorgonizing(void **braye_stegosaurian);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&nonimmanent_stutterer,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *pharmuthi_codswallop)\r\n{\r\n void (*unbuttons_xanthene)(void **) = hominization_gorgonizing;\r\n void **bothriums_clearings = 0;\r\n void **ebon_unpuritanic = 0;\r\n void *crusts_megasporangium = 0;\r\n ++global_variable;;\r\n if (pharmuthi_codswallop != 0) {;\r\n crusts_megasporangium = ((void *)pharmuthi_codswallop);\r\n bothriums_clearings = &crusts_megasporangium;\r\n ebon_unpuritanic = bothriums_clearings + 5;\r\n unbuttons_xanthene(ebon_unpuritanic);\r\n }\r\n}\r\n\r\nvoid hominization_gorgonizing(void **braye_stegosaurian)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *lycaeus_herdboy = 0;\r\n ++global_variable;;\r\n lycaeus_herdboy = ((char *)((char *)( *(braye_stegosaurian - 5))));\r\n \r\n buffer_value = atoi(lycaeus_herdboy);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\n if (((char *)( *(braye_stegosaurian - 5))) != 0) \r\n free(((char *)((char *)( *(braye_stegosaurian - 5)))));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1262:Improper Access Control for Register Interface\nB.No Vulnerabilities\nC.CWE-322:Key Exchange without Entity Authentication\nD.CWE-197:Numeric Truncation Error\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fscanf_to_char_12()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n }\r\n else\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n else\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\nvoid My_int_fscanf_to_char_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fscanf_to_char_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fscanf_to_char_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-197:Numeric Truncation Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-270:Privilege Context Switching Error\nB.CWE-1338:Improper Protections Against Hardware Overheating\nC.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nD.No Vulnerabilities\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint preaccess_stomatograph = 0;\r\nint global_variable;\r\nvoid handle_taint(char *ameed_incut);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid pharyngealized_theorems(char *(**glenice_pettles)[85]);\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&preaccess_stomatograph,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *ameed_incut)\r\n{\r\n void (*pruritus_pva)(char *(**)[85]) = pharyngealized_theorems;\r\n char *(**svetlana_calamined)[85] = 0;\r\n char *(*preserves_predisponent)[85] = 0;\r\n char **rhapsodizes_cacaxte = 0;\r\n char *postiche_trinil[85] = {0};\r\n ++global_variable;;\r\n if (ameed_incut != 0) {;\r\n postiche_trinil[38] = ameed_incut;\r\n preserves_predisponent = &postiche_trinil;\r\n svetlana_calamined = &preserves_predisponent;\r\n pruritus_pva(svetlana_calamined);\r\n }\r\n}\r\n\r\nvoid pharyngealized_theorems(char *(**glenice_pettles)[85])\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *berwyn_exhilarates = 0;\r\n ++global_variable;;\r\n berwyn_exhilarates = ((char *)( *( *glenice_pettles))[38]);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, berwyn_exhilarates);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (( *( *glenice_pettles))[38] != 0) \r\n free(((char *)( *( *glenice_pettles))[38]));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "89"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-341:Predictable from Observable State\nB.CWE-415:Double Free\nC.No Vulnerabilities\nD.CWE-760:Use of a One-Way Hash with a Predictable Salt\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_long_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n long * *dataPtr1 = &data;\r\n long * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n long * data = *dataPtr1;\r\n data = new long;\r\n \r\n delete data;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n long * data = *dataPtr2;\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n long * data;\r\n long * *dataPtr1 = &data;\r\n long * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n long * data = *dataPtr1;\r\n data = new long;\r\n \r\n *dataPtr1 = data;\r\n }\r\n {\r\n long * data = *dataPtr2;\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n long * *dataPtr1 = &data;\r\n long * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n long * data = *dataPtr1;\r\n data = new long;\r\n \r\n delete data;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n long * data = *dataPtr2;\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_long_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-415:Double Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1164:Irrelevant Code\nB.CWE-563:Assignment to Variable without Use\nC.No Vulnerabilities\nD.CWE-410:Insufficient Resource Pool\nE.CWE-238:Improper Handling of Incomplete Structural Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_value_long_03()\r\n{\r\n long data;\r\n if(5==5)\r\n {\r\n \r\n data = 5L;\r\n }\r\n if(5==5)\r\n {\r\n \r\n data = 10L;\r\n printLongLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n long data;\r\n if(5==5)\r\n {\r\n \r\n data = 5L;\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLongLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n long data;\r\n if(5==5)\r\n {\r\n \r\n data = 5L;\r\n }\r\n if(5==5)\r\n {\r\n \r\n printLongLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n long data;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 5L;\r\n printLongLine(data);\r\n }\r\n if(5==5)\r\n {\r\n \r\n data = 10L;\r\n printLongLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n long data;\r\n if(5==5)\r\n {\r\n \r\n data = 5L;\r\n printLongLine(data);\r\n }\r\n if(5==5)\r\n {\r\n \r\n data = 10L;\r\n printLongLine(data);\r\n }\r\n}\r\n\r\nvoid My_unused_value_long_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_value_long_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_value_long_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-563:Assignment to Variable without Use|A.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1120:Excessive Code Complexity\nB.CWE-469:Use of Pointer Subtraction to Determine Size\nC.CWE-467:Use of sizeof() on a Pointer Type\nD.No Vulnerabilities\nE.CWE-284:Improper Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n#include <shlwapi.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HUSKEY hKey = HKEY_CURRENT_USER;\r\n \r\n if (SHRegCreateUSKeyW(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n SHREGSET_HKCU) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_SHRegCreateUSKey_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_SHRegCreateUSKey_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-284:Improper Access Control|C.CWE-467:Use of sizeof() on a Pointer Type", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-646:Reliance on File Name or Extension of Externally-Supplied File\nC.CWE-675:Multiple Operations on Resource in Single-Operation Context\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_large_to_char_63bSink(int * dataPtr);\r\n\r\nvoid My_int_large_to_char_63()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = SHRT_MAX + 5;\r\n My_int_large_to_char_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_large_to_char_63bG2BSink(int * data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = CHAR_MAX-5;\r\n My_int_large_to_char_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_int_large_to_char_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_large_to_char_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_large_to_char_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-512:Spyware\nB.CWE-563:Assignment to Variable without Use\nC.CWE-667:Improper Locking\nD.No Vulnerabilities\nE.CWE-662:Improper Synchronization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-667:Improper Locking|E.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-140:Improper Neutralization of Delimiters\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-756:Missing Custom Error Page\nD.CWE-590:Free of Memory not on the Heap\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_free_wchar_t_static_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<wchar_t *> dataList);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = NULL; \r\n {\r\n \r\n static wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<wchar_t *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = NULL; \r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_free_wchar_t_static_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-152:Improper Neutralization of Macro Symbols\nB.CWE-628:Function Call with Incorrectly Specified Arguments\nC.No Vulnerabilities\nD.CWE-1318:Missing Support for Security Features in On-chip Fabrics or Buses\nE.CWE-688:Function Call With Incorrect Variable or Reference as Argument\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 100\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%s\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n int intFive = 5;\r\n \r\n sprintf(dest, \"%d\", intFive);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-688:Function Call With Incorrect Variable or Reference as Argument|B.CWE-628:Function Call with Incorrectly Specified Arguments", "cwe": "688"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-134:Use of Externally-Controlled Format String\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-638:Not Using Complete Mediation\nD.CWE-1164:Irrelevant Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_listen_socket_fprintf_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, char *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, char *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_fprintf_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-134:Use of Externally-Controlled Format String|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-332:Insufficient Entropy in PRNG\nC.CWE-121:Stack-based Buffer Overflow\nD.CWE-115:Misinterpretation of Input\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE805_char_alloca_ncpy_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-121:Stack-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-325:Missing Cryptographic Step\nB.CWE-573:Improper Following of Specification by Caller\nC.No Vulnerabilities\nD.CWE-341:Predictable from Observable State\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptDeriveKey_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptDeriveKey_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptDeriveKey_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptDeriveKey_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-325:Missing Cryptographic Step|B.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-252:Unchecked Return Value\nC.CWE-153:Improper Neutralization of Substitution Characters\nD.CWE-1220:Insufficient Granularity of Access Control\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fprintf_05()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n fprintf(stdout, \"%s\\n\", \"string\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\r\n {\r\n printLine(\"fprintf failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\r\n {\r\n printLine(\"fprintf failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fprintf_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fprintf_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fprintf_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-273:Improper Check for Dropped Privileges\nB.CWE-1239:Improper Zeroization of Hardware Register\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-667:Improper Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-273:Improper Check for Dropped Privileges|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-106:Struts: Plug-in Framework not in Use\nE.CWE-150:Improper Neutralization of Escape, Meta, or Control Sequences\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_int_rand_divide_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int> dataMap);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, int> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, int> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_rand_divide_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|B.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-347:Improper Verification of Cryptographic Signature\nB.CWE-135:Incorrect Calculation of Multi-Byte String Length\nC.No Vulnerabilities\nD.CWE-126:Buffer Over-read\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE129_fgets_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-1278:Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nC.No Vulnerabilities\nD.CWE-512:Spyware\nE.CWE-789:Memory Allocation with Excessive Size Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\nnamespace My_new_char_connect_socket_16\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n while(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n while(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n while(1)\r\n {\r\n \r\n data = 20;\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_connect_socket_16; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-391:Unchecked Error Condition\nC.CWE-194:Unexpected Sign Extension\nD.No Vulnerabilities\nE.CWE-271:Privilege Dropping / Lowering Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_strtol_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n long longNumber;\r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n printf(\"%li\\n\", longNumber);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n}\r\n\r\nvoid My_strtol_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strtol_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strtol_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-391:Unchecked Error Condition|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-1023:Incomplete Comparison with Missing Factors\nC.No Vulnerabilities\nD.CWE-271:Privilege Dropping / Lowering Errors\nE.CWE-272:Least Privilege Violation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateProcessAsUser_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateProcessAsUser_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateProcessAsUser_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateProcessAsUser_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-272:Least Privilege Violation|D.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-612:Improper Authorization of Index Containing Sensitive Information\nE.CWE-708:Incorrect Ownership Assignment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_environment_ifstream_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_ifstream_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-23:Relative Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-673:External Influence of Sphere Definition\nB.CWE-142:Improper Neutralization of Value Delimiters\nC.No Vulnerabilities\nD.CWE-606:Unchecked Input for Loop Condition\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _popen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic char * mSource(char * data)\r\n{\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n return data;\r\n}\r\n\r\nvoid My_char_popen_42()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic char * nG2BSource(char * data)\r\n{\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n return data;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_popen_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_popen_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_popen_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-426:Untrusted Search Path|A.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-456:Missing Initialization of a Variable\nB.CWE-912:Hidden Functionality\nC.No Vulnerabilities\nD.CWE-506:Embedded Malicious Code\nE.CWE-58:Path Equivalence: Windows 8.3 Filename\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n if (GetFileTime(hFile,\r\n NULL,\r\n NULL,\r\n &ftModified) == 0)\r\n {\r\n break;\r\n }\r\n \r\n qwResult -= 10 * _DAY;\r\n \r\n ftModified.dwLowDateTime = (DWORD)(qwResult & 0xFFFFFFFF);\r\n ftModified.dwHighDateTime = (DWORD)(qwResult >> 32);\r\n \r\n SetFileTime(hFile,\r\n (LPFILETIME)NULL,\r\n (LPFILETIME)NULL,\r\n &ftModified);\r\n }\r\n while (0);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_file_attrib_modified_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_file_attrib_modified_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_file_attrib_modified_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-506:Embedded Malicious Code|B.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nB.CWE-79:Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.No Vulnerabilities\nE.CWE-427:Uncontrolled Search Path Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_environment_10()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 250-dataLen-1);\r\n }\r\n }\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n strcat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_environment_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-427:Uncontrolled Search Path Element|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1338:Improper Protections Against Hardware Overheating\nC.CWE-1115:Source Code Element without Standard Prologue\nD.CWE-126:Buffer Over-read\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_wchar_t_memmove_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(50*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_wchar_t_memmove_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-489:Active Debug Code\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-28:Path Traversal: '..\\filedir'\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_wchar_t_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<wchar_t *> passwordVector);\r\n\r\nvoid m()\r\n{\r\n wchar_t * password;\r\n vector<wchar_t *> passwordVector;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n \r\n wcscpy(password, PASSWORD);\r\n \r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n mSink(passwordVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<wchar_t *> passwordVector);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n vector<wchar_t *> passwordVector;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n \r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n nG2BSink(passwordVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-142:Improper Neutralization of Value Delimiters\nB.CWE-52:Path Equivalence: '/multiple/trailing/slash//'\nC.CWE-665:Improper Initialization\nD.CWE-457:Use of Uninitialized Variable\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_twointsclass_array_declare_no_init_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_twointsclass_array_declare_no_init_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-457:Use of Uninitialized Variable|C.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-464:Addition of Data Structure Sentinel\nB.CWE-1317:Improper Access Control in Fabric Bridge\nC.CWE-366:Race Condition within a Thread\nD.CWE-138:Improper Neutralization of Special Elements\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_basic_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_basic_64()\r\n{\r\n char data;\r\n data = ' ';\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n My_basic_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_basic_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n \r\n data = 'a';\r\n My_basic_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_basic_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-464:Addition of Data Structure Sentinel|D.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1125:Excessive Attack Surface\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-262:Not Using Password Aging\nD.CWE-590:Free of Memory not on the Heap\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_char_alloca_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL; \r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n char * dataBuffer = (char *)ALLOCA(sizeof(char));\r\n *dataBuffer = 'A';\r\n data = dataBuffer;\r\n }\r\n }\r\n printHexCharLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL; \r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * dataBuffer = new char;\r\n *dataBuffer = 'A';\r\n data = dataBuffer;\r\n }\r\n }\r\n printHexCharLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL; \r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n char * dataBuffer = new char;\r\n *dataBuffer = 'A';\r\n data = dataBuffer;\r\n }\r\n }\r\n printHexCharLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_char_alloca_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1177:Use of Prohibited Code\nB.CWE-676:Use of Potentially Dangerous Function\nC.CWE-40:Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\nD.No Vulnerabilities\nE.CWE-941:Incorrectly Specified Destination in a Communication Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n#define CHAR_BUFFER_SIZE 10\r\n\r\nnamespace My_basic_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char charBuffer[CHAR_BUFFER_SIZE];\r\n \r\n \r\n cin >> charBuffer;\r\n charBuffer[CHAR_BUFFER_SIZE-1] = '\\0';\r\n printLine(charBuffer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char charBuffer[CHAR_BUFFER_SIZE];\r\n \r\n cin.width(CHAR_BUFFER_SIZE);\r\n cin >> charBuffer;\r\n charBuffer[CHAR_BUFFER_SIZE-1] = '\\0';\r\n printLine(charBuffer);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_basic_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-676:Use of Potentially Dangerous Function|A.CWE-1177:Use of Prohibited Code", "cwe": "676"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-585:Empty Synchronized Block\nC.CWE-595:Comparison of Object References Instead of Object Contents\nD.No Vulnerabilities\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_class_declare_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * *dataPtr1 = &data;\r\n TwoIntsClass * *dataPtr2 = &data;\r\n data = NULL; \r\n {\r\n TwoIntsClass * data = *dataPtr1;\r\n {\r\n \r\n TwoIntsClass dataBuffer;\r\n dataBuffer.intOne = 1;\r\n dataBuffer.intTwo = 1;\r\n data = &dataBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n TwoIntsClass * data = *dataPtr2;\r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * *dataPtr1 = &data;\r\n TwoIntsClass * *dataPtr2 = &data;\r\n data = NULL; \r\n {\r\n TwoIntsClass * data = *dataPtr1;\r\n {\r\n \r\n TwoIntsClass * dataBuffer = new TwoIntsClass;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n TwoIntsClass * data = *dataPtr2;\r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_class_declare_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-590:Free of Memory not on the Heap|E.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-79:Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nE.CWE-1109:Use of Same Variable for Multiple Purposes\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_03()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(5==5)\r\n {\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(5==5)\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-1259:Improper Restriction of Security Token Assignment\nE.CWE-1274:Improper Access Control for Volatile Memory Containing Boot Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_wchar_t_malloc_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSource(wchar_t * &data)\r\n{\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n delete [] data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(wchar_t * &data)\r\n{\r\n \r\n data = new wchar_t[100];\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n delete [] data;\r\n}\r\n\r\n\r\nstatic void nB2GSource(wchar_t * &data)\r\n{\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n free(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_wchar_t_malloc_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.No Vulnerabilities\nC.CWE-104:Struts: Form Bean Does Not Extend Validation Class\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_free_wchar_t_alloca_14()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n }\r\n printWLine(data);\r\n \r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n }\r\n printWLine(data);\r\n \r\n free(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n }\r\n printWLine(data);\r\n \r\n free(data);\r\n}\r\n\r\nvoid My_free_wchar_t_alloca_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_free_wchar_t_alloca_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_free_wchar_t_alloca_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|E.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1053:Missing Documentation for Design\nB.CWE-667:Improper Locking\nC.CWE-287:Improper Authentication\nD.No Vulnerabilities\nE.CWE-662:Improper Synchronization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n}\r\n\r\nvoid My_basic_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-667:Improper Locking|E.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-319:Cleartext Transmission of Sensitive Information\nC.CWE-259:Use of Hard-coded Password\nD.CWE-311:Missing Encryption of Sensitive Data\nE.CWE-324:Use of a Key Past its Expiration Date\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nwchar_t * My_w32_wchar_t_listen_socket_61bSource(wchar_t * password);\r\n\r\nvoid My_w32_wchar_t_listen_socket_61()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n password = My_w32_wchar_t_listen_socket_61bSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nwchar_t * My_w32_wchar_t_listen_socket_61bG2BSource(wchar_t * password);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n password = My_w32_wchar_t_listen_socket_61bG2BSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nwchar_t * My_w32_wchar_t_listen_socket_61bB2GSource(wchar_t * password);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n password = My_w32_wchar_t_listen_socket_61bB2GSource(password);\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_61()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-319:Cleartext Transmission of Sensitive Information|D.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-363:Race Condition Enabling Link Following\nC.CWE-114:Process Control\nD.No Vulnerabilities\nE.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_console_53bSink(wchar_t * data);\r\n\r\nvoid My_w32_wchar_t_console_53()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n My_w32_wchar_t_console_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_console_53bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n My_w32_wchar_t_console_53bG2BSink(data);\r\n}\r\n\r\nvoid My_w32_wchar_t_console_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_console_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_console_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-123:Write-what-where Condition\nC.No Vulnerabilities\nD.CWE-1224:Improper Restriction of Write-Once Bit Fields\nE.CWE-520:.NET Misconfiguration: Use of Impersonation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(mStruct data)\r\n{\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_44()\r\n{\r\n mStruct data;\r\n \r\n void (*funcPtr) (mStruct) = mSink;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(mStruct data)\r\n{\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n void (*funcPtr) (mStruct) = nG2BSink;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n funcPtr(data);\r\n}\r\n\r\nvoid My_connect_socket_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-912:Hidden Functionality\nB.CWE-506:Embedded Malicious Code\nC.CWE-1278:Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nD.No Vulnerabilities\nE.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\n#define _SECOND ((INT64)10000000)\r\n#define _MINUTE (60 * _SECOND)\r\n#define _HOUR (60 * _MINUTE)\r\n#define _DAY (24 * _HOUR)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_file_attrib_accessed_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n FILETIME ftAccess;\r\n ULONGLONG qwResult;\r\n HANDLE hFile = INVALID_HANDLE_VALUE;\r\n do\r\n {\r\n hFile = CreateFile(TEXT(\"mFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE, \r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n if (!GetFileTime(hFile,\r\n NULL,\r\n &ftAccess,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n qwResult -= 10 * _DAY;\r\n \r\n ftAccess.dwLowDateTime = (DWORD)(qwResult & 0xFFFFFFFF);\r\n ftAccess.dwHighDateTime = (DWORD)(qwResult >> 32);\r\n \r\n SetFileTime(hFile,\r\n (LPFILETIME)NULL,\r\n &ftAccess,\r\n (LPFILETIME)NULL);\r\n }\r\n while (0);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_file_attrib_accessed_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_file_attrib_accessed_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_file_attrib_accessed_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-506:Embedded Malicious Code|A.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-841:Improper Enforcement of Behavioral Workflow\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-665:Improper Initialization\nE.CWE-109:Struts: Validator Turned Off\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_twointsclass_array_declare_no_init_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalTrue)\r\n {\r\n \r\n ; \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalTrue)\r\n {\r\n \r\n ; \r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalTrue)\r\n {\r\n \r\n ; \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass dataUninitArray[10];\r\n data = dataUninitArray;\r\n if(globalTrue)\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_twointsclass_array_declare_no_init_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-457:Use of Uninitialized Variable|D.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1284:Improper Validation of Specified Quantity in Input\nB.CWE-606:Unchecked Input for Loop Condition\nC.No Vulnerabilities\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_console_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"15\");\r\n funcPtr(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(char * data)\r\n{\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nB2GSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_console_44()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-606:Unchecked Input for Loop Condition|A.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nB.CWE-506:Embedded Malicious Code\nC.CWE-511:Logic/Time Bomb\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CompareFileTime_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CompareFileTime_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CompareFileTime_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CompareFileTime_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|B.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')\nB.CWE-510:Trapdoor\nC.CWE-665:Improper Initialization\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_wchar_t_cat_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_cat_34()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_cat_34_unionType myUnion;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_wchar_t_cat_34_unionType myUnion;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = L'\\0'; \r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_cat_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-425:Direct Request ('Forced Browsing')\nC.No Vulnerabilities\nD.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE170_char_loop_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-148:Improper Neutralization of Input Leaders\nC.CWE-617:Reachable Assertion\nD.No Vulnerabilities\nE.CWE-273:Improper Check for Dropped Privileges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <rpcdce.h>\r\n# pragma comment(lib, \"rpcrt4\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RpcImpersonateClient_05()\r\n{\r\n if(staticTrue)\r\n {\r\n RpcImpersonateClient(0);\r\n \r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n \r\n if (RpcImpersonateClient(0) != RPC_S_OK)\r\n {\r\n exit(1);\r\n }\r\n \r\n }\r\n}\r\n\r\nvoid My_w32_RpcImpersonateClient_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RpcImpersonateClient_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RpcImpersonateClient_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-273:Improper Check for Dropped Privileges|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nC.CWE-194:Unexpected Sign Extension\nD.No Vulnerabilities\nE.CWE-627:Dynamic Variable Evaluation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define CHAR_ARRAY_SIZE 8\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_memcpy_15()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n int tempInt;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n \r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n tempInt = atoi(inputBuffer);\r\n if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\r\n {\r\n data = -1;\r\n }\r\n else\r\n {\r\n data = tempInt;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = 100-1;\r\n break;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 100-1;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_listen_socket_memcpy_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_memcpy_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_memcpy_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1112:Incomplete Documentation of Program Execution\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-1119:Excessive Use of Unconditional Branching\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_malloc_65bSink(int data);\r\n\r\nvoid My_connect_socket_malloc_65()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = My_connect_socket_malloc_65bSink;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_malloc_65bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_connect_socket_malloc_65bG2BSink;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_connect_socket_malloc_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_malloc_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_malloc_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-280:Improper Handling of Insufficient Permissions or Privileges \nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_array_malloc_partial_init_13()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_array_malloc_partial_init_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_array_malloc_partial_init_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_array_malloc_partial_init_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-457:Use of Uninitialized Variable|A.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-912:Hidden Functionality\nC.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nD.No Vulnerabilities\nE.CWE-806:Buffer Access Using Size of Source Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n\r\n#define _SECOND ((INT64)10000000)\r\n#define _MINUTE (60 * _SECOND)\r\n#define _HOUR (60 * _MINUTE)\r\n#define _DAY (24 * _HOUR)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_file_attrib_created_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n FILETIME ftCreate;\r\n ULONGLONG qwResult;\r\n HANDLE hFile = INVALID_HANDLE_VALUE;\r\n do\r\n {\r\n hFile = CreateFile(TEXT(\"mFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE, \r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n break;\r\n }\r\n if (GetFileTime(hFile,\r\n &ftCreate,\r\n NULL,\r\n NULL) == 0)\r\n {\r\n break;\r\n }\r\n \r\n qwResult -= 10 * _DAY;\r\n \r\n ftCreate.dwLowDateTime = (DWORD)(qwResult & 0xFFFFFFFF);\r\n ftCreate.dwHighDateTime = (DWORD)(qwResult >> 32);\r\n \r\n SetFileTime(hFile,\r\n &ftCreate,\r\n (LPFILETIME)NULL,\r\n (LPFILETIME)NULL);\r\n }\r\n while (0);\r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n HANDLE hFile = CreateFile(TEXT(\"nFile.txt\"),\r\n GENERIC_READ | GENERIC_WRITE,\r\n 0,\r\n NULL,\r\n CREATE_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL, NULL);\r\n \r\n if (hFile != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(hFile);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_file_attrib_created_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_file_attrib_created_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_file_attrib_created_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-506:Embedded Malicious Code|B.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-324:Use of a Key Past its Expiration Date\nB.CWE-1261:Improper Handling of Single Event Upsets\nC.No Vulnerabilities\nD.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <mysql.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint placoderm_gynecomaniac = 0;\r\n\r\nunion subrogating_nonlevel \r\n{\r\n char *lambitive_uredos;\r\n double pending_paeonin;\r\n char *adieu_cappadocian;\r\n char obli_gammiest;\r\n int unseductively_modigliani;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *camises_subaxillar);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&placoderm_gynecomaniac,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *camises_subaxillar)\r\n{\r\n MYSQL_ROW row;\r\n unsigned int num_fields;\r\n my_ulonglong num_rows;\r\n MYSQL_RES *result;\r\n int i;\r\n int status;\r\n char query_buffer[1000];\r\n MYSQL *conn;\r\n unsigned int dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char * dbdatabase = 0;\r\n char use_str[150] = {0};\r\n int random_int = 0;\r\n char *crewet_dutchmen = 0;\r\n union subrogating_nonlevel britannically_jesu;\r\n ++global_variable;;\r\n if (camises_subaxillar != 0) {;\r\n britannically_jesu . lambitive_uredos = camises_subaxillar;\r\n crewet_dutchmen = ((char *)britannically_jesu . lambitive_uredos);\r\n \r\n dbhost = getenv(\"DBMYSQLHOST\");\r\n dbuser = getenv(\"DBMYSQLUSER\");\r\n dbpassword = getenv(\"DBMYSQLPASSWORD\");\r\n dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\r\n dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\r\n conn = mysql_init(0);\r\n if (conn != 0) {\r\n if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\r\n snprintf(use_str,150,\"USE %s;\", dbdatabase);\r\n if (mysql_query(conn, use_str) == 0) {\r\n \r\n\r\n srand(time(NULL));\r\n random_int = (rand() % 1000) + 100;\r\n snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, crewet_dutchmen);\r\n \r\n \r\n \r\n\r\n if (mysql_query(conn,query_buffer)) {\r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n } else {\r\n printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\r\n }\r\n \r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n mysql_close(conn);\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n else {\r\n \r\n printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\r\n }\r\n }\r\n \r\n;\r\n if (britannically_jesu . lambitive_uredos != 0) \r\n free(((char *)britannically_jesu . lambitive_uredos));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "89"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1127:Compilation with Insufficient Warnings or Errors\nB.CWE-419:Unprotected Primary Channel\nC.No Vulnerabilities\nD.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_w32_wchar_t_connect_socket_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_wchar_t_connect_socket_84\r\n{\r\npublic:\r\n My_w32_wchar_t_connect_socket_84(wchar_t * dataCopy);\r\n ~My_w32_wchar_t_connect_socket_84();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_wchar_t_connect_socket_84G2B\r\n{\r\npublic:\r\n My_w32_wchar_t_connect_socket_84G2B(wchar_t * dataCopy);\r\n ~My_w32_wchar_t_connect_socket_84G2B();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-622:Improper Validation of Function Hook Arguments\nB.CWE-79:Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nC.CWE-401:Missing Release of Memory after Effective Lifetime\nD.No Vulnerabilities\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_calloc_05()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n \r\n data = (char *)calloc(100, sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n \r\n data = (char *)calloc(100, sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n \r\n data = (char *)calloc(100, sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = (char *)ALLOCA(100*sizeof(char));\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n \r\n data = (char *)ALLOCA(100*sizeof(char));\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(staticTrue)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid My_char_calloc_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_calloc_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_calloc_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-401:Missing Release of Memory after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-780:Use of RSA Algorithm without OAEP\nC.CWE-300:Channel Accessible by Non-Endpoint\nD.CWE-127:Buffer Under-read\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_cpy_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n wchar_t * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n structType myStruct;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n structType myStruct;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_cpy_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-396:Declaration of Catch for Generic Exception\nB.CWE-564:SQL Injection: Hibernate\nC.CWE-370:Missing Check for Certificate Revocation after Initial Check\nD.CWE-705:Incorrect Control Flow Scoping\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_and_domain_error_01\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n catch (domain_error &)\r\n {\r\n \r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_and_domain_error_01; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-396:Declaration of Catch for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-670:Always-Incorrect Control Flow Implementation\nC.CWE-318:Cleartext Storage of Sensitive Information in Executable\nD.CWE-483:Incorrect Block Delimitation\nE.CWE-1301:Insufficient or Incomplete Data Removal within Hardware Component\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_semicolon_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-483:Incorrect Block Delimitation|B.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-163:Improper Neutralization of Multiple Trailing Special Elements\nC.CWE-1289:Improper Validation of Unsafe Equivalence in Input\nD.No Vulnerabilities\nE.CWE-798:Use of Hard-coded Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_03()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(5==5)\r\n {\r\n \r\n strcpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(5==5)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-259:Use of Hard-coded Password|E.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nB.CWE-1098:Data Element containing Pointer Item without Proper Copy Control Element\nC.CWE-174:Double Decoding of the Same Data\nD.No Vulnerabilities\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef union\r\n{\r\n void * unionFirst;\r\n void * unionSecond;\r\n} My_char_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_34()\r\n{\r\n void * data;\r\n My_char_34_unionType myUnion;\r\n \r\n data = NULL;\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n void * data = myUnion.unionSecond;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n My_char_34_unionType myUnion;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n void * data = myUnion.unionSecond;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\nvoid My_char_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-383:J2EE Bad Practices: Direct Use of Threads\nB.CWE-121:Stack-based Buffer Overflow\nC.CWE-1106:Insufficient Use of Symbolic Constants\nD.CWE-787:Out-of-bounds Write\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef struct _My_My_My_My_My_My_My_My_My_My_My_My_My_My_CWE806_wchar_t_declare_ncpy_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-121:Stack-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-205:Observable Behavioral Discrepancy\nB.CWE-693:Protection Mechanism Failure\nC.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nD.No Vulnerabilities\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_DES_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_DES_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_DES_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_DES_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|B.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-787:Out-of-bounds Write\nC.CWE-1220:Insufficient Granularity of Access Control\nD.CWE-1241:Use of Predictable Algorithm in Random Number Generator\nE.CWE-121:Stack-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_CWE806_wchar_t_declare_loop_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-121:Stack-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nB.No Vulnerabilities\nC.CWE-299:Improper Check for Certificate Revocation\nD.CWE-1053:Missing Documentation for Design\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_32()\r\n{\r\n void * data;\r\n void * *dataPtr1 = &data;\r\n void * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n void * data = *dataPtr1;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n void * data = *dataPtr2;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n void * *dataPtr1 = &data;\r\n void * *dataPtr2 = &data;\r\n \r\n data = NULL;\r\n {\r\n void * data = *dataPtr1;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n void * data = *dataPtr2;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\nvoid My_short_32()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-220:Storage of File With Sensitive Data Under FTP Root\nB.CWE-311:Missing Encryption of Sensitive Data\nC.No Vulnerabilities\nD.CWE-213:Exposure of Sensitive Information Due to Incompatible Policies\nE.CWE-319:Cleartext Transmission of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_listen_socket_04()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = wcslen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(password, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(password, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_04()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-319:Cleartext Transmission of Sensitive Information|B.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-346:Origin Validation Error\nB.No Vulnerabilities\nC.CWE-476:NULL Pointer Dereference\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-941:Incorrectly Specified Destination in a Communication Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_null_check_after_deref_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n if (intPointer != NULL)\r\n {\r\n *intPointer = 10;\r\n }\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n *intPointer = 10;\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n *intPointer = 10;\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_null_check_after_deref_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_null_check_after_deref_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_null_check_after_deref_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-172:Encoding Error\nC.CWE-537:Java Runtime Error Message Containing Sensitive Information\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.CWE-176:Improper Handling of Unicode Encoding\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, wchar_t *> dataMap);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n map<int, wchar_t *> dataMap;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, wchar_t *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n map<int, wchar_t *> dataMap;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, wchar_t *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n map<int, wchar_t *> dataMap;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-176:Improper Handling of Unicode Encoding|B.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-420:Unprotected Alternate Channel\nB.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-404:Improper Resource Shutdown or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_w32CloseHandle_15()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(6)\r\n {\r\n case 6:\r\n if (data != NULL)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(6)\r\n {\r\n case 6:\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fopen_w32CloseHandle_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32CloseHandle_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32CloseHandle_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1322:Use of Blocking Code in Single-threaded, Non-blocking Context\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-1074:Class with Excessively Deep Inheritance\nD.No Vulnerabilities\nE.CWE-391:Unchecked Error Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wcstombs_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wcstombs_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wcstombs_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wcstombs_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-391:Unchecked Error Condition|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1188:Initialization of a Resource with an Insecure Default\nB.CWE-912:Hidden Functionality\nC.No Vulnerabilities\nD.CWE-506:Embedded Malicious Code\nE.CWE-181:Incorrect Behavior Order: Validate Before Filter\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define FILENAME \"conf.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_file_transfer_listen_socket_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char contents[65536]; \r\n FILE * pFile;\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(contents, (int)(65535), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n contents[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, contents, strlen(contents), 0) != strlen(contents))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_file_transfer_listen_socket_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-506:Embedded Malicious Code|B.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nC.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nD.No Vulnerabilities\nE.CWE-58:Path Equivalence: Windows 8.3 Filename\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#include <process.h>\r\n#define EXECLP _wexeclp\r\n#else \r\n#define EXECLP execlp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_listen_socket_execlp_51bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_listen_socket_execlp_51()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_wchar_t_listen_socket_execlp_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_listen_socket_execlp_51bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"*.*\");\r\n My_wchar_t_listen_socket_execlp_51bG2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_listen_socket_execlp_51()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_listen_socket_execlp_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_listen_socket_execlp_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1261:Improper Handling of Single Event Upsets\nB.CWE-1339:Insufficient Precision or Accuracy of a Real Number\nC.CWE-787:Out-of-bounds Write\nD.No Vulnerabilities\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nmStruct My_connect_socket_61bSource(mStruct data);\r\n\r\nvoid My_connect_socket_61()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n data = My_connect_socket_61bSource(data);\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nmStruct My_connect_socket_61bG2BSource(mStruct data);\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n data = My_connect_socket_61bG2BSource(data);\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_61()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|C.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nB.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nC.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nD.No Vulnerabilities\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\nint stingbull_muscidae = 0;\r\nint global_variable;\r\n\r\nstruct presocialism_particularised \r\n{\r\n char *deletive_unsupplicating;\r\n double neurotropy_forepeak;\r\n char *calyptriform_unrejoicing;\r\n char reenlighten_gonadectomy;\r\n int posteens_skeins;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nstruct presocialism_particularised debugged_nonrelativeness(struct presocialism_particularised wroken_hool);\r\n#define GRAPTOLITOIDEA_CATEGORIZATION(x) cleansers_zacata((struct presocialism_particularised) x)\r\nvoid cleansers_zacata(struct presocialism_particularised bebouldered_tubinares);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n struct presocialism_particularised barghests_nominated = {0};\r\n struct presocialism_particularised rewelcome_schizophrene;\r\n char *cakchikel_ensculpture;;\r\n if (__sync_bool_compare_and_swap(&stingbull_muscidae,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cakchikel_ensculpture = getenv(\"GUMBOILS_CARES\");\r\n if (cakchikel_ensculpture != 0) {;\r\n rewelcome_schizophrene . deletive_unsupplicating = ((char *)cakchikel_ensculpture);\r\n barghests_nominated = debugged_nonrelativeness(rewelcome_schizophrene);\r\n\tGRAPTOLITOIDEA_CATEGORIZATION(barghests_nominated);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nstruct presocialism_particularised debugged_nonrelativeness(struct presocialism_particularised wroken_hool)\r\n{\r\n ++global_variable;\r\n return wroken_hool;\r\n}\r\n\r\nvoid cleansers_zacata(struct presocialism_particularised bebouldered_tubinares)\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n int nFields;\r\n int i;\r\n int j = 0;\r\n char *soliloquacious_alep = 0;\r\n ++global_variable;;\r\n soliloquacious_alep = ((char *)bebouldered_tubinares . deletive_unsupplicating);\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", soliloquacious_alep);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != 2) {\r\n \r\n printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n nFields = PQnfields(res);\r\n for (i = 0; i < nFields; i++)\r\n printf(\"%-15s\", PQfname(res, i));\r\n printf(\"\\n\\n\");\r\n \r\n for (i = 0; i < PQntuples(res); i++)\r\n {\r\n for (j = 0; j < nFields; j++)\r\n printf(\"%-15s\", PQgetvalue(res, i, j));\r\n printf(\"\\n\");\r\n }\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "89"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1222:Insufficient Granularity of Address Regions Protected by Register Locks\nC.CWE-20:Improper Input Validation\nD.CWE-129:Improper Validation of Array Index\nE.CWE-289:Authentication Bypass by Alternate Name\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint relevel_basie = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid pearten_frankish(void **formidolous_johnsonville);\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n void (*jugulates_longaville)(void **) = pearten_frankish;\r\n int vacillancy_jadwin;\r\n void **hectically_sulphones = 0;\r\n void **pluteutei_mithras = 0;\r\n void *unprotruded_tergeminate = 0;\r\n char *pallini_usefulness;;\r\n if (__sync_bool_compare_and_swap(&relevel_basie,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&pallini_usefulness,\"ISOPATHY_ABORTING\");\r\n if (pallini_usefulness != 0) {;\r\n unprotruded_tergeminate = ((void *)pallini_usefulness);\r\n vacillancy_jadwin = 1;\r\n hectically_sulphones = &unprotruded_tergeminate;\r\n pluteutei_mithras = ((void **)(((unsigned long )hectically_sulphones) * vacillancy_jadwin * vacillancy_jadwin)) + 5;\r\n jugulates_longaville(pluteutei_mithras);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid pearten_frankish(void **formidolous_johnsonville)\r\n{\r\n int i;\r\n int index;\r\n char **ptr_after = 0;\r\n unsigned char *count = 0;\r\n char **ptr_before = 0;\r\n unsigned char str_buf[40] = {0};\r\n char *grayson_miletus = 0;\r\n ++global_variable;;\r\n grayson_miletus = ((char *)((char *)( *(formidolous_johnsonville - 5))));\r\n \r\n ptr_after = malloc(sizeof(char *));\r\n if (ptr_after == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n count = malloc(sizeof(unsigned char ) * 62);\r\n if (count == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n ptr_before = malloc(sizeof(char *));\r\n if (ptr_before == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n *ptr_before = grayson_miletus;\r\n *ptr_after = grayson_miletus;\r\n strncpy((char*) str_buf,grayson_miletus,39);\r\n str_buf[39] = 0;\r\n for (i = 0; i < 62; i++) {\r\n count[i] = 0;\r\n }\r\n \r\n \r\n for (i = 0; i < strlen(grayson_miletus); i++) {\r\n \r\n \r\n if (grayson_miletus[i] > 96) {\r\n index = grayson_miletus[i] - 'a' + 36;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else if (grayson_miletus[i] < 58) {\r\n index = grayson_miletus[i] - 48;\r\n \r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n else {\r\n index = grayson_miletus[i] - 'A' + 10;\r\n if (count[index] < 255)\r\n count[index]++;\r\n }\r\n }\r\n \r\n \r\n for (i = 0; i < 62; i++)\r\n printf(\"index %d: %d\\n\",i,count[i]);\r\n printf(\"%d %d\\n\",strlen( *ptr_before),strlen( *ptr_after));\r\n if (ptr_before != 0) {\r\n free(ptr_before);\r\n }\r\n if (count != 0) {\r\n free(count);\r\n }\r\n if (ptr_after != 0) {\r\n free(ptr_after);\r\n }\r\n \r\n;\r\n if (((char *)( *(formidolous_johnsonville - 5))) != 0) \r\n free(((char *)((char *)( *(formidolous_johnsonville - 5)))));\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-129:Improper Validation of Array Index|C.CWE-20:Improper Input Validation", "cwe": "129"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-468:Incorrect Pointer Scaling\nB.CWE-1041:Use of Redundant Code\nC.CWE-153:Improper Neutralization of Substitution Characters\nD.No Vulnerabilities\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_01()\r\n{\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+(2*sizeof(int)));\r\n printIntLine(toPrint);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n}\r\n\r\nvoid My_int_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-468:Incorrect Pointer Scaling|E.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-791:Incomplete Filtering of Special Elements\nC.CWE-476:NULL Pointer Dereference\nD.CWE-420:Unprotected Alternate Channel\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint saucebox_damaskin = 0;\r\nint global_variable;\r\nvoid handle_taint(char *eleusinion_beguin);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nchar *firebreak_orm(char *chirpiest_horseback);\r\nvoid lasal_cacothelin(char *babylon_winigan);\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&saucebox_damaskin,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n#define EDEOLOGY_HEMIANOPIC(x) lasal_cacothelin((char *) x)\r\n\r\nvoid handle_taint(char *eleusinion_beguin)\r\n{\r\n char *seel_alate = 0;\r\n int elver_noncontrastive = 0;\r\n char *glutinose_dessma = 0;\r\n ++global_variable;;\r\n if (eleusinion_beguin != 0) {;\r\n elver_noncontrastive = ((int )(strlen(eleusinion_beguin)));\r\n glutinose_dessma = ((char *)(malloc(elver_noncontrastive + 1)));\r\n if (glutinose_dessma == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(glutinose_dessma,0,elver_noncontrastive + 1);\r\n memcpy(glutinose_dessma,eleusinion_beguin,elver_noncontrastive);\r\n if (eleusinion_beguin != 0) \r\n free(((char *)eleusinion_beguin));\r\n seel_alate = firebreak_orm(glutinose_dessma);\r\n\tEDEOLOGY_HEMIANOPIC(seel_alate);\r\n }\r\n}\r\n\r\nchar *firebreak_orm(char *chirpiest_horseback)\r\n{\r\n ++global_variable;\r\n return chirpiest_horseback;\r\n}\r\n\r\nvoid lasal_cacothelin(char *babylon_winigan)\r\n{\r\n char buffer[80];\r\n FILE *pFile = 0;\r\n char *woodiness_ackton = 0;\r\n ++global_variable;;\r\n woodiness_ackton = ((char *)babylon_winigan);\r\n \r\n \r\n\r\n pFile = fopen(woodiness_ackton,\"r\");\r\n buffer[0] = 0;\r\n \r\n \r\n \r\n\r\n fgets(buffer,79,pFile);\r\n printf(buffer);\r\n printf(\"\\n\");\r\n fclose(pFile);\r\n \r\n \r\n;\r\n if (babylon_winigan != 0) \r\n free(((char *)babylon_winigan));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-33:Path Traversal: '....' (Multiple Dot)\nC.CWE-912:Hidden Functionality\nD.CWE-506:Embedded Malicious Code\nE.CWE-834:Excessive Iteration\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CRLF \"\\r\\n\"\r\n#define MAIL_SERVER \"smtp.gmail.com\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_email_01()\r\n{\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n struct sockaddr_in service;\r\n struct hostent *hostIP;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char recBuffer[4096] = \"\";\r\n char msgBuffer[255] = \"\";\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n hostIP = gethostbyname(MAIL_SERVER);\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr = *((struct in_addr*)*hostIP->h_addr_list);\r\n service.sin_port = htons(25);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"HELO %s%s\", MAIL_SERVER, CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"MAIL FROM:<%s>%s\", \"sender@example.com\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"RCPT TO:<%s>%s\", \"receiver@example.com\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"DATA%s\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n sprintf(msgBuffer, \"%s%s\", \"Shhh, I'm sending some m stuff!\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"%s.%s\", CRLF, CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n \r\n sprintf(msgBuffer, \"QUIT%s\", CRLF);\r\n if (send(connectSocket, msgBuffer, strlen(msgBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n closesocket(connectSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_email_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-506:Embedded Malicious Code|C.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-476:NULL Pointer Dereference\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int * data)\r\n{\r\n \r\n printIntLine(*data);\r\n}\r\n\r\nvoid My_int_44()\r\n{\r\n int * data;\r\n \r\n void (*funcPtr) (int *) = mSink;\r\n \r\n data = NULL;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int * data)\r\n{\r\n \r\n printIntLine(*data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n int tmpData = 5;\r\n void (*funcPtr) (int *) = nG2BSink;\r\n \r\n {\r\n data = &tmpData;\r\n }\r\n funcPtr(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(int * data)\r\n{\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(*data);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n void (*funcPtr) (int *) = nB2GSink;\r\n \r\n data = NULL;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_int_44()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-122:Heap-based Buffer Overflow\nB.CWE-283:Unverified Ownership\nC.CWE-787:Out-of-bounds Write\nD.CWE-274:Improper Handling of Insufficient Privileges\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nnamespace My_cpp_My_cpp_CWE129_fgets_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-122:Heap-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.No Vulnerabilities\nC.CWE-331:Insufficient Entropy\nD.CWE-641:Improper Restriction of Names for Files and Other Resources\nE.CWE-377:Insecure Temporary File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define TEMPNAM _wtempnam\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TEMPNAM tempnam\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_tempnam_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_tempnam_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_tempnam_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_tempnam_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-377:Insecure Temporary File|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nC.CWE-127:Buffer Under-read\nD.No Vulnerabilities\nE.CWE-1118:Insufficient Documentation of Error Handling Techniques\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic char * mSource(char * data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_malloc_char_memcpy_21()\r\n{\r\n char * data;\r\n data = NULL;\r\n mStatic = 1; \r\n data = mSource(data);\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(char));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic char * nG2B1Source(char * data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(char));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic char * nG2B2Source(char * data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, 100*sizeof(char));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_char_memcpy_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_char_memcpy_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_char_memcpy_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nB.No Vulnerabilities\nC.CWE-332:Insufficient Entropy in PRNG\nD.CWE-484:Omitted Break Statement in Switch\nE.CWE-188:Reliance on Data/Memory Layout\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_modify_local_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n char *charPtr;\r\n structCharInt.charFirst = 1;\r\n charPtr = &structCharInt.charFirst;\r\n \r\n *(int*)(charPtr + sizeof(int)) = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\nvoid My_modify_local_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_modify_local_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_modify_local_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-188:Reliance on Data/Memory Layout|A.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-340:Generation of Predictable Numbers or Identifiers\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-415:Double Free\nD.No Vulnerabilities\nE.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_wchar_t_22\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint mGlobal = 0;\r\n\r\nvoid mSink(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n data = new wchar_t;\r\n \r\n delete data;\r\n mGlobal = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint nB2G1Global = 0;\r\nint nB2G2Global = 0;\r\nint nG2B1Global = 0;\r\n\r\n\r\nvoid nB2G1Sink(wchar_t * data);\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n data = new wchar_t;\r\n \r\n delete data;\r\n nB2G1Global = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nvoid nB2G2Sink(wchar_t * data);\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n data = new wchar_t;\r\n \r\n delete data;\r\n nB2G2Global = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nvoid nG2B1Sink(wchar_t * data);\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n data = new wchar_t;\r\n \r\n nG2B1Global = 1; \r\n nG2B1Sink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_wchar_t_22; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-415:Double Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-151:Improper Neutralization of Comment Delimiters\nB.CWE-673:External Influence of Sphere Definition\nC.No Vulnerabilities\nD.CWE-916:Use of Password Hash With Insufficient Computational Effort\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM system\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\ntypedef struct _My_char_system_67_structType\r\n{\r\n char * structFirst;\r\n} My_char_system_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_system_67bSink(My_char_system_67_structType myStruct);\r\n\r\nvoid My_char_system_67()\r\n{\r\n char * data;\r\n My_char_system_67_structType myStruct;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n myStruct.structFirst = data;\r\n My_char_system_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_system_67bG2BSink(My_char_system_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n My_char_system_67_structType myStruct;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n myStruct.structFirst = data;\r\n My_char_system_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_char_system_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_system_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_system_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-426:Untrusted Search Path|B.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1284:Improper Validation of Specified Quantity in Input\nB.CWE-194:Unexpected Sign Extension\nC.CWE-1268:Policy Privileges are not Assigned Consistently Between Control and Data Agents\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _My_rand_malloc_67_structType\r\n{\r\n short structFirst;\r\n} My_rand_malloc_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_rand_malloc_67bSink(My_rand_malloc_67_structType myStruct);\r\n\r\nvoid My_rand_malloc_67()\r\n{\r\n short data;\r\n My_rand_malloc_67_structType myStruct;\r\n \r\n data = 0;\r\n \r\n data = (short)RAND32();\r\n myStruct.structFirst = data;\r\n My_rand_malloc_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_rand_malloc_67bG2BSink(My_rand_malloc_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n My_rand_malloc_67_structType myStruct;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n myStruct.structFirst = data;\r\n My_rand_malloc_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_rand_malloc_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_malloc_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_malloc_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-194:Unexpected Sign Extension|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-667:Improper Locking\nC.CWE-832:Unlock of a Resource that is not Locked\nD.CWE-383:J2EE Bad Practices: Direct Use of Threads\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-832:Unlock of a Resource that is not Locked|B.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-468:Incorrect Pointer Scaling\nC.CWE-1067:Excessive Execution of Sequential Searches of Data Resource\nD.No Vulnerabilities\nE.CWE-1265:Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+(2*sizeof(int)));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-468:Incorrect Pointer Scaling|A.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nC.No Vulnerabilities\nD.CWE-293:Using Referer Field for Authentication\nE.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_new_use_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n TwoIntsClass * pointer = new TwoIntsClass;\r\n TwoIntsClass data = *pointer; \r\n delete pointer;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n TwoIntsClass data;\r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n TwoIntsClass * pointer = new TwoIntsClass;\r\n *pointer = data; \r\n {\r\n TwoIntsClass data = *pointer;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n delete pointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_new_use_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-489:Active Debug Code\nC.CWE-682:Incorrect Calculation\nD.No Vulnerabilities\nE.CWE-1042:Static Member Data Element outside of a Singleton Class Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_min_postdec_12()\r\n{\r\n short data;\r\n data = 0;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = SHRT_MIN;\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n data--;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n else\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n data--;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n short data;\r\n data = 0;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = SHRT_MIN;\r\n }\r\n else\r\n {\r\n \r\n data = SHRT_MIN;\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n data--;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n else\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n data--;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n data = 0;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = -2;\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n data--;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n data--;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_min_postdec_12()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_min_postdec_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_min_postdec_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|C.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-590:Free of Memory not on the Heap\nD.No Vulnerabilities\nE.CWE-509:Replicating Malicious Code (Virus or Worm)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_struct_declare_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct * *dataPtr1 = &data;\r\n twoIntsStruct * *dataPtr2 = &data;\r\n data = NULL; \r\n {\r\n twoIntsStruct * data = *dataPtr1;\r\n {\r\n \r\n twoIntsStruct dataBuffer;\r\n dataBuffer.intOne = 1;\r\n dataBuffer.intTwo = 1;\r\n data = &dataBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n twoIntsStruct * data = *dataPtr2;\r\n printStructLine(data);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct * *dataPtr1 = &data;\r\n twoIntsStruct * *dataPtr2 = &data;\r\n data = NULL; \r\n {\r\n twoIntsStruct * data = *dataPtr1;\r\n {\r\n \r\n twoIntsStruct * dataBuffer = new twoIntsStruct;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n twoIntsStruct * data = *dataPtr2;\r\n printStructLine(data);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_struct_declare_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-131:Incorrect Calculation of Buffer Size\nB.No Vulnerabilities\nC.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-400:Uncontrolled Resource Consumption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\nnamespace My_fgets_sleep_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(int &count);\r\n\r\nvoid m()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n mSource(count);\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(int &count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n nG2BSource(count);\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n}\r\n\r\n\r\nvoid nB2GSource(int &count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n nB2GSource(count);\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fgets_sleep_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1357:Reliance on Insufficiently Trustworthy Component\nB.No Vulnerabilities\nC.CWE-1300:Improper Protection of Physical Side Channels\nD.CWE-476:NULL Pointer Dereference\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_null_check_after_deref_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n if (intPointer != NULL)\r\n {\r\n *intPointer = 10;\r\n }\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n *intPointer = 10;\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n *intPointer = 10;\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n int *intPointer = NULL;\r\n intPointer = (int *)malloc(sizeof(int));\r\n *intPointer = 5;\r\n printIntLine(*intPointer);\r\n \r\n *intPointer = 10;\r\n printIntLine(*intPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_null_check_after_deref_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_null_check_after_deref_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_null_check_after_deref_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-476:NULL Pointer Dereference|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-296:Improper Following of a Certificate's Chain of Trust\nC.CWE-563:Assignment to Variable without Use\nD.No Vulnerabilities\nE.CWE-617:Reachable Assertion\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nstatic int My_listen_socket_45Data;\r\nstatic int My_listen_socket_45G2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n int data = My_listen_socket_45Data;\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_listen_socket_45()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_listen_socket_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n int data = My_listen_socket_45G2BData;\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n My_listen_socket_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid My_listen_socket_45()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-617:Reachable Assertion|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-396:Declaration of Catch for Generic Exception\nB.CWE-1079:Parent Class without Virtual Destructor Method\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-396:Declaration of Catch for Generic Exception|C.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-799:Improper Control of Interaction Frequency\nB.CWE-1290:Incorrect Decoding of Security Identifiers \nC.No Vulnerabilities\nD.CWE-122:Heap-based Buffer Overflow\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_c_My_c_My_c_My_c_CWE129_fscanf_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-122:Heap-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-404:Improper Resource Shutdown or Release\nB.CWE-1294:Insecure Security Identifier Mechanism\nC.CWE-1064:Invokable Control Element with Signature Containing an Excessive Number of Parameters\nD.No Vulnerabilities\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_new_int64_t_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n data = new int64_t;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n data = new int64_t;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n data = new int64_t;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n data = NULL;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n int64_t dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n \r\n int64_t dataNBuffer;\r\n data = &dataNBuffer;\r\n \r\n *data = 5LL;\r\n printLongLongLine(*data);\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_int64_t_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|A.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-663:Use of a Non-reentrant Function in a Concurrent Context\nB.CWE-1260:Improper Handling of Overlap Between Protected Memory Ranges\nC.No Vulnerabilities\nD.CWE-662:Improper Synchronization\nE.CWE-1071:Empty Code Block\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint leptomeningitis_lactocele = 0;\r\nint global_variable;\r\nvoid handle_taint(char *chronologic_premies);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid reacting_jacana(char **corkwing_multisonorous);\r\nvoid boldoine_somatically(char **opianyl_taramasalata);\r\nvoid waily_unmodifiably(char **porchlike_spece);\r\nvoid zootomical_adonizing(char **preultimate_nonexceptional);\r\nvoid ostentous_lymphopenia(char **landladyship_screeny);\r\nvoid battalions_bonding(char **boodledom_scylla);\r\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas);\r\nvoid hultgren_humuslike(char **coronatorial_rifi);\r\nvoid draisine_uncombed(char **soundproofed_vaporability);\r\nvoid journeyman_cesiums(char **affusions_hardstand);\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid arrFunc (struct data *Data) {\r\n int *arr = malloc(sizeof(int) * Data->qsize);\r\n int i;\r\n int j;\r\n FILE *fp;\r\n static int ctr;\r\n \r\n \r\n ctr = 0; \r\n for(i = 0; \r\n i < Data->data_size; \r\n i++, ctr++)\r\n {\r\n \r\n Data->data[ctr] = '\\0';\r\n printf(\"I: %d, C: %d\\n\", i, ctr);\r\n if (Data->qsize > 5) {\r\n fp = fopen(\"asdfqwer1234\", \"w+\");\r\n fprintf(fp, \"%d\", i);\r\n fclose(fp);\r\n for (j = 0; j < Data->qsize; j++) {\r\n arr[j] = Data->qsize - j;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n }\r\n }\r\n free(arr);\r\n \r\n \r\n \r\n}\r\nvoid *replaceSymbols(void *data) {\r\n struct data *Data = data;\r\n int i;\r\n \r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if (((Data->data[i] >= '!' && Data->data[i] <= '/') ||\r\n (Data->data[i] >= ':' && Data->data[i] <= '@') ||\r\n (Data->data[i] >= '[' && Data->data[i] <= '`') ||\r\n (Data->data[i] >= '{' && Data->data[i] <= '~')) &&\r\n (Data->data[i] != '@' && Data->data[i] != '.'))\r\n {\r\n Data->data[i] = '_';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\nvoid *toCaps(void *data) {\r\n struct data *Data = data;\r\n int threadTiming = 500000;\r\n int j;\r\n int *arr;\r\n int i;\r\n \r\n \r\n arr = malloc(sizeof(int)*threadTiming);\r\n if (arr != NULL) {\r\n for (j = 0; j < threadTiming; j++) {\r\n arr[j] = threadTiming - j;\r\n }\r\n qsort(arr, threadTiming, sizeof(int), &comp);\r\n free (arr);\r\n arr = NULL;\r\n }\r\n pthread_mutex_lock(&mutex);\r\n for(i = 0; i < Data->data_size; i++) {\r\n if(Data->data[i] >= 'a' && Data->data[i] <= 'z') {\r\n Data->data[i] -= 'a' - 'A';\r\n }\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n arrFunc(Data);\r\n return NULL;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&leptomeningitis_lactocele,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *chronologic_premies)\r\n{\r\n int sammy_noncommendably;\r\n char **hickishness_tubal = 0;\r\n char **erythrophage_algebraized = 0;\r\n char *frizzling_browningesque[66] = {0};\r\n ++global_variable;;\r\n if (chronologic_premies != 0) {;\r\n frizzling_browningesque[63] = chronologic_premies;\r\n sammy_noncommendably = 1;\r\n hickishness_tubal = frizzling_browningesque;\r\n erythrophage_algebraized = ((char **)(((unsigned long )hickishness_tubal) * sammy_noncommendably * sammy_noncommendably)) + 5;\r\n reacting_jacana(erythrophage_algebraized);\r\n }\r\n}\r\n\r\nvoid reacting_jacana(char **corkwing_multisonorous)\r\n{\r\n ++global_variable;;\r\n boldoine_somatically(corkwing_multisonorous);\r\n}\r\n\r\nvoid boldoine_somatically(char **opianyl_taramasalata)\r\n{\r\n ++global_variable;;\r\n waily_unmodifiably(opianyl_taramasalata);\r\n}\r\n\r\nvoid waily_unmodifiably(char **porchlike_spece)\r\n{\r\n ++global_variable;;\r\n zootomical_adonizing(porchlike_spece);\r\n}\r\n\r\nvoid zootomical_adonizing(char **preultimate_nonexceptional)\r\n{\r\n ++global_variable;;\r\n ostentous_lymphopenia(preultimate_nonexceptional);\r\n}\r\n\r\nvoid ostentous_lymphopenia(char **landladyship_screeny)\r\n{\r\n ++global_variable;;\r\n battalions_bonding(landladyship_screeny);\r\n}\r\n\r\nvoid battalions_bonding(char **boodledom_scylla)\r\n{\r\n ++global_variable;;\r\n chlorophyllian_glossopetra(boodledom_scylla);\r\n}\r\n\r\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas)\r\n{\r\n ++global_variable;;\r\n hultgren_humuslike(prioristic_bugshas);\r\n}\r\n\r\nvoid hultgren_humuslike(char **coronatorial_rifi)\r\n{\r\n ++global_variable;;\r\n draisine_uncombed(coronatorial_rifi);\r\n}\r\n\r\nvoid draisine_uncombed(char **soundproofed_vaporability)\r\n{\r\n ++global_variable;;\r\n journeyman_cesiums(soundproofed_vaporability);\r\n}\r\n\r\nvoid journeyman_cesiums(char **affusions_hardstand)\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data = malloc(sizeof(struct data));\r\n char *gasterophilus_dinitril = 0;\r\n ++global_variable;;\r\n gasterophilus_dinitril = ((char *)(affusions_hardstand - 5)[63]);\r\n \r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(gasterophilus_dinitril)+ 1));\r\n if (Data->data &&\r\n (sscanf(gasterophilus_dinitril, \"%d %s\", &Data->qsize, Data->data) == 2) &&\r\n (strlen(Data->data) != 0)) {\r\n pthread_mutex_init(&mutex, NULL);\r\n Data->data_size = strlen(Data->data);\r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, replaceSymbols, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toCaps, (void*)Data) != 0) {\r\n printf(\"Error initilizing thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex);\r\n \r\n \r\n free(Data->data);\r\n \r\n }\r\n else {\r\n printf(\"Error parsing input.\\n\");\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if ((affusions_hardstand - 5)[63] != 0) \r\n free(((char *)(affusions_hardstand - 5)[63]));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-663:Use of a Non-reentrant Function in a Concurrent Context|D.CWE-662:Improper Synchronization", "cwe": "663"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\nD.CWE-185:Incorrect Regular Expression\nE.CWE-476:NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint forestation_sparmannia = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n char buffer[80];\r\n FILE *pFile = 0;\r\n char *amenorrho_tragopan = 0;\r\n char **gauffer_hexanchidae = 0;\r\n int antigrowth_beshrewing = 0;\r\n char *misers_clavis = 0;\r\n int whatsoever_schoolma = 45;\r\n char *deprecators_bloomery;;\r\n if (__sync_bool_compare_and_swap(&forestation_sparmannia,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&deprecators_bloomery,\"3498\",whatsoever_schoolma);\r\n if (deprecators_bloomery != 0) {;\r\n antigrowth_beshrewing = ((int )(strlen(deprecators_bloomery)));\r\n misers_clavis = ((char *)(malloc(antigrowth_beshrewing + 1)));\r\n if (misers_clavis == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(misers_clavis,0,antigrowth_beshrewing + 1);\r\n memcpy(misers_clavis,deprecators_bloomery,antigrowth_beshrewing);\r\n if (deprecators_bloomery != 0) \r\n free(((char *)deprecators_bloomery));\r\n gauffer_hexanchidae = &misers_clavis;\r\n if ( *gauffer_hexanchidae != 0) {\r\n goto blasdell_intorsion;\r\n }\r\n ++global_variable;\r\n blasdell_intorsion:;\r\n amenorrho_tragopan = ((char *)( *gauffer_hexanchidae));\r\n \r\n \r\n\r\n pFile = fopen(amenorrho_tragopan,\"r\");\r\n buffer[0] = 0;\r\n \r\n \r\n \r\n\r\n fgets(buffer,79,pFile);\r\n printf(buffer);\r\n printf(\"\\n\");\r\n fclose(pFile);\r\n \r\n \r\n;\r\n if ( *gauffer_hexanchidae != 0) \r\n free(((char *)( *gauffer_hexanchidae)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-476:NULL Pointer Dereference|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.No Vulnerabilities\nC.CWE-1224:Improper Restriction of Write-Once Bit Fields\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-927:Use of Implicit Intent for Sensitive Communication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_rand_postdec_31()\r\n{\r\n char data;\r\n data = ' ';\r\n \r\n data = (char)RAND32();\r\n {\r\n char dataCopy = data;\r\n char data = dataCopy;\r\n {\r\n \r\n data--;\r\n char result = data;\r\n printHexCharLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n \r\n data = -2;\r\n {\r\n char dataCopy = data;\r\n char data = dataCopy;\r\n {\r\n \r\n data--;\r\n char result = data;\r\n printHexCharLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char data;\r\n data = ' ';\r\n \r\n data = (char)RAND32();\r\n {\r\n char dataCopy = data;\r\n char data = dataCopy;\r\n \r\n if (data > CHAR_MIN)\r\n {\r\n data--;\r\n char result = data;\r\n printHexCharLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_rand_postdec_31()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_rand_postdec_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_rand_postdec_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.CWE-316:Cleartext Storage of Sensitive Information in Memory\nC.CWE-1066:Missing Serialization Control Element\nD.CWE-272:Least Privilege Violation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_RegOpenKeyEx_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExA(\r\n HKEY_LOCAL_MACHINE,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExA(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegOpenKeyExA(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n KEY_WRITE,\r\n &hKey) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_RegOpenKeyEx_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_RegOpenKeyEx_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_RegOpenKeyEx_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-272:Least Privilege Violation|A.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1229:Creation of Emergent Resource\nB.CWE-369:Divide By Zero\nC.No Vulnerabilities\nD.CWE-149:Improper Neutralization of Quoting Syntax\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nstatic int My_int_listen_socket_modulo_45Data;\r\nstatic int My_int_listen_socket_modulo_45G2BData;\r\nstatic int My_int_listen_socket_modulo_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n int data = My_int_listen_socket_modulo_45Data;\r\n \r\n printIntLine(100 % data);\r\n}\r\n\r\nvoid My_int_listen_socket_modulo_45()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_int_listen_socket_modulo_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n int data = My_int_listen_socket_modulo_45G2BData;\r\n \r\n printIntLine(100 % data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n My_int_listen_socket_modulo_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n int data = My_int_listen_socket_modulo_45B2GData;\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 % data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_int_listen_socket_modulo_45B2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_int_listen_socket_modulo_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_listen_socket_modulo_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_listen_socket_modulo_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-369:Divide By Zero|E.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-13:ASP.NET Misconfiguration: Password in Configuration File\nC.No Vulnerabilities\nD.CWE-521:Weak Password Requirements\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_int_fscanf_divide_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<int> dataList);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n list<int> dataList;\r\n \r\n data = -1;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<int> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n list<int> dataList;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<int> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n list<int> dataList;\r\n \r\n data = -1;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_fscanf_divide_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-369:Divide By Zero|A.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-793:Only Filtering One Instance of a Special Element\nB.No Vulnerabilities\nC.CWE-697:Incorrect Comparison\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_array_wchar_t_81\r\n{\r\n\r\nclass My_new_array_wchar_t_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_array_wchar_t_81 : public My_new_array_wchar_t_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_array_wchar_t_81G2B : public My_new_array_wchar_t_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\nclass My_new_array_wchar_t_81B2G : public My_new_array_wchar_t_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-606:Unchecked Input for Loop Condition\nB.CWE-282:Improper Ownership Management\nC.CWE-1284:Improper Validation of Specified Quantity in Input\nD.CWE-203:Observable Discrepancy\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_connect_socket_15()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n strcpy(data, \"15\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcpy(data, \"15\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_connect_socket_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-606:Unchecked Input for Loop Condition|C.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\nB.No Vulnerabilities\nC.CWE-511:Logic/Time Bomb\nD.CWE-532:Insertion of Sensitive Information into Log File\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CompareFileTime_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CompareFileTime_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CompareFileTime_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CompareFileTime_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|E.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.No Vulnerabilities\nC.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nD.CWE-1392:Use of Default Credentials\nE.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_04()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_04()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nB.No Vulnerabilities\nC.CWE-393:Return of Wrong Status Code\nD.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nE.CWE-804:Guessable CAPTCHA\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_access_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-650:Trusting HTTP Permission Methods on the Server Side\nB.No Vulnerabilities\nC.CWE-567:Unsynchronized Access to Shared Data in a Multithreaded Context\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_class_new_use_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n TwoIntsClass * pointer = new TwoIntsClass;\r\n TwoIntsClass data = *pointer; \r\n delete pointer;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n TwoIntsClass data;\r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n TwoIntsClass * pointer = new TwoIntsClass;\r\n *pointer = data; \r\n {\r\n TwoIntsClass data = *pointer;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n TwoIntsClass data;\r\n data.intOne = 1;\r\n data.intTwo = 2;\r\n TwoIntsClass * pointer = new TwoIntsClass;\r\n *pointer = data; \r\n {\r\n TwoIntsClass data = *pointer;\r\n printIntLine(data.intOne);\r\n printIntLine(data.intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_new_use_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-675:Multiple Operations on Resource in Single-Operation Context\nB.CWE-585:Empty Synchronized Block\nC.No Vulnerabilities\nD.CWE-665:Improper Initialization\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_char_cat_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(char * &data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(char * &data)\r\n{\r\n \r\n data[0] = '\\0'; \r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_cat_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-588:Attempt to Access Child of a Non-structure Pointer\nB.CWE-768:Incorrect Short Circuit Evaluation\nC.CWE-360:Trust of System Event Data\nD.No Vulnerabilities\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_struct_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n void * &dataRef = data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n {\r\n void * data = dataRef;\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n void * &dataRef = data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n {\r\n void * data = dataRef;\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_struct_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-588:Attempt to Access Child of a Non-structure Pointer|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nB.CWE-259:Use of Hard-coded Password\nC.CWE-798:Use of Hard-coded Credentials\nD.No Vulnerabilities\nE.CWE-35:Path Traversal: '.../...//'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_07()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(staticFive==5)\r\n {\r\n \r\n strcpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_07()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-256:Plaintext Storage of a Password\nB.CWE-354:Improper Validation of Integrity Check Value\nC.CWE-522:Insufficiently Protected Credentials\nD.No Vulnerabilities\nE.CWE-470:Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_char_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<char *> dataList);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<char *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<char *> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-256:Plaintext Storage of a Password|C.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-560:Use of umask() with chmod-style Argument\nB.CWE-345:Insufficient Verification of Data Authenticity\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32CreateFile_no_close_53bSink(HANDLE data);\r\n\r\nvoid My_w32CreateFile_no_close_53()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n My_w32CreateFile_no_close_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32CreateFile_no_close_53bB2GSink(HANDLE data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n My_w32CreateFile_no_close_53bB2GSink(data);\r\n}\r\n\r\nvoid My_w32CreateFile_no_close_53()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_no_close_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_no_close_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-129:Improper Validation of Array Index\nB.CWE-396:Declaration of Catch for Generic Exception\nC.No Vulnerabilities\nD.CWE-166:Improper Handling of Missing Special Element\nE.CWE-705:Incorrect Control Flow Scoping\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_dotdotdot_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (...)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_dotdotdot_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-396:Declaration of Catch for Generic Exception|E.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1099:Inconsistent Naming Conventions for Identifiers\nB.CWE-333:Improper Handling of Insufficient Entropy in TRNG\nC.CWE-665:Improper Initialization\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_cat_17()\r\n{\r\n int i;\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_cat_17()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.No Vulnerabilities\nC.CWE-620:Unverified Password Change\nD.CWE-1069:Empty Exception Block\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_new_char_loop_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticTrue)\r\n {\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n size_t i;\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_loop_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-209:Generation of Error Message Containing Sensitive Information\nC.CWE-278:Insecure Preserved Inherited Permissions\nD.CWE-573:Improper Following of Specification by Caller\nE.CWE-325:Missing Cryptographic Step\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptCreateHash_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptCreateHash_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptCreateHash_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptCreateHash_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-325:Missing Cryptographic Step|D.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-839:Numeric Range Comparison Without Minimum Check\nB.CWE-416:Use After Free\nC.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\nD.No Vulnerabilities\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_new_delete_array_wchar_t_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n delete [] data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_wchar_t_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-590:Free of Memory not on the Heap\nC.No Vulnerabilities\nD.CWE-683:Function Call With Incorrect Order of Arguments\nE.CWE-104:Struts: Form Bean Does Not Extend Validation Class\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_class_placement_new_66\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(TwoIntsClass * dataArray[]);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n data = NULL; \r\n {\r\n \r\n char buffer[sizeof(TwoIntsClass)];\r\n TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n \r\n dataArray[2] = data;\r\n mSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(TwoIntsClass * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n TwoIntsClass * dataArray[5];\r\n data = NULL; \r\n {\r\n \r\n TwoIntsClass * dataBuffer = new TwoIntsClass;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n dataArray[2] = data;\r\n nG2BSink(dataArray);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_class_placement_new_66; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-590:Free of Memory not on the Heap|A.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1118:Insufficient Documentation of Error Handling Techniques\nB.No Vulnerabilities\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-1332:Improper Handling of Faults that Lead to Instruction Skips\nE.CWE-194:Unexpected Sign Extension\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n\r\n#define CHAR_ARRAY_SIZE 8\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\nstatic short My_connect_socket_malloc_45Data;\r\nstatic short My_connect_socket_malloc_45G2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n short data = My_connect_socket_malloc_45Data;\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\nvoid My_connect_socket_malloc_45()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n int tempInt;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n tempInt = atoi(inputBuffer);\r\n if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\r\n {\r\n data = -1;\r\n }\r\n else\r\n {\r\n data = tempInt;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_malloc_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n short data = My_connect_socket_malloc_45G2BData;\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n My_connect_socket_malloc_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid My_connect_socket_malloc_45()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_malloc_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_malloc_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-194:Unexpected Sign Extension|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nB.No Vulnerabilities\nC.CWE-511:Logic/Time Bomb\nD.CWE-506:Embedded Malicious Code\nE.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CompareFileTime_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CompareFileTime_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CompareFileTime_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CompareFileTime_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|D.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.No Vulnerabilities\nC.CWE-1086:Class with Excessive Number of Child Classes\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_listen_socket_sleep_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_listen_socket_sleep_83\r\n{\r\npublic:\r\n My_listen_socket_sleep_83(int countCopy);\r\n ~My_listen_socket_sleep_83();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_listen_socket_sleep_83G2B\r\n{\r\npublic:\r\n My_listen_socket_sleep_83G2B(int countCopy);\r\n ~My_listen_socket_sleep_83G2B();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\nclass My_listen_socket_sleep_83B2G\r\n{\r\npublic:\r\n My_listen_socket_sleep_83B2G(int countCopy);\r\n ~My_listen_socket_sleep_83B2G();\r\n\r\nprivate:\r\n int count;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-1255:Comparison Logic is Vulnerable to Power Side-Channel Attacks\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.No Vulnerabilities\nE.CWE-97:Improper Neutralization of Server-Side Includes (SSI) Within a Web Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_01()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|A.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1115:Source Code Element without Standard Prologue\nC.CWE-682:Incorrect Calculation\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-285:Improper Authorization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_max_preinc_13()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = LLONG_MAX;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = LLONG_MAX;\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data < LLONG_MAX)\r\n {\r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = LLONG_MAX;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n if (data < LLONG_MAX)\r\n {\r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 2;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = 2;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int64_t_max_preinc_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_max_preinc_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_max_preinc_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-190:Integer Overflow or Wraparound|C.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-605:Multiple Binds to the Same Port\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-412:Unrestricted Externally Accessible Lock\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n#ifdef _WIN32\r\n BOOL bOptVal = TRUE;\r\n int bOptLen = sizeof(BOOL);\r\n#else\r\n int bOptVal = 1;\r\n int bOptLen = sizeof(int);\r\n#endif\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-605:Multiple Binds to the Same Port|C.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "605"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-638:Not Using Complete Mediation\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.No Vulnerabilities\nD.CWE-1318:Missing Support for Security Features in On-chip Fabrics or Buses\nE.CWE-413:Improper Resource Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nstatic wchar_t * mSource(wchar_t * password)\r\n{\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n return password;\r\n}\r\n\r\nvoid My_w32_wchar_t_42()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n password = mSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic wchar_t * nG2BSource(wchar_t * password)\r\n{\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n return password;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n password = nG2BSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|E.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-506:Embedded Malicious Code\nC.CWE-510:Trapdoor\nD.No Vulnerabilities\nE.CWE-829:Inclusion of Functionality from Untrusted Control Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_connection_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(80);\r\n \r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_connection_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-510:Trapdoor|B.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-523:Unprotected Transport of Credentials\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-194:Unexpected Sign Extension\nD.CWE-580:clone() Method Without super.clone()\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_listen_socket_memmove_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_listen_socket_memmove_83\r\n{\r\npublic:\r\n My_listen_socket_memmove_83(short dataCopy);\r\n ~My_listen_socket_memmove_83();\r\n\r\nprivate:\r\n short data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_listen_socket_memmove_83G2B\r\n{\r\npublic:\r\n My_listen_socket_memmove_83G2B(short dataCopy);\r\n ~My_listen_socket_memmove_83G2B();\r\n\r\nprivate:\r\n short data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-459:Incomplete Cleanup\nB.No Vulnerabilities\nC.CWE-1109:Use of Same Variable for Multiple Purposes\nD.CWE-643:Improper Neutralization of Data within XPath Expressions ('XPath Injection')\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|A.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-26:Path Traversal: '/dir/../filename'\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-1109:Use of Same Variable for Multiple Purposes\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\n#include <sys/stat.h> \r\nint upsloping_nipmuc = 0;\r\nint global_variable;\r\nvoid handle_taint(char *alexanderson_adamina);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid cursedest_recaptivate(int meara_homesites,... );\r\nvoid overfertilizes_bandsman(char *kiswa_mythomaniac);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&upsloping_nipmuc,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *alexanderson_adamina)\r\n{\r\n int cuproid_airfoils = 0;\r\n char *lampong_enforcer = 0;\r\n ++global_variable;;\r\n if (alexanderson_adamina != 0) {;\r\n cuproid_airfoils = ((int )(strlen(alexanderson_adamina)));\r\n lampong_enforcer = ((char *)(malloc(cuproid_airfoils + 1)));\r\n if (lampong_enforcer == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(lampong_enforcer,0,cuproid_airfoils + 1);\r\n memcpy(lampong_enforcer,alexanderson_adamina,cuproid_airfoils);\r\n if (alexanderson_adamina != 0) \r\n free(((char *)alexanderson_adamina));\r\n cursedest_recaptivate(1,lampong_enforcer);\r\n }\r\n}\r\n#define INMESHED_COADMIRED(x) overfertilizes_bandsman((char *) x)\r\n\r\nvoid cursedest_recaptivate(int meara_homesites,... )\r\n{\r\n char *preobservation_list = 0;\r\n va_list flavius_hysterometer;\r\n ++global_variable;;\r\n if (meara_homesites > 0) {\r\n __builtin_va_start(flavius_hysterometer,meara_homesites);\r\n preobservation_list = (va_arg(flavius_hysterometer,char *));\r\n __builtin_va_end(flavius_hysterometer);\r\n }\r\n\tINMESHED_COADMIRED(preobservation_list);\r\n}\r\n\r\nvoid overfertilizes_bandsman(char *kiswa_mythomaniac)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *chromized_forepole = 0;\r\n ++global_variable;;\r\n chromized_forepole = ((char *)kiswa_mythomaniac);\r\n \r\n if (strlen(chromized_forepole) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(chromized_forepole) == 1) {\r\n parsed_input = malloc((strlen(chromized_forepole)+1) * sizeof(char));\r\n urlDecode(chromized_forepole, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (kiswa_mythomaniac != 0) \r\n free(((char *)kiswa_mythomaniac));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-121:Stack-based Buffer Overflow\nB.CWE-1117:Callable with Insufficient Behavioral Summary\nC.CWE-787:Out-of-bounds Write\nD.No Vulnerabilities\nE.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_My_My_My_My_My_My_My_CWE805_char_declare_ncat_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-121:Stack-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-549:Missing Password Field Masking\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-682:Incorrect Calculation\nE.CWE-468:Incorrect Pointer Scaling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+(2*sizeof(int)));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-468:Incorrect Pointer Scaling|D.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1125:Excessive Attack Surface\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-197:Numeric Truncation Error\nD.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_connect_socket_to_short_07()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\nvoid My_int_connect_socket_to_short_07()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_to_short_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_to_short_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-197:Numeric Truncation Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-540:Inclusion of Sensitive Information in Source Code\nB.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nC.CWE-188:Reliance on Data/Memory Layout\nD.CWE-195:Signed to Unsigned Conversion Error\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_union_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n union\r\n {\r\n struct\r\n {\r\n char charFirst, charSecond, charThird, charFourth;\r\n } structChars;\r\n long longNumber;\r\n } unionStructLong;\r\n unionStructLong.longNumber = 0x10203040;\r\n \r\n unionStructLong.structChars.charFourth |= 0x80; \r\n printIntLine(unionStructLong.longNumber);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n}\r\n\r\nvoid My_union_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_union_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_union_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-188:Reliance on Data/Memory Layout|B.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-256:Plaintext Storage of a Password\nB.No Vulnerabilities\nC.CWE-478:Missing Default Case in Multiple Condition Expression\nD.CWE-314:Cleartext Storage in the Registry\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nnamespace My_w32_wchar_t_82\r\n{\r\n\r\nclass My_w32_wchar_t_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_wchar_t_82 : public My_w32_wchar_t_82_base\r\n{\r\npublic:\r\n void action(wchar_t * data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_wchar_t_82G2B : public My_w32_wchar_t_82_base\r\n{\r\npublic:\r\n void action(wchar_t * data);\r\n};\r\n\r\nclass My_w32_wchar_t_82B2G : public My_w32_wchar_t_82_base\r\n{\r\npublic:\r\n void action(wchar_t * data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-153:Improper Neutralization of Substitution Characters\nB.CWE-590:Free of Memory not on the Heap\nC.No Vulnerabilities\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_struct_static_53\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(twoIntsStruct * data);\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n {\r\n \r\n static twoIntsStruct dataBuffer;\r\n dataBuffer.intOne = 1;\r\n dataBuffer.intTwo = 1;\r\n data = &dataBuffer;\r\n }\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(twoIntsStruct * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n {\r\n \r\n twoIntsStruct * dataBuffer = new twoIntsStruct;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n nG2BSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_struct_static_53; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-590:Free of Memory not on the Heap|D.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-72:Improper Handling of Apple HFS+ Alternate Data Stream Path\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.CWE-605:Multiple Binds to the Same Port\nE.CWE-394:Unexpected Status Code or Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n#ifdef _WIN32\r\n BOOL bOptVal = TRUE;\r\n int bOptLen = sizeof(BOOL);\r\n#else\r\n int bOptVal = 1;\r\n int bOptLen = sizeof(int);\r\n#endif\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_basic_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-605:Multiple Binds to the Same Port|C.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "605"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-25:Path Traversal: '/../filedir'\nE.CWE-796:Only Filtering Special Elements Relative to a Marker\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_rand_divide_10()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = RAND32();\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = RAND32();\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = RAND32();\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 7;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = 7;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n printIntLine(100 / data);\r\n }\r\n}\r\n\r\nvoid My_int_rand_divide_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_rand_divide_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_rand_divide_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|B.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-363:Race Condition Enabling Link Following\nB.CWE-62:UNIX Hard Link\nC.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nD.No Vulnerabilities\nE.CWE-301:Reflection Attack in an Authentication Protocol\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint jinx_kulturkampf = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid irregeneracy_lipopexia(int counterearth_chironomic,char **gimels_sizzlingly);\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n \r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForChange(char* file, char* sleepFile) {\r\n int fd;\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForChange\\n\");\r\n strcat(filename, file);\r\n strcat(filename, \".pid\");\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n printf(\"Error writing to file.\");\r\n }\r\n \r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n readFile(sleepFile);\r\n }\r\n}\r\nint path_is_relative(char *path) {\r\n char *chr = 0;\r\n \r\n chr = strchr(path,'/');\r\n if (chr == 0) {\r\n \r\n printf(\"Path is relative\\n\");\r\n return 1;\r\n } else {\r\n \r\n printf(\"Path is not relative\\n\");\r\n return 0;\r\n }\r\n}\r\nchar * get_absolute_path(char * path) {\r\n char * abs_path = malloc (sizeof(char) * (strlen(\"/opt//workspace/testData/\") * strlen(path) + 1));\r\n \r\n if (abs_path == NULL) {\r\n printf(\"Cannot allocate memory for path\\n\");\r\n } else {\r\n printf(\"Creating absolute path\\n\");\r\n strcpy(abs_path, \"/opt//workspace/testData/\");\r\n strcat(abs_path, path);\r\n }\r\n return abs_path;\r\n}\r\nint isSymLink(char *file) {\r\n struct stat statbuf;\r\n \r\n if (lstat(file, &statbuf) < 0) { \r\n printf(\"Error accessing path.\\n\");\r\n return 1; \r\n }\r\n if (S_ISLNK(statbuf.st_mode) == 1) {\r\n printf(\"Path is symlink.\\n\");\r\n return 1;\r\n }\r\n printf(\"Path is valid.\\n\");\r\n return 0;\r\n}\r\nint path_is_not_symlink(char * abs_path) {\r\n \r\n return (isSymLink(abs_path) == 0);\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n int nonaffilliated_nabalism = 7;\r\n char **eradiate_obligingly = 0;\r\n char *larbolins_traducent[82] = {0};\r\n char *tetrabelodon_sunfish;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&jinx_kulturkampf,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n tetrabelodon_sunfish = getenv(\"RHIZODERMIS_HANDWRITINGS\");\r\n if (tetrabelodon_sunfish != 0) {;\r\n larbolins_traducent[76] = tetrabelodon_sunfish;\r\n eradiate_obligingly = larbolins_traducent;\r\n irregeneracy_lipopexia(nonaffilliated_nabalism,eradiate_obligingly);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid irregeneracy_lipopexia(int counterearth_chironomic,char **gimels_sizzlingly)\r\n{\r\n int size = 0;\r\n FILE *file = 0;\r\n char *buffer = 0;\r\n char *str = 0;\r\n char *abs_path = 0;\r\n char *sleep_file = 0;\r\n char *antimalarial_colmesneil = 0;\r\n ++global_variable;\r\n counterearth_chironomic--;\r\n if (counterearth_chironomic > 0) {\r\n irregeneracy_lipopexia(counterearth_chironomic,gimels_sizzlingly);\r\n return ;\r\n }\r\n antimalarial_colmesneil = ((char *)gimels_sizzlingly[76]);\r\n \r\n str = malloc(sizeof(char) * (strlen(antimalarial_colmesneil) + 1));\r\n sleep_file = malloc(sizeof(char) * (strlen(antimalarial_colmesneil) + 1));\r\n if (str != NULL && sleep_file != NULL &&\r\n (sscanf(antimalarial_colmesneil, \"%s %s\",\r\n sleep_file,\r\n str) == 2) &&\r\n (strlen(str) != 0) &&\r\n (strlen(sleep_file) != 0))\r\n {\r\n \r\n \r\n if (path_is_relative(str)) {\r\n abs_path = get_absolute_path(str);\r\n if (abs_path != NULL) {\r\n if (path_is_not_symlink(abs_path)) {\r\n \r\n \r\n waitForChange(abs_path, sleep_file);\r\n file = fopen(abs_path,\"rb\");\r\n \r\n if (file != 0) {\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\r\n if (buffer) {\r\n \r\n \r\n fread(buffer,sizeof(char ),size,file);\r\n buffer[size] = '\\0';\r\n printf(buffer);\r\n fclose(file);\r\n free(buffer);\r\n \r\n }\r\n }\r\n }\r\n free (abs_path);\r\n }\r\n }\r\n free(str);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n;\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-363:Race Condition Enabling Link Following|C.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition", "cwe": "363"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-705:Incorrect Control Flow Scoping\nC.CWE-396:Declaration of Catch for Generic Exception\nD.CWE-577:EJB Bad Practices: Use of Sockets\nE.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_exception_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-396:Declaration of Catch for Generic Exception|B.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling\nC.No Vulnerabilities\nD.CWE-912:Hidden Functionality\nE.CWE-283:Unverified Ownership\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define FILENAME \"conf.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_file_transfer_connect_socket_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char contents[65536]; \r\n FILE * pFile;\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(contents, (int)(65535), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n contents[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(connectSocket, contents, strlen(contents), 0) != strlen(contents))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_file_transfer_connect_socket_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-506:Embedded Malicious Code|D.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.CWE-1053:Missing Documentation for Design\nC.CWE-377:Insecure Temporary File\nD.No Vulnerabilities\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define TMPNAM tmpnam\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TMPNAM tmpnam\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_tmpnam_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char * filename;\r\n int fileDesc;\r\n filename = TMPNAM(NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_tmpnam_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_tmpnam_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_tmpnam_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-377:Insecure Temporary File|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-341:Predictable from Observable State\nC.No Vulnerabilities\nD.CWE-682:Incorrect Calculation\nE.CWE-642:External Control of Critical State Data\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\nint paraders_nonsubstitutive = 0;\r\nint global_variable;\r\n\r\nunion cinchonia_contriturate \r\n{\r\n char *vagrance_scutch;\r\n double wodeleie_visually;\r\n char *isobathic_mirly;\r\n char pamprodactylism_hole;\r\n int beetlike_singhal;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid ramean_androdynamous(int moonish_instantiate,union cinchonia_contriturate *unscarred_apreynte);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int desmotropic_pseudocarcinoid = 7;\r\n union cinchonia_contriturate *endodontically_pliability = {0};\r\n union cinchonia_contriturate novendial_equimolar;\r\n int myoneuralgia_prepuces = 5;\r\n char *urethrovesical_concaptive;;\r\n if (__sync_bool_compare_and_swap(&paraders_nonsubstitutive,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&urethrovesical_concaptive,\"1993\",myoneuralgia_prepuces);\r\n if (urethrovesical_concaptive != 0) {;\r\n novendial_equimolar . vagrance_scutch = urethrovesical_concaptive;\r\n endodontically_pliability = &novendial_equimolar;\r\n ramean_androdynamous(desmotropic_pseudocarcinoid,endodontically_pliability);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid ramean_androdynamous(int moonish_instantiate,union cinchonia_contriturate *unscarred_apreynte)\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *itabuna_anchusins = 0;\r\n ++global_variable;\r\n moonish_instantiate--;\r\n if (moonish_instantiate > 0) {\r\n ramean_androdynamous(moonish_instantiate,unscarred_apreynte);\r\n return ;\r\n }\r\n itabuna_anchusins = ((char *)( *unscarred_apreynte) . vagrance_scutch);\r\n \r\n input = atoi(itabuna_anchusins);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\n if (( *unscarred_apreynte) . vagrance_scutch != 0) \r\n free(((char *)( *unscarred_apreynte) . vagrance_scutch));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-170:Improper Null Termination\nB.CWE-585:Empty Synchronized Block\nC.No Vulnerabilities\nD.CWE-665:Improper Initialization\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic char * mSource(char * data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n ; \r\n }\r\n return data;\r\n}\r\n\r\nvoid My_char_cat_21()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n mStatic = 1; \r\n data = mSource(data);\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic char * nG2B1Source(char * data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic char * nG2B2Source(char * data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_cat_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_cat_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_cat_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-87:Improper Neutralization of Alternate XSS Syntax\nB.CWE-396:Declaration of Catch for Generic Exception\nC.CWE-565:Reliance on Cookies without Validation and Integrity Checking\nD.CWE-317:Cleartext Storage of Sensitive Information in GUI\nE.No Vulnerabilities\n", "input": "int ssl_get_new_session(SSL *s, int session)\r\r\n{\r\r\n /* This gets used by clients and servers. */\r\r\n\r\r\n unsigned int tmp;\r\r\n SSL_SESSION *ss = NULL;\r\r\n GEN_SESSION_CB cb = def_generate_session_id;\r\r\n\r\r\n if ((ss = SSL_SESSION_new()) == NULL)\r\r\n return (0);\r\r\n\r\r\n /* If the context has a default timeout, use it */\r\r\n if (s->session_ctx->session_timeout == 0)\r\r\n ss->timeout = SSL_get_default_timeout(s);\r\r\n else\r\r\n ss->timeout = s->session_ctx->session_timeout;\r\r\n\r\r\n SSL_SESSION_free(s->session);\r\r\n s->session = NULL;\r\r\n\r\r\n if (session) {\r\r\n if (s->version == SSL3_VERSION) {\r\r\n ss->ssl_version = SSL3_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == TLS1_VERSION) {\r\r\n ss->ssl_version = TLS1_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == TLS1_1_VERSION) {\r\r\n ss->ssl_version = TLS1_1_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == TLS1_2_VERSION) {\r\r\n ss->ssl_version = TLS1_2_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == DTLS1_M_VER) {\r\r\n ss->ssl_version = DTLS1_M_VER;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == DTLS1_VERSION) {\r\r\n ss->ssl_version = DTLS1_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else if (s->version == DTLS1_2_VERSION) {\r\r\n ss->ssl_version = DTLS1_2_VERSION;\r\r\n ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\r\r\n } else {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n\r\r\n /*-\r\r\n * If RFC5077 ticket, use empty session ID (as server).\r\r\n * Note that:\r\r\n * (a) ssl_get_prev_session() does lookahead into the\r\r\n * ClientHello extensions to find the session ticket.\r\r\n * When ssl_get_prev_session() fails, s3_srvr.c calls\r\r\n * ssl_get_new_session() in ssl3_get_client_hello().\r\r\n * At that point, it has not yet parsed the extensions,\r\r\n * however, because of the lookahead, it already knows\r\r\n * whether a ticket is expected or not.\r\r\n *\r\r\n * (b) s3_clnt.c calls ssl_get_new_session() before parsing\r\r\n * ServerHello extensions, and before recording the session\r\r\n * ID received from the server, so this block is a noop.\r\r\n */\r\r\n if (s->tlsext_ticket_expected) {\r\r\n ss->session_id_length = 0;\r\r\n goto sess_id_done;\r\r\n }\r\r\n\r\r\n /* Choose which callback will set the session ID */\r\r\n CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\r\r\n if (s->generate_session_id)\r\r\n cb = s->generate_session_id;\r\r\n else if (s->session_ctx->generate_session_id)\r\r\n cb = s->session_ctx->generate_session_id;\r\r\n CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\r\r\n /* Choose a session ID */\r\r\n tmp = ss->session_id_length;\r\r\n if (!cb(s, ss->session_id, &tmp)) {\r\r\n /* The callback failed */\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION,\r\r\n SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n /*\r\r\n * Don't allow the callback to set the session length to zero. nor\r\r\n * set it higher than it was.\r\r\n */\r\r\n if (!tmp || (tmp > ss->session_id_length)) {\r\r\n /* The callback set an illegal length */\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION,\r\r\n SSL_R_SSL_SESSION_ID_HAS_M_LENGTH);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n ss->session_id_length = tmp;\r\r\n /* Finally, check for a conflict */\r\r\n if (SSL_has_matching_session_id(s, ss->session_id,\r\r\n ss->session_id_length)) {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_SSL_SESSION_ID_CONFLICT);\r\r\n SSL_SESSION_free(ss);\r\r\n return (0);\r\r\n }\r\r\n\r\r\n sess_id_done:\r\r\n if (s->tlsext_hostname) {\r\r\n ss->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\r\r\n if (ss->tlsext_hostname == NULL) {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);\r\r\n SSL_SESSION_free(ss);\r\r\n return 0;\r\r\n }\r\r\n }\r\r\n } else {\r\r\n ss->session_id_length = 0;\r\r\n }\r\r\n\r\r\n if (s->sid_ctx_length > sizeof ss->sid_ctx) {\r\r\n SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);\r\r\n SSL_SESSION_free(ss);\r\r\n return 0;\r\r\n }\r\r\n memcpy(ss->sid_ctx, s->sid_ctx, s->sid_ctx_length);\r\r\n ss->sid_ctx_length = s->sid_ctx_length;\r\r\n s->session = ss;\r\r\n ss->ssl_version = s->version;\r\r\n ss->verify_result = X509_V_OK;\r\r\n\r\r\n return (1);\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.No Vulnerabilities|E.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1223:Race Condition for Write-Once Attributes\nC.CWE-1066:Missing Serialization Control Element\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_twoIntsStruct_realloc_22Global = 0;\r\n\r\nvoid My_twoIntsStruct_realloc_22Sink(twoIntsStruct * data);\r\n\r\nvoid My_twoIntsStruct_realloc_22()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL;\r\n \r\n data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine(&data[0]);\r\n My_twoIntsStruct_realloc_22Global = 1; \r\n My_twoIntsStruct_realloc_22Sink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_twoIntsStruct_realloc_22B2G1Global = 0;\r\nint My_twoIntsStruct_realloc_22B2G2Global = 0;\r\nint My_twoIntsStruct_realloc_22G2BGlobal = 0;\r\n\r\n\r\nvoid My_twoIntsStruct_realloc_22B2G1Sink(twoIntsStruct * data);\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL;\r\n \r\n data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine(&data[0]);\r\n My_twoIntsStruct_realloc_22B2G1Global = 0; \r\n My_twoIntsStruct_realloc_22B2G1Sink(data);\r\n}\r\n\r\n\r\nvoid My_twoIntsStruct_realloc_22B2G2Sink(twoIntsStruct * data);\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL;\r\n \r\n data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine(&data[0]);\r\n My_twoIntsStruct_realloc_22B2G2Global = 1; \r\n My_twoIntsStruct_realloc_22B2G2Sink(data);\r\n}\r\n\r\n\r\nvoid My_twoIntsStruct_realloc_22G2BSink(twoIntsStruct * data);\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL;\r\n \r\n data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine(&data[0]);\r\n My_twoIntsStruct_realloc_22G2BGlobal = 1; \r\n My_twoIntsStruct_realloc_22G2BSink(data);\r\n}\r\n\r\nvoid My_twoIntsStruct_realloc_22()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_twoIntsStruct_realloc_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_twoIntsStruct_realloc_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-842:Placement of User into Incorrect Group\nB.No Vulnerabilities\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-1334:Unauthorized Error Injection Can Degrade Hardware Redundancy\nE.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint eusporangiate_fisheater = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid womanfully_ochrea(char **const foreguess_anguille);\r\nvoid chun_beadily(char **faradising_jeavons);\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n char *phytochlorin_kiddy[79] = {0};\r\n char *nickelized_gillar;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&eusporangiate_fisheater,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n nickelized_gillar = getenv(\"ANTIMALARIAL_BECUMBER\");\r\n if (nickelized_gillar != 0) {;\r\n phytochlorin_kiddy[49] = nickelized_gillar;\r\n womanfully_ochrea(phytochlorin_kiddy);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid womanfully_ochrea(char **const foreguess_anguille)\r\n{\r\n void (*bonnetlike_dibranch)(char **) = chun_beadily;\r\n ++global_variable;;\r\n bonnetlike_dibranch(foreguess_anguille);\r\n}\r\n\r\nvoid chun_beadily(char **faradising_jeavons)\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n int nFields;\r\n int i;\r\n int j = 0;\r\n char *papilla_fertileness = 0;\r\n ++global_variable;;\r\n papilla_fertileness = ((char *)((char **)faradising_jeavons)[49]);\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", papilla_fertileness);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != 2) {\r\n \r\n printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n nFields = PQnfields(res);\r\n for (i = 0; i < nFields; i++)\r\n printf(\"%-15s\", PQfname(res, i));\r\n printf(\"\\n\\n\");\r\n \r\n for (i = 0; i < PQntuples(res); i++)\r\n {\r\n for (j = 0; j < nFields; j++)\r\n printf(\"%-15s\", PQgetvalue(res, i, j));\r\n printf(\"\\n\");\r\n }\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "89"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1192:System-on-Chip (SoC) Using Components without Unique, Immutable Identifiers\nB.No Vulnerabilities\nC.CWE-770:Allocation of Resources Without Limits or Throttling\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_malloc_wchar_t_fscanf_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n size_t &dataRef = data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n {\r\n size_t data = dataRef;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n size_t &dataRef = data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n {\r\n size_t data = dataRef;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n size_t &dataRef = data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n {\r\n size_t data = dataRef;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_wchar_t_fscanf_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-789:Memory Allocation with Excessive Size Value|C.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-28:Path Traversal: '..\\filedir'\nB.No Vulnerabilities\nC.CWE-467:Use of sizeof() on a Pointer Type\nD.CWE-1077:Floating Point Comparison with Incorrect Operator\nE.CWE-131:Incorrect Calculation of Buffer Size\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n short * mShort = NULL;\r\n \r\n mShort = (short *)malloc(sizeof(mShort));\r\n if (mShort == NULL) {exit(-1);}\r\n *mShort = 5;\r\n printShortLine(*mShort);\r\n free(mShort);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n short * nShort = NULL;\r\n \r\n nShort = (short *)malloc(sizeof(*nShort));\r\n if (nShort == NULL) {exit(-1);}\r\n *nShort = 6;\r\n printShortLine(*nShort);\r\n free(nShort);\r\n }\r\n}\r\n\r\nvoid My_short_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-467:Use of sizeof() on a Pointer Type|E.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nB.CWE-325:Missing Cryptographic Step\nC.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nD.No Vulnerabilities\nE.CWE-573:Improper Following of Specification by Caller\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptHashData_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptHashData_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptHashData_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptHashData_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-325:Missing Cryptographic Step|E.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nB.CWE-104:Struts: Form Bean Does Not Extend Validation Class\nC.No Vulnerabilities\nD.CWE-1098:Data Element containing Pointer Item without Proper Copy Control Element\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fopen_no_close_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fopen_no_close_83\r\n{\r\npublic:\r\n My_fopen_no_close_83(FILE * dataCopy);\r\n ~My_fopen_no_close_83();\r\n\r\nprivate:\r\n FILE * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fopen_no_close_83B2G\r\n{\r\npublic:\r\n My_fopen_no_close_83B2G(FILE * dataCopy);\r\n ~My_fopen_no_close_83B2G();\r\n\r\nprivate:\r\n FILE * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-204:Observable Response Discrepancy\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-369:Divide By Zero\nE.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic int My_int_rand_divide_45Data;\r\nstatic int My_int_rand_divide_45G2BData;\r\nstatic int My_int_rand_divide_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n int data = My_int_rand_divide_45Data;\r\n \r\n printIntLine(100 / data);\r\n}\r\n\r\nvoid My_int_rand_divide_45()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n My_int_rand_divide_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n int data = My_int_rand_divide_45G2BData;\r\n \r\n printIntLine(100 / data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n My_int_rand_divide_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n int data = My_int_rand_divide_45B2GData;\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n My_int_rand_divide_45B2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_int_rand_divide_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_rand_divide_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_rand_divide_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-369:Divide By Zero|B.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1328:Security Version Number Mutable to Older Versions\nB.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nC.No Vulnerabilities\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_short_min_multiply_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(short &data);\r\n\r\nvoid m()\r\n{\r\n short data;\r\n data = 0;\r\n mSource(data);\r\n if(data < 0) \r\n {\r\n \r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(short &data);\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n data = 0;\r\n nG2BSource(data);\r\n if(data < 0) \r\n {\r\n \r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n\r\nvoid nB2GSource(short &data);\r\n\r\nstatic void nB2G()\r\n{\r\n short data;\r\n data = 0;\r\n nB2GSource(data);\r\n if(data < 0) \r\n {\r\n \r\n if (data > (SHRT_MIN/2))\r\n {\r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too small to perform multiplication.\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_short_min_multiply_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-836:Use of Password Hash Instead of Password for Authentication\nB.CWE-670:Always-Incorrect Control Flow Implementation\nC.CWE-656:Reliance on Security Through Obscurity\nD.No Vulnerabilities\nE.CWE-483:Incorrect Block Delimitation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_semicolon_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-483:Incorrect Block Delimitation|B.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.CWE-537:Java Runtime Error Message Containing Sensitive Information\nC.CWE-256:Plaintext Storage of a Password\nD.No Vulnerabilities\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_32()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_32()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-510:Trapdoor\nC.CWE-382:J2EE Bad Practices: Use of System.exit()\nD.CWE-42:Path Equivalence: 'filename.' (Trailing Dot)\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <ws2tcpip.h>\r\n#else\r\n#include <netdb.h>\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_hostname_based_logic_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char hostname[NI_MAXHOST];\r\n char servInfo[NI_MAXSERV];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n if (getnameinfo((struct sockaddr *)&acceptService,\r\n sizeof(struct sockaddr),\r\n hostname,\r\n NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"admin.google.com\", hostname) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_hostname_based_logic_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_hostname_based_logic_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_hostname_based_logic_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|E.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nB.CWE-531:Inclusion of Sensitive Information in Test Code\nC.CWE-732:Incorrect Permission Assignment for Critical Resource\nD.No Vulnerabilities\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic int64_t * mSource(int64_t * data)\r\n{\r\n \r\n data = (int64_t *)malloc(1*sizeof(int64_t));\r\n return data;\r\n}\r\n\r\nvoid My_int64_t_malloc_42()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n data = mSource(data);\r\n \r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic int64_t * nB2GSource(int64_t * data)\r\n{\r\n \r\n data = (int64_t *)malloc(1*sizeof(int64_t));\r\n return data;\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n data = NULL; \r\n data = nB2GSource(data);\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_int64_t_malloc_42()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_malloc_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_malloc_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-690:Unchecked Return Value to NULL Pointer Dereference|E.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-760:Use of a One-Way Hash with a Predictable Salt\nB.CWE-1294:Insecure Security Identifier Mechanism\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_accept_bind_listen_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_accept_bind_listen_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_accept_bind_listen_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_accept_bind_listen_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1054:Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer\nB.No Vulnerabilities\nC.CWE-363:Race Condition Enabling Link Following\nD.CWE-457:Use of Uninitialized Variable\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double_array_alloca_partial_init_09()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<(10/2); i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double_array_alloca_partial_init_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double_array_alloca_partial_init_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double_array_alloca_partial_init_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-457:Use of Uninitialized Variable|E.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-480:Use of Incorrect Operator\nC.CWE-1342:Information Exposure through Microarchitectural State after Transient Execution\nD.No Vulnerabilities\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic char* staticStringM = \"Hello\";\r\nstatic char* staticStringN = \"Hello\";\r\n\r\nstatic char * helperM()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringM;\r\n }\r\n}\r\n\r\nstatic char * helperN()\r\n{\r\n \r\n if(rand()%2 == 0)\r\n {\r\n return NULL;\r\n }\r\n else\r\n {\r\n return staticStringN;\r\n }\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_18()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n if(helperM == NULL)\r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n \r\n if(helperN() == NULL) \r\n {\r\n printLine(\"Got a NULL\");\r\n }\r\n}\r\n\r\nvoid My_basic_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-480:Use of Incorrect Operator|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "480"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nB.CWE-1393:Use of Default Password\nC.No Vulnerabilities\nD.CWE-693:Protection Mechanism Failure\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_3DES_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_3DES_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_3DES_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_3DES_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|D.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-335:Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\nB.No Vulnerabilities\nC.CWE-609:Double-Checked Locking\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_realloc_02()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));\r\n if(1)\r\n {\r\n \r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));\r\n if(1)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_realloc_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_realloc_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_realloc_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-690:Unchecked Return Value to NULL Pointer Dereference|E.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-274:Improper Handling of Insufficient Privileges\nB.CWE-343:Predictable Value Range from Previous Values\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.CWE-127:Buffer Under-read\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_char_ncpy_06()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n strncpy(dest, data, strlen(dest));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n strncpy(dest, data, strlen(dest));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * dataBuffer = (char *)malloc(100*sizeof(char));\r\n if (dataBuffer == NULL) {exit(-1);}\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n strncpy(dest, data, strlen(dest));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid My_malloc_char_ncpy_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_char_ncpy_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_char_ncpy_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-105:Struts: Form Field Without Validator\nB.CWE-25:Path Traversal: '/../filedir'\nC.CWE-912:Hidden Functionality\nD.CWE-506:Embedded Malicious Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_base64_encoded_payload_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n char * encodedPayload = \"Y2FsYy5leGU=\";\r\n BYTE * decodedPayload = NULL;\r\n DWORD requiredLength;\r\n do\r\n {\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n NULL,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload = (BYTE*) malloc(requiredLength + 1);\r\n if (decodedPayload == NULL)\r\n {\r\n break;\r\n }\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n decodedPayload,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload[requiredLength] = '\\0';\r\n if (system((char*)decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n free(decodedPayload);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_base64_encoded_payload_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_base64_encoded_payload_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_base64_encoded_payload_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-506:Embedded Malicious Code|C.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-129:Improper Validation of Array Index\nD.No Vulnerabilities\nE.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_calloc_18()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));\r\n goto sink;\r\nsink:\r\n \r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));\r\n goto sink;\r\nsink:\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_struct_calloc_18()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_calloc_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_calloc_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-690:Unchecked Return Value to NULL Pointer Dereference|A.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-121:Stack-based Buffer Overflow\nC.No Vulnerabilities\nD.CWE-676:Use of Potentially Dangerous Function\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE805_char_declare_memcpy_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-121:Stack-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-364:Signal Handler Race Condition\nB.No Vulnerabilities\nC.CWE-1357:Reliance on Insufficiently Trustworthy Component\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.CWE-469:Use of Pointer Subtraction to Determine Size\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\ntypedef struct _structSigAtomic\r\n{\r\n sig_atomic_t val;\r\n} structSigAtomic;\r\n\r\nstructSigAtomic *My_basic_07StructSigAtomicM = NULL;\r\nstructSigAtomic *My_basic_07StructSigAtomicN = NULL;\r\n\r\nstatic void helperM(int sig)\r\n{\r\n if (My_basic_07StructSigAtomicM != NULL)\r\n {\r\n My_basic_07StructSigAtomicM->val = 2;\r\n }\r\n}\r\n\r\nstatic void helperN(int sig)\r\n{\r\n if (My_basic_07StructSigAtomicN != NULL)\r\n {\r\n My_basic_07StructSigAtomicN->val = 2;\r\n }\r\n}\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_07StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_07StructSigAtomicM);\r\n My_basic_07StructSigAtomicM = NULL;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_07StructSigAtomicM = gStructSigAtomic;\r\n My_basic_07StructSigAtomicM->val = 1;\r\n \r\n signal(SIGINT, helperM);\r\n \r\n if (My_basic_07StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_07StructSigAtomicM);\r\n My_basic_07StructSigAtomicM = NULL;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_07StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_07StructSigAtomicN);\r\n My_basic_07StructSigAtomicN = 0;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_07StructSigAtomicN = gStructSigAtomic;\r\n My_basic_07StructSigAtomicN->val = 1;\r\n \r\n signal(SIGINT, helperN);\r\n \r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_07StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_07StructSigAtomicN);\r\n My_basic_07StructSigAtomicN = NULL;\r\n }\r\n signal(SIGINT, helperN);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_07StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_07StructSigAtomicN);\r\n My_basic_07StructSigAtomicN = 0;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_07StructSigAtomicN = gStructSigAtomic;\r\n My_basic_07StructSigAtomicN->val = 1;\r\n \r\n signal(SIGINT, helperN);\r\n \r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_07StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_07StructSigAtomicN);\r\n My_basic_07StructSigAtomicN = NULL;\r\n }\r\n signal(SIGINT, helperN);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-364:Signal Handler Race Condition|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "364"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-82:Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\nB.CWE-682:Incorrect Calculation\nC.CWE-369:Divide By Zero\nD.No Vulnerabilities\nE.CWE-211:Externally-Generated Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic int mSource(int data)\r\n{\r\n \r\n data = RAND32();\r\n return data;\r\n}\r\n\r\nvoid My_int_rand_divide_42()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = mSource(data);\r\n \r\n printIntLine(100 / data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2BSource(int data)\r\n{\r\n \r\n data = 7;\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = nG2BSource(data);\r\n \r\n printIntLine(100 / data);\r\n}\r\n\r\n\r\nstatic int nB2GSource(int data)\r\n{\r\n \r\n data = RAND32();\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = nB2GSource(data);\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n}\r\n\r\nvoid My_int_rand_divide_42()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_rand_divide_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_rand_divide_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-369:Divide By Zero|B.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-253:Incorrect Check of Function Return Value\nD.CWE-821:Incorrect Synchronization\nE.CWE-276:Incorrect Default Permissions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fread_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) == 0)\r\n {\r\n printLine(\"fread failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\r\n {\r\n printLine(\"fread failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\r\n {\r\n printLine(\"fread failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fread_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fread_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fread_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-253:Incorrect Check of Function Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-825:Expired Pointer Dereference\nB.CWE-682:Incorrect Calculation\nC.CWE-469:Use of Pointer Subtraction to Determine Size\nD.No Vulnerabilities\nE.CWE-143:Improper Neutralization of Record Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SOURCE_STRING L\"abc/opqrstu\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t string1[] = SOURCE_STRING;\r\n wchar_t string2[] = SOURCE_STRING;\r\n wchar_t * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = wcschr(string1, L'/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string2);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t string1[] = SOURCE_STRING;\r\n wchar_t * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = wcschr(string1, L'/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t string1[] = SOURCE_STRING;\r\n wchar_t * slashInString1;\r\n size_t indexOfSlashInString1;\r\n slashInString1 = wcschr(string1, L'/');\r\n if (slashInString1 == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n indexOfSlashInString1 = (size_t)(slashInString1 - string1);\r\n \r\n printUnsignedLine(indexOfSlashInString1);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-469:Use of Pointer Subtraction to Determine Size|B.CWE-682:Incorrect Calculation", "cwe": "469"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-511:Logic/Time Bomb\nB.CWE-1323:Improper Management of Sensitive Trace Data\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-771:Missing Reference to Active Allocated Resource\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32CreateFile_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, HANDLE> dataMap);\r\n\r\nvoid m()\r\n{\r\n HANDLE data;\r\n map<int, HANDLE> dataMap;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(map<int, HANDLE> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n map<int, HANDLE> dataMap;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32CreateFile_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|D.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-232:Improper Handling of Undefined Values\nC.CWE-710:Improper Adherence to Coding Standards\nD.No Vulnerabilities\nE.CWE-444:Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double_pointer_alloca_use_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n double * * pointer = (double * *)ALLOCA(sizeof(double *));\r\n double * data = *pointer; \r\n printDoubleLine(*data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n double * data;\r\n double * * pointer = (double * *)ALLOCA(sizeof(double *));\r\n \r\n data = (double *)malloc(sizeof(double));\r\n if (data == NULL) {exit(-1);}\r\n *data = 5.0;\r\n *pointer = data; \r\n {\r\n double * data = *pointer;\r\n printDoubleLine(*data);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double_pointer_alloca_use_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double_pointer_alloca_use_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double_pointer_alloca_use_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.CWE-413:Improper Resource Locking\nD.CWE-135:Incorrect Calculation of Multi-Byte String Length\nE.CWE-566:Authorization Bypass Through User-Controlled SQL Primary Key\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} My_w32_wchar_t_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_34()\r\n{\r\n wchar_t * password;\r\n My_w32_wchar_t_34_unionType myUnion;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n myUnion.unionFirst = password;\r\n {\r\n wchar_t * password = myUnion.unionSecond;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n My_w32_wchar_t_34_unionType myUnion;\r\n \r\n password = L\"\";\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n myUnion.unionFirst = password;\r\n {\r\n wchar_t * password = myUnion.unionSecond;\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|C.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nC.CWE-762:Mismatched Memory Management Routines\nD.CWE-425:Direct Request ('Forced Browsing')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_struct_malloc_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new twoIntsStruct[100];\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = new twoIntsStruct[100];\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_struct_malloc_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point\nB.CWE-123:Write-what-where Condition\nC.No Vulnerabilities\nD.CWE-787:Out-of-bounds Write\nE.CWE-691:Insufficient Control Flow Management\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_63bSink(mStruct * dataPtr);\r\n\r\nvoid My_connect_socket_63()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_63bG2BSink(mStruct * data);\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n My_connect_socket_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_connect_socket_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-692:Incomplete Denylist to Cross-Site Scripting\nC.CWE-546:Suspicious Comment\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-233:Improper Handling of Parameters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_HACK_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_HACK_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_HACK_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_HACK_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1071:Empty Code Block\nB.CWE-426:Untrusted Search Path\nC.CWE-673:External Influence of Sphere Definition\nD.No Vulnerabilities\nE.CWE-1247:Improper Protection Against Voltage and Clock Glitches\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM _wsystem\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_system_52bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_system_52()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n My_wchar_t_system_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_system_52bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n My_wchar_t_system_52bG2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_system_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_system_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_system_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-426:Untrusted Search Path|C.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\nB.No Vulnerabilities\nC.CWE-807:Reliance on Untrusted Inputs in a Security Decision\nD.CWE-413:Improper Resource Locking\nE.CWE-591:Sensitive Data Storage in Improperly Locked Memory\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_64bSink(void * passwordVoidPtr);\r\n\r\nvoid My_w32_char_64()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_64bSink(&password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_64bG2BSink(void * passwordVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_64bG2BSink(&password);\r\n}\r\n\r\nvoid My_w32_char_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-591:Sensitive Data Storage in Improperly Locked Memory|D.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1041:Use of Redundant Code\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.No Vulnerabilities\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-155:Improper Neutralization of Wildcards or Matching Symbols\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_freopen_w32_close_54bSink(FILE * data);\r\n\r\nvoid My_freopen_w32_close_54()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n My_freopen_w32_close_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_freopen_w32_close_54bB2GSink(FILE * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n My_freopen_w32_close_54bB2GSink(data);\r\n}\r\n\r\nvoid My_freopen_w32_close_54()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_w32_close_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_w32_close_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.No Vulnerabilities\nC.CWE-459:Incomplete Cleanup\nD.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nE.CWE-783:Operator Precedence Logic Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|C.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1222:Insufficient Granularity of Address Regions Protected by Register Locks\nB.CWE-1338:Improper Protections Against Hardware Overheating\nC.No Vulnerabilities\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_My_My_My_My_My_My_My_My_My_CWE839_connect_socket_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-410:Insufficient Resource Pool\nB.No Vulnerabilities\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-680:Integer Overflow to Buffer Overflow\nE.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_malloc_fscanf_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_malloc_fscanf_83\r\n{\r\npublic:\r\n My_malloc_fscanf_83(int dataCopy);\r\n ~My_malloc_fscanf_83();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_malloc_fscanf_83G2B\r\n{\r\npublic:\r\n My_malloc_fscanf_83G2B(int dataCopy);\r\n ~My_malloc_fscanf_83G2B();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-185:Incorrect Regular Expression\nD.No Vulnerabilities\nE.CWE-183:Permissive List of Allowed Inputs\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_alloca_memcpy_54bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_alloca_memcpy_54()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataMBuffer;\r\n My_wchar_t_alloca_memcpy_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_alloca_memcpy_54bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n \r\n data = dataNBuffer;\r\n My_wchar_t_alloca_memcpy_54bG2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_alloca_memcpy_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_alloca_memcpy_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_alloca_memcpy_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-479:Signal Handler Use of a Non-reentrant Function\nD.CWE-416:Use After Free\nE.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_int64_t_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n else\r\n {\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printLongLongLine(data[0]);\r\n \r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n else\r\n {\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n }\r\n else\r\n {\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printLongLongLine(data[0]);\r\n \r\n }\r\n else\r\n {\r\n \r\n printLongLongLine(data[0]);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_int64_t_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-416:Use After Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-164:Improper Neutralization of Internal Special Elements\nC.CWE-1111:Incomplete I/O Documentation\nD.CWE-673:External Influence of Sphere Definition\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_popen_14()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(globalFive==5)\r\n {\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(globalFive==5)\r\n {\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n }\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_popen_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_popen_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_popen_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-426:Untrusted Search Path|D.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-366:Race Condition within a Thread\nC.CWE-1177:Use of Prohibited Code\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.CWE-170:Improper Null Termination\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#define N_ITERS 1000000\r\n\r\nstatic int gMInt = 0;\r\nstatic int gNInt = 0;\r\nstatic stdThreadLock gNLock = NULL;\r\n\r\nstatic void helperM(void *args)\r\n{\r\n int i;\r\n \r\n \r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n gMInt = gMInt + 1;\r\n }\r\n}\r\n\r\nstatic void helperN(void *args)\r\n{\r\n int i;\r\n \r\n stdThreadLockAcquire(gNLock);\r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n gNInt = gNInt + 1;\r\n }\r\n stdThreadLockRelease(gNLock);\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_global_int_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n gMInt = 0;\r\n if (!stdThreadCreate(helperM, NULL, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperM, NULL, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n printIntLine(gMInt);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, NULL, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, NULL, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(gNInt);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_global_int_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_global_int_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_global_int_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-366:Race Condition within a Thread|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "366"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.CWE-272:Least Privilege Violation\nC.No Vulnerabilities\nD.CWE-682:Incorrect Calculation\nE.CWE-830:Inclusion of Web Functionality from an Untrusted Source\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_RegCreateKeyEx_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExA(\r\n HKEY_LOCAL_MACHINE,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExA(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_RegCreateKeyEx_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_RegCreateKeyEx_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_RegCreateKeyEx_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|A.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\nB.CWE-763:Release of Invalid Pointer or Reference\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.No Vulnerabilities\nE.CWE-578:EJB Bad Practices: Use of Class Loader\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_connect_socket_02()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(1)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(1)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_connect_socket_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-416:Use After Free\nC.CWE-335:Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-755:Improper Handling of Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_int64_t_01\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n delete [] data;\r\n \r\n printLongLongLine(data[0]);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n \r\n printLongLongLine(data[0]);\r\n \r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n data = new int64_t[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5LL;\r\n }\r\n }\r\n \r\n delete [] data;\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_int64_t_01; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-253:Incorrect Check of Function Return Value\nD.No Vulnerabilities\nE.CWE-408:Incorrect Behavior Order: Early Amplification\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fputs_16()\r\n{\r\n while(1)\r\n {\r\n \r\n if (fputs(\"string\", stdout) == 0)\r\n {\r\n printLine(\"fputs failed!\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n \r\n if (fputs(\"string\", stdout) == EOF)\r\n {\r\n printLine(\"fputs failed!\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_fputs_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fputs_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fputs_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-253:Incorrect Check of Function Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1261:Improper Handling of Single Event Upsets\nB.No Vulnerabilities\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-1053:Missing Documentation for Design\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_large_14()\r\n{\r\n short data;\r\n \r\n data = -1;\r\n if(globalFive==5)\r\n {\r\n \r\n data = CHAR_MAX + 1;\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = -1;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = -1;\r\n if(globalFive==5)\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\nvoid My_short_large_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_large_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_large_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nC.CWE-330:Use of Insufficiently Random Values\nD.CWE-662:Improper Synchronization\nE.CWE-304:Missing Critical Step in Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|C.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1098:Data Element containing Pointer Item without Proper Copy Control Element\nC.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_max_square_17()\r\n{\r\n int i,j;\r\n char data;\r\n data = ' ';\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = CHAR_MAX;\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n \r\n char result = data * data;\r\n printHexCharLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n char data;\r\n data = ' ';\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = CHAR_MAX;\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))\r\n {\r\n char result = data * data;\r\n printHexCharLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n char data;\r\n data = ' ';\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = 2;\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n \r\n char result = data * data;\r\n printHexCharLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_max_square_17()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_max_square_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_max_square_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-190:Integer Overflow or Wraparound|E.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1339:Insufficient Precision or Accuracy of a Real Number\nB.CWE-403:Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')\nC.CWE-511:Logic/Time Bomb\nD.No Vulnerabilities\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <time.h>\r\n\r\n#define TIME_CHECK ((time_t)1199163600) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_time_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n time_t currentTime;\r\n \r\n time(&currentTime);\r\n if (currentTime > TIME_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_time_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_time_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_time_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-511:Logic/Time Bomb|E.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-185:Incorrect Regular Expression\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-599:Missing Validation of OpenSSL Certificate\nE.CWE-122:Heap-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_c_My_c_My_c_My_c_CWE193_char_loop_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-122:Heap-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-290:Authentication Bypass by Spoofing\nB.CWE-312:Cleartext Storage of Sensitive Information\nC.No Vulnerabilities\nD.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\nE.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_16()\r\n{\r\n while(1)\r\n {\r\n \r\n printLine(getenv(\"PATH\"));\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n \r\n printLine(\"Not in path\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable|B.CWE-312:Cleartext Storage of Sensitive Information", "cwe": "526"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-546:Suspicious Comment\nB.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nC.No Vulnerabilities\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-525:Use of Web Browser Cache Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_FIXME_02()\r\n{\r\n if(1)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_FIXME_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_FIXME_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_FIXME_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-599:Missing Validation of OpenSSL Certificate\nB.CWE-114:Process Control\nC.CWE-73:External Control of File Name or Path\nD.No Vulnerabilities\nE.CWE-1289:Improper Validation of Unsafe Equivalence in Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_listen_socket_18()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_18()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.No Vulnerabilities\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-1319:Improper Protection against Electromagnetic Fault Injection (EM-FI)\nE.CWE-1224:Improper Restriction of Write-Once Bit Fields\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_delete_wchar_t_malloc_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new wchar_t;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = new wchar_t;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_wchar_t_malloc_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1025:Comparison Using Wrong Factors\nB.No Vulnerabilities\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nE.CWE-1393:Use of Default Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fopen_no_close_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_fopen_no_close_64()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_no_close_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fopen_no_close_64bB2GSink(void * dataVoidPtr);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_no_close_64bB2GSink(&data);\r\n}\r\n\r\nvoid My_fopen_no_close_64()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_no_close_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_no_close_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-366:Race Condition within a Thread\nB.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nC.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nD.CWE-102:Struts: Duplicate Validation Forms\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#define N_ITERS 1000000\r\n\r\nstatic stdThreadLock gNLock = NULL;\r\n\r\nstatic void helperM(void *args)\r\n{\r\n int *pIntArgs = (int*)args;\r\n int i;\r\n \r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n *pIntArgs = *pIntArgs + 1;\r\n }\r\n}\r\n\r\nstatic void helperN(void *args)\r\n{\r\n int *pIntArgs = (int *)args;\r\n int i;\r\n \r\n stdThreadLockAcquire(gNLock);\r\n for (i = 0; i < N_ITERS; i++)\r\n {\r\n *pIntArgs = *pIntArgs + 1;\r\n }\r\n stdThreadLockRelease(gNLock);\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_byref_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valMSink;\r\n valMSink = 0;\r\n if (!stdThreadCreate(helperM, (void*)&valMSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperM, (void*)&valMSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n printIntLine(valMSink);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n stdThread threadA = NULL;\r\n stdThread threadB = NULL;\r\n int valNSink;\r\n valNSink = 0;\r\n if (!stdThreadLockCreate(&gNLock))\r\n {\r\n return;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadA))\r\n {\r\n threadA = NULL;\r\n }\r\n if (!stdThreadCreate(helperN, (void*)&valNSink, &threadB))\r\n {\r\n threadB = NULL;\r\n }\r\n if (threadA && stdThreadJoin(threadA))\r\n {\r\n stdThreadDestroy(threadA);\r\n }\r\n if (threadB && stdThreadJoin(threadB))\r\n {\r\n stdThreadDestroy(threadB);\r\n }\r\n stdThreadLockDestroy(gNLock);\r\n printIntLine(valNSink);\r\n }\r\n}\r\n\r\nvoid My_int_byref_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_byref_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_byref_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-366:Race Condition within a Thread|C.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "366"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1073:Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses\nC.CWE-426:Untrusted Search Path\nD.CWE-172:Encoding Error\nE.CWE-176:Improper Handling of Unicode Encoding\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_65bSink(wchar_t * data);\r\n\r\nvoid My_w32_65()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = My_w32_65bSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_65bG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = My_w32_65bG2BSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n funcPtr(data);\r\n}\r\n\r\n\r\nvoid My_w32_65bB2GSink(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = My_w32_65bB2GSink;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_w32_65()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-176:Improper Handling of Unicode Encoding|D.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1331:Improper Isolation of Shared Resources in Network On Chip (NoC)\nC.CWE-832:Unlock of a Resource that is not Locked\nD.CWE-667:Improper Locking\nE.CWE-1283:Mutable Attestation or Measurement Reporting Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-832:Unlock of a Resource that is not Locked|D.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-757:Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\nB.No Vulnerabilities\nC.CWE-625:Permissive Regular Expression\nD.CWE-415:Double Free\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nstatic wchar_t * My_malloc_free_wchar_t_45Data;\r\nstatic wchar_t * My_malloc_free_wchar_t_45G2BData;\r\nstatic wchar_t * My_malloc_free_wchar_t_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n wchar_t * data = My_malloc_free_wchar_t_45Data;\r\n \r\n free(data);\r\n}\r\n\r\nvoid My_malloc_free_wchar_t_45()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n My_malloc_free_wchar_t_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n wchar_t * data = My_malloc_free_wchar_t_45G2BData;\r\n \r\n free(data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n My_malloc_free_wchar_t_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n wchar_t * data = My_malloc_free_wchar_t_45B2GData;\r\n \r\n \r\n ; \r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n My_malloc_free_wchar_t_45B2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_malloc_free_wchar_t_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_wchar_t_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_wchar_t_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-673:External Influence of Sphere Definition\nB.CWE-1262:Improper Access Control for Register Interface\nC.CWE-182:Collapse of Data into Unsafe Value\nD.CWE-426:Untrusted Search Path\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _popen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_popen_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, \"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_popen_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_popen_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_popen_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-426:Untrusted Search Path|A.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\nB.CWE-129:Improper Validation of Array Index\nC.No Vulnerabilities\nD.CWE-459:Incomplete Cleanup\nE.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-499:Serializable Class Containing Sensitive Data\nB.CWE-704:Incorrect Type Conversion or Cast\nC.CWE-606:Unchecked Input for Loop Condition\nD.CWE-1284:Improper Validation of Specified Quantity in Input\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_environment_10()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"15\");\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n strcpy(data, \"15\");\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_environment_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-606:Unchecked Input for Loop Condition|D.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-306:Missing Authentication for Critical Function\nB.No Vulnerabilities\nC.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include <inttypes.h>\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int64_t data)\r\n{\r\n {\r\n \r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n}\r\n\r\nvoid My_int64_t_fscanf_preinc_41()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int64_t data)\r\n{\r\n {\r\n \r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n data = 2;\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(int64_t data)\r\n{\r\n \r\n if (data < LLONG_MAX)\r\n {\r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n nB2GSink(data);\r\n}\r\n\r\nvoid My_int64_t_fscanf_preinc_41()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_fscanf_preinc_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_fscanf_preinc_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-190:Integer Overflow or Wraparound|E.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-468:Incorrect Pointer Scaling\nB.CWE-1292:Incorrect Conversion of Security Identifiers\nC.CWE-682:Incorrect Calculation\nD.No Vulnerabilities\nE.CWE-1068:Inconsistency Between Implementation and Documented Design\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-468:Incorrect Pointer Scaling|C.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-328:Use of Weak Hash\nC.CWE-326:Inadequate Encryption Strength\nD.CWE-1336:Improper Neutralization of Special Elements Used in a Template Engine\nE.CWE-536:Servlet Runtime Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define SHA1_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_SHA1_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA1_SUM_SIZE], calcHash[SHA1_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA1_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA1_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA1_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_SHA1_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_SHA1_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_SHA1_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-328:Use of Weak Hash|C.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-414:Missing Lock Check\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-1124:Excessively Deep Nesting\nD.CWE-476:NULL Pointer Dereference\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint birotatory_oversoak = 0;\r\nint global_variable;\r\n\r\nunion reassort_protectorate \r\n{\r\n char *unpresuming_resail;\r\n double refurbishment_dour;\r\n char *nontreated_ultramodernist;\r\n char peg_amazes;\r\n int nonacidity_baleless;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid pseudotracheal_calcrete(int triangula_laziness,union reassort_protectorate *offbeats_generatrix);\r\nvoid itasca_macrocladous(int leafstalk_unalternated,union reassort_protectorate *seams_nerve);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int chloroformic_solating = 7;\r\n union reassort_protectorate *undefaceable_caped = 0;\r\n union reassort_protectorate metatarsal_cartmaker = {0};\r\n union reassort_protectorate paradigmatic_bnsc;\r\n char *cyatholith_hoydening;;\r\n if (__sync_bool_compare_and_swap(&birotatory_oversoak,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cyatholith_hoydening = getenv(\"FRACTIONLET_KLUANG\");\r\n if (cyatholith_hoydening != 0) {;\r\n paradigmatic_bnsc . unpresuming_resail = cyatholith_hoydening;\r\n undefaceable_caped = &paradigmatic_bnsc;\r\n pseudotracheal_calcrete(chloroformic_solating,undefaceable_caped);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid pseudotracheal_calcrete(int triangula_laziness,union reassort_protectorate *offbeats_generatrix)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *cyanhidrosis_procellas = 0;\r\n ++global_variable;\r\n triangula_laziness--;\r\n if (triangula_laziness > 0) {\r\n itasca_macrocladous(triangula_laziness,offbeats_generatrix);\r\n return ;\r\n }\r\n cyanhidrosis_procellas = ((char *)( *offbeats_generatrix) . unpresuming_resail);\r\n \r\n buffer_value = atoi(cyanhidrosis_procellas);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n\r\nvoid itasca_macrocladous(int leafstalk_unalternated,union reassort_protectorate *seams_nerve)\r\n{\r\n ++global_variable;\r\n pseudotracheal_calcrete(leafstalk_unalternated,seams_nerve);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-761:Free of Pointer not at Start of Buffer\nB.No Vulnerabilities\nC.CWE-52:Path Equivalence: '/multiple/trailing/slash//'\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-1101:Reliance on Runtime Component in Generated Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_console_01()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_char_console_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-761:Free of Pointer not at Start of Buffer|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1386:Insecure Operation on Windows Junction / Mount Point\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-1021:Improper Restriction of Rendered UI Layers or Frames\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n\r\nstatic int My_int_rand_square_45Data;\r\nstatic int My_int_rand_square_45G2BData;\r\nstatic int My_int_rand_square_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n int data = My_int_rand_square_45Data;\r\n {\r\n \r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\nvoid My_int_rand_square_45()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = RAND32();\r\n My_int_rand_square_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n int data = My_int_rand_square_45G2BData;\r\n {\r\n \r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n My_int_rand_square_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n int data = My_int_rand_square_45B2GData;\r\n \r\n if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))\r\n {\r\n int result = data * data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = RAND32();\r\n My_int_rand_square_45B2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_int_rand_square_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_rand_square_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_rand_square_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|E.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.CWE-1394:Use of Default Cryptographic Key\nC.No Vulnerabilities\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-916:Use of Password Hash With Insufficient Computational Effort\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nint My_listen_socket_68Data;\r\nint My_listen_socket_68G2BData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_listen_socket_68bSink();\r\n\r\nvoid My_listen_socket_68()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_listen_socket_68Data = data;\r\n My_listen_socket_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_listen_socket_68bG2BSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n My_listen_socket_68G2BData = data;\r\n My_listen_socket_68bG2BSink();\r\n}\r\n\r\nvoid My_listen_socket_68()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-617:Reachable Assertion|D.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-329:Generation of Predictable IV with CBC Mode\nB.CWE-184:Incomplete List of Disallowed Inputs\nC.No Vulnerabilities\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-590:Free of Memory not on the Heap\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_array_class_declare_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i;\r\n TwoIntsClass * data;\r\n data = NULL; \r\n for(i = 0; i < 1; i++)\r\n {\r\n {\r\n \r\n TwoIntsClass dataBuffer[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i].intOne = 1;\r\n dataBuffer[i].intTwo = 1;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(data[0].intOne);\r\n \r\n delete [] data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n TwoIntsClass * data;\r\n data = NULL; \r\n for(h = 0; h < 1; h++)\r\n {\r\n {\r\n \r\n TwoIntsClass * dataBuffer = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i].intOne = 1;\r\n dataBuffer[i].intTwo = 1;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(data[0].intOne);\r\n \r\n delete [] data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_class_declare_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-590:Free of Memory not on the Heap|D.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.No Vulnerabilities\nC.CWE-665:Improper Initialization\nD.CWE-1323:Improper Management of Sensitive Trace Data\nE.CWE-440:Expected Behavior Violation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_cat_63bSink(wchar_t * * dataPtr);\r\n\r\nvoid My_wchar_t_cat_63()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n My_wchar_t_cat_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_cat_63bG2BSink(wchar_t * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = L'\\0'; \r\n My_wchar_t_cat_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_wchar_t_cat_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_cat_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_cat_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-413:Improper Resource Locking\nC.CWE-1041:Use of Redundant Code\nD.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nE.CWE-577:EJB Bad Practices: Use of Sockets\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_04()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(STATIC_CONST_TRUE)\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(STATIC_CONST_TRUE)\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_char_04()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-591:Sensitive Data Storage in Improperly Locked Memory|B.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.CWE-396:Declaration of Catch for Generic Exception\nC.CWE-146:Improper Neutralization of Expression/Command Delimiters\nD.No Vulnerabilities\nE.CWE-705:Incorrect Control Flow Scoping\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_and_domain_error_03\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(5==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n catch (domain_error &)\r\n {\r\n \r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_and_domain_error_03; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-396:Declaration of Catch for Generic Exception|E.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1332:Improper Handling of Faults that Lead to Instruction Skips\nB.No Vulnerabilities\nC.CWE-1274:Improper Access Control for Volatile Memory Containing Boot Code\nD.CWE-134:Use of Externally-Controlled Format String\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include <stdarg.h>\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mVaSinkB(char * data, ...)\r\n{\r\n {\r\n char dest[100] = \"\";\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vsnprintf(dest, 100-1, data, args);\r\n va_end(args);\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_char_connect_socket_w32_vsnprintf_18()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n goto sink;\r\nsink:\r\n mVaSinkB(data, data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void nB2GVaSinkG(char * data, ...)\r\n{\r\n {\r\n char dest[100] = \"\";\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vsnprintf(dest, 100-1, \"%s\", args);\r\n va_end(args);\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n goto sink;\r\nsink:\r\n nB2GVaSinkG(data, data);\r\n}\r\n\r\nstatic void nG2BVaSinkB(char * data, ...)\r\n{\r\n {\r\n char dest[100] = \"\";\r\n va_list args;\r\n va_start(args, data);\r\n \r\n vsnprintf(dest, 100-1, data, args);\r\n va_end(args);\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n goto sink;\r\nsink:\r\n nG2BVaSinkB(data, data);\r\n}\r\n\r\nvoid My_char_connect_socket_w32_vsnprintf_18()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_w32_vsnprintf_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_w32_vsnprintf_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-134:Use of Externally-Controlled Format String|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.CWE-1224:Improper Restriction of Write-Once Bit Fields\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.No Vulnerabilities\nE.CWE-585:Empty Synchronized Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_declare_ncpy_52bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_declare_ncpy_52()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n My_wchar_t_declare_ncpy_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_declare_ncpy_52bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n My_wchar_t_declare_ncpy_52bG2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_declare_ncpy_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_declare_ncpy_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_declare_ncpy_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-121:Stack-based Buffer Overflow\nB.CWE-1385:Missing Origin Validation in WebSockets\nC.CWE-654:Reliance on a Single Factor in a Security Decision\nD.No Vulnerabilities\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING L\"AAAAAAAAAA\"\r\n\r\nnamespace My_My_My_My_My_My_CWE193_wchar_t_declare_memmove_82_base\r\n{\r\npublic:\r\n void action(wchar_t * data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-121:Stack-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-426:Untrusted Search Path\nB.CWE-464:Addition of Data Structure Sentinel\nC.CWE-462:Duplicate Key in Associative List (Alist)\nD.No Vulnerabilities\nE.CWE-673:External Influence of Sphere Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic wchar_t * mSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n return data;\r\n}\r\n\r\nvoid My_wchar_t_popen_42()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic wchar_t * nG2BSource(wchar_t * data)\r\n{\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n return data;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_popen_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_popen_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_popen_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-426:Untrusted Search Path|E.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nE.CWE-391:Unchecked Error Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#include <math.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_sqrt_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n double doubleNumber;\r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_sqrt_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_sqrt_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_sqrt_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-391:Unchecked Error Condition|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1288:Improper Validation of Consistency within Input\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.No Vulnerabilities\nD.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nnamespace My_int_fgets_to_char_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int &data)\r\n{\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int &data)\r\n{\r\n \r\n data = CHAR_MAX-5;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_fgets_to_char_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\nB.CWE-364:Signal Handler Race Condition\nC.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nD.CWE-428:Unquoted Search Path or Element\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\ntypedef struct _structSigAtomic\r\n{\r\n sig_atomic_t val;\r\n} structSigAtomic;\r\n\r\nstructSigAtomic *My_basic_17StructSigAtomicM = NULL;\r\nstructSigAtomic *My_basic_17StructSigAtomicN = NULL;\r\n\r\nstatic void helperM(int sig)\r\n{\r\n if (My_basic_17StructSigAtomicM != NULL)\r\n {\r\n My_basic_17StructSigAtomicM->val = 2;\r\n }\r\n}\r\n\r\nstatic void helperN(int sig)\r\n{\r\n if (My_basic_17StructSigAtomicN != NULL)\r\n {\r\n My_basic_17StructSigAtomicN->val = 2;\r\n }\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_17StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_17StructSigAtomicM);\r\n My_basic_17StructSigAtomicM = NULL;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_17StructSigAtomicM = gStructSigAtomic;\r\n My_basic_17StructSigAtomicM->val = 1;\r\n \r\n signal(SIGINT, helperM);\r\n \r\n if (My_basic_17StructSigAtomicM != NULL)\r\n {\r\n free(My_basic_17StructSigAtomicM);\r\n My_basic_17StructSigAtomicM = NULL;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n structSigAtomic *gStructSigAtomic = NULL;\r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_17StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_17StructSigAtomicN);\r\n My_basic_17StructSigAtomicN = 0;\r\n }\r\n gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\r\n if (gStructSigAtomic == NULL) {exit(-1);}\r\n My_basic_17StructSigAtomicN = gStructSigAtomic;\r\n My_basic_17StructSigAtomicN->val = 1;\r\n \r\n signal(SIGINT, helperN);\r\n \r\n signal(SIGINT, SIG_DFL);\r\n if (My_basic_17StructSigAtomicN != NULL)\r\n {\r\n free(My_basic_17StructSigAtomicN);\r\n My_basic_17StructSigAtomicN = NULL;\r\n }\r\n signal(SIGINT, helperN);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-364:Signal Handler Race Condition|C.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "364"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nB.CWE-786:Access of Memory Location Before Start of Buffer\nC.CWE-124:Buffer Underwrite ('Buffer Underflow')\nD.No Vulnerabilities\nE.CWE-480:Use of Incorrect Operator\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_declare_ncpy_66bSink(wchar_t * dataArray[]);\r\n\r\nvoid My_wchar_t_declare_ncpy_66()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n \r\n dataArray[2] = data;\r\n My_wchar_t_declare_ncpy_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_declare_ncpy_66bG2BSink(wchar_t * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n dataArray[2] = data;\r\n My_wchar_t_declare_ncpy_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_wchar_t_declare_ncpy_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_declare_ncpy_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_declare_ncpy_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-124:Buffer Underwrite ('Buffer Underflow')|B.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1025:Comparison Using Wrong Factors\nB.CWE-912:Hidden Functionality\nC.CWE-506:Embedded Malicious Code\nD.CWE-98:Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define FILENAME \"conf.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_file_transfer_listen_socket_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char contents[65536]; \r\n FILE * pFile;\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(contents, (int)(65535), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n contents[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, contents, strlen(contents), 0) != strlen(contents))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_file_transfer_listen_socket_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-506:Embedded Malicious Code|B.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-197:Numeric Truncation Error\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.CWE-1262:Improper Access Control for Register Interface\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_rand_to_short_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int &data)\r\n{\r\n \r\n data = RAND32();\r\n}\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int &data)\r\n{\r\n \r\n data = CHAR_MAX-5;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_rand_to_short_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-197:Numeric Truncation Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-408:Incorrect Behavior Order: Early Amplification\nB.CWE-682:Incorrect Calculation\nC.CWE-190:Integer Overflow or Wraparound\nD.No Vulnerabilities\nE.CWE-473:PHP External Variable Modification\n", "input": "\r\n\r\n\r\n#include <inttypes.h>\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_fscanf_multiply_03()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(5==5)\r\n {\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n }\r\n if(5==5)\r\n {\r\n if(data > 0) \r\n {\r\n \r\n int64_t result = data * 2;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(5==5)\r\n {\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if(data > 0) \r\n {\r\n \r\n if (data < (LLONG_MAX/2))\r\n {\r\n int64_t result = data * 2;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(5==5)\r\n {\r\n \r\n fscanf (stdin, \"%\" SCNd64, &data);\r\n }\r\n if(5==5)\r\n {\r\n if(data > 0) \r\n {\r\n \r\n if (data < (LLONG_MAX/2))\r\n {\r\n int64_t result = data * 2;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 2;\r\n }\r\n if(5==5)\r\n {\r\n if(data > 0) \r\n {\r\n \r\n int64_t result = data * 2;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n if(5==5)\r\n {\r\n \r\n data = 2;\r\n }\r\n if(5==5)\r\n {\r\n if(data > 0) \r\n {\r\n \r\n int64_t result = data * 2;\r\n printLongLongLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int64_t_fscanf_multiply_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_fscanf_multiply_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_fscanf_multiply_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-382:J2EE Bad Practices: Use of System.exit()\nB.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nC.No Vulnerabilities\nD.CWE-188:Reliance on Data/Memory Layout\nE.CWE-170:Improper Null Termination\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_union_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n union\r\n {\r\n struct\r\n {\r\n char charFirst, charSecond, charThird, charFourth;\r\n } structChars;\r\n long longNumber;\r\n } unionStructLong;\r\n unionStructLong.longNumber = 0x10203040;\r\n \r\n unionStructLong.structChars.charFourth |= 0x80; \r\n printIntLine(unionStructLong.longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_union_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_union_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_union_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-188:Reliance on Data/Memory Layout|B.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-705:Incorrect Control Flow Scoping\nB.CWE-749:Exposed Dangerous Method or Function\nC.CWE-682:Incorrect Calculation\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.No Vulnerabilities\n", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint lopsticks_requiteless = 0;\r\nint global_variable;\r\nvoid procarp_containership(char **unforeign_recuperative);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid hensonville_kala(void (*doublehanded_vantages)(char **));\r\nvoid whitleyville_spermatocide(int carlin_sadhaka,... );\r\nvoid function() {\r\n \r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&lopsticks_requiteless,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n hensonville_kala(procarp_containership);\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid procarp_containership(char **unforeign_recuperative)\r\n{\r\n int nonmilitary_cadelle = 0;\r\n char *ferahan_perimorph = 0;\r\n int foretimes_lento = 7;\r\n char *wiggiest_saltarella;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&wiggiest_saltarella,\"9378\",foretimes_lento);\r\n if (wiggiest_saltarella != 0) {;\r\n nonmilitary_cadelle = ((int )(strlen(wiggiest_saltarella)));\r\n ferahan_perimorph = ((char *)(malloc(nonmilitary_cadelle + 1)));\r\n if (ferahan_perimorph == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(ferahan_perimorph,0,nonmilitary_cadelle + 1);\r\n memcpy(ferahan_perimorph,wiggiest_saltarella,nonmilitary_cadelle);\r\n if (wiggiest_saltarella != 0) \r\n free(((char *)wiggiest_saltarella));\r\n *unforeign_recuperative = ferahan_perimorph;\r\n }\r\n}\r\n\r\nvoid hensonville_kala(void (*doublehanded_vantages)(char **))\r\n{\r\n ++global_variable;\r\n char *polyandry_homoeosis = 0;\r\n doublehanded_vantages(&polyandry_homoeosis);\r\n if (polyandry_homoeosis != 0) {;\r\n whitleyville_spermatocide(1,polyandry_homoeosis);\r\n }\r\n}\r\n\r\nvoid whitleyville_spermatocide(int carlin_sadhaka,... )\r\n{\r\n void (*function_ptr_1)() = 0;\r\n void (*function_ptr_2)() = 0;\r\n unsigned long input_num;\r\n void (*function_ptr_3)() = 0;\r\n void (*function_ptr_4)() = 0;\r\n char *byte_4 = 0;\r\n char *byte_3 = 0;\r\n unsigned long *ptr = 0;\r\n char *kessler_proregent = 0;\r\n char *maldonite_hypobole = 0;\r\n va_list gormands_nonexultation;\r\n ++global_variable;;\r\n if (carlin_sadhaka > 0) {\r\n __builtin_va_start(gormands_nonexultation,carlin_sadhaka);\r\n maldonite_hypobole = (va_arg(gormands_nonexultation,char *));\r\n __builtin_va_end(gormands_nonexultation);\r\n }\r\n kessler_proregent = ((char *)maldonite_hypobole);\r\n \r\n function_ptr_1 = function;\r\n function_ptr_2 = function;\r\n function_ptr_3 = function;\r\n function_ptr_4 = function;\r\n if (strlen(kessler_proregent) >= 1 &&\r\n kessler_proregent[0] != '-') {\r\n input_num = strtoul(kessler_proregent,0U,16);\r\n ptr = &input_num;\r\n if ( *ptr > 65535) {\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n byte_3 = ((char *)(ptr + 2));\r\n byte_4 = ((char *)(ptr + 3));\r\n \r\n \r\n *byte_3 = 0;\r\n *byte_4 = 0;\r\n \r\n \r\n \r\n \r\n \r\n }\r\n \r\n \r\n function_ptr_1();\r\n function_ptr_2();\r\n function_ptr_3();\r\n function_ptr_4();\r\n \r\n printf(\"Value = %i\\n\", input_num);\r\n } else if (strlen(kessler_proregent) == 0) {\r\n printf(\"Input is empty string\\n\");\r\n } else {\r\n printf(\"Input is negative number\\n\");\r\n }\r\n \r\n;\r\n if (maldonite_hypobole != 0) \r\n free(((char *)maldonite_hypobole));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-682:Incorrect Calculation|A.CWE-705:Incorrect Control Flow Scoping", "cwe": "682"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-123:Write-what-where Condition\nB.No Vulnerabilities\nC.CWE-284:Improper Access Control\nD.CWE-787:Out-of-bounds Write\nE.CWE-357:Insufficient UI Warning of Dangerous Operations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fgets_51bSink(mStruct data);\r\n\r\nvoid My_fgets_51()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n My_fgets_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fgets_51bG2BSink(mStruct data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n My_fgets_51bG2BSink(data);\r\n}\r\n\r\nvoid My_fgets_51()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-93:Improper Neutralization of CRLF Sequences ('CRLF Injection')\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-489:Active Debug Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_int_malloc_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = (int *)malloc(100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new int[100];\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = new int[100];\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_int_malloc_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\nB.No Vulnerabilities\nC.CWE-36:Absolute Path Traversal\nD.CWE-1097:Persistent Storable Data Element without Associated Comparison Control Element\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_wchar_t_listen_socket_open_34\r\n{\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n unionType myUnion;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n unionType myUnion;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_listen_socket_open_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.CWE-359:Exposure of Private Personal Information to an Unauthorized Actor\nC.No Vulnerabilities\nD.CWE-390:Detection of Error Condition Without Action\nE.CWE-20:Improper Input Validation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_wchar_t_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printWLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n printWLine(L\"fgetws failed!\");\r\n exit(1);\r\n }\r\n printWLine(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fgets_wchar_t_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_wchar_t_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_wchar_t_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-646:Reliance on File Name or Extension of Externally-Supplied File\nD.CWE-6:J2EE Misconfiguration: Insufficient Session-ID Length\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\nnamespace My_w32CreateFile_no_close_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32CreateFile_no_close_83\r\n{\r\npublic:\r\n My_w32CreateFile_no_close_83(HANDLE dataCopy);\r\n ~My_w32CreateFile_no_close_83();\r\n\r\nprivate:\r\n HANDLE data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32CreateFile_no_close_83B2G\r\n{\r\npublic:\r\n My_w32CreateFile_no_close_83B2G(HANDLE dataCopy);\r\n ~My_w32CreateFile_no_close_83B2G();\r\n\r\nprivate:\r\n HANDLE data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1280:Access Control Check Implemented After Asset is Accessed\nC.CWE-1269:Product Released in Non-Release Configuration\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_accept_bind_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_accept_bind_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_accept_bind_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_accept_bind_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-319:Cleartext Transmission of Sensitive Information\nB.CWE-1317:Improper Access Control in Fabric Bridge\nC.CWE-311:Missing Encryption of Sensitive Data\nD.No Vulnerabilities\nE.CWE-667:Improper Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_listen_socket_14()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalFive==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalFive==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalFive==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalFive==5)\r\n {\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_listen_socket_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_listen_socket_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_listen_socket_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-319:Cleartext Transmission of Sensitive Information|C.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-683:Function Call With Incorrect Order of Arguments\nB.No Vulnerabilities\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_bind_accept_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_bind_accept_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_bind_accept_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_bind_accept_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-478:Missing Default Case in Multiple Condition Expression\nB.CWE-797:Only Filtering Special Elements at an Absolute Position\nC.CWE-563:Assignment to Variable without Use\nD.CWE-1164:Irrelevant Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_unused_value_char_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_unused_value_char_84\r\n{\r\npublic:\r\n My_unused_value_char_84(char dataCopy);\r\n ~My_unused_value_char_84();\r\n\r\nprivate:\r\n char data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_unused_value_char_84G2B\r\n{\r\npublic:\r\n My_unused_value_char_84G2B(char dataCopy);\r\n ~My_unused_value_char_84G2B();\r\n\r\nprivate:\r\n char data;\r\n};\r\n\r\nclass My_unused_value_char_84B2G\r\n{\r\npublic:\r\n My_unused_value_char_84B2G(char dataCopy);\r\n ~My_unused_value_char_84B2G();\r\n\r\nprivate:\r\n char data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nC.CWE-797:Only Filtering Special Elements at an Absolute Position\nD.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nE.CWE-413:Improper Resource Locking\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_65bSink(char * password);\r\n\r\nvoid My_w32_char_65()\r\n{\r\n char * password;\r\n \r\n void (*funcPtr) (char *) = My_w32_char_65bSink;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n \r\n funcPtr(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_65bG2BSink(char * password);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n void (*funcPtr) (char *) = My_w32_char_65bG2BSink;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n funcPtr(password);\r\n}\r\n\r\nvoid My_w32_char_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-591:Sensitive Data Storage in Improperly Locked Memory|E.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1122:Excessive Halstead Complexity\nB.No Vulnerabilities\nC.CWE-638:Not Using Complete Mediation\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-789:Memory Allocation with Excessive Size Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_wchar_t_connect_socket_82\r\n{\r\n\r\nclass My_new_wchar_t_connect_socket_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(size_t data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_wchar_t_connect_socket_82 : public My_new_wchar_t_connect_socket_82_base\r\n{\r\npublic:\r\n void action(size_t data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_wchar_t_connect_socket_82G2B : public My_new_wchar_t_connect_socket_82_base\r\n{\r\npublic:\r\n void action(size_t data);\r\n};\r\n\r\nclass My_new_wchar_t_connect_socket_82B2G : public My_new_wchar_t_connect_socket_82_base\r\n{\r\npublic:\r\n void action(size_t data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-789:Memory Allocation with Excessive Size Value|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1283:Mutable Attestation or Measurement Reporting Data\nB.No Vulnerabilities\nC.CWE-140:Improper Neutralization of Delimiters\nD.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nE.CWE-693:Protection Mechanism Failure\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_3DES_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_3DES_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_3DES_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_3DES_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|E.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.CWE-353:Missing Support for Integrity Check\nC.CWE-240:Improper Handling of Inconsistent Structural Elements\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_cat_01()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_cat_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_cat_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_cat_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-348:Use of Less Trusted Source\nC.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nD.CWE-1038:Insecure Automated Optimizations\nE.CWE-535:Exposure of Information Through Shell Error Message\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fprintf(stderr, \"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-535:Exposure of Information Through Shell Error Message|C.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-191:Integer Underflow (Wrap or Wraparound)\nC.CWE-787:Out-of-bounds Write\nD.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_fscanf_predec_31()\r\n{\r\n short data;\r\n data = 0;\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n {\r\n short dataCopy = data;\r\n short data = dataCopy;\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n data = 0;\r\n \r\n data = -2;\r\n {\r\n short dataCopy = data;\r\n short data = dataCopy;\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n short data;\r\n data = 0;\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n {\r\n short dataCopy = data;\r\n short data = dataCopy;\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_fscanf_predec_31()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_fscanf_predec_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_fscanf_predec_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-242:Use of Inherently Dangerous Function\nC.CWE-1177:Use of Prohibited Code\nD.CWE-166:Improper Handling of Missing Special Element\nE.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 10\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n \r\n result = gets(dest);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n result = fgets(dest, DEST_SIZE, stdin);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n result = fgets(dest, DEST_SIZE, stdin);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-242:Use of Inherently Dangerous Function|C.CWE-1177:Use of Prohibited Code", "cwe": "242"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-157:Failure to Sanitize Paired Delimiters\nB.CWE-788:Access of Memory Location After End of Buffer\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-476:NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint samnite_sanguisorbaceae = 0;\r\ntypedef char *sphyraenoid_taegu;\r\nint global_variable;\r\nvoid handle_taint(char *unface_wini);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid baecher_adversus(sphyraenoid_taegu drugeteria_costars);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&samnite_sanguisorbaceae,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#define EXPLORATIONAL_WARMHEARTEDNESS(x) baecher_adversus((sphyraenoid_taegu) x)\r\n\r\nvoid handle_taint(char *unface_wini)\r\n{\r\n sphyraenoid_taegu unornamental_complanate = 0;\r\n long radio_choppin[10];\r\n sphyraenoid_taegu forthputting_immaterialist[10] = {0};\r\n sphyraenoid_taegu curiologic_niffers = 0;\r\n ++global_variable;;\r\n if (unface_wini != 0) {;\r\n curiologic_niffers = unface_wini;\r\n forthputting_immaterialist[5] = curiologic_niffers;\r\n radio_choppin[1] = 5;\r\n unornamental_complanate = *(forthputting_immaterialist + radio_choppin[1]);\r\n\tEXPLORATIONAL_WARMHEARTEDNESS(unornamental_complanate);\r\n }\r\n}\r\n\r\nvoid baecher_adversus(sphyraenoid_taegu drugeteria_costars)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *neuroanatomy_minutely = 0;\r\n ++global_variable;;\r\n neuroanatomy_minutely = ((char *)drugeteria_costars);\r\n \r\n buffer_value = atoi(neuroanatomy_minutely);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\n if (drugeteria_costars != 0) \r\n free(((char *)drugeteria_costars));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-476:NULL Pointer Dereference|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-625:Permissive Regular Expression\nB.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nC.CWE-127:Buffer Under-read\nD.No Vulnerabilities\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE839_negative_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-272:Least Privilege Violation\nB.CWE-271:Privilege Dropping / Lowering Errors\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.CWE-705:Incorrect Control Flow Scoping\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateProcessAsUser_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserW(pHandle,\r\n NULL,\r\n L\"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserW(pHandle,\r\n NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n STARTUPINFOW si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserW(pHandle,\r\n NULL,\r\n L\"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateProcessAsUser_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateProcessAsUser_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateProcessAsUser_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-272:Least Privilege Violation|B.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1285:Improper Validation of Specified Index, Position, or Offset in Input\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-589:Call to Non-ubiquitous API\nD.No Vulnerabilities\nE.CWE-400:Uncontrolled Resource Consumption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\nusing namespace std;\r\n\r\nnamespace My_listen_socket_for_loop_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<int> countList);\r\n\r\nvoid m()\r\n{\r\n int count;\r\n list<int> countList;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n countList.push_back(count);\r\n countList.push_back(count);\r\n countList.push_back(count);\r\n mSink(countList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<int> countList);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n list<int> countList;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n \r\n countList.push_back(count);\r\n countList.push_back(count);\r\n countList.push_back(count);\r\n nG2BSink(countList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<int> countList);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n list<int> countList;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n countList.push_back(count);\r\n countList.push_back(count);\r\n countList.push_back(count);\r\n nB2GSink(countList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_listen_socket_for_loop_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-447:Unimplemented or Unsupported Feature in UI\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-11:ASP.NET Misconfiguration: Creating Debug Binary\nE.CWE-377:Insecure Temporary File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define MKTEMP _wmktemp\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_mktemp_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_mktemp_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_mktemp_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_mktemp_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-377:Insecure Temporary File|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-685:Function Call With Incorrect Number of Arguments\nB.No Vulnerabilities\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-321:Use of Hard-coded Cryptographic Key\nE.CWE-671:Lack of Administrator Control over Security\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_12()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-321:Use of Hard-coded Cryptographic Key|C.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-317:Cleartext Storage of Sensitive Information in GUI\nC.No Vulnerabilities\nD.CWE-1094:Excessive Index Range Scan for a Data Resource\nE.CWE-476:NULL Pointer Dereference\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint microfilaria_encyclical = 0;\r\nint global_variable;\r\ntypedef char *rask_ultralaborious;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nrask_ultralaborious townspeople_unpropriety(rask_ultralaborious bushwife_perceive);\r\nvoid unmanoeuvred_baboo(rask_ultralaborious rabbets_fumaria);\r\n\r\nunsigned int avdevice_version()\r\n{\r\n void (*tholeite_pyxis)(rask_ultralaborious ) = unmanoeuvred_baboo;\r\n rask_ultralaborious nonvariably_geniture = 0;\r\n rask_ultralaborious frontier_redecimate = 0;\r\n char *multitude_quadrilaterals;;\r\n if (__sync_bool_compare_and_swap(&microfilaria_encyclical,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n multitude_quadrilaterals = getenv(\"CAULS_ICHTHYOFAUNAL\");\r\n if (multitude_quadrilaterals != 0) {;\r\n frontier_redecimate = multitude_quadrilaterals;\r\n nonvariably_geniture = townspeople_unpropriety(frontier_redecimate);\r\n tholeite_pyxis(nonvariably_geniture);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nrask_ultralaborious townspeople_unpropriety(rask_ultralaborious bushwife_perceive)\r\n{\r\n ++global_variable;\r\n return bushwife_perceive;\r\n}\r\n\r\nvoid unmanoeuvred_baboo(rask_ultralaborious rabbets_fumaria)\r\n{\r\n size_t j = 0;\r\n size_t i = 0;\r\n char *second_buff = 0;\r\n char *finder = \"aba\";\r\n int check = 0;\r\n char *dystocias_janker = 0;\r\n ++global_variable;;\r\n dystocias_janker = ((char *)rabbets_fumaria);\r\n \r\n \r\n for (i = 0; ((int )i) <= ((int )(strlen(dystocias_janker) - strlen(finder))); ++i) {\r\n for (j = 0; j < strlen(finder); ++j) {\r\n if (dystocias_janker[i + j] != finder[j]) {\r\n check = 0;\r\n break;\r\n }\r\n check = 1;\r\n }\r\n\r\n if (check == 1 && j == strlen(finder)) {\r\n printf(\"Found aba string\\n\");\r\n second_buff = &dystocias_janker[i];\r\n break;\r\n }\r\n }\r\n \r\n \r\n \r\n\r\n printf(\"String length is %i\\n\", strlen(second_buff));\r\n \r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-476:NULL Pointer Dereference|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-468:Incorrect Pointer Scaling\nD.CWE-694:Use of Multiple Resources with Duplicate Identifier\nE.CWE-1321:Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-468:Incorrect Pointer Scaling|B.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-331:Insufficient Entropy\nB.CWE-1334:Unauthorized Error Injection Can Degrade Hardware Redundancy\nC.No Vulnerabilities\nD.CWE-122:Heap-based Buffer Overflow\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic int * My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_CWE805_int_memmove_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-122:Heap-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-522:Insufficiently Protected Credentials\nB.CWE-487:Reliance on Package-level Scope\nC.CWE-256:Plaintext Storage of a Password\nD.No Vulnerabilities\nE.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_18()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|A.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.CWE-301:Reflection Attack in an Authentication Protocol\nC.No Vulnerabilities\nD.CWE-348:Use of Less Trusted Source\nE.CWE-457:Use of Uninitialized Variable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_array_declare_no_init_15()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n twoIntsStruct dataUninitArray[10];\r\n data = dataUninitArray;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_struct_array_declare_no_init_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_array_declare_no_init_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_array_declare_no_init_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-457:Use of Uninitialized Variable|A.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-213:Exposure of Sensitive Information Due to Incompatible Policies\nC.CWE-414:Missing Lock Check\nD.CWE-522:Insufficiently Protected Credentials\nE.CWE-256:Plaintext Storage of a Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\ntypedef union\r\n{\r\n char * unionFirst;\r\n char * unionSecond;\r\n} My_w32_char_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_34()\r\n{\r\n char * data;\r\n My_w32_char_34_unionType myUnion;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n My_w32_char_34_unionType myUnion;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n My_w32_char_34_unionType myUnion;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_34()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-256:Plaintext Storage of a Password|D.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.CWE-299:Improper Check for Certificate Revocation\nC.CWE-172:Encoding Error\nD.CWE-390:Detection of Error Condition Without Action\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_char_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n printLine(\"Please enter a string: \");\r\n \r\n if (fgets(data, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_char_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_char_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_char_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1277:Firmware Not Updateable\nB.CWE-197:Numeric Truncation Error\nC.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n#include \"cryptlib.h\"\r\n#include <openssl/evp.h>\r\n#include <openssl/lhash.h>\r\n#include \"eng_int.h\"\r\n\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct st_engine_pile {\r\n\r\nint nid;\r\n\r\nstruct stack_st_ENGINE *sk;\r\n\r\nENGINE *funct;\r\n\r\nint uptodate;}ENGINE_PILE;\r\n\r\nstruct lhash_st_ENGINE_PILE \r\n{\r\n int dummy;\r\n}\r\n;\r\n\r\n\r\nstruct st_engine_table \r\n{\r\n struct lhash_st_ENGINE_PILE piles;\r\n\r\n}\r\n;\r\ntypedef struct st_engine_pile_doall {\r\nengine_table_doall_cb *cb;\r\nvoid *arg;}ENGINE_PILE_DOALL;\r\n\r\nstatic unsigned int table_flags = 0;\r\n\r\nint pinang_ada = 0;\r\nint global_variable;\r\nvoid handle_taint(char *jotham_telesthesia);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct struct_data {\r\n char *buffer_member;\r\n unsigned short size_member;\r\n};\r\nstruct struct_data *init_data(long number_param)\r\n{\r\n \r\n struct struct_data *init_data_ptr = 0;\r\n init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\r\n if (init_data_ptr == 0)\r\n return 0;\r\n init_data_ptr -> size_member = 0;\r\n \r\n\r\n init_data_ptr -> size_member = number_param;\r\n init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\r\n \r\n \r\n \r\n if (init_data_ptr -> buffer_member == 0) {\r\n free(init_data_ptr);\r\n return 0;\r\n }\r\n memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\r\n init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\r\n return init_data_ptr;\r\n}\r\n\r\nunsigned int ENGINE_get_table_flags()\r\n{\r\n return table_flags;\r\n}\r\n\r\nvoid ENGINE_set_table_flags(unsigned int flags)\r\n{\r\n table_flags = flags;\r\n}\r\n\r\n\r\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\r\n{\r\n return (c -> nid);\r\n}\r\n\r\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\r\n{\r\n return a -> nid - b -> nid;\r\n}\r\n\r\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\r\n{\r\n const ENGINE_PILE *a = arg;\r\n return engine_pile_hash(a);\r\n}\r\n\r\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\r\n{\r\n const ENGINE_PILE *a = arg1;\r\n const ENGINE_PILE *b = arg2;\r\n return engine_pile_cmp(a,b);\r\n}\r\n\r\nstatic int int_table_check(ENGINE_TABLE **t,int create)\r\n{\r\n struct lhash_st_ENGINE_PILE *lh;\r\n if ( *t) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\r\n return 0;\r\n }\r\n *t = ((ENGINE_TABLE *)lh);\r\n return 1;\r\n}\r\n\r\n\r\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\r\n{\r\n int ret = 0;\r\n int added = 0;\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd;\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\r\n if (!( *table)) {\r\n added = 1;\r\n }\r\n if (!int_table_check(table,1)) {\r\n goto end;\r\n }\r\n if (added) {\r\n\r\n engine_cleanup_add_first(cleanup);\r\n }\r\n while(num_nids--){\r\n tmplate . nid = *nids;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n fnd -> uptodate = 1;\r\n fnd -> nid = *nids;\r\n fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\r\n if (!fnd -> sk) {\r\n CRYPTO_free(fnd);\r\n goto end;\r\n }\r\n fnd -> funct = ((void *)0);\r\n (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\r\n }\r\n\r\n (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\r\n\r\n if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\r\n goto end;\r\n }\r\n\r\n fnd -> uptodate = 0;\r\n if (setdefault) {\r\n if (!engine_unlocked_init(e)) {\r\n ERR_put_error(38,184,109,\"eng_table.c\",174);\r\n goto end;\r\n }\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = e;\r\n fnd -> uptodate = 1;\r\n }\r\n nids++;\r\n }\r\n ret = 1;\r\n end:\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\r\n return ret;\r\n}\r\n\r\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\r\n{\r\n int n;\r\n\r\n while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\r\n (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\r\n pile -> uptodate = 0;\r\n }\r\n if (pile -> funct == e) {\r\n engine_unlocked_finish(e,0);\r\n pile -> funct = ((void *)0);\r\n }\r\n}\r\n\r\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE *b = arg2;\r\n int_unregister_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\r\n if (int_table_check(table,0)) {\r\n lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\r\n}\r\n\r\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\r\n{\r\n sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\r\n if (p -> funct) {\r\n engine_unlocked_finish(p -> funct,0);\r\n }\r\n CRYPTO_free(p);\r\n}\r\n\r\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\r\n{\r\n ENGINE_PILE *a = arg;\r\n if (__sync_bool_compare_and_swap(&pinang_ada,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n int_cleanup_cb_doall(a);\r\n}\r\n\r\nvoid engine_table_cleanup(ENGINE_TABLE **table)\r\n{\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\r\n if ( *table) {\r\n lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\r\n lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\r\n *table = ((void *)0);\r\n }\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\r\n}\r\n\r\n#ifndef ENGINE_TABLE_DEBUG\r\n\r\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\r\n#else\r\n#endif\r\n{\r\n ENGINE *ret = ((void *)0);\r\n ENGINE_PILE tmplate;\r\n ENGINE_PILE *fnd = ((void *)0);\r\n int initres;\r\n int loop = 0;\r\n if (!( *table)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n return ((void *)0);\r\n }\r\n ERR_set_mark();\r\n CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\r\n\r\n if (!int_table_check(table,0)) {\r\n goto end;\r\n }\r\n tmplate . nid = nid;\r\n fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\r\n if (!fnd) {\r\n goto end;\r\n }\r\n if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n if (fnd -> uptodate) {\r\n ret = fnd -> funct;\r\n goto end;\r\n }\r\n trynext:\r\n ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\r\n if (!ret) {\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n\r\n if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\r\n initres = engine_unlocked_init(ret);\r\n }\r\n else {\r\n initres = 0;\r\n }\r\n if (initres) {\r\n\r\n if (fnd -> funct != ret && engine_unlocked_init(ret)) {\r\n\r\n if (fnd -> funct) {\r\n engine_unlocked_finish(fnd -> funct,0);\r\n }\r\n fnd -> funct = ret;\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n goto end;\r\n }\r\n goto trynext;\r\n end:\r\n\r\n if (fnd) {\r\n fnd -> uptodate = 1;\r\n }\r\n#ifdef ENGINE_TABLE_DEBUG\r\n#endif\r\n CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\r\n\r\n ERR_pop_to_mark();\r\n return ret;\r\n}\r\n\r\n\r\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\r\n{\r\n (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\r\n}\r\n\r\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\r\n{\r\n ENGINE_PILE *a = arg1;\r\n ENGINE_PILE_DOALL *b = arg2;\r\n int_cb_doall_arg(a,b);\r\n}\r\n\r\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\r\n{\r\n ENGINE_PILE_DOALL dall;\r\n dall . cb = cb;\r\n dall . arg = arg;\r\n lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\r\n}\r\n\r\nvoid handle_taint(char *jotham_telesthesia)\r\n{\r\n long number;\r\n struct struct_data *data = 0;\r\n char *wagon_cheapened = 0;\r\n int dryopians_lipkin;\r\n int kajeputs_slugger;\r\n char *catamnestic_disillusive = 0;\r\n int *invariableness_samydaceae = 0;\r\n int nosy_guirlande;\r\n char *empiricists_anemones[10] = {0};\r\n int propoundment_saxicavous = 0;\r\n char *twitty_onionet = 0;\r\n ++global_variable;;\r\n if (jotham_telesthesia != 0) {;\r\n propoundment_saxicavous = ((int )(strlen(jotham_telesthesia)));\r\n twitty_onionet = ((char *)(malloc(propoundment_saxicavous + 1)));\r\n if (twitty_onionet == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(twitty_onionet,0,propoundment_saxicavous + 1);\r\n memcpy(twitty_onionet,jotham_telesthesia,propoundment_saxicavous);\r\n if (jotham_telesthesia != 0) \r\n free(((char *)jotham_telesthesia));\r\n nosy_guirlande = 5;\r\n invariableness_samydaceae = &nosy_guirlande;\r\n empiricists_anemones[ *invariableness_samydaceae] = twitty_onionet;\r\n catamnestic_disillusive = empiricists_anemones[ *invariableness_samydaceae];\r\n kajeputs_slugger = 5;\r\n while(1 == 1){\r\n kajeputs_slugger = kajeputs_slugger * 2;\r\n kajeputs_slugger = kajeputs_slugger + 2;\r\n if (kajeputs_slugger > 1000) {\r\n break; \r\n }\r\n }\r\n dryopians_lipkin = kajeputs_slugger;\r\n wagon_cheapened = ((char *)catamnestic_disillusive);\r\n \r\n number = strtol(wagon_cheapened,0U,10);\r\n if (number > 0) {\r\n data = init_data(number);\r\n if (data != 0) {\r\n \r\n\r\n memset(data -> buffer_member, 98, number);\r\n \r\n data -> buffer_member[number - 1] = 0;\r\n printf(\"%s\\n\", data -> buffer_member);\r\n if (data -> buffer_member != 0U)\r\n free(data -> buffer_member);\r\n if (data != 0U)\r\n free(data);\r\n }\r\n } else {\r\n printf(\"Input is less than or equal to 0\\n\");\r\n }\r\n \r\n;\r\n if (catamnestic_disillusive != 0) \r\n free(((char *)catamnestic_disillusive));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-197:Numeric Truncation Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\nB.CWE-831:Signal Handler Function Associated with Multiple Signals\nC.CWE-157:Failure to Sanitize Paired Delimiters\nD.No Vulnerabilities\nE.CWE-364:Signal Handler Race Condition\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <signal.h> \r\n#include <unistd.h> \r\nint azurine_noncirculation = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid drepanaspis_whitcher(int nijinsky_multichannelled,char **homekeeper_sider);\r\nstruct data {\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nstruct data *Data;\r\nint loop;\r\nint *global1;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid waitForSig() {\r\n int fd;\r\n char outStr[25] = {0};\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForSig\\n\");\r\n sprintf(outStr, \"%d.pid\", getpid());\r\n strcat(filename, \"/opt//workspace/testData/\");\r\n strcat(filename, outStr);\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n \r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n \r\n printf(\"Error writing to file.\");\r\n }\r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n \r\n printf(\"Reading file1\\n\");\r\n readFile(Data->file1);\r\n readFile(Data->file2);\r\n }\r\n}\r\nvoid sig_handler (int sig) {\r\n printf(\"In sig_handler\\n\");\r\n \r\n \r\n \r\n \r\n \r\n global1[0] = -1;\r\n free(global1);\r\n global1 = NULL;\r\n \r\n \r\n printf(\"In sig handler\");\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n int emulatress_psycholeptic = 7;\r\n char **unbutcherlike_mrs = 0;\r\n int *scabish_austenitize = 0;\r\n int hemidactylous_organistic;\r\n char **plinthless_bipartisanism[10] = {0};\r\n char *soothest_lighterful[54] = {0};\r\n char *cautio_weekling;;\r\n if (__sync_bool_compare_and_swap(&azurine_noncirculation,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n cautio_weekling = getenv(\"PIDDLED_UNSALUBRIOUS\");\r\n if (cautio_weekling != 0) {;\r\n soothest_lighterful[45] = cautio_weekling;\r\n plinthless_bipartisanism[5] = soothest_lighterful;\r\n hemidactylous_organistic = 5;\r\n scabish_austenitize = &hemidactylous_organistic;\r\n unbutcherlike_mrs = *(plinthless_bipartisanism + *scabish_austenitize);\r\n drepanaspis_whitcher(emulatress_psycholeptic,unbutcherlike_mrs);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid drepanaspis_whitcher(int nijinsky_multichannelled,char **homekeeper_sider)\r\n{\r\n char *dreyfuss_maddle = 0;\r\n ++global_variable;\r\n nijinsky_multichannelled--;\r\n if (nijinsky_multichannelled > 0) {\r\n drepanaspis_whitcher(nijinsky_multichannelled,homekeeper_sider);\r\n return ;\r\n }\r\n dreyfuss_maddle = ((char *)homekeeper_sider[45]);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(dreyfuss_maddle) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(dreyfuss_maddle) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(dreyfuss_maddle) + 1));\r\n if (Data->data) {\r\n if ((sscanf(dreyfuss_maddle, \"%s %s %s\",\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 3) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n global1 = calloc(1, sizeof(int));\r\n \r\n \r\n \r\n \r\n if (signal(SIGUSR1, sig_handler) == SIG_ERR) {\r\n \r\n printf (\"Error catching SIGUSR1!\\n\");\r\n }\r\n printf(\"Set up SIGUSR1 handler\\n\");\r\n if (Data->data[0] >= 'A' && Data->data[0] <= 'Z') {\r\n if (signal(SIGUSR2, sig_handler) == SIG_ERR) {\r\n \r\n printf (\"Error catching SIGUSR2!\\n\");\r\n }\r\n printf(\"Set up SIGUSR2 handler\\n\");\r\n }\r\n waitForSig();\r\n printf(\"After waitForSig\\n\");\r\n signal(SIGUSR1, SIG_IGN); \r\n signal(SIGUSR2, SIG_IGN); \r\n if (global1 != NULL) {\r\n free(global1);\r\n global1 = NULL;\r\n }\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free (Data);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-831:Signal Handler Function Associated with Multiple Signals|E.CWE-364:Signal Handler Race Condition", "cwe": "831"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1204:Generation of Weak Initialization Vector (IV)\nB.CWE-580:clone() Method Without super.clone()\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_accept_listen_bind_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_accept_listen_bind_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_accept_listen_bind_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_accept_listen_bind_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-666:Operation on Resource in Wrong Phase of Lifetime|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1116:Inaccurate Comments\nB.CWE-770:Allocation of Resources Without Limits or Throttling\nC.No Vulnerabilities\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.CWE-1173:Improper Use of Validation Framework\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_fscanf_32\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n size_t *dataPtr1 = &data;\r\n size_t *dataPtr2 = &data;\r\n \r\n data = 0;\r\n {\r\n size_t data = *dataPtr1;\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n *dataPtr1 = data;\r\n }\r\n {\r\n size_t data = *dataPtr2;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n size_t *dataPtr1 = &data;\r\n size_t *dataPtr2 = &data;\r\n \r\n data = 0;\r\n {\r\n size_t data = *dataPtr1;\r\n \r\n data = 20;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n size_t data = *dataPtr2;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n size_t *dataPtr1 = &data;\r\n size_t *dataPtr2 = &data;\r\n \r\n data = 0;\r\n {\r\n size_t data = *dataPtr1;\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n *dataPtr1 = data;\r\n }\r\n {\r\n size_t data = *dataPtr2;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_fscanf_32; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-789:Memory Allocation with Excessive Size Value|B.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-98:Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')\nB.No Vulnerabilities\nC.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nD.CWE-403:Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')\nE.CWE-710:Improper Adherence to Coding Standards\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_pointer_alloca_use_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n wchar_t * * pointer = (wchar_t * *)ALLOCA(sizeof(wchar_t *));\r\n wchar_t * data = *pointer; \r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * data;\r\n wchar_t * * pointer = (wchar_t * *)ALLOCA(sizeof(wchar_t *));\r\n data = L\"string\";\r\n *pointer = data; \r\n {\r\n wchar_t * data = *pointer;\r\n printWLine(data);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n wchar_t * data;\r\n wchar_t * * pointer = (wchar_t * *)ALLOCA(sizeof(wchar_t *));\r\n data = L\"string\";\r\n *pointer = data; \r\n {\r\n wchar_t * data = *pointer;\r\n printWLine(data);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_pointer_alloca_use_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_pointer_alloca_use_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_pointer_alloca_use_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-270:Privilege Context Switching Error\nB.No Vulnerabilities\nC.CWE-1109:Use of Same Variable for Multiple Purposes\nD.CWE-176:Improper Handling of Unicode Encoding\nE.CWE-172:Encoding Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\nstatic wchar_t * My_w32_45Data;\r\nstatic wchar_t * My_w32_45G2BData;\r\nstatic wchar_t * My_w32_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n wchar_t * data = My_w32_45Data;\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n}\r\n\r\nvoid My_w32_45()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n My_w32_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n wchar_t * data = My_w32_45G2BData;\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n My_w32_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n wchar_t * data = My_w32_45B2GData;\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n My_w32_45B2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_w32_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-176:Improper Handling of Unicode Encoding|E.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nB.CWE-773:Missing Reference to Active File Descriptor or Handle\nC.CWE-771:Missing Reference to Active Allocated Resource\nD.No Vulnerabilities\nE.CWE-792:Incomplete Filtering of One or More Instances of Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fopen_52bSink(FILE * data);\r\n\r\nvoid My_fopen_52()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fopen_52bB2GSink(FILE * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_52bB2GSink(data);\r\n}\r\n\r\nvoid My_fopen_52()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-773:Missing Reference to Active File Descriptor or Handle|C.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-781:Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code\nB.CWE-546:Suspicious Comment\nC.No Vulnerabilities\nD.CWE-697:Incorrect Comparison\nE.CWE-1078:Inappropriate Source Code Style or Formatting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_HACK_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_HACK_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_HACK_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_HACK_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-546:Suspicious Comment|E.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-693:Protection Mechanism Failure\nB.No Vulnerabilities\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-184:Incomplete List of Disallowed Inputs\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_list_int_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n if(staticFive==5)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n list<int> data;\r\n if(staticFive==5)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n list<int> data;\r\n if(staticFive==5)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n list<int> data;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n list<int> data;\r\n if(staticFive==5)\r\n {\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-672:Operation on a Resource after Expiration or Release|E.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-842:Placement of User into Incorrect Group\nB.No Vulnerabilities\nC.CWE-687:Function Call With Incorrectly Specified Argument Value\nD.CWE-787:Out-of-bounds Write\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_listen_socket_66bSink(mStruct dataArray[]);\r\n\r\nvoid My_listen_socket_66()\r\n{\r\n mStruct data;\r\n mStruct dataArray[5];\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataArray[2] = data;\r\n My_listen_socket_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_listen_socket_66bG2BSink(mStruct dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n mStruct dataArray[5];\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n dataArray[2] = data;\r\n My_listen_socket_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_listen_socket_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1113:Inappropriate Comment Style\nC.CWE-73:External Control of File Name or Path\nD.CWE-114:Process Control\nE.CWE-581:Object Model Violation: Just One of Equals and Hashcode Defined\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_relativePath_13()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n strcpy(data, \"winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_relativePath_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_relativePath_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_relativePath_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-547:Use of Hard-coded, Security-relevant Constants\nC.CWE-259:Use of Hard-coded Password\nD.CWE-48:Path Equivalence: 'file name' (Internal Whitespace)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_09()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n strcpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-259:Use of Hard-coded Password|A.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-427:Uncontrolled Search Path Element\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-154:Improper Neutralization of Variable Name Delimiters\nD.CWE-749:Exposed Dangerous Method or Function\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_listen_socket_18()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n \r\n wcscat(data, NEW_PATH);\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_wchar_t_listen_socket_18()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_listen_socket_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_listen_socket_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-392:Missing Report of Error Condition\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-665:Improper Initialization\nE.CWE-296:Improper Following of a Certificate's Chain of Trust\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_pointer_12()\r\n{\r\n char * data;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n data = \"string\";\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printLine(data);\r\n }\r\n else\r\n {\r\n \r\n data = \"string\";\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = \"string\";\r\n printLine(data);\r\n }\r\n else\r\n {\r\n \r\n data = \"string\";\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = \"string\";\r\n }\r\n else\r\n {\r\n \r\n data = \"string\";\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printLine(data);\r\n }\r\n else\r\n {\r\n \r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_pointer_12()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_pointer_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_pointer_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-457:Use of Uninitialized Variable|D.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-134:Use of Externally-Controlled Format String\nB.No Vulnerabilities\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-1268:Policy Privileges are not Assigned Consistently Between Control and Data Agents\nE.CWE-1062:Parent Class with References to Child Class\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_console_printf_53bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_console_printf_53()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n My_wchar_t_console_printf_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_console_printf_53bG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, L\"fixedstringtest\");\r\n My_wchar_t_console_printf_53bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_wchar_t_console_printf_53bB2GSink(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n My_wchar_t_console_printf_53bB2GSink(data);\r\n}\r\n\r\nvoid My_wchar_t_console_printf_53()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_console_printf_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_console_printf_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-134:Use of Externally-Controlled Format String|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1055:Multiple Inheritance from Concrete Classes\nB.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-23:Relative Path Traversal\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH L\"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH L\"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_wchar_t_console_open_51\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"file.txt\");\r\n nG2BSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_console_open_51; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-23:Relative Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.CWE-580:clone() Method Without super.clone()\nC.CWE-303:Incorrect Implementation of Authentication Algorithm\nD.No Vulnerabilities\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int data)\r\n{\r\n {\r\n int buffer[10] = { 0 };\r\n \r\n if (data < 10)\r\n {\r\n printIntLine(buffer[data]);\r\n }\r\n else\r\n {\r\n printLine(\"ERROR: Array index is too big.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_My_My_My_CWE839_fgets_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-277:Insecure Inherited Permissions\nB.CWE-42:Path Equivalence: 'filename.' (Trailing Dot)\nC.No Vulnerabilities\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_stat_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-123:Write-what-where Condition\nC.CWE-1121:Excessive McCabe Cyclomatic Complexity\nD.CWE-1322:Use of Blocking Code in Single-threaded, Non-blocking Context\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fgets_65bSink(mStruct data);\r\n\r\nvoid My_fgets_65()\r\n{\r\n mStruct data;\r\n \r\n void (*funcPtr) (mStruct) = My_fgets_65bSink;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fgets_65bG2BSink(mStruct data);\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n void (*funcPtr) (mStruct) = My_fgets_65bG2BSink;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n funcPtr(data);\r\n}\r\n\r\nvoid My_fgets_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1319:Improper Protection against Electromagnetic Fault Injection (EM-FI)\nC.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nD.CWE-126:Buffer Over-read\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE129_rand_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-682:Incorrect Calculation\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-625:Permissive Regular Expression\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_connect_socket_postdec_08()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > INT_MIN)\r\n {\r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n if (data > INT_MIN)\r\n {\r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = -2;\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n \r\n data--;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_connect_socket_postdec_08()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_postdec_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_postdec_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|B.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1395:Dependency on Vulnerable Third-Party Component\nB.CWE-252:Unchecked Return Value\nC.No Vulnerabilities\nD.CWE-428:Unquoted Search Path or Element\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define RENAME rename\r\n#else\r\n#define RENAME rename\r\n#endif\r\n\r\n#define OLD_M_FILE_NAME \"oldmfilename.txt\"\r\n#define OLD_N_FILE_NAME \"oldnfilename.txt\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_rename_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n RENAME(OLD_M_FILE_NAME, \"newmfilename.txt\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, \"newnfilename.txt\") != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_rename_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_rename_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_rename_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-693:Protection Mechanism Failure\nB.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nC.CWE-593:Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\nD.CWE-1285:Improper Validation of Specified Index, Position, or Offset in Input\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_3DES_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_3DES_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_3DES_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_3DES_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|A.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-351:Insufficient Type Distinction\nB.CWE-126:Buffer Over-read\nC.No Vulnerabilities\nD.CWE-788:Access of Memory Location After End of Buffer\nE.CWE-674:Uncontrolled Recursion\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_memmove_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i;\r\n wchar_t * data;\r\n data = NULL;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = new wchar_t[50];\r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n wchar_t * data;\r\n data = NULL;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = new wchar_t[100];\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_memmove_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-126:Buffer Over-read|D.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-464:Addition of Data Structure Sentinel\nB.CWE-1265:Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\nC.No Vulnerabilities\nD.CWE-138:Improper Neutralization of Special Elements\nE.CWE-300:Channel Accessible by Non-Endpoint\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_31()\r\n{\r\n char data;\r\n data = ' ';\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n {\r\n char dataCopy = data;\r\n char data = dataCopy;\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n \r\n data = 'a';\r\n {\r\n char dataCopy = data;\r\n char data = dataCopy;\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-464:Addition of Data Structure Sentinel|D.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-287:Improper Authentication\nC.CWE-710:Improper Adherence to Coding Standards\nD.No Vulnerabilities\nE.CWE-584:Return Inside Finally Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_pointer_new_use_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n TwoIntsClass * * pointer = new TwoIntsClass *;\r\n TwoIntsClass * data = *pointer; \r\n delete pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n TwoIntsClass * data;\r\n \r\n data = new TwoIntsClass;\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n TwoIntsClass * * pointer = new TwoIntsClass *;\r\n *pointer = data; \r\n {\r\n TwoIntsClass * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n TwoIntsClass * data;\r\n \r\n data = new TwoIntsClass;\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n TwoIntsClass * * pointer = new TwoIntsClass *;\r\n *pointer = data; \r\n {\r\n TwoIntsClass * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n delete pointer;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_pointer_new_use_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-412:Unrestricted Externally Accessible Lock\nB.CWE-667:Improper Locking\nC.CWE-128:Wrap-around Error\nD.No Vulnerabilities\nE.CWE-357:Insufficient UI Warning of Dangerous Operations\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <unistd.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint epiphonemas_hayatake = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int fd;\r\n char *extension = \".lck\";\r\n char *thelockfile;\r\n char *anno_louisianians = 0;\r\n jmp_buf primp_sovkhoz;\r\n int carbolising_tanga;\r\n void **costain_adjument = 0;\r\n void *labyrinthitis_foresweat = 0;\r\n char *biliverdic_myriapodan;;\r\n if (__sync_bool_compare_and_swap(&epiphonemas_hayatake,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n biliverdic_myriapodan = getenv(\"DIFFRACTION_HOMOANISIC\");\r\n if (biliverdic_myriapodan != 0) {;\r\n labyrinthitis_foresweat = ((void *)biliverdic_myriapodan);\r\n costain_adjument = &labyrinthitis_foresweat;\r\n carbolising_tanga = setjmp(primp_sovkhoz);\r\n if (carbolising_tanga == 0) {\r\n longjmp(primp_sovkhoz,1);\r\n }\r\n anno_louisianians = ((char *)((char *)( *costain_adjument)));\r\n \r\n thelockfile = (char *)malloc(strlen(\"/opt//workspace/testData/\") + strlen(anno_louisianians) +\r\n strlen(extension) + 1);\r\n \r\n if (thelockfile) {\r\n \r\n \r\n strcpy(thelockfile, \"/opt//workspace/testData/\");\r\n strcat(thelockfile, anno_louisianians);\r\n strcat(thelockfile, extension);\r\n \r\n \r\n if (access(\"/opt//workspace/testData/\", R_OK && W_OK) == -1) {\r\n printf(\"Error accessing testData directory\\n\");\r\n } else {\r\n printf(\"Grabbing lock file: %s\\n\", thelockfile);\r\n \r\n \r\n \r\n while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\r\n sleep(0);\r\n }\r\n \r\n printf(\"Made it to the critical section\\n\");\r\n if (fd != -1) {\r\n close(fd);\r\n unlink(thelockfile);\r\n }\r\n free (thelockfile);\r\n }\r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-412:Unrestricted Externally Accessible Lock|B.CWE-667:Improper Locking", "cwe": "412"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-1024:Comparison of Incompatible Types\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-710:Improper Adherence to Coding Standards\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_pointer_alloca_use_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));\r\n twoIntsStruct * data = *pointer; \r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n twoIntsStruct * data;\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));\r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_struct_pointer_alloca_use_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_pointer_alloca_use_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_pointer_alloca_use_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1045:Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor\nB.CWE-836:Use of Password Hash Instead of Password for Authentication\nC.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint systematization_chapatties = 0;\r\nint global_variable;\r\nvoid handle_taint(char *dyess_metalepses);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&systematization_chapatties,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *dyess_metalepses)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *mastodontoid_ophthalmoptosis = 0;\r\n int nonchivalrously_michelangelo;\r\n int falcons_eulogisation;\r\n char *wolcott_chorographical = 0;\r\n int **********tumultuation_incomeless = 0;\r\n int *********platitudinarian_predivide = 0;\r\n int ********castling_sidebar = 0;\r\n int *******uninfringible_famiglietti = 0;\r\n int ******homer_euplotid = 0;\r\n int *****gpcd_enchodontid = 0;\r\n int ****reasoner_overinvolving = 0;\r\n int ***ensculpture_kusimanse = 0;\r\n int **wallpiece_unequalizing = 0;\r\n int *uprightly_nonembryonal = 0;\r\n int hirai_laryngectomized;\r\n char *ump_prejudicious[10] = {0};\r\n int graceful_watchfulness = 0;\r\n char *woofers_pallone = 0;\r\n ++global_variable;;\r\n if (dyess_metalepses != 0) {;\r\n graceful_watchfulness = ((int )(strlen(dyess_metalepses)));\r\n woofers_pallone = ((char *)(malloc(graceful_watchfulness + 1)));\r\n if (woofers_pallone == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(woofers_pallone,0,graceful_watchfulness + 1);\r\n memcpy(woofers_pallone,dyess_metalepses,graceful_watchfulness);\r\n if (dyess_metalepses != 0) \r\n free(((char *)dyess_metalepses));\r\n hirai_laryngectomized = 5;\r\n uprightly_nonembryonal = &hirai_laryngectomized;\r\n wallpiece_unequalizing = &uprightly_nonembryonal;\r\n ensculpture_kusimanse = &wallpiece_unequalizing;\r\n reasoner_overinvolving = &ensculpture_kusimanse;\r\n gpcd_enchodontid = &reasoner_overinvolving;\r\n homer_euplotid = &gpcd_enchodontid;\r\n uninfringible_famiglietti = &homer_euplotid;\r\n castling_sidebar = &uninfringible_famiglietti;\r\n platitudinarian_predivide = &castling_sidebar;\r\n tumultuation_incomeless = &platitudinarian_predivide;\r\n ump_prejudicious[ *( *( *( *( *( *( *( *( *( *tumultuation_incomeless)))))))))] = woofers_pallone;\r\n wolcott_chorographical = ump_prejudicious[ *( *( *( *( *( *( *( *( *( *tumultuation_incomeless)))))))))];\r\n falcons_eulogisation = 5;\r\n while(1 == 1){\r\n falcons_eulogisation = falcons_eulogisation * 2;\r\n falcons_eulogisation = falcons_eulogisation + 2;\r\n if (falcons_eulogisation > 1000) {\r\n break; \r\n }\r\n }\r\n nonchivalrously_michelangelo = falcons_eulogisation;\r\n mastodontoid_ophthalmoptosis = ((char *)wolcott_chorographical);\r\n \r\n if (strlen(mastodontoid_ophthalmoptosis) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n snprintf(command_buffer, 1000, \"%s%s\",command_str,mastodontoid_ophthalmoptosis);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n \r\n }\r\n \r\n;\r\n if (wolcott_chorographical != 0) \r\n free(((char *)wolcott_chorographical));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1329:Reliance on Component That is Not Updateable\nB.CWE-272:Least Privilege Violation\nC.CWE-562:Return of Stack Variable Address\nD.CWE-271:Privilege Dropping / Lowering Errors\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateProcessAsUser_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateProcessAsUser_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateProcessAsUser_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateProcessAsUser_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|D.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-469:Use of Pointer Subtraction to Determine Size\nB.CWE-427:Uncontrolled Search Path Element\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_char_environment_22Global = 0;\r\n\r\nchar * My_char_environment_22Source(char * data);\r\n\r\nvoid My_char_environment_22()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n My_char_environment_22Global = 1; \r\n data = My_char_environment_22Source(data);\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_char_environment_22G2B1Global = 0;\r\nint My_char_environment_22G2B2Global = 0;\r\n\r\n\r\nchar * My_char_environment_22G2B1Source(char * data);\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n My_char_environment_22G2B1Global = 0; \r\n data = My_char_environment_22G2B1Source(data);\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nchar * My_char_environment_22G2B2Source(char * data);\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n My_char_environment_22G2B2Global = 1; \r\n data = My_char_environment_22G2B2Source(data);\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_environment_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-427:Uncontrolled Search Path Element|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nB.No Vulnerabilities\nC.CWE-109:Struts: Validator Turned Off\nD.CWE-413:Improper Resource Locking\nE.CWE-294:Authentication Bypass by Capture-replay\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_03()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n if(5==5)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * password;\r\n \r\n password = L\"\";\r\n if(5==5)\r\n {\r\n password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(wchar_t)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n wcscpy(password, L\"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-591:Sensitive Data Storage in Improperly Locked Memory|D.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-703:Improper Check or Handling of Exceptional Conditions\nC.CWE-273:Improper Check for Dropped Privileges\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-357:Insufficient UI Warning of Dangerous Operations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-273:Improper Check for Dropped Privileges|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-253:Incorrect Check of Function Return Value\nC.CWE-140:Improper Neutralization of Delimiters\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-495:Private Data Structure Returned From A Public Method\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fwrite_03()\r\n{\r\n if(5==5)\r\n {\r\n \r\n if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n \r\n if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fwrite_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fwrite_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fwrite_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-253:Incorrect Check of Function Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-836:Use of Password Hash Instead of Password for Authentication\nB.CWE-511:Logic/Time Bomb\nC.No Vulnerabilities\nD.CWE-506:Embedded Malicious Code\nE.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define COUNT_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_counter_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\nvoid My_counter_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_counter_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_counter_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-511:Logic/Time Bomb|D.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nB.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-231:Improper Handling of Extra Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_accept_bind_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_accept_bind_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_accept_bind_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_accept_bind_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-666:Operation on Resource in Wrong Phase of Lifetime|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-675:Multiple Operations on Resource in Single-Operation Context\nC.No Vulnerabilities\nD.CWE-112:Missing XML Validation\nE.CWE-539:Use of Persistent Cookies Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n# define OPEN _open\r\n# define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n# define OPEN open\r\n# define CLOSE close\r\n#endif\r\n\r\nstatic int My_open_45Data;\r\nstatic int My_open_45G2BData;\r\nstatic int My_open_45B2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n int data = My_open_45Data;\r\n \r\n CLOSE(data);\r\n}\r\n\r\nvoid My_open_45()\r\n{\r\n int data;\r\n data = -1; \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n CLOSE(data);\r\n My_open_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n int data = My_open_45G2BData;\r\n \r\n CLOSE(data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n data = -1; \r\n \r\n data = OPEN(\"NSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n My_open_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n int data = My_open_45B2GData;\r\n \r\n \r\n ; \r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n data = -1; \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n CLOSE(data);\r\n My_open_45B2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid My_open_45()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-675:Multiple Operations on Resource in Single-Operation Context|A.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-790:Improper Filtering of Special Elements\nC.CWE-197:Numeric Truncation Error\nD.CWE-447:Unimplemented or Unsupported Feature in UI\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef union\r\n{\r\n short unionFirst;\r\n short unionSecond;\r\n} My_short_rand_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_rand_34()\r\n{\r\n short data;\r\n My_short_rand_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = (short)RAND32();\r\n myUnion.unionFirst = data;\r\n {\r\n short data = myUnion.unionSecond;\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n My_short_rand_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = CHAR_MAX-5;\r\n myUnion.unionFirst = data;\r\n {\r\n short data = myUnion.unionSecond;\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_rand_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_rand_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_rand_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-197:Numeric Truncation Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.No Vulnerabilities\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-685:Function Call With Incorrect Number of Arguments\nE.CWE-692:Incomplete Denylist to Cross-Site Scripting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\ntypedef struct _My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_My_CWE129_connect_socket_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|C.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-415:Double Free\nE.CWE-431:Missing Handler\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_long_01()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n data = (long *)malloc(100*sizeof(long));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n \r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n data = (long *)malloc(100*sizeof(long));\r\n if (data == NULL) {exit(-1);}\r\n \r\n \r\n free(data);\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n data = (long *)malloc(100*sizeof(long));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n \r\n \r\n ; \r\n}\r\n\r\nvoid My_malloc_free_long_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_long_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_long_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-587:Assignment of a Fixed Address to a Pointer\nB.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_alloca_use_01()\r\n{\r\n {\r\n int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));\r\n int64_t data = *pointer; \r\n printLongLongLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n int64_t data;\r\n int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));\r\n data = 5LL;\r\n *pointer = data; \r\n {\r\n int64_t data = *pointer;\r\n printLongLongLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int64_t_alloca_use_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_alloca_use_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_alloca_use_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-757:Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-1048:Invokable Control Element with Large Number of Outward Calls\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_accept_bind_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_listen_accept_bind_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_accept_bind_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_accept_bind_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-252:Unchecked Return Value\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-135:Incorrect Calculation of Multi-Byte String Length\nD.No Vulnerabilities\nE.CWE-1220:Insufficient Granularity of Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wfopen_53bSink(FILE * data);\r\n\r\nvoid My_w32_wfopen_53()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = _wfopen(L\"file.txt\", L\"w+\");\r\n My_w32_wfopen_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wfopen_53bB2GSink(FILE * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = _wfopen(L\"file.txt\", L\"w+\");\r\n My_w32_wfopen_53bB2GSink(data);\r\n}\r\n\r\nvoid My_w32_wfopen_53()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wfopen_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wfopen_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-690:Unchecked Return Value to NULL Pointer Dereference|A.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.No Vulnerabilities\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-507:Trojan Horse\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_ncat_54bSink(char * data);\r\n\r\nvoid My_char_ncat_54()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n My_char_ncat_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_ncat_54bG2BSink(char * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n My_char_ncat_54bG2BSink(data);\r\n}\r\n\r\nvoid My_char_ncat_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ncat_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ncat_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-665:Improper Initialization|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-121:Stack-based Buffer Overflow\nE.CWE-319:Cleartext Transmission of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE806_wchar_t_declare_memmove_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-121:Stack-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-403:Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')\nB.CWE-252:Unchecked Return Value\nC.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nD.CWE-472:External Control of Assumed-Immutable Web Parameter\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_long_malloc_22Global = 0;\r\n\r\nvoid My_long_malloc_22Sink(long * data);\r\n\r\nvoid My_long_malloc_22()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)malloc(1*sizeof(long));\r\n My_long_malloc_22Global = 1; \r\n My_long_malloc_22Sink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_long_malloc_22B2G1Global = 0;\r\nint My_long_malloc_22B2G2Global = 0;\r\n\r\n\r\nvoid My_long_malloc_22B2G1Sink(long * data);\r\n\r\nstatic void nB2G1()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)malloc(1*sizeof(long));\r\n My_long_malloc_22B2G1Global = 0; \r\n My_long_malloc_22B2G1Sink(data);\r\n}\r\n\r\n\r\nvoid My_long_malloc_22B2G2Sink(long * data);\r\n\r\nstatic void nB2G2()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)malloc(1*sizeof(long));\r\n My_long_malloc_22B2G2Global = 1; \r\n My_long_malloc_22B2G2Sink(data);\r\n}\r\n\r\nvoid My_long_malloc_22()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_long_malloc_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_long_malloc_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-690:Unchecked Return Value to NULL Pointer Dereference|B.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-122:Heap-based Buffer Overflow\nB.No Vulnerabilities\nC.CWE-304:Missing Critical Step in Authentication\nD.CWE-787:Out-of-bounds Write\nE.CWE-352:Cross-Site Request Forgery (CSRF)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\ntypedef struct _My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_CWE193_char_ncpy_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-122:Heap-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nB.CWE-787:Out-of-bounds Write\nC.CWE-121:Stack-based Buffer Overflow\nD.CWE-475:Undefined Behavior for Input to API\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE805_int64_t_declare_memcpy_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-121:Stack-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-121:Stack-based Buffer Overflow\nC.No Vulnerabilities\nD.CWE-759:Use of a One-Way Hash without a Salt\nE.CWE-1120:Excessive Code Complexity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_dest_wchar_t_declare_cat_44()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n \r\n data = dataMBuffer;\r\n data[0] = L'\\0'; \r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n funcPtr(data);\r\n}\r\n\r\nvoid My_dest_wchar_t_declare_cat_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_dest_wchar_t_declare_cat_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_dest_wchar_t_declare_cat_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-121:Stack-based Buffer Overflow|A.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-27:Path Traversal: 'dir/../../filename'\nC.CWE-203:Observable Discrepancy\nD.No Vulnerabilities\nE.CWE-710:Improper Adherence to Coding Standards\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_pointer_malloc_use_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));\r\n if (pointer == NULL) {exit(-1);}\r\n twoIntsStruct * data = *pointer; \r\n free(pointer);\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n twoIntsStruct * data;\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));\r\n if (pointer == NULL) {exit(-1);}\r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n free(pointer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * data;\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));\r\n if (pointer == NULL) {exit(-1);}\r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n free(pointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_pointer_malloc_use_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_pointer_malloc_use_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_pointer_malloc_use_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-476:NULL Pointer Dereference\nD.CWE-912:Hidden Functionality\nE.CWE-1087:Class with Virtual Method without a Virtual Destructor\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint fellies_forceless = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid unhorny_hydatigenous(void **manus_dillseed);\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n void (*unkill_tsukupin)(void **) = unhorny_hydatigenous;\r\n void **chorgi_symbionts = 0;\r\n void *browny_bravo = 0;\r\n char *thespian_tableman;;\r\n if (__sync_bool_compare_and_swap(&fellies_forceless,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n thespian_tableman = getenv(\"DAFTAR_GROOVIEST\");\r\n if (thespian_tableman != 0) {;\r\n browny_bravo = ((void *)thespian_tableman);\r\n chorgi_symbionts = &browny_bravo;\r\n unkill_tsukupin(chorgi_symbionts);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid unhorny_hydatigenous(void **manus_dillseed)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *beveled_qkt = 0;\r\n ++global_variable;;\r\n beveled_qkt = ((char *)((char *)( *manus_dillseed)));\r\n \r\n buffer_value = atoi(beveled_qkt);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1079:Parent Class without Virtual Destructor Method\nB.CWE-114:Process Control\nC.No Vulnerabilities\nD.CWE-73:External Control of File Name or Path\nE.CWE-1338:Improper Protections Against Hardware Overheating\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_console_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_w32_char_console_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_console_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_console_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-114:Process Control|D.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1287:Improper Validation of Specified Type of Input\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-588:Attempt to Access Child of a Non-structure Pointer\nD.No Vulnerabilities\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_struct_66bSink(void * dataArray[]);\r\n\r\nvoid My_struct_66()\r\n{\r\n void * data;\r\n void * dataArray[5];\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n \r\n dataArray[2] = data;\r\n My_struct_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_struct_66bG2BSink(void * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n void * dataArray[5];\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n dataArray[2] = data;\r\n My_struct_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_struct_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-588:Attempt to Access Child of a Non-structure Pointer|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-82:Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\nB.No Vulnerabilities\nC.CWE-400:Uncontrolled Resource Consumption\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-272:Least Privilege Violation\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <openssl/evp.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <sys/types.h> \r\n#include <sys/wait.h> \r\n#include <unistd.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint sherill_anorectous = 0;\r\nint global_variable;\r\n\r\nstruct sulphuretting_runology \r\n{\r\n char *afzelia_phlebology;\r\n double grotto_needlessly;\r\n char *loomed_serocystic;\r\n char preleased_keverne;\r\n int stucken_unluckily;\r\n}\r\n;\r\n#define LECANOSCOPIC_PARAPHYSATE(x) lasers_phylloclad((struct sulphuretting_runology) x)\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid lasers_phylloclad(struct sulphuretting_runology cylindrophis_whalebird);\r\nvoid evp_hash(const char *algorithm_name,char *filename) {\r\n int ii = 0;\r\n FILE *file_stream = 0;\r\n char hash_print_val[129] = {0};\r\n unsigned char file_contents[1024];\r\n size_t file_contents_size = 1024;\r\n size_t file_contents_size_read = 0;\r\n const EVP_MD *md_engine = 0;\r\n unsigned char md_value[64];\r\n unsigned int md_value_len = 0;\r\n EVP_MD_CTX *md_context = 0;\r\n int hash_update_result = 0;\r\n \r\n memset(md_value,0,64);\r\n file_stream = fopen(filename,\"rb\");\r\n if (file_stream != 0) {\r\n md_engine = EVP_get_digestbyname(algorithm_name);\r\n if (md_engine != 0) {\r\n md_context = EVP_MD_CTX_create();\r\n if (md_context != 0) {\r\n if (EVP_DigestInit_ex(md_context,md_engine,0)) {\r\n \r\n while(!feof(file_stream)) {\r\n \r\n memset(file_contents,0,file_contents_size);\r\n file_contents_size_read = fread(file_contents,\r\n sizeof(unsigned char ),file_contents_size,file_stream);\r\n hash_update_result = EVP_DigestUpdate(md_context,file_contents,file_contents_size_read);\r\n if (1 != hash_update_result) {\r\n break;\r\n }\r\n }\r\n \r\n if (1 == hash_update_result) {\r\n if (EVP_DigestFinal_ex(md_context,md_value,&md_value_len)) {\r\n for (ii = 0; ii < md_value_len; ++ii) {\r\n sprintf(&hash_print_val[ii * 2],\"%02x\",md_value[ii]);\r\n }\r\n printf(\"%s %s\\n\",hash_print_val,filename);\r\n } else {\r\n printf(\"Failure finalizing hash for file '%s' with algorithm '%s'.\\n\",\r\n filename,algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failure hashing file '%s' with algorithm '%s'.\\n\",filename,algorithm_name);\r\n }\r\n }\r\n EVP_MD_CTX_destroy(md_context);\r\n } else {\r\n printf(\"Could not create a context for hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Could not load hash algorithm: '%s'\\n\",algorithm_name);\r\n }\r\n } else {\r\n printf(\"Failed to open file: '%s'\\n\",filename);\r\n }\r\n if (file_stream != 0) {\r\n fclose(file_stream);\r\n file_stream = 0;\r\n }\r\n}\r\nstruct pid_fd {\r\n pid_t pid;\r\n int fd_array[2];\r\n};\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n struct sulphuretting_runology biot_kist = {0};\r\n int *usucaptible_enologist = 0;\r\n int cannoned_usedness;\r\n struct sulphuretting_runology branchiopodan_lulu[10] = {0};\r\n struct sulphuretting_runology oversacrificial_liras;\r\n char *monarchianist_scyros;;\r\n if (__sync_bool_compare_and_swap(&sherill_anorectous,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n monarchianist_scyros = getenv(\"MESOCARDIA_KEDARITE\");\r\n if (monarchianist_scyros != 0) {;\r\n oversacrificial_liras . afzelia_phlebology = ((char *)monarchianist_scyros);\r\n branchiopodan_lulu[5] = oversacrificial_liras;\r\n cannoned_usedness = 5;\r\n usucaptible_enologist = &cannoned_usedness;\r\n biot_kist = *(branchiopodan_lulu + *usucaptible_enologist);\r\n\tLECANOSCOPIC_PARAPHYSATE(biot_kist);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid lasers_phylloclad(struct sulphuretting_runology cylindrophis_whalebird)\r\n{\r\n int child_signal = 0;\r\n int child_pids_count = 21;\r\n pid_t child_pids[21];\r\n pid_t child_pid = -1;\r\n int ii = 0;\r\n int jj = 0;\r\n int algorithms_count = 7;\r\n const char *algorithms[7];\r\n struct pid_fd fd_array[21];\r\n int error = 0;\r\n int index = -1;\r\n char buf;\r\n char *gutow_armors = 0;\r\n ++global_variable;;\r\n gutow_armors = ((char *)cylindrophis_whalebird . afzelia_phlebology);\r\n \r\n algorithms[0] = \"MD5\";\r\n algorithms[1] = \"SHA1\";\r\n algorithms[2] = \"SHA224\";\r\n algorithms[3] = \"SHA256\";\r\n algorithms[4] = \"SHA384\";\r\n algorithms[5] = \"SHA512\";\r\n algorithms[6] = \"RIPEMD160\";\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_pids[ii] = -1;\r\n }\r\n if (!error) {\r\n OPENSSL_add_all_algorithms_noconf();\r\n fflush(stdout);\r\n fflush(stdin);\r\n \r\n for (ii = 0; ii < 3; ++ii) {\r\n for (jj = 0; jj < algorithms_count; ++jj) {\r\n index = jj + ii * algorithms_count;\r\n if (pipe(fd_array[index].fd_array) == -1) {\r\n error = 1;\r\n printf(\"Error opening pipe\\n\");\r\n } else {\r\n child_pid = fork();\r\n if (child_pid >= 0) {\r\n if (child_pid == 0) {\r\n close(fd_array[index].fd_array[0]);\r\n dup2(fd_array[index].fd_array[1], STDOUT_FILENO);\r\n \r\n \r\n evp_hash(algorithms[jj], gutow_armors);\r\n \r\n close(fd_array[index].fd_array[1]);\r\n exit(0);\r\n } else {\r\n close(fd_array[index].fd_array[1]);\r\n fd_array[index].pid = child_pid;\r\n continue;\r\n }\r\n } else {\r\n \r\n printf(\"Failed to fork a child process.\\n\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n }\r\n for (ii = 0; ii < child_pids_count; ++ii) {\r\n child_signal = 0;\r\n if (fd_array[ii].pid < 1) {\r\n continue;\r\n }\r\n if (-1 == waitpid(fd_array[ii].pid, &child_signal, 0)) {\r\n \r\n printf(\"Failed to wait for child process: %d\\n\",child_signal);\r\n } else {\r\n if (WIFEXITED(child_signal)) {\r\n printf(\"Child process exited with status: %d\\n\",WEXITSTATUS(child_signal));\r\n } else if (WIFSIGNALED(child_signal)) {\r\n \r\n printf(\"Child process received signal: %d\\n\",WTERMSIG(child_signal));\r\n }\r\n while (read(fd_array[ii].fd_array[0], &buf, 1) > 0) {\r\n printf(\"%c\", buf);\r\n }\r\n close(fd_array[ii].fd_array[0]);\r\n }\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-441:Unintended Proxy or Intermediary ('Confused Deputy')\nB.CWE-252:Unchecked Return Value\nC.No Vulnerabilities\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.CWE-520:.NET Misconfiguration: Use of Impersonation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_long_calloc_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(long * &data);\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n data = NULL; \r\n mSource(data);\r\n \r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(long * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n data = NULL; \r\n nB2GSource(data);\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_long_calloc_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-690:Unchecked Return Value to NULL Pointer Dereference|B.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1164:Irrelevant Code\nB.CWE-294:Authentication Bypass by Capture-replay\nC.CWE-563:Assignment to Variable without Use\nD.No Vulnerabilities\nE.CWE-780:Use of RSA Algorithm without OAEP\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_value_int64_t_17()\r\n{\r\n int i,j;\r\n int64_t data;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = 5LL;\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n data = 10LL;\r\n printLongLongLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n int64_t data;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n data = 5LL;\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n printLongLongLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n int64_t data;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = 5LL;\r\n printLongLongLine(data);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n data = 10LL;\r\n printLongLongLine(data);\r\n }\r\n}\r\n\r\nvoid My_unused_value_int64_t_17()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_value_int64_t_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_value_int64_t_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|A.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-330:Use of Insufficiently Random Values\nC.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nD.No Vulnerabilities\nE.CWE-283:Unverified Ownership\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|B.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.No Vulnerabilities\nC.CWE-408:Incorrect Behavior Order: Early Amplification\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-1271:Uninitialized Value on Reset for Registers Holding Security Settings\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\nnamespace My_char_connect_socket_w32spawnl_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_char_connect_socket_w32spawnl_83\r\n{\r\npublic:\r\n My_char_connect_socket_w32spawnl_83(char * dataCopy);\r\n ~My_char_connect_socket_w32spawnl_83();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_char_connect_socket_w32spawnl_83G2B\r\n{\r\npublic:\r\n My_char_connect_socket_w32spawnl_83G2B(char * dataCopy);\r\n ~My_char_connect_socket_w32spawnl_83G2B();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-437:Incomplete Model of Endpoint Features\nE.CWE-756:Missing Custom Error Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_51\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(void * data);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(void * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n nG2BSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_51; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-588:Attempt to Access Child of a Non-structure Pointer|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-650:Trusting HTTP Permission Methods on the Server Side\nB.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-195:Signed to Unsigned Conversion Error\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fgets_strncpy_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fgets_strncpy_83\r\n{\r\npublic:\r\n My_fgets_strncpy_83(int dataCopy);\r\n ~My_fgets_strncpy_83();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fgets_strncpy_83G2B\r\n{\r\npublic:\r\n My_fgets_strncpy_83G2B(int dataCopy);\r\n ~My_fgets_strncpy_83G2B();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-195:Signed to Unsigned Conversion Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-502:Deserialization of Untrusted Data\nB.No Vulnerabilities\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.CWE-1333:Inefficient Regular Expression Complexity\nE.CWE-546:Suspicious Comment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_LATER_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_LATER_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_LATER_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_LATER_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-546:Suspicious Comment|C.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-416:Use After Free\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.No Vulnerabilities\nE.CWE-686:Function Call With Incorrect Argument Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_free_char_01()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n \r\n printLine(data);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n \r\n printLine(data);\r\n \r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n free(data);\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid My_malloc_free_char_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_free_char_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_free_char_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-416:Use After Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1083:Data Access from Outside Expected Data Manager Component\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_accept_listen_bind_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_accept_listen_bind_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_accept_listen_bind_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_accept_listen_bind_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-180:Incorrect Behavior Order: Validate Before Canonicalize\nD.CWE-252:Unchecked Return Value\nE.CWE-1127:Compilation with Insufficient Warnings or Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_realloc_09()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n \r\n data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"Initialize\");\r\n printWLine(data);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n \r\n data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n wcscpy(data, L\"Initialize\");\r\n printWLine(data);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n \r\n data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n wcscpy(data, L\"Initialize\");\r\n printWLine(data);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_realloc_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_realloc_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_realloc_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-690:Unchecked Return Value to NULL Pointer Dereference|D.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-446:UI Discrepancy for Security Feature\nC.No Vulnerabilities\nD.CWE-197:Numeric Truncation Error\nE.CWE-174:Double Decoding of the Same Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fgets_to_short_07()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n \r\n data = CHAR_MAX-5;\r\n }\r\n {\r\n \r\n short shortData = (short)data;\r\n printShortLine(shortData);\r\n }\r\n}\r\n\r\nvoid My_int_fgets_to_short_07()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fgets_to_short_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fgets_to_short_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-197:Numeric Truncation Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-221:Information Loss or Omission\nB.No Vulnerabilities\nC.CWE-223:Omission of Security-relevant Information\nD.CWE-349:Acceptance of Extraneous Untrusted Data With Trusted Data\nE.CWE-584:Return Inside Finally Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SZ 15\r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login\\n\");\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login by %s\\n\", username);\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-223:Omission of Security-relevant Information|A.CWE-221:Information Loss or Omission", "cwe": "223"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nC.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-698:Execution After Redirect (EAR)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_alloca_use_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char * pointer = (char *)ALLOCA(sizeof(char));\r\n char data = *pointer; \r\n printHexCharLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data;\r\n char * pointer = (char *)ALLOCA(sizeof(char));\r\n data = 5;\r\n *pointer = data; \r\n {\r\n char data = *pointer;\r\n printHexCharLine(data);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char data;\r\n char * pointer = (char *)ALLOCA(sizeof(char));\r\n data = 5;\r\n *pointer = data; \r\n {\r\n char data = *pointer;\r\n printHexCharLine(data);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_alloca_use_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_alloca_use_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_alloca_use_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-392:Missing Report of Error Condition\nC.CWE-682:Incorrect Calculation\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<list<int> > dataList);\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n list<list<int> > dataList;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<list<int> > dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n list<list<int> > dataList;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<list<int> > dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n list<list<int> > dataList;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-672:Operation on a Resource after Expiration or Release|A.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-256:Plaintext Storage of a Password\nB.CWE-1118:Insufficient Documentation of Error Handling Techniques\nC.No Vulnerabilities\nD.CWE-467:Use of sizeof() on a Pointer Type\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n funcPtr(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(char * data)\r\n{\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nB2GSink;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_w32_char_44()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-832:Unlock of a Resource that is not Locked\nB.CWE-1085:Invokable Control Element with Excessive Volume of Commented-out Code\nC.CWE-667:Improper Locking\nD.No Vulnerabilities\nE.CWE-1066:Missing Serialization Control Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-832:Unlock of a Resource that is not Locked|C.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-167:Improper Handling of Additional Special Element\nB.CWE-82:Improper Neutralization of Script in Attributes of IMG Tags in a Web Page\nC.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nD.No Vulnerabilities\nE.CWE-188:Reliance on Data/Memory Layout\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_modify_local_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n char *charPtr;\r\n structCharInt.charFirst = 1;\r\n charPtr = &structCharInt.charFirst;\r\n \r\n *(int*)(charPtr + sizeof(int)) = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\nvoid My_modify_local_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_modify_local_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_modify_local_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-188:Reliance on Data/Memory Layout|C.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-562:Return of Stack Variable Address\nB.CWE-1276:Hardware Child Block Incorrectly Connected to Parent System\nC.CWE-369:Divide By Zero\nD.CWE-682:Incorrect Calculation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_zero_divide_81\r\n{\r\n\r\nclass My_int_zero_divide_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(int data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_int_zero_divide_81 : public My_int_zero_divide_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_int_zero_divide_81G2B : public My_int_zero_divide_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\nclass My_int_zero_divide_81B2G : public My_int_zero_divide_81_base\r\n{\r\npublic:\r\n void action(int data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-1094:Excessive Index Range Scan for a Data Resource\nC.CWE-682:Incorrect Calculation\nD.No Vulnerabilities\nE.CWE-340:Generation of Predictable Numbers or Identifiers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unsigned_int_min_postdec_11()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = 0;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n data--;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = 0;\r\n }\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > 0)\r\n {\r\n data--;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = 0;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if (data > 0)\r\n {\r\n data--;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n data--;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n unsigned int data;\r\n data = 0;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = -2;\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n data--;\r\n unsigned int result = data;\r\n printUnsignedLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_unsigned_int_min_postdec_11()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unsigned_int_min_postdec_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unsigned_int_min_postdec_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|C.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-391:Unchecked Error Condition\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')\nE.CWE-449:The UI Performs the Wrong Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_strtol_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_strtol_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strtol_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strtol_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-391:Unchecked Error Condition|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.No Vulnerabilities\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nstatic char * My_char_declare_cpy_45Data;\r\nstatic char * My_char_declare_cpy_45G2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n char * data = My_char_declare_cpy_45Data;\r\n {\r\n char dest[100*2];\r\n memset(dest, 'C', 100*2-1); \r\n dest[100*2-1] = '\\0'; \r\n \r\n strcpy(dest, data);\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_char_declare_cpy_45()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n My_char_declare_cpy_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n char * data = My_char_declare_cpy_45G2BData;\r\n {\r\n char dest[100*2];\r\n memset(dest, 'C', 100*2-1); \r\n dest[100*2-1] = '\\0'; \r\n \r\n strcpy(dest, data);\r\n printLine(dest);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n My_char_declare_cpy_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid My_char_declare_cpy_45()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_cpy_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_cpy_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-459:Incomplete Cleanup\nB.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nC.No Vulnerabilities\nD.CWE-164:Improper Neutralization of Internal Special Elements\nE.CWE-1125:Excessive Attack Surface\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|A.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-126:Buffer Over-read\nC.CWE-430:Deployment of Wrong Handler\nD.CWE-862:Missing Authorization\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE170_char_memcpy_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-645:Overly Restrictive Account Lockout Mechanism\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-335:Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fopen_w32CloseHandle_53bSink(FILE * data);\r\n\r\nvoid My_fopen_w32CloseHandle_53()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_w32CloseHandle_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fopen_w32CloseHandle_53bB2GSink(FILE * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_w32CloseHandle_53bB2GSink(data);\r\n}\r\n\r\nvoid My_fopen_w32CloseHandle_53()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32CloseHandle_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32CloseHandle_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-762:Mismatched Memory Management Routines\nD.No Vulnerabilities\nE.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_array_int_alloca_45\r\n{\r\n\r\nstatic int * mData;\r\nstatic int * nG2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n int * data = mData;\r\n printIntLine(data[0]);\r\n \r\n delete [] data;\r\n}\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n data = NULL; \r\n {\r\n \r\n int * dataBuffer = (int *)ALLOCA(100*sizeof(int));\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n mData = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n int * data = nG2BData;\r\n printIntLine(data[0]);\r\n \r\n delete [] data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n data = NULL; \r\n {\r\n \r\n int * dataBuffer = new int[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n nG2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_int_alloca_45; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-590:Free of Memory not on the Heap|C.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-351:Insufficient Type Distinction\nC.CWE-1116:Inaccurate Comments\nD.CWE-617:Reachable Assertion\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_15()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = ASSERT_VALUE+1;\r\n break;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = ASSERT_VALUE+1;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_listen_socket_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-617:Reachable Assertion|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-514:Covert Channel\nB.No Vulnerabilities\nC.CWE-104:Struts: Form Bean Does Not Extend Validation Class\nD.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nE.CWE-330:Use of Insufficiently Random Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|E.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-183:Permissive List of Allowed Inputs\nC.CWE-787:Out-of-bounds Write\nD.CWE-862:Missing Authorization\nE.CWE-121:Stack-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_My_CWE805_int_alloca_loop_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-121:Stack-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-256:Plaintext Storage of a Password\nC.CWE-697:Incorrect Comparison\nD.CWE-197:Numeric Truncation Error\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_54bSink(wchar_t * data);\r\n\r\nvoid My_w32_wchar_t_54()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n My_w32_wchar_t_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_54bG2BSink(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n My_w32_wchar_t_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_w32_wchar_t_54bB2GSink(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n My_w32_wchar_t_54bB2GSink(data);\r\n}\r\n\r\nvoid My_w32_wchar_t_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-781:Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code\nC.CWE-195:Signed to Unsigned Conversion Error\nD.CWE-1252:CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nusing namespace std;\r\n\r\nnamespace My_connect_socket_strncpy_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int> dataVector);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<int> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_connect_socket_strncpy_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-195:Signed to Unsigned Conversion Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-328:Use of Weak Hash\nB.CWE-326:Inadequate Encryption Strength\nC.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\nD.No Vulnerabilities\nE.CWE-454:External Initialization of Trusted Variables or Data Stores\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD5_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD5_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD5_SUM_SIZE], calcHash[MD5_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD5_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD5_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD5_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD5_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD5_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD5_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-328:Use of Weak Hash|B.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.CWE-291:Reliance on IP Address for Authentication\nC.CWE-793:Only Filtering One Instance of a Special Element\nD.CWE-459:Incomplete Cleanup\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-455:Non-exit on Failed Initialization\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-342:Predictable Exact Value from Previous Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_free_long_static_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<long *> dataVector);\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n vector<long *> dataVector;\r\n data = NULL; \r\n {\r\n \r\n static long dataBuffer[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5L;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<long *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n long * data;\r\n vector<long *> dataVector;\r\n data = NULL; \r\n {\r\n \r\n long * dataBuffer = (long *)malloc(100*sizeof(long));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5L;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_free_long_static_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-106:Struts: Plug-in Framework not in Use\nB.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nC.No Vulnerabilities\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_doubleNaN2int_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)(sqrt(doubleNumber)));\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n \r\n if (doubleNumber < 0)\r\n {\r\n printLine(\"Value is negative\");\r\n }\r\n else\r\n {\r\n printIntLine((int)(sqrt(doubleNumber)));\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n \r\n if (doubleNumber < 0)\r\n {\r\n printLine(\"Value is negative\");\r\n }\r\n else\r\n {\r\n printIntLine((int)(sqrt(doubleNumber)));\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_doubleNaN2int_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_doubleNaN2int_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_doubleNaN2int_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-681:Incorrect Conversion between Numeric Types|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-792:Incomplete Filtering of One or More Instances of Special Elements\nB.CWE-195:Signed to Unsigned Conversion Error\nC.No Vulnerabilities\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-109:Struts: Validator Turned Off\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\nusing namespace std;\r\n\r\nnamespace My_fgets_memcpy_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int> dataVector);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<int> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n vector<int> dataVector;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fgets_memcpy_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-195:Signed to Unsigned Conversion Error|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.CWE-786:Access of Memory Location Before Start of Buffer\nC.CWE-127:Buffer Under-read\nD.No Vulnerabilities\nE.CWE-323:Reusing a Nonce, Key Pair in Encryption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_new_wchar_t_loop_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, wchar_t *> dataMap);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n map<int, wchar_t *> dataMap;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, wchar_t *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n map<int, wchar_t *> dataMap;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_loop_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|B.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-763:Release of Invalid Pointer or Reference\nC.No Vulnerabilities\nD.CWE-1193:Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nE.CWE-351:Insufficient Type Distinction\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_char_malloc_34\r\n{\r\n\r\ntypedef union\r\n{\r\n char * unionFirst;\r\n char * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n unionType myUnion;\r\n \r\n data = NULL;\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n unionType myUnion;\r\n \r\n data = NULL;\r\n \r\n data = new char[100];\r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n unionType myUnion;\r\n \r\n data = NULL;\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n \r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_char_malloc_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-762:Mismatched Memory Management Routines|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nC.CWE-123:Write-what-where Condition\nD.CWE-787:Out-of-bounds Write\nE.CWE-584:Return Inside Finally Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\nstatic mStruct My_connect_socket_45Data;\r\nstatic mStruct My_connect_socket_45G2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n mStruct data = My_connect_socket_45Data;\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_connect_socket_45()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n mStruct data = My_connect_socket_45G2BData;\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n My_connect_socket_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid My_connect_socket_45()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-123:Write-what-where Condition|D.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-940:Improper Verification of Source of a Communication Channel\nB.CWE-353:Missing Support for Integrity Check\nC.No Vulnerabilities\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_class_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(TwoIntsClass * * dataPtr);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n delete data;\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(TwoIntsClass * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(TwoIntsClass * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n data = new TwoIntsClass;\r\n data->intOne = 1;\r\n data->intTwo = 2;\r\n \r\n delete data;\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_class_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.No Vulnerabilities\nC.CWE-496:Public Data Assigned to Private Array-Typed Field\nD.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nE.CWE-492:Use of Inner Class Containing Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_console_13()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (256-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_console_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_console_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_console_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-486:Comparison of Classes by Name\nB.CWE-685:Function Call With Incorrect Number of Arguments\nC.No Vulnerabilities\nD.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nE.CWE-628:Function Call with Incorrectly Specified Arguments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 100 \r\n#define SOURCE_STRING \"AAA\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-685:Function Call With Incorrect Number of Arguments|E.CWE-628:Function Call with Incorrectly Specified Arguments", "cwe": "685"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\nE.CWE-618:Exposed Unsafe ActiveX Method\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_file_14()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (256-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n if(globalFive==5)\r\n {\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_char_file_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_file_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_file_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-321:Use of Hard-coded Cryptographic Key\nB.No Vulnerabilities\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-784:Reliance on Cookies without Validation and Integrity Checking in a Security Decision\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * cryptoKey)\r\n{\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_44()\r\n{\r\n wchar_t * cryptoKey;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n \r\n funcPtr(cryptoKey);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * cryptoKey)\r\n{\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n funcPtr(cryptoKey);\r\n}\r\n\r\nvoid My_w32_wchar_t_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-321:Use of Hard-coded Cryptographic Key|C.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.No Vulnerabilities\nD.CWE-1059:Insufficient Technical Documentation\nE.CWE-271:Privilege Dropping / Lowering Errors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_rand_for_loop_54bSink(int count);\r\n\r\nvoid My_rand_for_loop_54()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = RAND32();\r\n My_rand_for_loop_54bSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_rand_for_loop_54bG2BSink(int count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n My_rand_for_loop_54bG2BSink(count);\r\n}\r\n\r\n\r\nvoid My_rand_for_loop_54bB2GSink(int count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = RAND32();\r\n My_rand_for_loop_54bB2GSink(count);\r\n}\r\n\r\nvoid My_rand_for_loop_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_for_loop_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_for_loop_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nB.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nC.CWE-459:Incomplete Cleanup\nD.CWE-302:Authentication Bypass by Assumed-Immutable Data\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|C.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.CWE-301:Reflection Attack in an Authentication Protocol\nC.No Vulnerabilities\nD.CWE-507:Trojan Horse\nE.CWE-1302:Missing Security Identifier\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_RegCreateKeyEx_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_RegCreateKeyEx_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_RegCreateKeyEx_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_RegCreateKeyEx_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-284:Improper Access Control|B.CWE-301:Reflection Attack in an Authentication Protocol", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-330:Use of Insufficiently Random Values\nC.CWE-1109:Use of Same Variable for Multiple Purposes\nD.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nE.CWE-662:Improper Synchronization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n \r\n int data = rand();\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n int data;\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptGenRandom(hCryptProv, sizeof(data), (BYTE *) &data))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n printIntLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)|B.CWE-330:Use of Insufficiently Random Values", "cwe": "338"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-708:Incorrect Ownership Assignment\nB.CWE-638:Not Using Complete Mediation\nC.No Vulnerabilities\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_short_51bSink(void * data);\r\n\r\nvoid My_short_51()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n My_short_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_short_51bG2BSink(void * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n My_short_51bG2BSink(data);\r\n}\r\n\r\nvoid My_short_51()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.No Vulnerabilities\nE.CWE-941:Incorrectly Specified Destination in a Communication Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_13()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = CreateFile(\"MSink_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n data = CreateFile(\"NSink_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n data = CreateFile(\"NSink_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-653:Improper Isolation or Compartmentalization\nB.No Vulnerabilities\nC.CWE-570:Expression is Always False\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_bind_accept_listen_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_bind_accept_listen_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_bind_accept_listen_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_bind_accept_listen_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-666:Operation on Resource in Wrong Phase of Lifetime|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-763:Release of Invalid Pointer or Reference\nC.No Vulnerabilities\nD.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nE.CWE-263:Password Aging with Long Expiration\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_char_realloc_03\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = NULL;\r\n \r\n data = (char *)realloc(data, 100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(5==5)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = NULL;\r\n \r\n data = (char *)realloc(data, 100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = NULL;\r\n \r\n data = (char *)realloc(data, 100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n }\r\n if(5==5)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new char[100];\r\n }\r\n if(5==5)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n \r\n data = new char[100];\r\n }\r\n if(5==5)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_char_realloc_03; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-762:Mismatched Memory Management Routines|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-820:Missing Synchronization\nB.CWE-322:Key Exchange without Entity Authentication\nC.CWE-644:Improper Neutralization of HTTP Headers for Scripting Syntax\nD.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nint interregnal_spirobranchia = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar *evaluates_irremeably(char *ransomers_hortensia);\r\nstruct list {\r\n int data;\r\n struct list *previous;\r\n struct list *next;\r\n};\r\nstruct queue {\r\n pthread_mutex_t lock;\r\n pthread_cond_t is_empty;\r\n pthread_cond_t is_full;\r\n int size;\r\n int capacity;\r\n struct list *head;\r\n struct list *tail;\r\n};\r\nstruct data {\r\n int qsize;\r\n int data;\r\n char* file1;\r\n char* file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nint enqueue(struct queue *ssQ, int data) {\r\n int rtnval = 0;\r\n if (ssQ != NULL) {\r\n struct list *elem = malloc(sizeof(struct list));\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size >= ssQ->capacity) {\r\n pthread_cond_wait(&(ssQ->is_full), &(ssQ->lock));\r\n }\r\n elem->next = NULL;\r\n elem->previous = ssQ->tail;\r\n elem->data = data;\r\n if (ssQ->tail != NULL) {\r\n ssQ->tail->next = elem;\r\n }\r\n ssQ->tail = elem;\r\n ssQ->size++;\r\n if (ssQ->head == NULL) {\r\n ssQ->head = elem;\r\n }\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_empty));\r\n }\r\n else {\r\n rtnval = -1;\r\n }\r\n return rtnval;\r\n}\r\nint dequeue(struct queue *ssQ) {\r\n int val = -1;\r\n if (ssQ != NULL) {\r\n struct list *elem;\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size <= 0) {\r\n pthread_cond_wait(&(ssQ->is_empty), &(ssQ->lock));\r\n }\r\n elem = ssQ->head;\r\n ssQ->head = elem->next;\r\n if(ssQ->head != NULL) {\r\n ssQ->head->previous = NULL;\r\n }\r\n else {\r\n ssQ->tail = NULL;\r\n }\r\n val = elem->data;\r\n ssQ->size--;\r\n free(elem);\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_full));\r\n }\r\n return val;\r\n}\r\nstruct queue *get_instance (char* file2) {\r\n static struct queue *ssQ = NULL;\r\n \r\n \r\n \r\n if (ssQ == NULL) {\r\n if (file2 != NULL) {\r\n readFile(file2);\r\n }\r\n ssQ = (struct queue *)calloc(1, sizeof(struct queue));\r\n pthread_mutex_init(&(ssQ->lock), NULL);\r\n pthread_cond_init(&(ssQ->is_empty), NULL);\r\n pthread_cond_init(&(ssQ->is_full), NULL);\r\n ssQ->size = 0;\r\n ssQ->capacity = 30;\r\n ssQ->head = NULL;\r\n ssQ->tail = NULL;\r\n }\r\n \r\n \r\n return ssQ;\r\n}\r\nvoid *print_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ = get_instance(ssD->file2);\r\n int i;\r\n \r\n \r\n \r\n while ((i = dequeue(ssQ)) != -1) {\r\n printf(\"Data: %d\\n\", i);\r\n }\r\n \r\n return NULL;\r\n}\r\nvoid *calc_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ;\r\n int *qsort_arr;\r\n int i;\r\n \r\n qsort_arr = malloc(sizeof(int)*ssD->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < ssD->qsize; i++) {\r\n qsort_arr[i] = ssD->qsize - i;\r\n }\r\n qsort(qsort_arr, ssD->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(ssD->file1);\r\n ssQ = get_instance(NULL);\r\n \r\n for (i = 0; i < ssD->data; i++) {\r\n \r\n if (enqueue(ssQ, i) == -1) {\r\n break;\r\n }\r\n }\r\n enqueue(ssQ, -1);\r\n \r\n return NULL;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n pthread_t t0, t1;\r\n struct data* Data;\r\n char *hexamethylene_offendedly = 0;\r\n char *recharger_pdn = 0;\r\n int lagting_laurvikite = 91;\r\n char *hectoliter_titers;;\r\n if (__sync_bool_compare_and_swap(&interregnal_spirobranchia,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&hectoliter_titers,\"2708\",lagting_laurvikite);\r\n if (hectoliter_titers != 0) {;\r\n recharger_pdn = evaluates_irremeably(hectoliter_titers);\r\n hexamethylene_offendedly = ((char *)recharger_pdn);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->file1 = malloc(sizeof(char) * (strlen(hexamethylene_offendedly) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(hexamethylene_offendedly) + 1));\r\n if ((sscanf(hexamethylene_offendedly, \"%d %s %s %d\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n &(Data->data)) == 4) &&\r\n Data->qsize >= 0 &&\r\n Data->data >= 0 &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calc_data, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (pthread_create(&t1, NULL, print_data, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->file1);\r\n free(Data->file2);\r\n free(Data);\r\n }\r\n \r\n;\r\n if (recharger_pdn != 0) \r\n free(((char *)recharger_pdn));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nchar *evaluates_irremeably(char *ransomers_hortensia)\r\n{\r\n ++global_variable;\r\n return ransomers_hortensia;\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context|A.CWE-820:Missing Synchronization", "cwe": "543"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1109:Use of Same Variable for Multiple Purposes\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-1075:Unconditional Control Flow Transfer outside of Switch Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_w32CloseHandle_07()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticFive==5)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticFive==5)\r\n {\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_w32CloseHandle_07()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1321:Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\nB.CWE-675:Multiple Operations on Resource in Single-Operation Context\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-305:Authentication Bypass by Primary Weakness\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32CreateFile_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, HANDLE> dataMap);\r\n\r\nvoid m()\r\n{\r\n HANDLE data;\r\n map<int, HANDLE> dataMap;\r\n data = INVALID_HANDLE_VALUE; \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n CloseHandle(data);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, HANDLE> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n HANDLE data;\r\n map<int, HANDLE> dataMap;\r\n data = INVALID_HANDLE_VALUE; \r\n \r\n data = CreateFile(\"NSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, HANDLE> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n map<int, HANDLE> dataMap;\r\n data = INVALID_HANDLE_VALUE; \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n CloseHandle(data);\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32CreateFile_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-675:Multiple Operations on Resource in Single-Operation Context|C.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nB.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nC.CWE-653:Improper Isolation or Compartmentalization\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_char_file_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<char *> dataList);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (256-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<char *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n list<char *> dataList;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_file_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')\nB.CWE-284:Improper Access Control\nC.CWE-1222:Insufficient Granularity of Address Regions Protected by Register Locks\nD.CWE-462:Duplicate Key in Associative List (Alist)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_CreateDesktop_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HDESK hDesk;\r\n wchar_t * desktopName = L\"DesktopExample\";\r\n \r\n hDesk = CreateDesktopW(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HDESK hDesk;\r\n wchar_t * desktopName = L\"DesktopExample\";\r\n \r\n hDesk = CreateDesktopW(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HDESK hDesk;\r\n wchar_t * desktopName = L\"DesktopExample\";\r\n \r\n hDesk = CreateDesktopW(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_CreateDesktop_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_CreateDesktop_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_CreateDesktop_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-284:Improper Access Control|A.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-103:Struts: Incomplete validate() Method Definition\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.No Vulnerabilities\nE.CWE-187:Partial String Comparison\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define M_SOURCE_FIXED_STRING L\"Fixed String\" \r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fixed_string_09()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n \r\n wcscpy(data, M_SOURCE_FIXED_STRING);\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n \r\n wcscpy(data, M_SOURCE_FIXED_STRING);\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n \r\n wcscpy(data, M_SOURCE_FIXED_STRING);\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fixed_string_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fixed_string_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fixed_string_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-913:Improper Control of Dynamically-Managed Code Resources\nB.CWE-522:Insufficiently Protected Credentials\nC.CWE-256:Plaintext Storage of a Password\nD.No Vulnerabilities\nE.CWE-1099:Inconsistent Naming Conventions for Identifiers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_03()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n }\r\n if(5==5)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n }\r\n if(5==5)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n if(5==5)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n if(5==5)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|B.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-154:Improper Neutralization of Variable Name Delimiters\nC.CWE-665:Improper Initialization\nD.CWE-457:Use of Uninitialized Variable\nE.CWE-1164:Irrelevant Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double_14()\r\n{\r\n double data;\r\n if(globalFive==5)\r\n {\r\n \r\n ; \r\n }\r\n if(globalFive==5)\r\n {\r\n \r\n printDoubleLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n double data;\r\n if(globalFive==5)\r\n {\r\n \r\n ; \r\n }\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 5.0;\r\n printDoubleLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n double data;\r\n if(globalFive==5)\r\n {\r\n \r\n ; \r\n }\r\n if(globalFive==5)\r\n {\r\n \r\n data = 5.0;\r\n printDoubleLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n double data;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 5.0;\r\n }\r\n if(globalFive==5)\r\n {\r\n \r\n printDoubleLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n double data;\r\n if(globalFive==5)\r\n {\r\n \r\n data = 5.0;\r\n }\r\n if(globalFive==5)\r\n {\r\n \r\n printDoubleLine(data);\r\n }\r\n}\r\n\r\nvoid My_double_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-457:Use of Uninitialized Variable|C.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1328:Security Version Number Mutable to Older Versions\nC.CWE-377:Insecure Temporary File\nD.CWE-668:Exposure of Resource to Wrong Sphere\nE.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define TMPNAM tmpnam\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TMPNAM tmpnam\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_tmpnam_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char * filename;\r\n int fileDesc;\r\n filename = TMPNAM(NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_tmpnam_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_tmpnam_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_tmpnam_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-377:Insecure Temporary File|D.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-404:Improper Resource Shutdown or Release\nB.No Vulnerabilities\nC.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nD.CWE-50:Path Equivalence: '//multiple/leading/slash'\nE.CWE-111:Direct Use of Unsafe JNI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\ntypedef union\r\n{\r\n int unionFirst;\r\n int unionSecond;\r\n} My_open_no_close_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_no_close_34()\r\n{\r\n int data;\r\n My_open_no_close_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_open_no_close_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_no_close_34()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_no_close_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_no_close_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|A.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.No Vulnerabilities\nE.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint glycerize_foulsome = 0;\r\n\r\nstruct overpositively_hybridae \r\n{\r\n char *cowpoke_snogs;\r\n double nekrasov_caruncle;\r\n char *mestizos_axillary;\r\n char unruly_paraphs;\r\n int lateness_parisianly;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int i = 0;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *heap_buff_64 = 0;\r\n char *granularly_dutuburi = 0;\r\n struct overpositively_hybridae *unkindlily_dimberdamber = {0};\r\n struct overpositively_hybridae statolithic_subscript;\r\n char *thomasite_siruelas;;\r\n if (__sync_bool_compare_and_swap(&glycerize_foulsome,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n thomasite_siruelas = getenv(\"GRANDNEPHEWS_OUTBEGGED\");\r\n if (thomasite_siruelas != 0) {;\r\n statolithic_subscript . cowpoke_snogs = ((char *)thomasite_siruelas);\r\n unkindlily_dimberdamber = &statolithic_subscript;\r\n granularly_dutuburi = ((char *)( *unkindlily_dimberdamber) . cowpoke_snogs);\r\n \r\n \r\n \r\n heap_buff_64 = (char*) malloc(64 * sizeof(char));\r\n if (heap_buff_64 != NULL) {\r\n memset(heap_buff_64, 'A' ,64);\r\n heap_buff_64[64 - 1] = '\\0';\r\n \r\n \r\n \r\n taint_len = ((int )(strlen(granularly_dutuburi)));\r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n \r\n \r\n heap_buff_64[buff_size] = granularly_dutuburi[taint_len];\r\n }\r\n \r\n for (; i < 64; ++i) {\r\n heap_buff_64[i] = toupper(heap_buff_64[i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\r\n free(heap_buff_64);\r\n \r\n \r\n \r\n }\r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-124:Buffer Underwrite ('Buffer Underflow')|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-342:Predictable Exact Value from Previous Values\nB.No Vulnerabilities\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-397:Declaration of Throws for Generic Exception\nE.CWE-620:Unverified Password Change\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std; \r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_throw_exception_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n throw exception();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_throw_exception_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-397:Declaration of Throws for Generic Exception|C.CWE-705:Incorrect Control Flow Scoping", "cwe": "397"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1395:Dependency on Vulnerable Third-Party Component\nB.No Vulnerabilities\nC.CWE-176:Improper Handling of Unicode Encoding\nD.CWE-1106:Insufficient Use of Symbolic Constants\nE.CWE-172:Encoding Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_09()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-176:Improper Handling of Unicode Encoding|E.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.CWE-319:Cleartext Transmission of Sensitive Information\nC.No Vulnerabilities\nD.CWE-48:Path Equivalence: 'file name' (Internal Whitespace)\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_listen_socket_11()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_listen_socket_11()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_listen_socket_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_listen_socket_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-319:Cleartext Transmission of Sensitive Information|E.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nB.No Vulnerabilities\nC.CWE-230:Improper Handling of Missing Values\nD.CWE-293:Using Referer Field for Authentication\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_14()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_char_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\nC.CWE-794:Incomplete Filtering of Multiple Instances of Special Elements\nD.CWE-820:Missing Synchronization\nE.CWE-231:Improper Handling of Extra Values\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <sys/stat.h> \r\nint triazane_misconjugated = 0;\r\nint global_variable;\r\nvoid handle_taint(char *paleostriatum_shoq);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nstruct list {\r\n int data;\r\n struct list *previous;\r\n struct list *next;\r\n};\r\nstruct queue {\r\n pthread_mutex_t lock;\r\n pthread_cond_t is_empty;\r\n pthread_cond_t is_full;\r\n int size;\r\n int capacity;\r\n struct list *head;\r\n struct list *tail;\r\n};\r\nstruct data {\r\n int qsize;\r\n int data;\r\n char* file1;\r\n char* file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nint enqueue(struct queue *ssQ, int data) {\r\n int rtnval = 0;\r\n if (ssQ != NULL) {\r\n struct list *elem = malloc(sizeof(struct list));\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size >= ssQ->capacity) {\r\n pthread_cond_wait(&(ssQ->is_full), &(ssQ->lock));\r\n }\r\n elem->next = NULL;\r\n elem->previous = ssQ->tail;\r\n elem->data = data;\r\n if (ssQ->tail != NULL) {\r\n ssQ->tail->next = elem;\r\n }\r\n ssQ->tail = elem;\r\n ssQ->size++;\r\n if (ssQ->head == NULL) {\r\n ssQ->head = elem;\r\n }\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_empty));\r\n }\r\n else {\r\n rtnval = -1;\r\n }\r\n return rtnval;\r\n}\r\nint dequeue(struct queue *ssQ) {\r\n int val = -1;\r\n if (ssQ != NULL) {\r\n struct list *elem;\r\n pthread_mutex_lock(&(ssQ->lock));\r\n while (ssQ->size <= 0) {\r\n pthread_cond_wait(&(ssQ->is_empty), &(ssQ->lock));\r\n }\r\n elem = ssQ->head;\r\n ssQ->head = elem->next;\r\n if(ssQ->head != NULL) {\r\n ssQ->head->previous = NULL;\r\n }\r\n else {\r\n ssQ->tail = NULL;\r\n }\r\n val = elem->data;\r\n ssQ->size--;\r\n free(elem);\r\n pthread_mutex_unlock(&(ssQ->lock));\r\n pthread_cond_broadcast(&(ssQ->is_full));\r\n }\r\n return val;\r\n}\r\nstruct queue *get_instance (char* file2) {\r\n static struct queue *ssQ = NULL;\r\n \r\n \r\n \r\n if (ssQ == NULL) {\r\n if (file2 != NULL) {\r\n readFile(file2);\r\n }\r\n ssQ = (struct queue *)calloc(1, sizeof(struct queue));\r\n pthread_mutex_init(&(ssQ->lock), NULL);\r\n pthread_cond_init(&(ssQ->is_empty), NULL);\r\n pthread_cond_init(&(ssQ->is_full), NULL);\r\n ssQ->size = 0;\r\n ssQ->capacity = 30;\r\n ssQ->head = NULL;\r\n ssQ->tail = NULL;\r\n }\r\n \r\n \r\n return ssQ;\r\n}\r\nvoid *print_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ = get_instance(ssD->file2);\r\n int i;\r\n \r\n \r\n \r\n while ((i = dequeue(ssQ)) != -1) {\r\n printf(\"Data: %d\\n\", i);\r\n }\r\n \r\n return NULL;\r\n}\r\nvoid *calc_data (void *data) {\r\n struct data *ssD = (struct data *)data;\r\n struct queue *ssQ;\r\n int *qsort_arr;\r\n int i;\r\n \r\n qsort_arr = malloc(sizeof(int)*ssD->qsize);\r\n if (qsort_arr != NULL) {\r\n for (i = 0; i < ssD->qsize; i++) {\r\n qsort_arr[i] = ssD->qsize - i;\r\n }\r\n qsort(qsort_arr, ssD->qsize, sizeof(int), &comp);\r\n free (qsort_arr);\r\n qsort_arr = NULL;\r\n }\r\n readFile(ssD->file1);\r\n ssQ = get_instance(NULL);\r\n \r\n for (i = 0; i < ssD->data; i++) {\r\n \r\n if (enqueue(ssQ, i) == -1) {\r\n break;\r\n }\r\n }\r\n enqueue(ssQ, -1);\r\n \r\n return NULL;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&triazane_misconjugated,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *paleostriatum_shoq)\r\n{\r\n pthread_t t0, t1;\r\n struct data* Data;\r\n char *pardalote_democratism = 0;\r\n char **patroclinous_oscheocele = 0;\r\n int *tamales_nelson = 0;\r\n int lawrightman_onymal;\r\n char **apocha_misentered[10] = {0};\r\n char *pastier_extacie[33] = {0};\r\n ++global_variable;;\r\n if (paleostriatum_shoq != 0) {;\r\n pastier_extacie[22] = paleostriatum_shoq;\r\n apocha_misentered[5] = pastier_extacie;\r\n lawrightman_onymal = 5;\r\n tamales_nelson = &lawrightman_onymal;\r\n patroclinous_oscheocele = *(apocha_misentered + *tamales_nelson);\r\n pardalote_democratism = ((char *)patroclinous_oscheocele[22]);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->file1 = malloc(sizeof(char) * (strlen(pardalote_democratism) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(pardalote_democratism) + 1));\r\n if ((sscanf(pardalote_democratism, \"%d %s %s %d\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n &(Data->data)) == 4) &&\r\n Data->qsize >= 0 &&\r\n Data->data >= 0 &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calc_data, Data) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n if (pthread_create(&t1, NULL, print_data, Data) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->file1);\r\n free(Data->file2);\r\n free(Data);\r\n }\r\n \r\n;\r\n if (patroclinous_oscheocele[22] != 0) \r\n free(((char *)patroclinous_oscheocele[22]));\r\nclose_printf_context();\r\n }\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context|D.CWE-820:Missing Synchronization", "cwe": "543"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-397:Declaration of Throws for Generic Exception\nC.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-436:Interpretation Conflict\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std; \r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_throw_exception_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n throw exception();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_throw_exception_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-397:Declaration of Throws for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "397"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-194:Unexpected Sign Extension\nB.CWE-303:Incorrect Implementation of Authentication Algorithm\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-80:Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n\r\n#define CHAR_ARRAY_SIZE 8\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_memcpy_66bSink(short dataArray[]);\r\n\r\nvoid My_connect_socket_memcpy_66()\r\n{\r\n short data;\r\n short dataArray[5];\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n int tempInt;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n tempInt = atoi(inputBuffer);\r\n if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\r\n {\r\n data = -1;\r\n }\r\n else\r\n {\r\n data = tempInt;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataArray[2] = data;\r\n My_connect_socket_memcpy_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_memcpy_66bG2BSink(short dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n short dataArray[5];\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n dataArray[2] = data;\r\n My_connect_socket_memcpy_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_connect_socket_memcpy_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_memcpy_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_memcpy_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-194:Unexpected Sign Extension|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nC.CWE-468:Incorrect Pointer Scaling\nD.CWE-682:Incorrect Calculation\nE.CWE-1267:Policy Uses Obsolete Encoding\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+(2*sizeof(int)));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int *intPointer = intArray;\r\n \r\n \r\n int toPrint = *(intPointer+2);\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-468:Incorrect Pointer Scaling|D.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.No Vulnerabilities\nC.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nD.CWE-396:Declaration of Catch for Generic Exception\nE.CWE-705:Incorrect Control Flow Scoping\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_dotdotdot_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(1)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (...)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_dotdotdot_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-396:Declaration of Catch for Generic Exception|E.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-482:Comparing instead of Assigning\nB.CWE-806:Buffer Access Using Size of Source Buffer\nC.CWE-1079:Parent Class without Virtual Destructor Method\nD.CWE-480:Use of Incorrect Operator\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n int intMSink = 0;\r\n \r\n printIntLine(intMSink);\r\n \r\n intMSink == 5;\r\n printIntLine(intMSink);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intNSink = 0;\r\n \r\n printIntLine(intNSink);\r\n \r\n intNSink = 5;\r\n printIntLine(intNSink);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n int intNSink = 0;\r\n \r\n printIntLine(intNSink);\r\n \r\n intNSink = 5;\r\n printIntLine(intNSink);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-482:Comparing instead of Assigning|D.CWE-480:Use of Incorrect Operator", "cwe": "482"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-298:Improper Validation of Certificate Expiration\nB.CWE-131:Incorrect Calculation of Buffer Size\nC.CWE-467:Use of sizeof() on a Pointer Type\nD.No Vulnerabilities\nE.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n int * mInt = NULL;\r\n \r\n mInt = (int *)malloc(sizeof(mInt));\r\n if (mInt == NULL) {exit(-1);}\r\n *mInt = 5;\r\n printIntLine(*mInt);\r\n free(mInt);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-467:Use of sizeof() on a Pointer Type|B.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-36:Absolute Path Traversal\nC.CWE-159:Improper Handling of Invalid Use of Special Elements\nD.No Vulnerabilities\nE.CWE-391:Unchecked Error Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FOPEN _wfopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nnamespace My_wchar_t_console_fopen_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, L\"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, L\"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, L\"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_console_fopen_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-36:Absolute Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.CWE-696:Incorrect Behavior Order\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.No Vulnerabilities\nE.CWE-1224:Improper Restriction of Write-Once Bit Fields\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fopen_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fopen_83\r\n{\r\npublic:\r\n My_fopen_83(FILE * dataCopy);\r\n ~My_fopen_83();\r\n\r\nprivate:\r\n FILE * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fopen_83B2G\r\n{\r\npublic:\r\n My_fopen_83B2G(FILE * dataCopy);\r\n ~My_fopen_83B2G();\r\n\r\nprivate:\r\n FILE * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-305:Authentication Bypass by Primary Weakness\nC.CWE-114:Process Control\nD.CWE-73:External Control of File Name or Path\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_w32_char_console_22Global = 0;\r\n\r\nchar * My_w32_char_console_22Source(char * data);\r\n\r\nvoid My_w32_char_console_22()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n My_w32_char_console_22Global = 1; \r\n data = My_w32_char_console_22Source(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_w32_char_console_22G2B1Global = 0;\r\nint My_w32_char_console_22G2B2Global = 0;\r\n\r\n\r\nchar * My_w32_char_console_22G2B1Source(char * data);\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n My_w32_char_console_22G2B1Global = 0; \r\n data = My_w32_char_console_22G2B1Source(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nchar * My_w32_char_console_22G2B2Source(char * data);\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n My_w32_char_console_22G2B2Global = 1; \r\n data = My_w32_char_console_22G2B2Source(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_console_22()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_console_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_console_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|D.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.CWE-197:Numeric Truncation Error\nC.CWE-573:Improper Following of Specification by Caller\nD.No Vulnerabilities\nE.CWE-475:Undefined Behavior for Input to API\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-475:Undefined Behavior for Input to API|C.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-393:Return of Wrong Status Code\nD.No Vulnerabilities\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_bind_accept_listen_03()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_bind_accept_listen_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_bind_accept_listen_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_bind_accept_listen_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-666:Operation on Resource in Wrong Phase of Lifetime|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-761:Free of Pointer not at Start of Buffer\nB.CWE-763:Release of Invalid Pointer or Reference\nC.CWE-162:Improper Neutralization of Trailing Special Elements\nD.No Vulnerabilities\nE.CWE-1322:Use of Blocking Code in Single-threaded, Non-blocking Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_file_14()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(globalFive==5)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_file_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_file_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_file_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-761:Free of Pointer not at Start of Buffer|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-606:Unchecked Input for Loop Condition\nB.CWE-556:ASP.NET Misconfiguration: Use of Identity Impersonation\nC.No Vulnerabilities\nD.CWE-1123:Excessive Use of Self-Modifying Code\nE.CWE-1284:Improper Validation of Specified Quantity in Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\ntypedef struct _My_char_environment_67_structType\r\n{\r\n char * structFirst;\r\n} My_char_environment_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_environment_67bSink(My_char_environment_67_structType myStruct);\r\n\r\nvoid My_char_environment_67()\r\n{\r\n char * data;\r\n My_char_environment_67_structType myStruct;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n myStruct.structFirst = data;\r\n My_char_environment_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_environment_67bG2BSink(My_char_environment_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n My_char_environment_67_structType myStruct;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"15\");\r\n myStruct.structFirst = data;\r\n My_char_environment_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_char_environment_67bB2GSink(My_char_environment_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n My_char_environment_67_structType myStruct;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n myStruct.structFirst = data;\r\n My_char_environment_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_char_environment_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-606:Unchecked Input for Loop Condition|E.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-341:Predictable from Observable State\nB.CWE-127:Buffer Under-read\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE839_fscanf_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-274:Improper Handling of Insufficient Privileges\nC.CWE-456:Missing Initialization of a Variable\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_min_multiply_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<char> dataList);\r\n\r\nvoid m()\r\n{\r\n char data;\r\n list<char> dataList;\r\n data = ' ';\r\n \r\n data = CHAR_MIN;\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<char> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n list<char> dataList;\r\n data = ' ';\r\n \r\n data = -2;\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<char> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n char data;\r\n list<char> dataList;\r\n data = ' ';\r\n \r\n data = CHAR_MIN;\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_min_multiply_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-642:External Control of Critical State Data\nC.CWE-273:Improper Check for Dropped Privileges\nD.No Vulnerabilities\nE.CWE-280:Improper Handling of Insufficient Permissions or Privileges \n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_01()\r\n{\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-273:Improper Check for Dropped Privileges|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-447:Unimplemented or Unsupported Feature in UI\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-693:Protection Mechanism Failure\nE.CWE-122:Heap-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_c_My_c_My_c_My_c_My_c_My_c_My_c_My_c_CWE193_char_cpy_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-122:Heap-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.No Vulnerabilities\nD.CWE-1056:Invokable Control Element with Variadic Parameters\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_negative_malloc_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int &data)\r\n{\r\n \r\n data = -1;\r\n}\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(int &data)\r\n{\r\n \r\n data = 100-1;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2BSource(data);\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_negative_malloc_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-601:URL Redirection to Untrusted Site ('Open Redirect')\nC.CWE-172:Encoding Error\nD.CWE-176:Improper Handling of Unicode Encoding\nE.CWE-477:Use of Obsolete Function\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_02()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(1)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(1)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(1)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(1)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_02()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-176:Improper Handling of Unicode Encoding|C.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-134:Use of Externally-Controlled Format String\nB.CWE-1119:Excessive Use of Unconditional Branching\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.No Vulnerabilities\nE.CWE-447:Unimplemented or Unsupported Feature in UI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_file_printf_32()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n \r\n wprintf(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n \r\n wcscpy(data, L\"fixedstringtest\");\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n \r\n wprintf(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n \r\n wprintf(L\"%s\\n\", data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_file_printf_32()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_printf_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_printf_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-134:Use of Externally-Controlled Format String|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nB.CWE-479:Signal Handler Use of a Non-reentrant Function\nC.CWE-784:Reliance on Cookies without Validation and Integrity Checking in a Security Decision\nD.No Vulnerabilities\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <signal.h>\r\n\r\nstatic void helperM(int sig)\r\n{\r\n \r\n \r\n void *voidPointer = malloc(10);\r\n if (voidPointer == NULL) {exit(-1);}\r\n free(voidPointer);\r\n}\r\n\r\nstatic volatile sig_atomic_t volatileSigAtomic = 0;\r\n\r\nstatic void helperN(int sig)\r\n{\r\n \r\n volatileSigAtomic = sig;\r\n}\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n signal(SIGINT, helperM);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n signal(SIGINT, helperN);\r\n }\r\n}\r\n\r\nvoid My_basic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-479:Signal Handler Use of a Non-reentrant Function|A.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "cwe": "479"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.CWE-323:Reusing a Nonce, Key Pair in Encryption\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.No Vulnerabilities\nE.CWE-475:Undefined Behavior for Input to API\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_03()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(5==5)\r\n {\r\n \r\n data = CreateFile(\"MSink_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n data = CreateFile(\"NSink_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(5==5)\r\n {\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n data = CreateFile(\"NSink_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-646:Reliance on File Name or Extension of Externally-Supplied File\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-1289:Improper Validation of Unsafe Equivalence in Input\nD.No Vulnerabilities\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_strncpy_06()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_listen_socket_strncpy_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_strncpy_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_strncpy_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.No Vulnerabilities\nC.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nD.CWE-1241:Use of Predictable Algorithm in Random Number Generator\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_memmove_06()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memmove(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_listen_socket_memmove_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_memmove_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_memmove_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-646:Reliance on File Name or Extension of Externally-Supplied File\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.No Vulnerabilities\nD.CWE-400:Uncontrolled Resource Consumption\nE.CWE-603:Use of Client-Side Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_fscanf_sleep_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<int> countVector);\r\n\r\nvoid m()\r\n{\r\n int count;\r\n vector<int> countVector;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n \r\n countVector.insert(countVector.end(), 1, count);\r\n countVector.insert(countVector.end(), 1, count);\r\n countVector.insert(countVector.end(), 1, count);\r\n mSink(countVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(vector<int> countVector);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n vector<int> countVector;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n \r\n countVector.insert(countVector.end(), 1, count);\r\n countVector.insert(countVector.end(), 1, count);\r\n countVector.insert(countVector.end(), 1, count);\r\n nG2BSink(countVector);\r\n}\r\n\r\n\r\nvoid nB2GSink(vector<int> countVector);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n vector<int> countVector;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n countVector.insert(countVector.end(), 1, count);\r\n countVector.insert(countVector.end(), 1, count);\r\n countVector.insert(countVector.end(), 1, count);\r\n nB2GSink(countVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fscanf_sleep_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-40:Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\nB.CWE-468:Incorrect Pointer Scaling\nC.No Vulnerabilities\nD.CWE-28:Path Traversal: '..\\filedir'\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-468:Incorrect Pointer Scaling|E.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-312:Cleartext Storage of Sensitive Information\nC.CWE-1298:Hardware Logic Contains Race Conditions\nD.No Vulnerabilities\nE.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_03()\r\n{\r\n if(5==5)\r\n {\r\n \r\n printLine(getenv(\"PATH\"));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\nvoid My_basic_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable|B.CWE-312:Cleartext Storage of Sensitive Information", "cwe": "526"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-476:NULL Pointer Dereference\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-567:Unsynchronized Access to Shared Data in a Multithreaded Context\nE.CWE-621:Variable Extraction Error\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint lubbers_marquis = 0;\r\nint global_variable;\r\ntypedef char *jerseyan_dhootie;\r\n#define GEEJEE_POLICY(x) oyens_ravings((jerseyan_dhootie *) x)\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid oyens_ravings(jerseyan_dhootie *thamuria_helmeted);\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n jerseyan_dhootie *lenticonus_convex = 0;\r\n jerseyan_dhootie *hongkong_personality = 0;\r\n jerseyan_dhootie contravening_omniscience = 0;\r\n char *haff_burgeoning;;\r\n if (__sync_bool_compare_and_swap(&lubbers_marquis,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&haff_burgeoning,\"WINTERY_NOVI\");\r\n if (haff_burgeoning != 0) {;\r\n contravening_omniscience = haff_burgeoning;\r\n lenticonus_convex = &contravening_omniscience;\r\n hongkong_personality = lenticonus_convex + 5;\r\n\tGEEJEE_POLICY(hongkong_personality);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid oyens_ravings(jerseyan_dhootie *thamuria_helmeted)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *lithophany_aeronef = 0;\r\n ++global_variable;;\r\n lithophany_aeronef = ((char *)( *(thamuria_helmeted - 5)));\r\n \r\n \r\n\r\n if (strlen(lithophany_aeronef) < 63) {\r\n skip_malloc_buffer = malloc(strlen(lithophany_aeronef + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,lithophany_aeronef);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if ( *(thamuria_helmeted - 5) != 0) \r\n free(((char *)( *(thamuria_helmeted - 5))));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-476:NULL Pointer Dereference|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nB.CWE-73:External Control of File Name or Path\nC.No Vulnerabilities\nD.CWE-114:Process Control\nE.CWE-689:Permission Race Condition During Resource Copy\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_console_03()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_console_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_console_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_console_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-114:Process Control|B.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-770:Allocation of Resources Without Limits or Throttling\nC.CWE-252:Unchecked Return Value\nD.CWE-1107:Insufficient Isolation of Symbolic Constant Definitions\nE.CWE-789:Memory Allocation with Excessive Size Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_fgets_15()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = 20;\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 20;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_fgets_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_fgets_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_fgets_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-789:Memory Allocation with Excessive Size Value|B.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-126:Buffer Over-read\nC.CWE-357:Insufficient UI Warning of Dangerous Operations\nD.CWE-1384:Improper Handling of Physical or Environmental Conditions\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_alloca_loop_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataMBuffer;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, char *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataNBuffer;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_alloca_loop_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-556:ASP.NET Misconfiguration: Use of Identity Impersonation\nC.CWE-439:Behavioral Change in New Version or Environment\nD.CWE-126:Buffer Over-read\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_alloca_memcpy_10()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n if(globalTrue)\r\n {\r\n \r\n data = dataMBuffer;\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = dataNBuffer;\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n wmemset(dataMBuffer, L'A', 50-1); \r\n dataMBuffer[50-1] = L'\\0'; \r\n wmemset(dataNBuffer, L'A', 100-1); \r\n dataNBuffer[100-1] = L'\\0'; \r\n if(globalTrue)\r\n {\r\n \r\n data = dataNBuffer;\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n \r\n memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_alloca_memcpy_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_alloca_memcpy_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_alloca_memcpy_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1302:Missing Security Identifier\nC.CWE-151:Improper Neutralization of Comment Delimiters\nD.CWE-457:Use of Uninitialized Variable\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_pointer_03()\r\n{\r\n twoIntsStruct * data;\r\n if(5==5)\r\n {\r\n \r\n ; \r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n if(5==5)\r\n {\r\n \r\n ; \r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n if(5==5)\r\n {\r\n \r\n ; \r\n }\r\n if(5==5)\r\n {\r\n \r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n if(5==5)\r\n {\r\n \r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n}\r\n\r\nvoid My_struct_pointer_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_pointer_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_pointer_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-457:Use of Uninitialized Variable|E.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1120:Excessive Code Complexity\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-459:Incomplete Cleanup\nD.CWE-1083:Data Access from Outside Expected Data Manager Component\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#define FDOPEN fdopen\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#define FDOPEN fdopen\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char filename[] = \"mXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char filename[] = \"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-459:Incomplete Cleanup|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-761:Free of Pointer not at Start of Buffer\nC.CWE-449:The UI Performs the Wrong Action\nD.No Vulnerabilities\nE.CWE-332:Insufficient Entropy in PRNG\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_console_04()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_console_04()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-761:Free of Pointer not at Start of Buffer|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-755:Improper Handling of Exceptional Conditions\nB.CWE-584:Return Inside Finally Block\nC.CWE-112:Missing XML Validation\nD.No Vulnerabilities\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n#include <errno.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_sqrt_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n \r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_sqrt_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_sqrt_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_sqrt_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|A.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-925:Improper Verification of Intent by Broadcast Receiver\nB.CWE-667:Improper Locking\nC.No Vulnerabilities\nD.CWE-832:Unlock of a Resource that is not Locked\nE.CWE-687:Function Call With Incorrectly Specified Argument Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-832:Unlock of a Resource that is not Locked|B.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1059:Insufficient Technical Documentation\nB.No Vulnerabilities\nC.CWE-590:Free of Memory not on the Heap\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-1120:Excessive Code Complexity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_free_long_static_66bSink(long * dataArray[]);\r\n\r\nvoid My_free_long_static_66()\r\n{\r\n long * data;\r\n long * dataArray[5];\r\n data = NULL; \r\n {\r\n \r\n static long dataBuffer[100];\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5L;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n \r\n dataArray[2] = data;\r\n My_free_long_static_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_free_long_static_66bG2BSink(long * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n long * data;\r\n long * dataArray[5];\r\n data = NULL; \r\n {\r\n \r\n long * dataBuffer = (long *)malloc(100*sizeof(long));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5L;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n dataArray[2] = data;\r\n My_free_long_static_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_free_long_static_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_free_long_static_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_free_long_static_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-590:Free of Memory not on the Heap|D.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-673:External Influence of Sphere Definition\nC.CWE-261:Weak Encoding for Password\nD.CWE-836:Use of Password Hash Instead of Password for Authentication\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_popen_41Sink(wchar_t * data)\r\n{\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_popen_41()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n My_wchar_t_popen_41Sink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nvoid My_wchar_t_popen_41G2BSink(wchar_t * data)\r\n{\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"wb\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n My_wchar_t_popen_41G2BSink(data);\r\n}\r\n\r\nvoid My_wchar_t_popen_41()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_popen_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_popen_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-426:Untrusted Search Path|B.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nC.CWE-1326:Missing Immutable Root of Trust in Hardware\nD.CWE-412:Unrestricted Externally Accessible Lock\nE.CWE-667:Improper Locking\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <sys/stat.h> \r\nint unengaged_stoneblindness = 0;\r\n\r\nunion serodiagnosis_havlagah \r\n{\r\n char *airfields_angiokeratoma;\r\n double larget_safeblower;\r\n char *histories_massoy;\r\n char cutify_giles;\r\n int gellman_strate;\r\n}\r\n;\r\nint global_variable;\r\nvoid handle_taint(char *balneology_hukbalahap);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid throughgang_jewishly(int guaycuru_gobletful,union serodiagnosis_havlagah dispraised_rectifiable);\r\nvoid kromeski_trespassing(int nondistracting_shafter,union serodiagnosis_havlagah epidemial_munch);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&unengaged_stoneblindness,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *balneology_hukbalahap)\r\n{\r\n int deductile_jews = 7;\r\n union serodiagnosis_havlagah overelaborately_electrolytical = {0};\r\n long laetic_goldfinches[10];\r\n union serodiagnosis_havlagah dilo_tingle[10] = {0};\r\n union serodiagnosis_havlagah unworkmanlike_unreined;\r\n ++global_variable;;\r\n if (balneology_hukbalahap != 0) {;\r\n unworkmanlike_unreined . airfields_angiokeratoma = balneology_hukbalahap;\r\n dilo_tingle[5] = unworkmanlike_unreined;\r\n laetic_goldfinches[1] = 5;\r\n overelaborately_electrolytical = *(dilo_tingle + laetic_goldfinches[1]);\r\n throughgang_jewishly(deductile_jews,overelaborately_electrolytical);\r\n }\r\n}\r\n\r\nvoid throughgang_jewishly(int guaycuru_gobletful,union serodiagnosis_havlagah dispraised_rectifiable)\r\n{\r\n int fd;\r\n char *extension = \".lck\";\r\n char *thelockfile;\r\n char *haplomous_pervades = 0;\r\n ++global_variable;\r\n guaycuru_gobletful--;\r\n if (guaycuru_gobletful > 0) {\r\n kromeski_trespassing(guaycuru_gobletful,dispraised_rectifiable);\r\n return ;\r\n }\r\n haplomous_pervades = ((char *)dispraised_rectifiable . airfields_angiokeratoma);\r\n \r\n thelockfile = (char *)malloc(strlen(\"/opt//workspace/testData/\") + strlen(haplomous_pervades) +\r\n strlen(extension) + 1);\r\n \r\n if (thelockfile) {\r\n \r\n \r\n strcpy(thelockfile, \"/opt//workspace/testData/\");\r\n strcat(thelockfile, haplomous_pervades);\r\n strcat(thelockfile, extension);\r\n \r\n \r\n if (access(\"/opt//workspace/testData/\", R_OK && W_OK) == -1) {\r\n printf(\"Error accessing testData directory\\n\");\r\n } else {\r\n printf(\"Grabbing lock file: %s\\n\", thelockfile);\r\n \r\n \r\n \r\n while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\r\n sleep(0);\r\n }\r\n \r\n printf(\"Made it to the critical section\\n\");\r\n if (fd != -1) {\r\n close(fd);\r\n unlink(thelockfile);\r\n }\r\n free (thelockfile);\r\n }\r\n }\r\n;\r\n if (dispraised_rectifiable . airfields_angiokeratoma != 0) \r\n free(((char *)dispraised_rectifiable . airfields_angiokeratoma));\r\nclose_printf_context();\r\n}\r\n\r\nvoid kromeski_trespassing(int nondistracting_shafter,union serodiagnosis_havlagah epidemial_munch)\r\n{\r\n ++global_variable;\r\n throughgang_jewishly(nondistracting_shafter,epidemial_munch);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-412:Unrestricted Externally Accessible Lock|E.CWE-667:Improper Locking", "cwe": "412"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-325:Missing Cryptographic Step\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.CWE-573:Improper Following of Specification by Caller\nE.CWE-622:Improper Validation of Function Hook Arguments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptHashData_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptHashData_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptHashData_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptHashData_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-325:Missing Cryptographic Step|D.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1284:Improper Validation of Specified Quantity in Input\nB.CWE-475:Undefined Behavior for Input to API\nC.No Vulnerabilities\nD.CWE-573:Improper Following of Specification by Caller\nE.CWE-322:Key Exchange without Entity Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-475:Undefined Behavior for Input to API|D.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-565:Reliance on Cookies without Validation and Integrity Checking\nC.CWE-682:Incorrect Calculation\nD.No Vulnerabilities\nE.CWE-611:Improper Restriction of XML External Entity Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nint64_t My_int64_t_min_postdec_68Data;\r\nint64_t My_int64_t_min_postdec_68G2BData;\r\nint64_t My_int64_t_min_postdec_68B2GData;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int64_t_min_postdec_68bSink();\r\n\r\nvoid My_int64_t_min_postdec_68()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n data = LLONG_MIN;\r\n My_int64_t_min_postdec_68Data = data;\r\n My_int64_t_min_postdec_68bSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int64_t_min_postdec_68bG2BSink();\r\nvoid My_int64_t_min_postdec_68bB2GSink();\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n data = -2;\r\n My_int64_t_min_postdec_68G2BData = data;\r\n My_int64_t_min_postdec_68bG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n \r\n data = LLONG_MIN;\r\n My_int64_t_min_postdec_68B2GData = data;\r\n My_int64_t_min_postdec_68bB2GSink();\r\n}\r\n\r\nvoid My_int64_t_min_postdec_68()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_min_postdec_68();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_min_postdec_68();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|C.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.CWE-770:Allocation of Resources Without Limits or Throttling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_wchar_t_listen_socket_82\r\n{\r\n\r\nclass My_new_wchar_t_listen_socket_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(size_t data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_wchar_t_listen_socket_82 : public My_new_wchar_t_listen_socket_82_base\r\n{\r\npublic:\r\n void action(size_t data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_wchar_t_listen_socket_82G2B : public My_new_wchar_t_listen_socket_82_base\r\n{\r\npublic:\r\n void action(size_t data);\r\n};\r\n\r\nclass My_new_wchar_t_listen_socket_82B2G : public My_new_wchar_t_listen_socket_82_base\r\n{\r\npublic:\r\n void action(size_t data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-789:Memory Allocation with Excessive Size Value|E.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-510:Trapdoor\nB.CWE-1263:Improper Physical Access Control\nC.No Vulnerabilities\nD.CWE-481:Assigning instead of Comparing\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_connection_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(80);\r\n \r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_connection_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-510:Trapdoor|E.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-240:Improper Handling of Inconsistent Structural Elements\nC.CWE-288:Authentication Bypass Using an Alternate Path or Channel\nD.CWE-765:Multiple Unlocks of a Critical Resource\nE.CWE-667:Improper Locking\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint liras_antisepticise = 0;\r\nint global_variable;\r\n\r\nunion hispano_analogise \r\n{\r\n char *personhood_cashmere;\r\n double rosa_multilobular;\r\n char *domed_shelf;\r\n char leawill_biggening;\r\n int recoach_bereavement;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid whush_multichambered(union hispano_analogise popweed_contemptibly);\r\npthread_t t0, t1, t2;\r\nsem_t sem;\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n}\r\nvoid *toCap (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int *arr;\r\n int i = 0;\r\n int i = 0;\r\n \r\n printf(\"Inside toCap\\n\");\r\n \r\n sem_wait(&sem); \r\n \r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n for(i = 0; i < strlen(Data->data); i++) {\r\n if (Data->data[i] >= 'a' && Data->data[i] <= 'z') { \r\n Data->data[i] -= 32; \r\n }\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\nint isalpha(char c) {\r\n return ((c >= 'A' && c <= 'Z') ||\r\n (c >= 'a' && c <= 'z'));\r\n}\r\nvoid *delNonAlpha (void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i = 0;\r\n int j = 0;\r\n char *temp = NULL;\r\n \r\n printf(\"Inside delNonAlpha\\n\");\r\n \r\n sem_wait(&sem);\r\n temp = malloc(sizeof(char) * (strlen(Data->data) + 1));\r\n while(Data->data[i] != '\\0') {\r\n if (isalpha(Data->data[i])) {\r\n temp[j++] = Data->data[i];\r\n }\r\n i++;\r\n }\r\n temp[++j] = '\\0';\r\n free(Data->data);\r\n Data->data = NULL; \r\n \r\n \r\n readFile(Data->file2);\r\n \r\n Data->data = temp;\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n#define MIMOSACEAE_BLAEUW(x) whush_multichambered((union hispano_analogise) x)\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n union hispano_analogise fazenda_newscasting;\r\n char *reinstalment_sacristans;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&liras_antisepticise,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n reinstalment_sacristans = getenv(\"TECTON_FLUORINATING\");\r\n if (reinstalment_sacristans != 0) {;\r\n fazenda_newscasting . personhood_cashmere = reinstalment_sacristans;\r\n\tMIMOSACEAE_BLAEUW(fazenda_newscasting);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid whush_multichambered(union hispano_analogise popweed_contemptibly)\r\n{\r\n pthread_t t0, t1;\r\n int hasNonAlpha = 0;\r\n int i = 0;\r\n struct data* Data;\r\n char *contubernium_discustom = 0;\r\n ++global_variable;;\r\n contubernium_discustom = ((char *)popweed_contemptibly . personhood_cashmere);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(contubernium_discustom) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(contubernium_discustom) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(contubernium_discustom) + 1));\r\n if (Data->data) {\r\n if ((sscanf(contubernium_discustom, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0)) {\r\n sem_init(&sem, 0, 1);\r\n while (Data->data[i] != '\\0') { \r\n if(isalpha(Data->data[i]) == 0) {\r\n hasNonAlpha = 1;\r\n }\r\n i++;\r\n }\r\n if (hasNonAlpha != 0) {\r\n \r\n \r\n sem_post(&sem);\r\n pthread_create(&t0, NULL, delNonAlpha, Data); \r\n \r\n } \r\n pthread_create(&t1, NULL, toCap, Data);\r\n if (hasNonAlpha != 0) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n } else {\r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-765:Multiple Unlocks of a Critical Resource|E.CWE-667:Improper Locking", "cwe": "765"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-305:Authentication Bypass by Primary Weakness\nB.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nC.No Vulnerabilities\nD.CWE-616:Incomplete Identification of Uploaded File Variables (PHP)\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_environment_63bSink(wchar_t * * dataPtr);\r\n\r\nvoid My_w32_wchar_t_environment_63()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 256-dataLen-1);\r\n }\r\n }\r\n My_w32_wchar_t_environment_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_environment_63bG2BSink(wchar_t * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n My_w32_wchar_t_environment_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_w32_wchar_t_environment_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_environment_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_environment_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1023:Incomplete Comparison with Missing Factors\nB.CWE-262:Not Using Password Aging\nC.No Vulnerabilities\nD.CWE-916:Use of Password Hash With Insufficient Computational Effort\nE.CWE-839:Numeric Range Comparison Without Minimum Check\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint revocate_inspheration = 0;\r\nint global_variable;\r\nvoid handle_taint(char *stockishness_tensile);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid overdoses_pelletal(void *stunter_agavose);\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&revocate_inspheration,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n#define SARAWAKESE_DENNYSVILLE(x) overdoses_pelletal((void *) x)\r\n\r\nvoid handle_taint(char *stockishness_tensile)\r\n{\r\n void *owenist_phytalbumose = 0;\r\n int **************************************************giallolino_underbodies = 0;\r\n int *************************************************bagatine_affluentness = 0;\r\n int ************************************************troch_dermatatrophia = 0;\r\n int ***********************************************congaing_clampdown = 0;\r\n int **********************************************geitonogamous_etudes = 0;\r\n int *********************************************anapaganize_normannic = 0;\r\n int ********************************************luminodynamist_bollandus = 0;\r\n int *******************************************breadth_dimorphite = 0;\r\n int ******************************************manzoni_tegyrius = 0;\r\n int *****************************************clatch_chorographer = 0;\r\n int ****************************************unspruced_hyperpyrexia = 0;\r\n int ***************************************syncategoreme_tavola = 0;\r\n int **************************************suitcases_reminted = 0;\r\n int *************************************otti_streetsboro = 0;\r\n int ************************************slipshodness_tholos = 0;\r\n int ***********************************whirroo_noncausal = 0;\r\n int **********************************ensphere_anopheline = 0;\r\n int *********************************tithable_clews = 0;\r\n int ********************************puntout_resail = 0;\r\n int *******************************flyable_cashmerette = 0;\r\n int ******************************lovevine_veii = 0;\r\n int *****************************coalitionist_impartibilibly = 0;\r\n int ****************************nondegrading_nostalgia = 0;\r\n int ***************************mallows_sulpharsenious = 0;\r\n int **************************jubbahs_developoid = 0;\r\n int *************************topinabee_dabble = 0;\r\n int ************************excavating_belvidere = 0;\r\n int ***********************louch_mispenning = 0;\r\n int **********************palaeostylic_shkupetar = 0;\r\n int *********************courtin_hathaway = 0;\r\n int ********************vociferations_mediatrix = 0;\r\n int *******************fibred_clairvoyants = 0;\r\n int ******************proctorially_amides = 0;\r\n int *****************latherer_trichinoid = 0;\r\n int ****************painfulness_boride = 0;\r\n int ***************pathoneurosis_overpopulation = 0;\r\n int **************zapu_palici = 0;\r\n int *************misdeeming_incongruously = 0;\r\n int ************pentacrinus_forksful = 0;\r\n int ***********subslots_prosely = 0;\r\n int **********earthwards_elotherium = 0;\r\n int *********polyacanthus_noughty = 0;\r\n int ********unpurpled_cemetaries = 0;\r\n int *******vibrant_overfrankness = 0;\r\n int ******aures_polymazia = 0;\r\n int *****brahmana_cottier = 0;\r\n int ****ange_encouragement = 0;\r\n int ***mill_mistakingly = 0;\r\n int **coharmonize_irrefragability = 0;\r\n int *seismol_kolinskies = 0;\r\n int unrosined_hypochdria;\r\n void *journeycake_ottoville[10] = {0};\r\n void *lagrangeville_outvotes = 0;\r\n ++global_variable;;\r\n if (stockishness_tensile != 0) {;\r\n lagrangeville_outvotes = ((void *)stockishness_tensile);\r\n unrosined_hypochdria = 5;\r\n seismol_kolinskies = &unrosined_hypochdria;\r\n coharmonize_irrefragability = &seismol_kolinskies;\r\n mill_mistakingly = &coharmonize_irrefragability;\r\n ange_encouragement = &mill_mistakingly;\r\n brahmana_cottier = &ange_encouragement;\r\n aures_polymazia = &brahmana_cottier;\r\n vibrant_overfrankness = &aures_polymazia;\r\n unpurpled_cemetaries = &vibrant_overfrankness;\r\n polyacanthus_noughty = &unpurpled_cemetaries;\r\n earthwards_elotherium = &polyacanthus_noughty;\r\n subslots_prosely = &earthwards_elotherium;\r\n pentacrinus_forksful = &subslots_prosely;\r\n misdeeming_incongruously = &pentacrinus_forksful;\r\n zapu_palici = &misdeeming_incongruously;\r\n pathoneurosis_overpopulation = &zapu_palici;\r\n painfulness_boride = &pathoneurosis_overpopulation;\r\n latherer_trichinoid = &painfulness_boride;\r\n proctorially_amides = &latherer_trichinoid;\r\n fibred_clairvoyants = &proctorially_amides;\r\n vociferations_mediatrix = &fibred_clairvoyants;\r\n courtin_hathaway = &vociferations_mediatrix;\r\n palaeostylic_shkupetar = &courtin_hathaway;\r\n louch_mispenning = &palaeostylic_shkupetar;\r\n excavating_belvidere = &louch_mispenning;\r\n topinabee_dabble = &excavating_belvidere;\r\n jubbahs_developoid = &topinabee_dabble;\r\n mallows_sulpharsenious = &jubbahs_developoid;\r\n nondegrading_nostalgia = &mallows_sulpharsenious;\r\n coalitionist_impartibilibly = &nondegrading_nostalgia;\r\n lovevine_veii = &coalitionist_impartibilibly;\r\n flyable_cashmerette = &lovevine_veii;\r\n puntout_resail = &flyable_cashmerette;\r\n tithable_clews = &puntout_resail;\r\n ensphere_anopheline = &tithable_clews;\r\n whirroo_noncausal = &ensphere_anopheline;\r\n slipshodness_tholos = &whirroo_noncausal;\r\n otti_streetsboro = &slipshodness_tholos;\r\n suitcases_reminted = &otti_streetsboro;\r\n syncategoreme_tavola = &suitcases_reminted;\r\n unspruced_hyperpyrexia = &syncategoreme_tavola;\r\n clatch_chorographer = &unspruced_hyperpyrexia;\r\n manzoni_tegyrius = &clatch_chorographer;\r\n breadth_dimorphite = &manzoni_tegyrius;\r\n luminodynamist_bollandus = &breadth_dimorphite;\r\n anapaganize_normannic = &luminodynamist_bollandus;\r\n geitonogamous_etudes = &anapaganize_normannic;\r\n congaing_clampdown = &geitonogamous_etudes;\r\n troch_dermatatrophia = &congaing_clampdown;\r\n bagatine_affluentness = &troch_dermatatrophia;\r\n giallolino_underbodies = &bagatine_affluentness;\r\n journeycake_ottoville[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *giallolino_underbodies)))))))))))))))))))))))))))))))))))))))))))))))))] = lagrangeville_outvotes;\r\n owenist_phytalbumose = journeycake_ottoville[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *giallolino_underbodies)))))))))))))))))))))))))))))))))))))))))))))))))];\r\n\tSARAWAKESE_DENNYSVILLE(owenist_phytalbumose);\r\n }\r\n}\r\n\r\nvoid overdoses_pelletal(void *stunter_agavose)\r\n{\r\n char *buffer = 0U;\r\n int len;\r\n char *brat_bissonata = 0;\r\n ++global_variable;;\r\n brat_bissonata = ((char *)((char *)stunter_agavose));\r\n \r\n len = atoi(brat_bissonata);\r\n \r\n\r\n if (len < 4096) {\r\n buffer = ((char *)(malloc(4096 * sizeof(char ))));\r\n if (buffer != 0) {\r\n memset(buffer,'a',4096);\r\n \r\n \r\n\r\n memset(&buffer[len],'b',4096 - len);\r\n \r\n buffer[4095] = 0;\r\n printf(\"%s\\n\",buffer);\r\n free(buffer);\r\n }\r\n } else {\r\n printf(\"Number is too large to use\\n\");\r\n }\r\n \r\n \r\n;\r\n if (((char *)stunter_agavose) != 0) \r\n free(((char *)((char *)stunter_agavose)));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-839:Numeric Range Comparison Without Minimum Check|A.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "839"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.CWE-549:Missing Password Field Masking\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-1125:Excessive Attack Surface\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_char_environment_open_44\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n funcPtr(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_open_44; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-36:Absolute Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-584:Return Inside Finally Block\nB.CWE-121:Stack-based Buffer Overflow\nC.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nD.No Vulnerabilities\nE.CWE-787:Out-of-bounds Write\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define SNPRINTF _snwprintf\r\n#else\r\n#define SNPRINTF snprintf\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_My_My_My_My_My_My_My_CWE805_wchar_t_alloca_snprintf_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-121:Stack-based Buffer Overflow|E.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-764:Multiple Locks of a Critical Resource\nC.CWE-300:Channel Accessible by Non-Endpoint\nD.CWE-667:Improper Locking\nE.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint communistical_krusenstern = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid runelike_bergaptene(int mogitocia_hereticated,char **members_cohen);\r\nsem_t sem;\r\npthread_t t0, t1;\r\nchar *global_str;\r\nint isspace(char c) {\r\n return (c == ' ' || c == '\\t' || c == '\\n');\r\n}\r\nvoid *replaceSpace () {\r\n int i = 0;\r\n printf(\"Replacing spaces\\n\");\r\n \r\n \r\n \r\n sem_wait(&sem); \r\n sem_wait(&sem);\r\n \r\n while(global_str[i] != '\\0') {\r\n if (isspace(global_str[i]) != 0) {\r\n global_str[i] = '_';\r\n }\r\n i++;\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\nvoid *toCap () {\r\n int i = 0;\r\n \r\n \r\n printf(\"Capitalizing input\\n\");\r\n sem_wait(&sem);\r\n \r\n while(global_str[i] != '\\0') {\r\n if (global_str[i] > 'a' && global_str[i] < 'z') {\r\n global_str[i] -= 'a' - 'A';\r\n }\r\n i++;\r\n }\r\n sem_post(&sem);\r\n return NULL;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int acholoe_mallanders = 7;\r\n int isosmotic_unfighting;\r\n char **sniffily_perceivers = 0;\r\n char **pretyped_cosponsor = 0;\r\n int guernseyed_cowcatcher = 0;\r\n char *nonexcerptible_jamesstore = 0;\r\n char *pennon_myrrha;;\r\n if (__sync_bool_compare_and_swap(&communistical_krusenstern,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n pennon_myrrha = getenv(\"QUINSYBERRY_CRATON\");\r\n if (pennon_myrrha != 0) {;\r\n guernseyed_cowcatcher = ((int )(strlen(pennon_myrrha)));\r\n nonexcerptible_jamesstore = ((char *)(malloc(guernseyed_cowcatcher + 1)));\r\n if (nonexcerptible_jamesstore == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(nonexcerptible_jamesstore,0,guernseyed_cowcatcher + 1);\r\n memcpy(nonexcerptible_jamesstore,pennon_myrrha,guernseyed_cowcatcher);\r\n isosmotic_unfighting = 1;\r\n sniffily_perceivers = &nonexcerptible_jamesstore;\r\n pretyped_cosponsor = ((char **)(((unsigned long )sniffily_perceivers) * isosmotic_unfighting * isosmotic_unfighting)) + 5;\r\n runelike_bergaptene(acholoe_mallanders,pretyped_cosponsor);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid runelike_bergaptene(int mogitocia_hereticated,char **members_cohen)\r\n{\r\n int hasSpaces = 0;\r\n int i = 0;\r\n char *nonpresidential_killable = 0;\r\n ++global_variable;\r\n mogitocia_hereticated--;\r\n if (mogitocia_hereticated > 0) {\r\n runelike_bergaptene(mogitocia_hereticated,members_cohen);\r\n return ;\r\n }\r\n nonpresidential_killable = ((char *)( *(members_cohen - 5)));\r\n \r\n sem_init(&sem, 0, 1);\r\n while(nonpresidential_killable[i] != '\\0') { \r\n if (isspace(nonpresidential_killable[i++]) != 0) { \r\n hasSpaces = 1;\r\n }\r\n }\r\n \r\n global_str = malloc(sizeof(char) * strlen(nonpresidential_killable) + 1);\r\n strcpy(global_str, nonpresidential_killable);\r\n if (hasSpaces == 1) {\r\n \r\n \r\n if (pthread_create(&t0, NULL, replaceSpace, NULL) != 0) {\r\n printf(\"Thread 0 failed to spawn.\");\r\n }\r\n \r\n }\r\n if (pthread_create(&t1, NULL, toCap, NULL) != 0) {\r\n printf(\"Thread 1 failed to spawn.\");\r\n }\r\n if (hasSpaces == 1) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n;\r\n if ( *(members_cohen - 5) != 0) \r\n free(((char *)( *(members_cohen - 5))));\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-764:Multiple Locks of a Critical Resource|D.CWE-667:Improper Locking", "cwe": "764"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-606:Unchecked Input for Loop Condition\nB.No Vulnerabilities\nC.CWE-1284:Improper Validation of Specified Quantity in Input\nD.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\nE.CWE-73:External Control of File Name or Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_console_63bSink(char * * dataPtr);\r\n\r\nvoid My_char_console_63()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n My_char_console_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_console_63bG2BSink(char * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"15\");\r\n My_char_console_63bG2BSink(&data);\r\n}\r\n\r\n\r\nvoid My_char_console_63bB2GSink(char * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n My_char_console_63bB2GSink(&data);\r\n}\r\n\r\nvoid My_char_console_63()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_console_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_console_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-606:Unchecked Input for Loop Condition|C.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-121:Stack-based Buffer Overflow\nB.CWE-1075:Unconditional Control Flow Transfer outside of Switch Block\nC.No Vulnerabilities\nD.CWE-787:Out-of-bounds Write\nE.CWE-841:Improper Enforcement of Behavioral Workflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_My_CWE129_rand_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-121:Stack-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-781:Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code\nB.CWE-665:Improper Initialization\nC.CWE-165:Improper Neutralization of Multiple Internal Special Elements\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_ncat_16()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n \r\n ; \r\n break;\r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n \r\n data[0] = L'\\0'; \r\n break;\r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_ncat_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_ncat_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_ncat_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-194:Unexpected Sign Extension\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.CWE-1293:Missing Source Correlation of Multiple Independent Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fscanf_malloc_31()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n {\r\n short dataCopy = data;\r\n short data = dataCopy;\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n {\r\n short dataCopy = data;\r\n short data = dataCopy;\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fscanf_malloc_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_malloc_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_malloc_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-648:Incorrect Use of Privileged APIs\nB.CWE-141:Improper Neutralization of Parameter/Argument Delimiters\nC.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nD.CWE-188:Reliance on Data/Memory Layout\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_union_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n union\r\n {\r\n struct\r\n {\r\n char charFirst, charSecond, charThird, charFourth;\r\n } structChars;\r\n long longNumber;\r\n } unionStructLong;\r\n unionStructLong.longNumber = 0x10203040;\r\n \r\n unionStructLong.structChars.charFourth |= 0x80; \r\n printIntLine(unionStructLong.longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_union_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_union_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_union_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-188:Reliance on Data/Memory Layout|C.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.CWE-165:Improper Neutralization of Multiple Internal Special Elements\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-1318:Missing Support for Security Features in On-chip Fabrics or Buses\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_34\r\n{\r\n\r\ntypedef union\r\n{\r\n void * unionFirst;\r\n void * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n unionType myUnion;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n myUnion.unionFirst = data;\r\n {\r\n void * data = myUnion.unionSecond;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n unionType myUnion;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n myUnion.unionFirst = data;\r\n {\r\n void * data = myUnion.unionSecond;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-588:Attempt to Access Child of a Non-structure Pointer|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-357:Insufficient UI Warning of Dangerous Operations\nB.CWE-416:Use After Free\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-684:Incorrect Provision of Specified Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_free_wchar_t_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n printWLine(data);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n printWLine(data);\r\n \r\n}\r\n\r\n\r\nvoid nB2GSource(wchar_t * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_free_wchar_t_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-140:Improper Neutralization of Delimiters\nB.No Vulnerabilities\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-1280:Access Control Check Implemented After Asset is Accessed\nE.CWE-588:Attempt to Access Child of a Non-structure Pointer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_06()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = &dataMBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\nvoid My_struct_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-588:Attempt to Access Child of a Non-structure Pointer|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-773:Missing Reference to Active File Descriptor or Handle\nB.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\nC.CWE-771:Missing Reference to Active Allocated Resource\nD.No Vulnerabilities\nE.CWE-103:Struts: Incomplete validate() Method Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_fopen_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, FILE *> dataMap);\r\n\r\nvoid m()\r\n{\r\n FILE * data;\r\n map<int, FILE *> dataMap;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(map<int, FILE *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n map<int, FILE *> dataMap;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fopen_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-773:Missing Reference to Active File Descriptor or Handle|C.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-114:Process Control\nB.CWE-685:Function Call With Incorrect Number of Arguments\nC.No Vulnerabilities\nD.CWE-185:Incorrect Regular Expression\nE.CWE-73:External Control of File Name or Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_connect_socket_16()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n \r\n wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n break;\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_connect_socket_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_connect_socket_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_connect_socket_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-114:Process Control|E.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-194:Unexpected Sign Extension\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\nE.CWE-253:Incorrect Check of Function Return Value\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <limits.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint ismay_maurus = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid englewood_cosma(char **heavyback_clasped);\r\nshort get_int_value(char *ss_tainted_buff)\r\n{\r\n \r\n short to_short = 0;\r\n int tainted_int = 0;\r\n tainted_int = atoi(ss_tainted_buff);\r\n if (tainted_int != 0) {\r\n if (tainted_int > 30000)\r\n tainted_int = 30000;\r\n if (tainted_int < -30000)\r\n tainted_int = -30000;\r\n to_short = ((short )tainted_int);\r\n }\r\n return to_short;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n void (*plumming_singeress)(char **) = englewood_cosma;\r\n char **grayling_pulas = 0;\r\n long katrina_dysmenorrhagia[10];\r\n char **mikrkra_hoovey[10] = {0};\r\n char *parorexia_daws[6] = {0};\r\n int blandation_afric = 6;\r\n char *outfooling_scatty;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&ismay_maurus,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&outfooling_scatty,\"9718\",blandation_afric);\r\n if (outfooling_scatty != 0) {;\r\n parorexia_daws[3] = outfooling_scatty;\r\n mikrkra_hoovey[5] = parorexia_daws;\r\n katrina_dysmenorrhagia[1] = 5;\r\n grayling_pulas = *(mikrkra_hoovey + katrina_dysmenorrhagia[1]);\r\n plumming_singeress(grayling_pulas);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid englewood_cosma(char **heavyback_clasped)\r\n{\r\n unsigned int to_unsign = 0;\r\n char *buff = 0;\r\n FILE *file = 0;\r\n int counter = 0;\r\n int bytes_read = 0;\r\n char *weirdward_rapturously = 0;\r\n ++global_variable;;\r\n weirdward_rapturously = ((char *)heavyback_clasped[3]);\r\n \r\n buff = ((char *)(malloc(30000 * sizeof(char ))));\r\n if (buff == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(buff, 0, 30000);\r\n \r\n\r\n to_unsign = get_int_value(weirdward_rapturously);\r\n \r\n \r\n \r\n file = fopen(\"/opt//workspace/testData/myfile.txt\",\"r\");\r\n if (file != 0) {\r\n \r\n while (((unsigned int )counter) < to_unsign) {\r\n \r\n bytes_read = fread(&buff[counter],\r\n sizeof(char), 1000, file);\r\n if (bytes_read == 0) {\r\n break;\r\n }\r\n counter += bytes_read;\r\n }\r\n \r\n fclose(file);\r\n buff[to_unsign] = '\\0';\r\n printf(\"buff is %d long, and has contents: %s \\n\",strlen(buff), buff);\r\n } else {\r\n printf(\"Cannot open file %s\\n\", \"/opt//workspace/testData/myfile.txt\");\r\n }\r\n if (buff != 0) {\r\n free(buff);\r\n }\r\n \r\n;\r\n if (heavyback_clasped[3] != 0) \r\n free(((char *)heavyback_clasped[3]));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-194:Unexpected Sign Extension|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-184:Incomplete List of Disallowed Inputs\nB.CWE-510:Trapdoor\nC.No Vulnerabilities\nD.CWE-506:Embedded Malicious Code\nE.CWE-1419:Incorrect Initialization of Resource\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <ws2tcpip.h>\r\n#else\r\n#include <netdb.h>\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_hostname_based_logic_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char hostname[NI_MAXHOST];\r\n char servInfo[NI_MAXSERV];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n if (getnameinfo((struct sockaddr *)&acceptService,\r\n sizeof(struct sockaddr),\r\n hostname,\r\n NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"admin.google.com\", hostname) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_hostname_based_logic_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_hostname_based_logic_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_hostname_based_logic_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|D.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-195:Signed to Unsigned Conversion Error\nC.No Vulnerabilities\nD.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nE.CWE-707:Improper Neutralization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_malloc_use_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int * pointer = (int *)malloc(sizeof(int));\r\n if (pointer == NULL) {exit(-1);}\r\n int data = *pointer; \r\n free(pointer);\r\n printIntLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int data;\r\n int * pointer = (int *)malloc(sizeof(int));\r\n if (pointer == NULL) {exit(-1);}\r\n data = 5;\r\n *pointer = data; \r\n {\r\n int data = *pointer;\r\n printIntLine(data);\r\n }\r\n free(pointer);\r\n }\r\n}\r\n\r\nvoid My_int_malloc_use_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_malloc_use_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_malloc_use_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nB.CWE-134:Use of Externally-Controlled Format String\nC.CWE-309:Use of Password System for Primary Authentication\nD.CWE-668:Exposure of Resource to Wrong Sphere\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_wchar_t_environment_vfprintf_83\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_wchar_t_environment_vfprintf_83\r\n{\r\npublic:\r\n My_wchar_t_environment_vfprintf_83(wchar_t * dataCopy);\r\n ~My_wchar_t_environment_vfprintf_83();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_wchar_t_environment_vfprintf_83G2B\r\n{\r\npublic:\r\n My_wchar_t_environment_vfprintf_83G2B(wchar_t * dataCopy);\r\n ~My_wchar_t_environment_vfprintf_83G2B();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\nclass My_wchar_t_environment_vfprintf_83B2G\r\n{\r\npublic:\r\n My_wchar_t_environment_vfprintf_83B2G(wchar_t * dataCopy);\r\n ~My_wchar_t_environment_vfprintf_83B2G();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-134:Use of Externally-Controlled Format String|D.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nB.CWE-145:Improper Neutralization of Section Delimiters\nC.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_stat_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n struct STAT statBuffer;\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (STAT(filename, &statBuffer) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_stat_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_stat_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_stat_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-628:Function Call with Incorrectly Specified Arguments\nC.No Vulnerabilities\nD.CWE-126:Buffer Over-read\nE.CWE-1090:Method Containing Access of a Member Element from Another Class\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE129_fgets_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.CWE-773:Missing Reference to Active File Descriptor or Handle\nC.CWE-391:Unchecked Error Condition\nD.No Vulnerabilities\nE.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32CreateFile_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<HANDLE> dataList);\r\n\r\nvoid m()\r\n{\r\n HANDLE data;\r\n list<HANDLE> dataList;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(list<HANDLE> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n HANDLE data;\r\n list<HANDLE> dataList;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32CreateFile_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nB.No Vulnerabilities\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-36:Absolute Path Traversal\nE.CWE-1116:Inaccurate Comments\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FOPEN fopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nnamespace My_char_file_fopen_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_fopen_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-36:Absolute Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-152:Improper Neutralization of Macro Symbols\nB.No Vulnerabilities\nC.CWE-208:Observable Timing Discrepancy\nD.CWE-319:Cleartext Transmission of Sensitive Information\nE.CWE-131:Incorrect Calculation of Buffer Size\n", "input": "ProcRenderCreateCursor (ClientPtr client)\r\r\n{\r\r\n REQUEST(xRenderCreateCursorReq);\r\r\n PicturePtr\t pSrc;\r\r\n ScreenPtr\t pScreen;\r\r\n unsigned short width, height;\r\r\n CARD32\t *argbbits, *argb;\r\r\n unsigned char *srcbits, *srcline;\r\r\n unsigned char *mskbits, *mskline;\r\r\n int\t\t stride;\r\r\n int\t\t x, y;\r\r\n int\t\t nbytes_mono;\r\r\n CursorMetricRec cm;\r\r\n CursorPtr\t pCursor;\r\r\n CARD32\t twocolor[3];\r\r\n int\t\t rc, ncolor;\r\r\n\r\r\n REQUEST_SIZE_MATCH (xRenderCreateCursorReq);\r\r\n LEGAL_NEW_RESOURCE(stuff->cid, client);\r\r\n \r\r\n VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);\r\r\n if (!pSrc->pDrawable)\r\r\n return MDrawable;\r\r\n pScreen = pSrc->pDrawable->pScreen;\r\r\n width = pSrc->pDrawable->width;\r\r\n height = pSrc->pDrawable->height;\r\r\n if (height && width > UINT32_MAX/(height*sizeof(CARD32)))\r\r\n\treturn MAlloc;\r\r\n if ( stuff->x > width \r\r\n || stuff->y > height )\r\r\n\treturn MMatch;\r\r\n argbbits = malloc(width * height * sizeof (CARD32));\r\r\n if (!argbbits)\r\r\n\treturn MAlloc;\r\r\n \r\r\n stride = BitmapBytePad(width);\r\r\n nbytes_mono = stride*height;\r\r\n srcbits = calloc(1, nbytes_mono);\r\r\n if (!srcbits)\r\r\n {\r\r\n\tfree(argbbits);\r\r\n\treturn MAlloc;\r\r\n }\r\r\n mskbits = calloc(1, nbytes_mono);\r\r\n if (!mskbits)\r\r\n {\r\r\n\tfree(argbbits);\r\r\n\tfree(srcbits);\r\r\n\treturn MAlloc;\r\r\n }\r\r\n\r\r\n if (pSrc->format == PICT_a8r8g8b8)\r\r\n {\r\r\n\t(*pScreen->GetImage) (pSrc->pDrawable,\r\r\n\t\t\t 0, 0, width, height, ZPixmap,\r\r\n\t\t\t 0xffffffff, (pointer) argbbits);\r\r\n }\r\r\n else\r\r\n {\r\r\n\tPixmapPtr\tpPixmap;\r\r\n\tPicturePtr\tpPicture;\r\r\n\tPictFormatPtr\tpFormat;\r\r\n\tint\t\terror;\r\r\n\r\r\n\tpFormat = PictureMatchFormat (pScreen, 32, PICT_a8r8g8b8);\r\r\n\tif (!pFormat)\r\r\n\t{\r\r\n\t free(argbbits);\r\r\n\t free(srcbits);\r\r\n\t free(mskbits);\r\r\n\t return MImplementation;\r\r\n\t}\r\r\n\tpPixmap = (*pScreen->CreatePixmap) (pScreen, width, height, 32,\r\r\n\t\t\t\t\t CREATE_PIXMAP_USAGE_SCRATCH);\r\r\n\tif (!pPixmap)\r\r\n\t{\r\r\n\t free(argbbits);\r\r\n\t free(srcbits);\r\r\n\t free(mskbits);\r\r\n\t return MAlloc;\r\r\n\t}\r\r\n\tpPicture = CreatePicture (0, &pPixmap->drawable, pFormat, 0, 0, \r\r\n\t\t\t\t client, &error);\r\r\n\tif (!pPicture)\r\r\n\t{\r\r\n\t free(argbbits);\r\r\n\t free(srcbits);\r\r\n\t free(mskbits);\r\r\n\t return error;\r\r\n\t}\r\r\n\t(*pScreen->DestroyPixmap) (pPixmap);\r\r\n\tCompositePicture (PictOpSrc,\r\r\n\t\t\t pSrc, 0, pPicture,\r\r\n\t\t\t 0, 0, 0, 0, 0, 0, width, height);\r\r\n\t(*pScreen->GetImage) (pPicture->pDrawable,\r\r\n\t\t\t 0, 0, width, height, ZPixmap,\r\r\n\t\t\t 0xffffffff, (pointer) argbbits);\r\r\n\tFreePicture (pPicture, 0);\r\r\n }\r\r\n /*\r\r\n * Check whether the cursor can be directly supported by \r\r\n * the core cursor code\r\r\n */\r\r\n ncolor = 0;\r\r\n argb = argbbits;\r\r\n for (y = 0; ncolor <= 2 && y < height; y++)\r\r\n {\r\r\n\tfor (x = 0; ncolor <= 2 && x < width; x++)\r\r\n\t{\r\r\n\t CARD32 p = *argb++;\r\r\n\t CARD32 a = (p >> 24);\r\r\n\r\r\n\t if (a == 0)\t /* transparent */\r\r\n\t\tcontinue;\r\r\n\t if (a == 0xff) /* opaque */\r\r\n\t {\r\r\n\t\tint n;\r\r\n\t\tfor (n = 0; n < ncolor; n++)\r\r\n\t\t if (p == twocolor[n])\r\r\n\t\t\tbreak;\r\r\n\t\tif (n == ncolor)\r\r\n\t\t twocolor[ncolor++] = p;\r\r\n\t }\r\r\n\t else\r\r\n\t\tncolor = 3;\r\r\n\t}\r\r\n }\r\r\n \r\r\n /*\r\r\n * Convert argb image to two plane cursor\r\r\n */\r\r\n srcline = srcbits;\r\r\n mskline = mskbits;\r\r\n argb = argbbits;\r\r\n for (y = 0; y < height; y++)\r\r\n {\r\r\n\tfor (x = 0; x < width; x++)\r\r\n\t{\r\r\n\t CARD32 p = *argb++;\r\r\n\r\r\n\t if (ncolor <= 2)\r\r\n\t {\r\r\n\t\tCARD32\ta = ((p >> 24));\r\r\n\r\r\n\t\tRenderSetBit (mskline, x, a != 0);\r\r\n\t\tRenderSetBit (srcline, x, a != 0 && p == twocolor[0]);\r\r\n\t }\r\r\n\t else\r\r\n\t {\r\r\n\t\tCARD32\ta = ((p >> 24) * DITHER_SIZE + 127) / 255;\r\r\n\t\tCARD32\ti = ((CvtR8G8B8toY15(p) >> 7) * DITHER_SIZE + 127) / 255;\r\r\n\t\tCARD32\td = orderedDither[y&(DITHER_DIM-1)][x&(DITHER_DIM-1)];\r\r\n\t\t/* Set mask from dithered alpha value */\r\r\n\t\tRenderSetBit(mskline, x, a > d);\r\r\n\t\t/* Set src from dithered intensity value */\r\r\n\t\tRenderSetBit(srcline, x, a > d && i <= d);\r\r\n\t }\r\r\n\t}\r\r\n\tsrcline += stride;\r\r\n\tmskline += stride;\r\r\n }\r\r\n /*\r\r\n * Dither to white and black if the cursor has more than two colors\r\r\n */\r\r\n if (ncolor > 2)\r\r\n {\r\r\n\ttwocolor[0] = 0xff000000;\r\r\n\ttwocolor[1] = 0xffffffff;\r\r\n }\r\r\n else\r\r\n {\r\r\n\tfree(argbbits);\r\r\n\targbbits = 0;\r\r\n }\r\r\n \r\r\n#define GetByte(p,s)\t(((p) >> (s)) & 0xff)\r\r\n#define GetColor(p,s)\t(GetByte(p,s) | (GetByte(p,s) << 8))\r\r\n \r\r\n cm.width = width;\r\r\n cm.height = height;\r\r\n cm.xhot = stuff->x;\r\r\n cm.yhot = stuff->y;\r\r\n rc = AllocARGBCursor(srcbits, mskbits, argbbits, &cm,\r\r\n\t\t\t GetColor(twocolor[0], 16),\r\r\n\t\t\t GetColor(twocolor[0], 8),\r\r\n\t\t\t GetColor(twocolor[0], 0),\r\r\n\t\t\t GetColor(twocolor[1], 16),\r\r\n\t\t\t GetColor(twocolor[1], 8),\r\r\n\t\t\t GetColor(twocolor[1], 0),\r\r\n\t\t\t &pCursor, client, stuff->cid);\r\r\n if (rc != Success)\r\r\n\treturn rc;\r\r\n if (!AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor))\r\r\n\treturn MAlloc;\r\r\n\r\r\n return Success;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.No Vulnerabilities|B.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-675:Multiple Operations on Resource in Single-Operation Context\nB.CWE-913:Improper Control of Dynamically-Managed Code Resources\nC.CWE-252:Unchecked Return Value\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_calloc_05()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));\r\n if(staticTrue)\r\n {\r\n \r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n data = NULL; \r\n \r\n data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));\r\n if(staticTrue)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0].intOne = 1;\r\n data[0].intTwo = 1;\r\n printStructLine(&data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_calloc_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_calloc_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_calloc_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-690:Unchecked Return Value to NULL Pointer Dereference|C.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-431:Missing Handler\nB.CWE-354:Improper Validation of Integrity Check Value\nC.CWE-131:Incorrect Calculation of Buffer Size\nD.No Vulnerabilities\nE.CWE-467:Use of sizeof() on a Pointer Type\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int * mInt = NULL;\r\n \r\n mInt = (int *)malloc(sizeof(mInt));\r\n if (mInt == NULL) {exit(-1);}\r\n *mInt = 5;\r\n printIntLine(*mInt);\r\n free(mInt);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int * nInt = NULL;\r\n \r\n nInt = (int *)malloc(sizeof(*nInt));\r\n if (nInt == NULL) {exit(-1);}\r\n *nInt = 6;\r\n printIntLine(*nInt);\r\n free(nInt);\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-467:Use of sizeof() on a Pointer Type|C.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-436:Interpretation Conflict\nB.CWE-392:Missing Report of Error Condition\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_freopen_w32CloseHandle_14()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n if(globalFive==5)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n if(globalFive==5)\r\n {\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_freopen_w32CloseHandle_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_w32CloseHandle_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_w32CloseHandle_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-404:Improper Resource Shutdown or Release|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-474:Use of Function with Inconsistent Implementations\nB.CWE-284:Improper Access Control\nC.CWE-1357:Reliance on Insufficiently Trustworthy Component\nD.No Vulnerabilities\nE.CWE-322:Key Exchange without Entity Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateFile_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HANDLE hFile;\r\n char * fileName = \"C:\\\\temp\\\\file.txt\";\r\n \r\n hFile = CreateFileA(\r\n fileName,\r\n FILE_ALL_ACCESS,\r\n FILE_SHARE_READ,\r\n NULL,\r\n CREATE_NEW,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"File could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"File created successfully\");\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n HANDLE hFile;\r\n char * fileName = \"C:\\\\temp\\\\file.txt\";\r\n \r\n hFile = CreateFileA(\r\n fileName,\r\n GENERIC_READ,\r\n FILE_SHARE_READ,\r\n NULL,\r\n CREATE_NEW,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"File could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"File created successfully\");\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n HANDLE hFile;\r\n char * fileName = \"C:\\\\temp\\\\file.txt\";\r\n \r\n hFile = CreateFileA(\r\n fileName,\r\n GENERIC_READ,\r\n FILE_SHARE_READ,\r\n NULL,\r\n CREATE_NEW,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if (hFile == INVALID_HANDLE_VALUE)\r\n {\r\n printLine(\"File could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"File created successfully\");\r\n CloseHandle(hFile);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateFile_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateFile_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateFile_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-284:Improper Access Control|C.CWE-1357:Reliance on Insufficiently Trustworthy Component", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-197:Numeric Truncation Error\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-1304:Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_connect_socket_to_char_63bSink(int * dataPtr);\r\n\r\nvoid My_int_connect_socket_to_char_63()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_int_connect_socket_to_char_63bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_connect_socket_to_char_63bG2BSink(int * data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = CHAR_MAX-5;\r\n My_int_connect_socket_to_char_63bG2BSink(&data);\r\n}\r\n\r\nvoid My_int_connect_socket_to_char_63()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_to_char_63();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_to_char_63();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-197:Numeric Truncation Error|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-1053:Missing Documentation for Design\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.CWE-838:Inappropriate Encoding for Output Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_01()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n}\r\n\r\nvoid My_open_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling\nB.CWE-1065:Runtime Resource Management Control Element in a Component Built to Run on Application Servers\nC.No Vulnerabilities\nD.CWE-770:Allocation of Resources Without Limits or Throttling\nE.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint reexpresses_semiharden = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid tantra_warfaring(char **agacante_paymastership);\r\nFILE *open_file(char *filename_param)\r\n{\r\n FILE *f;\r\n \r\n \r\n \r\n\r\n\r\n f = fopen(filename_param,\"w\");\r\n \r\n \r\n if (!f)\r\n return 0;\r\n else\r\n return f;\r\n fclose(f);\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n void (*epanaphora_attrib)(char **) = tantra_warfaring;\r\n char *postliminious_peridinium[54] = {0};\r\n char *speedometer_unordered;;\r\n if (__sync_bool_compare_and_swap(&reexpresses_semiharden,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n speedometer_unordered = getenv(\"INSTANTIATE_CONSISTING\");\r\n if (speedometer_unordered != 0) {;\r\n postliminious_peridinium[47] = speedometer_unordered;\r\n epanaphora_attrib(postliminious_peridinium);\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid tantra_warfaring(char **agacante_paymastership)\r\n{\r\n char * filename = 0;\r\n int filename_len = 0;\r\n unsigned int num_files;\r\n FILE **filearray;\r\n int i;\r\n char *gigahertzes_galuth = 0;\r\n ++global_variable;;\r\n gigahertzes_galuth = ((char *)agacante_paymastership[47]);\r\n \r\n if (strlen(gigahertzes_galuth) > 0 &&\r\n gigahertzes_galuth[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n printf(\"Getting input value\\n\");\r\n num_files = strtoul(gigahertzes_galuth,0,16);\r\n if (num_files > 0xffff)\r\n num_files = 0;\r\n filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\r\n filename_len = strlen(\"/opt//workspace/testData/temp\") + 10;\r\n filename = (char*) malloc(filename_len * sizeof(char));\r\n if (filearray != 0) {\r\n for (i = 0; i < num_files; ++i)\r\n filearray[i] = 0;\r\n printf(\"Creating files\\n\");\r\n for (i = 0; i < num_files; ++i) {\r\n snprintf(filename,filename_len,\"%s_%08x\", \"/opt//workspace/testData/temp\", i);\r\n filearray[i] = open_file(filename);\r\n if (filearray[i] == 0)\r\n break;\r\n }\r\n if (i < num_files)\r\n printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\r\n for (i = 0; i < num_files; ++i)\r\n if (filearray[i] != 0)\r\n fclose(filearray[i]);\r\n free(filearray);\r\n free(filename);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling|D.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "774"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-308:Use of Single-factor Authentication\nB.No Vulnerabilities\nC.CWE-478:Missing Default Case in Multiple Condition Expression\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-397:Declaration of Throws for Generic Exception\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\nusing namespace std; \r\n\r\nnamespace My_throw_exception_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n throw exception();\r\n }\r\n else\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n else\r\n {\r\n \r\n throw range_error(\"Test\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_throw_exception_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-397:Declaration of Throws for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "397"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-91:XML Injection (aka Blind XPath Injection)\nB.CWE-590:Free of Memory not on the Heap\nC.CWE-762:Mismatched Memory Management Routines\nD.No Vulnerabilities\nE.CWE-1280:Access Control Check Implemented After Asset is Accessed\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef union\r\n{\r\n long * unionFirst;\r\n long * unionSecond;\r\n} My_free_long_alloca_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_free_long_alloca_34()\r\n{\r\n long * data;\r\n My_free_long_alloca_34_unionType myUnion;\r\n data = NULL; \r\n {\r\n \r\n long * dataBuffer = (long *)ALLOCA(100*sizeof(long));\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5L;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n long * data = myUnion.unionSecond;\r\n printLongLine(data[0]);\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n long * data;\r\n My_free_long_alloca_34_unionType myUnion;\r\n data = NULL; \r\n {\r\n \r\n long * dataBuffer = (long *)malloc(100*sizeof(long));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n {\r\n size_t i;\r\n for (i = 0; i < 100; i++)\r\n {\r\n dataBuffer[i] = 5L;\r\n }\r\n }\r\n data = dataBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n long * data = myUnion.unionSecond;\r\n printLongLine(data[0]);\r\n \r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_free_long_alloca_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_free_long_alloca_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_free_long_alloca_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-590:Free of Memory not on the Heap|C.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-127:Buffer Under-read\nC.CWE-1064:Invokable Control Element with Signature Containing an Excessive Number of Parameters\nD.CWE-13:ASP.NET Misconfiguration: Password in Configuration File\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_malloc_wchar_t_memcpy_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<wchar_t *> dataList);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<wchar_t *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n data = NULL;\r\n {\r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_wchar_t_memcpy_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-196:Unsigned to Signed Conversion Error\nB.No Vulnerabilities\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-300:Channel Accessible by Non-Endpoint\nE.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n unsigned intUnsigned;\r\n int intSigned;\r\n intUnsigned = rand();\r\n if (rand() % 2 == 0)\r\n {\r\n intUnsigned = UINT_MAX - intUnsigned;\r\n }\r\n \r\n intSigned = intUnsigned;\r\n printIntLine(intSigned);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n unsigned intUnsigned;\r\n int intSigned;\r\n intUnsigned = rand();\r\n if (rand() % 2 == 0)\r\n {\r\n intUnsigned = UINT_MAX - intUnsigned;\r\n }\r\n \r\n if (intUnsigned > INT_MAX)\r\n {\r\n exit(1);\r\n }\r\n intSigned = intUnsigned;\r\n printIntLine(intSigned);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-196:Unsigned to Signed Conversion Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "196"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nB.CWE-61:UNIX Symbolic Link (Symlink) Following\nC.No Vulnerabilities\nD.CWE-693:Protection Mechanism Failure\nE.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_DES_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_DES_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_DES_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_DES_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|D.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-680:Integer Overflow to Buffer Overflow\nD.CWE-372:Incomplete Internal State Distinction\nE.CWE-262:Not Using Password Aging\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\nnamespace My_new_listen_socket_05\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticTrue)\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_listen_socket_05; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-680:Integer Overflow to Buffer Overflow|B.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1037:Processor Optimization Removal or Modification of Security-critical Code\nB.No Vulnerabilities\nC.CWE-642:External Control of Critical State Data\nD.CWE-480:Use of Incorrect Operator\nE.CWE-15:External Control of System or Configuration Setting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_11()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-15:External Control of System or Configuration Setting|C.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-159:Improper Handling of Invalid Use of Special Elements\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-770:Allocation of Resources Without Limits or Throttling\nD.No Vulnerabilities\nE.CWE-1395:Dependency on Vulnerable Third-Party Component\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint unprosperously_fenerate = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n int stack_size = 0;\r\n char *pevely_interess = 0;\r\n int stemmatiform_jawed;\r\n char **wellton_dillon = 0;\r\n char **subsequentness_sugent = 0;\r\n int wilfully_attribution = 13;\r\n char *connellsville_alcarraza;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&unprosperously_fenerate,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&connellsville_alcarraza,\"4163\",wilfully_attribution);\r\n if (connellsville_alcarraza != 0) {;\r\n stemmatiform_jawed = 1;\r\n wellton_dillon = &connellsville_alcarraza;\r\n subsequentness_sugent = ((char **)(((unsigned long )wellton_dillon) * stemmatiform_jawed * stemmatiform_jawed)) + 5;\r\n pevely_interess = ((char *)( *(subsequentness_sugent - 5)));\r\n \r\n \r\n \r\n if (strlen(pevely_interess) > 1 &&\r\n pevely_interess[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n stack_size = strtoul(pevely_interess,0,0);\r\n printf(\"Allocating stack array\\n\");\r\n \r\n \r\n \r\n char stack_string[stack_size];\r\n memset(stack_string,'x',stack_size - 1);\r\n \r\n }\r\n \r\n \r\n;\r\n if ( *(subsequentness_sugent - 5) != 0) \r\n free(((char *)( *(subsequentness_sugent - 5))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|C.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1262:Improper Access Control for Register Interface\nC.CWE-627:Dynamic Variable Evaluation\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-761:Free of Pointer not at Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\nnamespace My_char_listen_socket_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(char * &data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n mSource(data);\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(char * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n nB2GSource(data);\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-761:Free of Pointer not at Start of Buffer|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-475:Undefined Behavior for Input to API\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _My_fopen_w32_close_67_structType\r\n{\r\n FILE * structFirst;\r\n} My_fopen_w32_close_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fopen_w32_close_67bSink(My_fopen_w32_close_67_structType myStruct);\r\n\r\nvoid My_fopen_w32_close_67()\r\n{\r\n FILE * data;\r\n My_fopen_w32_close_67_structType myStruct;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n myStruct.structFirst = data;\r\n My_fopen_w32_close_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fopen_w32_close_67bB2GSink(My_fopen_w32_close_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n My_fopen_w32_close_67_structType myStruct;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n myStruct.structFirst = data;\r\n My_fopen_w32_close_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_fopen_w32_close_67()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32_close_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32_close_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-165:Improper Neutralization of Multiple Internal Special Elements\nC.CWE-256:Plaintext Storage of a Password\nD.CWE-522:Insufficiently Protected Credentials\nE.CWE-81:Improper Neutralization of Script in an Error Message Web Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\n\r\nint My_w32_char_22Global = 0;\r\n\r\nvoid My_w32_char_22Sink(char * data);\r\n\r\nvoid My_w32_char_22()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_22Global = 1; \r\n My_w32_char_22Sink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nint My_w32_char_22B2G1Global = 0;\r\nint My_w32_char_22B2G2Global = 0;\r\nint My_w32_char_22G2BGlobal = 0;\r\n\r\n\r\nvoid My_w32_char_22B2G1Sink(char * data);\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_22B2G1Global = 0; \r\n My_w32_char_22B2G1Sink(data);\r\n}\r\n\r\n\r\nvoid My_w32_char_22B2G2Sink(char * data);\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n }\r\n My_w32_char_22B2G2Global = 1; \r\n My_w32_char_22B2G2Sink(data);\r\n}\r\n\r\n\r\nvoid My_w32_char_22G2BSink(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(data, 100, pFile) == NULL)\r\n {\r\n data[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = '\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n My_w32_char_22G2BGlobal = 1; \r\n My_w32_char_22G2BSink(data);\r\n}\r\n\r\nvoid My_w32_char_22()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_22();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_22();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|D.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-138:Improper Neutralization of Special Elements\nB.CWE-464:Addition of Data Structure Sentinel\nC.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nD.CWE-262:Not Using Password Aging\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_basic_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char> dataMap);\r\n\r\nvoid m()\r\n{\r\n char data;\r\n map<int, char> dataMap;\r\n data = ' ';\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, char> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n map<int, char> dataMap;\r\n data = ' ';\r\n \r\n data = 'a';\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_basic_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-464:Addition of Data Structure Sentinel|A.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-507:Trojan Horse\nC.CWE-645:Overly Restrictive Account Lockout Mechanism\nD.CWE-788:Access of Memory Location After End of Buffer\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_loop_09()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = (wchar_t *)malloc(50*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 50-1); \r\n data[50-1] = L'\\0'; \r\n }\r\n {\r\n size_t i, destLen;\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n destLen = wcslen(dest);\r\n \r\n for (i = 0; i < destLen; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n }\r\n {\r\n size_t i, destLen;\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n destLen = wcslen(dest);\r\n \r\n for (i = 0; i < destLen; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1); \r\n data[100-1] = L'\\0'; \r\n }\r\n {\r\n size_t i, destLen;\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1);\r\n dest[100-1] = L'\\0'; \r\n destLen = wcslen(dest);\r\n \r\n for (i = 0; i < destLen; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_loop_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_loop_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_loop_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|D.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-1077:Floating Point Comparison with Incorrect Operator\nC.No Vulnerabilities\nD.CWE-588:Attempt to Access Child of a Non-structure Pointer\nE.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_03()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(5==5)\r\n {\r\n \r\n data = &dataMBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n if(5==5)\r\n {\r\n \r\n data = &dataNBuffer;\r\n }\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\nvoid My_struct_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-588:Attempt to Access Child of a Non-structure Pointer|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-448:Obsolete Feature in UI\nB.CWE-787:Out-of-bounds Write\nC.CWE-123:Write-what-where Condition\nD.No Vulnerabilities\nE.CWE-311:Missing Encryption of Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\ntypedef union\r\n{\r\n mStruct unionFirst;\r\n mStruct unionSecond;\r\n} My_fgets_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_34()\r\n{\r\n mStruct data;\r\n My_fgets_34_unionType myUnion;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n mStruct data = myUnion.unionSecond;\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n My_fgets_34_unionType myUnion;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n myUnion.unionFirst = data;\r\n {\r\n mStruct data = myUnion.unionSecond;\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n }\r\n}\r\n\r\nvoid My_fgets_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-123:Write-what-where Condition|B.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-176:Improper Handling of Unicode Encoding\nB.No Vulnerabilities\nC.CWE-172:Encoding Error\nD.CWE-839:Numeric Range Comparison Without Minimum Check\nE.CWE-268:Privilege Chaining\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\nnamespace My_w32_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n}\r\n\r\n\r\nvoid nB2GSource(wchar_t * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n nB2GSource(data);\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-176:Improper Handling of Unicode Encoding|C.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-325:Missing Cryptographic Step\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-277:Insecure Inherited Permissions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptEncrypt_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptEncrypt_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptEncrypt_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptEncrypt_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-325:Missing Cryptographic Step|C.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.No Vulnerabilities\nC.CWE-114:Process Control\nD.CWE-838:Inappropriate Encoding for Output Context\nE.CWE-603:Use of Client-Side Authentication\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_console_09()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_console_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_console_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_console_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-114:Process Control|A.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-571:Expression is Always True\nC.CWE-126:Buffer Over-read\nD.No Vulnerabilities\nE.CWE-198:Use of Incorrect Byte Ordering\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef struct _My_char_alloca_memcpy_67_structType\r\n{\r\n char * structFirst;\r\n} My_char_alloca_memcpy_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_alloca_memcpy_67bSink(My_char_alloca_memcpy_67_structType myStruct);\r\n\r\nvoid My_char_alloca_memcpy_67()\r\n{\r\n char * data;\r\n My_char_alloca_memcpy_67_structType myStruct;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataMBuffer;\r\n myStruct.structFirst = data;\r\n My_char_alloca_memcpy_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_alloca_memcpy_67bG2BSink(My_char_alloca_memcpy_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n My_char_alloca_memcpy_67_structType myStruct;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataNBuffer;\r\n myStruct.structFirst = data;\r\n My_char_alloca_memcpy_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_char_alloca_memcpy_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_alloca_memcpy_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_alloca_memcpy_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.CWE-836:Use of Password Hash Instead of Password for Authentication\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-1077:Floating Point Comparison with Incorrect Operator\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_ncat_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<wchar_t *> dataList);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(list<wchar_t *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n list<wchar_t *> dataList;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = L'\\0'; \r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_ncat_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-393:Return of Wrong Status Code\nB.No Vulnerabilities\nC.CWE-454:External Initialization of Trusted Variables or Data Stores\nD.CWE-682:Incorrect Calculation\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_connect_socket_modulo_54bSink(int data);\r\n\r\nvoid My_int_connect_socket_modulo_54()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_int_connect_socket_modulo_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_connect_socket_modulo_54bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n My_int_connect_socket_modulo_54bG2BSink(data);\r\n}\r\n\r\n\r\nvoid My_int_connect_socket_modulo_54bB2GSink(int data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_int_connect_socket_modulo_54bB2GSink(data);\r\n}\r\n\r\nvoid My_int_connect_socket_modulo_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_modulo_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_modulo_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-654:Reliance on a Single Factor in a Security Decision\nB.CWE-704:Incorrect Type Conversion or Cast\nC.No Vulnerabilities\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_01()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-20:Improper Input Validation\nB.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nC.CWE-586:Explicit Call to Finalize()\nD.No Vulnerabilities\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\nint corojo_physicist = 0;\r\nint global_variable;\r\n\r\nunion amphipyrenin_winthrop \r\n{\r\n char *tenderish_recarbon;\r\n double squatting_holds;\r\n char *letterman_ulnage;\r\n char ectopistes_catamiting;\r\n int kolhoz_vire;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized);\r\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless);\r\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie);\r\nint toupper(int c) {\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n union amphipyrenin_winthrop beaners_thickbrained;\r\n int sieracki_zebec = 1001;\r\n char *methodism_boogers;;\r\n if (__sync_bool_compare_and_swap(&corojo_physicist,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&methodism_boogers,\"5759\",sieracki_zebec);\r\n if (methodism_boogers != 0) {;\r\n beaners_thickbrained . tenderish_recarbon = methodism_boogers;\r\n chaffinch_preventuring(beaners_thickbrained);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized)\r\n{\r\n int surefooted_antonomastic = 7;\r\n ++global_variable;;\r\n cento_waterhorse(surefooted_antonomastic,cognizes_abolitionized);\r\n}\r\n\r\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless)\r\n{\r\n int oc_i = 0;\r\n char stack_buffer_64[64];\r\n char *sulfato_minipanic = 0;\r\n ++global_variable;\r\n cicatrices_pyridazine--;\r\n if (cicatrices_pyridazine > 0) {\r\n dictyopteran_guttering(cicatrices_pyridazine,slappers_fibreless);\r\n return ;\r\n }\r\n sulfato_minipanic = ((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon);\r\n \r\n memset(stack_buffer_64,0,64);\r\n \r\n \r\n \r\n \r\n \r\n strcpy(stack_buffer_64,sulfato_minipanic);\r\n \r\n \r\n \r\n for (; oc_i < 64; ++oc_i) {\r\n stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",stack_buffer_64);\r\n \r\n \r\n \r\n \r\n;\r\n if (((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon != 0) \r\n free(((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon));\r\nclose_printf_context();\r\n}\r\n\r\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie)\r\n{\r\n ++global_variable;\r\n cento_waterhorse(sympossia_criophorus,sardoin_malanie);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')|A.CWE-20:Improper Input Validation", "cwe": "120"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-329:Generation of Predictable IV with CBC Mode\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.No Vulnerabilities\nD.CWE-141:Improper Neutralization of Parameter/Argument Delimiters\nE.CWE-770:Allocation of Resources Without Limits or Throttling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_fscanf_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSource(size_t &data)\r\n{\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n}\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n mSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(size_t &data)\r\n{\r\n \r\n data = 20;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n nG2BSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2GSource(size_t &data)\r\n{\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n nB2GSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_fscanf_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|E.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-416:Use After Free\nB.CWE-1104:Use of Unmaintained Third Party Components\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-1055:Multiple Inheritance from Concrete Classes\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_class_03\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(data[0].intOne);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(5==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(data[0].intOne);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new TwoIntsClass[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n }\r\n if(5==5)\r\n {\r\n \r\n printIntLine(data[0].intOne);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_class_03; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.No Vulnerabilities\nC.CWE-195:Signed to Unsigned Conversion Error\nD.CWE-1323:Improper Management of Sensitive Trace Data\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "aiff_read_comm_chunk (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt)\r\r\n{\tBUF_UNION\tubuf ;\r\r\n\tint subformat, samplerate ;\r\r\n\r\r\n\tubuf.scbuf [0] = 0 ;\r\r\n\r\r\n\t/* The COMM chunk has an int aligned to an odd word boundary. Some\r\r\n\t** procesors are not able to deal with this (ie bus fault) so we have\r\r\n\t** to take special care.\r\r\n\t*/\r\r\n\r\r\n\tpsf_binheader_readf (psf, \"E242b\", &(comm_fmt->numChannels), &(comm_fmt->numSampleFrames),\r\r\n\t\t\t\t&(comm_fmt->sampleSize), &(comm_fmt->sampleRate), SIGNED_SIZEOF (comm_fmt->sampleRate)) ;\r\r\n\r\r\n\tif (comm_fmt->size > 0x10000 && (comm_fmt->size & 0xffff) == 0)\r\r\n\t{\tpsf_log_printf (psf, \" COMM : %d (0x%x) *** should be \", comm_fmt->size, comm_fmt->size) ;\r\r\n\t\tcomm_fmt->size = ENDSWAP_32 (comm_fmt->size) ;\r\r\n\t\tpsf_log_printf (psf, \"%d (0x%x)\\n\", comm_fmt->size, comm_fmt->size) ;\r\r\n\t\t}\r\r\n\telse\r\r\n\t\tpsf_log_printf (psf, \" COMM : %d\\n\", comm_fmt->size) ;\r\r\n\r\r\n\tif (comm_fmt->size == SIZEOF_AIFF_COMM)\r\r\n\t\tcomm_fmt->encoding = NONE_MARKER ;\r\r\n\telse if (comm_fmt->size == SIZEOF_AIFC_COMM_MIN)\r\r\n\t\tpsf_binheader_readf (psf, \"Em\", &(comm_fmt->encoding)) ;\r\r\n\telse if (comm_fmt->size >= SIZEOF_AIFC_COMM)\r\r\n\t{\tuint8_t encoding_len ;\r\r\n\t\tunsigned read_len ;\r\r\n\r\r\n\t\tpsf_binheader_readf (psf, \"Em1\", &(comm_fmt->encoding), &encoding_len) ;\r\r\n\r\r\n\t\tcomm_fmt->size = SF_MIN (sizeof (ubuf.scbuf), make_size_t (comm_fmt->size)) ;\r\r\n\t\tmemset (ubuf.scbuf, 0, comm_fmt->size) ;\r\r\n\t\tread_len = comm_fmt->size - SIZEOF_AIFC_COMM + 1 ;\r\r\n\t\tpsf_binheader_readf (psf, \"b\", ubuf.scbuf, read_len) ;\r\r\n\t\tubuf.scbuf [read_len + 1] = 0 ;\r\r\n\t\t} ;\r\r\n\r\r\n\tsamplerate = tenbytefloat2int (comm_fmt->sampleRate) ;\r\r\n\r\r\n\tpsf_log_printf (psf, \" Sample Rate : %d\\n\", samplerate) ;\r\r\n\tpsf_log_printf (psf, \" Frames : %u%s\\n\", comm_fmt->numSampleFrames, (comm_fmt->numSampleFrames == 0 && psf->filelength > 104) ? \" (Should not be 0)\" : \"\") ;\r\r\n\r\r\n\tif (comm_fmt->numChannels < 1 || comm_fmt->numChannels >= SF_MAX_CHANNELS)\r\r\n\t{\tpsf_log_printf (psf, \" Channels : %d (should be >= 1 and < %d)\\n\", comm_fmt->numChannels, SF_MAX_CHANNELS) ;\r\r\n\t\treturn SFE_CHANNEL_COUNT_M ;\r\r\n\t\t} ;\r\r\n\r\r\n\tpsf_log_printf (psf, \" Channels : %d\\n\", comm_fmt->numChannels) ;\r\r\n\r\r\n\t/* Found some broken 'fl32' files with comm.samplesize == 16. Fix it here. */\r\r\n\tif ((comm_fmt->encoding == fl32_MARKER || comm_fmt->encoding == FL32_MARKER) && comm_fmt->sampleSize != 32)\r\r\n\t{\tpsf_log_printf (psf, \" Sample Size : %d (should be 32)\\n\", comm_fmt->sampleSize) ;\r\r\n\t\tcomm_fmt->sampleSize = 32 ;\r\r\n\t\t}\r\r\n\telse if ((comm_fmt->encoding == fl64_MARKER || comm_fmt->encoding == FL64_MARKER) && comm_fmt->sampleSize != 64)\r\r\n\t{\tpsf_log_printf (psf, \" Sample Size : %d (should be 64)\\n\", comm_fmt->sampleSize) ;\r\r\n\t\tcomm_fmt->sampleSize = 64 ;\r\r\n\t\t}\r\r\n\telse\r\r\n\t\tpsf_log_printf (psf, \" Sample Size : %d\\n\", comm_fmt->sampleSize) ;\r\r\n\r\r\n\tsubformat = s_bitwidth_to_subformat (comm_fmt->sampleSize) ;\r\r\n\r\r\n\tpsf->sf.samplerate = samplerate ;\r\r\n\tpsf->sf.frames = comm_fmt->numSampleFrames ;\r\r\n\tpsf->sf.channels = comm_fmt->numChannels ;\r\r\n\tpsf->bytewidth = BITWIDTH2BYTES (comm_fmt->sampleSize) ;\r\r\n\r\r\n\tpsf->endian = SF_ENDIAN_BIG ;\r\r\n\r\r\n\tswitch (comm_fmt->encoding)\r\r\n\t{\tcase NONE_MARKER :\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | subformat) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase twos_MARKER :\r\r\n\t\tcase in24_MARKER :\r\r\n\t\tcase in32_MARKER :\r\r\n\t\t\t\tpsf->sf.format = (SF_ENDIAN_BIG | SF_FORMAT_AIFF | subformat) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase sowt_MARKER :\r\r\n\t\tcase ni24_MARKER :\r\r\n\t\tcase ni32_MARKER :\r\r\n\t\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\r\r\n\t\t\t\tpsf->sf.format = (SF_ENDIAN_LITTLE | SF_FORMAT_AIFF | subformat) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase fl32_MARKER :\r\r\n\t\tcase FL32_MARKER :\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_FLOAT) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase ulaw_MARKER :\r\r\n\t\tcase ULAW_MARKER :\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_ULAW) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase alaw_MARKER :\r\r\n\t\tcase ALAW_MARKER :\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_ALAW) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase fl64_MARKER :\r\r\n\t\tcase FL64_MARKER :\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_DOUBLE) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase raw_MARKER :\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_PCM_U8) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase DWVW_MARKER :\r\r\n\t\t\t\tpsf->sf.format = SF_FORMAT_AIFF ;\r\r\n\t\t\t\tswitch (comm_fmt->sampleSize)\r\r\n\t\t\t\t{\tcase 12 :\r\r\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_12 ;\r\r\n\t\t\t\t\t\tbreak ;\r\r\n\t\t\t\t\tcase 16 :\r\r\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_16 ;\r\r\n\t\t\t\t\t\tbreak ;\r\r\n\t\t\t\t\tcase 24 :\r\r\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_24 ;\r\r\n\t\t\t\t\t\tbreak ;\r\r\n\r\r\n\t\t\t\t\tdefault :\r\r\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_N ;\r\r\n\t\t\t\t\t\tbreak ;\r\r\n\t\t\t\t\t} ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tcase GSM_MARKER :\r\r\n\t\t\t\tpsf->sf.format = SF_FORMAT_AIFF ;\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_GSM610) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\r\r\n\t\tcase ima4_MARKER :\r\r\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\r\r\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_IMA_ADPCM) ;\r\r\n\t\t\t\tbreak ;\r\r\n\r\r\n\t\tdefault :\r\r\n\t\t\tpsf_log_printf (psf, \"AIFC : Unimplemented format : %M\\n\", comm_fmt->encoding) ;\r\r\n\t\t\treturn SFE_UNIMPLEMENTED ;\r\r\n\t\t} ;\r\r\n\r\r\n\tif (! ubuf.scbuf [0])\r\r\n\t\tpsf_log_printf (psf, \" Encoding : %M\\n\", comm_fmt->encoding) ;\r\r\n\telse\r\r\n\t\tpsf_log_printf (psf, \" Encoding : %M => %s\\n\", comm_fmt->encoding, ubuf.scbuf) ;\r\r\n\r\r\n\treturn 0 ;\r\r\n} /* aiff_read_comm_chunk */\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.No Vulnerabilities|B.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-395:Use of NullPointerException Catch to Detect NULL Pointer Dereference\nB.CWE-462:Duplicate Key in Associative List (Alist)\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-400:Uncontrolled Resource Consumption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_sleep_03()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = RAND32();\r\n }\r\n if(5==5)\r\n {\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = RAND32();\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = RAND32();\r\n }\r\n if(5==5)\r\n {\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n count = 20;\r\n }\r\n if(5==5)\r\n {\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(5==5)\r\n {\r\n \r\n count = 20;\r\n }\r\n if(5==5)\r\n {\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\nvoid My_rand_sleep_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_sleep_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_sleep_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-400:Uncontrolled Resource Consumption|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-770:Allocation of Resources Without Limits or Throttling\nC.CWE-789:Memory Allocation with Excessive Size Value\nD.CWE-1066:Missing Serialization Control Element\nE.CWE-342:Predictable Exact Value from Previous Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_connect_socket_42\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic size_t mSource(size_t data)\r\n{\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n return data;\r\n}\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n data = mSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic size_t nG2BSource(size_t data)\r\n{\r\n \r\n data = 20;\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n data = nG2BSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic size_t nB2GSource(size_t data)\r\n{\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = strtoul(inputBuffer, NULL, 0);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n data = nB2GSource(data);\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_connect_socket_42; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-789:Memory Allocation with Excessive Size Value|B.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.No Vulnerabilities\nD.CWE-415:Double Free\nE.CWE-436:Interpretation Conflict\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_class_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_delete_array_class_84\r\n{\r\npublic:\r\n My_new_delete_array_class_84(TwoIntsClass * dataCopy);\r\n ~My_new_delete_array_class_84();\r\n\r\nprivate:\r\n TwoIntsClass * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_delete_array_class_84G2B\r\n{\r\npublic:\r\n My_new_delete_array_class_84G2B(TwoIntsClass * dataCopy);\r\n ~My_new_delete_array_class_84G2B();\r\n\r\nprivate:\r\n TwoIntsClass * data;\r\n};\r\n\r\nclass My_new_delete_array_class_84B2G\r\n{\r\npublic:\r\n My_new_delete_array_class_84B2G(TwoIntsClass * dataCopy);\r\n ~My_new_delete_array_class_84B2G();\r\n\r\nprivate:\r\n TwoIntsClass * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-415:Double Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-680:Integer Overflow to Buffer Overflow\nB.No Vulnerabilities\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-687:Function Call With Incorrectly Specified Argument Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_fscanf_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n goto source;\r\nsource:\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n goto source;\r\nsource:\r\n \r\n data = 20;\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_fscanf_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-839:Numeric Range Comparison Without Minimum Check\nC.No Vulnerabilities\nD.CWE-507:Trojan Horse\nE.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_06()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_char_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nB.No Vulnerabilities\nC.CWE-41:Improper Resolution of Path Equivalence\nD.CWE-1394:Use of Default Cryptographic Key\nE.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_access_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|A.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-838:Inappropriate Encoding for Output Context\nB.No Vulnerabilities\nC.CWE-188:Reliance on Data/Memory Layout\nD.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nE.CWE-515:Covert Storage Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_modify_local_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n char *charPtr;\r\n structCharInt.charFirst = 1;\r\n charPtr = &structCharInt.charFirst;\r\n \r\n *(int*)(charPtr + sizeof(int)) = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n struct\r\n {\r\n char charFirst;\r\n int intSecond;\r\n } structCharInt;\r\n structCharInt.charFirst = 1;\r\n \r\n structCharInt.intSecond = 5;\r\n printIntLine(structCharInt.charFirst);\r\n printIntLine(structCharInt.intSecond);\r\n }\r\n }\r\n}\r\n\r\nvoid My_modify_local_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_modify_local_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_modify_local_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-188:Reliance on Data/Memory Layout|D.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1386:Insecure Operation on Windows Junction / Mount Point\nB.CWE-195:Signed to Unsigned Conversion Error\nC.CWE-253:Incorrect Check of Function Return Value\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define REMOVE _wremove\r\n#else\r\n#define REMOVE remove\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_remove_10()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n if (REMOVE(L\"removemem.txt\") == 0)\r\n {\r\n printLine(\"remove failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (REMOVE(L\"removemen.txt\") != 0)\r\n {\r\n printLine(\"remove failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n \r\n if (REMOVE(L\"removemen.txt\") != 0)\r\n {\r\n printLine(\"remove failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_remove_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_remove_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_remove_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-253:Incorrect Check of Function Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-680:Integer Overflow to Buffer Overflow\nB.No Vulnerabilities\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\nE.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_new_rand_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = RAND32();\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = 20;\r\n }\r\n {\r\n size_t dataBytes,i;\r\n int *intPointer;\r\n \r\n dataBytes = data * sizeof(int); \r\n intPointer = (int*)new char[dataBytes];\r\n for (i = 0; i < (size_t)data; i++)\r\n {\r\n intPointer[i] = 0; \r\n }\r\n printIntLine(intPointer[0]);\r\n delete [] intPointer;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_rand_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-680:Integer Overflow to Buffer Overflow|C.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nC.CWE-691:Insufficient Control Flow Management\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-837:Improper Enforcement of a Single, Unique Action\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\n#include <ctype.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint munith_spruiker = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid siberians_butterfingered(int segments_carpetbag,... );\r\nvoid humanistical_circulates(char *saka_parroter);\r\nvoid urlDecode(char *src, char *dst) {\r\n char a, b;\r\n while (*src) {\r\n if ((*src == '%') &&\r\n ((a = src[1]) && (b = src[2])) &&\r\n (isxdigit(a) && isxdigit(b))) {\r\n if (a >= 'a')\r\n a -= 'a'-'A';\r\n if (a >= 'A')\r\n a -= ('A' - 10);\r\n else\r\n a -= '0';\r\n if (b >= 'a')\r\n b -= 'a'-'A';\r\n if (b >= 'A')\r\n b -= ('A' - 10);\r\n else\r\n b -= '0';\r\n *dst++ = 16*a+b;\r\n src+=3;\r\n } else {\r\n *dst++ = *src++;\r\n }\r\n }\r\n *dst++ = '\\0';\r\n}\r\nint isValid(char *src) {\r\n int i = 0;\r\n while (src[i] != '\\0') {\r\n if(src[i] == ';') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '|') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n else if(src[i] == '&') {\r\n if (i == 0 || src[i-1] != '\\\\') {\r\n return 0;\r\n }\r\n }\r\n i++;\r\n }\r\n return 1;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n char *manuscription_kingsman;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&munith_spruiker,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&manuscription_kingsman,\"SHANK_JERKIES\");\r\n if (manuscription_kingsman != 0) {;\r\n siberians_butterfingered(1,manuscription_kingsman);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#define PETROGLYPH_ELATROMETER(x) humanistical_circulates((char *) x)\r\n\r\nvoid siberians_butterfingered(int segments_carpetbag,... )\r\n{\r\n char *dioritic_figworm = 0;\r\n va_list scrubwomen_empresa;\r\n ++global_variable;;\r\n if (segments_carpetbag > 0) {\r\n __builtin_va_start(scrubwomen_empresa,segments_carpetbag);\r\n dioritic_figworm = (va_arg(scrubwomen_empresa,char *));\r\n __builtin_va_end(scrubwomen_empresa);\r\n }\r\n\tPETROGLYPH_ELATROMETER(dioritic_figworm);\r\n}\r\n\r\nvoid humanistical_circulates(char *saka_parroter)\r\n{\r\n FILE *fpipe;\r\n char buffer[100];\r\n char *parsed_input;\r\n char command_buffer[1000];\r\n char *command_str = \"nslookup \";\r\n char *cuirass_pawnee = 0;\r\n ++global_variable;;\r\n cuirass_pawnee = ((char *)saka_parroter);\r\n \r\n if (strlen(cuirass_pawnee) < 1000 - strlen(command_str)) {\r\n \r\n \r\n \r\n if (isValid(cuirass_pawnee) == 1) {\r\n parsed_input = malloc((strlen(cuirass_pawnee)+1) * sizeof(char));\r\n urlDecode(cuirass_pawnee, parsed_input);\r\n snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\r\n \r\n \r\n \r\n \r\n fpipe = popen(command_buffer,\"r\");\r\n if (fpipe != 0) {\r\n while(fgets(buffer,100,fpipe) != 0) {\r\n printf(buffer);\r\n }\r\n pclose(fpipe);\r\n }\r\n }\r\n \r\n }\r\n \r\n;\r\n if (saka_parroter != 0) \r\n free(((char *)saka_parroter));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-159:Improper Handling of Invalid Use of Special Elements\nB.No Vulnerabilities\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-920:Improper Restriction of Power Consumption\nE.CWE-325:Missing Cryptographic Step\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptDeriveKey_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptDeriveKey_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptDeriveKey_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptDeriveKey_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-325:Missing Cryptographic Step|C.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-15:External Control of System or Configuration Setting\nB.CWE-241:Improper Handling of Unexpected Data Type\nC.CWE-642:External Control of Critical State Data\nD.No Vulnerabilities\nE.CWE-554:ASP.NET Misconfiguration: Not Using Input Validation Framework\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_w32_64()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"hostname\");\r\n My_w32_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_w32_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-15:External Control of System or Configuration Setting|C.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-665:Improper Initialization\nB.CWE-573:Improper Following of Specification by Caller\nC.No Vulnerabilities\nD.CWE-675:Multiple Operations on Resource in Single-Operation Context\nE.CWE-1234:Hardware Internal or Debug Modes Allow Override of Locks\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_10()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(globalTrue)\r\n {\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(globalTrue)\r\n {\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(globalTrue)\r\n {\r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n \r\n fclose(data);\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(globalTrue)\r\n {\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\nvoid My_fopen_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-675:Multiple Operations on Resource in Single-Operation Context|B.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-50:Path Equivalence: '//multiple/leading/slash'\nB.CWE-704:Incorrect Type Conversion or Cast\nC.No Vulnerabilities\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-483:Incorrect Block Delimitation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, void *> dataMap);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n \r\n data = NULL;\r\n {\r\n \r\n char charBuffer = 'a';\r\n data = &charBuffer;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, void *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n map<int, void *> dataMap;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1317:Improper Access Control in Fabric Bridge\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.CWE-704:Incorrect Type Conversion or Cast\nD.CWE-597:Use of Wrong Operator in String Comparison\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_struct_52bSink(void * data);\r\n\r\nvoid My_struct_52()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n My_struct_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_struct_52bG2BSink(void * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n My_struct_52bG2BSink(data);\r\n}\r\n\r\nvoid My_struct_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-588:Attempt to Access Child of a Non-structure Pointer|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-259:Use of Hard-coded Password\nC.CWE-1325:Improperly Controlled Sequential Memory Allocation\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-1271:Uninitialized Value on Reset for Registers Holding Security Settings\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_02()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(1)\r\n {\r\n \r\n wcscpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n if(1)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-259:Use of Hard-coded Password|D.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-271:Privilege Dropping / Lowering Errors\nB.CWE-272:Least Privilege Violation\nC.CWE-807:Reliance on Untrusted Inputs in a Security Decision\nD.CWE-1044:Architecture with Number of Horizontal Layers Outside of Expected Range\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateProcessAsUser_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"C:\\\\Program Files\\\\NApp arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n STARTUPINFOA si;\r\n PROCESS_INFORMATION pi;\r\n HANDLE pHandle = NULL;\r\n \r\n if(!CreateProcessAsUserA(pHandle,\r\n NULL,\r\n \"\\\"C:\\\\Program Files\\\\NApp\\\" arg1 arg2\",\r\n NULL,\r\n NULL,\r\n FALSE,\r\n DETACHED_PROCESS,\r\n NULL,\r\n NULL,\r\n &si,\r\n &pi))\r\n {\r\n printLine(\"CreateProcessAsUser failed\");\r\n RevertToSelf();\r\n CloseHandle(pHandle);\r\n return;\r\n }\r\n else\r\n {\r\n printLine(\"CreateProcessAUser successful\");\r\n }\r\n \r\n WaitForSingleObject(pi.hProcess, INFINITE);\r\n \r\n CloseHandle(pi.hProcess);\r\n CloseHandle(pi.hThread);\r\n CloseHandle(pHandle);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateProcessAsUser_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateProcessAsUser_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateProcessAsUser_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-272:Least Privilege Violation|A.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-603:Use of Client-Side Authentication\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.No Vulnerabilities\nD.CWE-134:Use of Externally-Controlled Format String\nE.CWE-301:Reflection Attack in an Authentication Protocol\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_char_file_w32_vsnprintf_81\r\n{\r\n\r\nclass My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(char * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_char_file_w32_vsnprintf_81 : public My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_char_file_w32_vsnprintf_81G2B : public My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\nclass My_char_file_w32_vsnprintf_81B2G : public My_char_file_w32_vsnprintf_81_base\r\n{\r\npublic:\r\n void action(char * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-134:Use of Externally-Controlled Format String|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-121:Stack-based Buffer Overflow\nB.No Vulnerabilities\nC.CWE-328:Use of Weak Hash\nD.CWE-787:Out-of-bounds Write\nE.CWE-862:Missing Authorization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE805_wchar_t_declare_ncat_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-121:Stack-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-468:Incorrect Pointer Scaling\nB.CWE-219:Storage of File with Sensitive Data Under Web Root\nC.No Vulnerabilities\nD.CWE-682:Incorrect Calculation\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-468:Incorrect Pointer Scaling|D.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nC.CWE-1288:Improper Validation of Consistency within Input\nD.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_realloc_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n SecureZeroMemory(password, 200 * sizeof(wchar_t));\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n password = realloc(password, 200 * sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n \r\n wcscpy(password, L\"Nothing to see here\");\r\n printWLine(password);\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_realloc_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_realloc_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_realloc_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-779:Logging of Excessive Data\nC.CWE-766:Critical Data Element Declared Public\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fputc_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n fputc((int)'A', stdout);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (fputc((int)'A', stdout) == EOF)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n \r\n if (fputc((int)'A', stdout) == EOF)\r\n {\r\n printLine(\"fputc failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fputc_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fputc_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fputc_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.No Vulnerabilities\nC.CWE-1047:Modules with Circular Dependencies\nD.CWE-124:Buffer Underwrite ('Buffer Underflow')\nE.CWE-480:Use of Incorrect Operator\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_wchar_t_memmove_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n memmove(data, source, 100*sizeof(wchar_t));\r\n \r\n data[100-1] = L'\\0';\r\n printWLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_memmove_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-124:Buffer Underwrite ('Buffer Underflow')|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-435:Improper Interaction Between Multiple Correctly-Behaving Entities\nC.CWE-506:Embedded Malicious Code\nD.CWE-692:Incomplete Denylist to Cross-Site Scripting\nE.CWE-912:Hidden Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_base64_encoded_payload_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n char * encodedPayload = \"Y2FsYy5leGU=\";\r\n BYTE * decodedPayload = NULL;\r\n DWORD requiredLength;\r\n do\r\n {\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n NULL,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload = (BYTE*) malloc(requiredLength + 1);\r\n if (decodedPayload == NULL)\r\n {\r\n break;\r\n }\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n decodedPayload,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload[requiredLength] = '\\0';\r\n if (system((char*)decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n free(decodedPayload);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_base64_encoded_payload_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_base64_encoded_payload_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_base64_encoded_payload_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-506:Embedded Malicious Code|E.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-683:Function Call With Incorrect Order of Arguments\nB.CWE-641:Improper Restriction of Names for Files and Other Resources\nC.CWE-224:Obscured Security-relevant Information by Alternate Name\nD.No Vulnerabilities\nE.CWE-346:Origin Validation Error\n", "input": " explicit DBusServices(const content::MainFunctionParams& parameters) {\r\r\n bluez::BluezDBusManager::Initialize(\r\r\n DBusThreadManager::Get()->GetSystemBus(),\r\r\n chromeos::DBusThreadManager::Get()->IsUsingFakes());\r\r\n\r\r\n if (GetAshConfig() != ash::Config::MASH) {\r\r\n PowerPolicyController::Initialize(\r\r\n DBusThreadManager::Get()->GetPowerManagerClient());\r\r\n }\r\r\n\r\r\n proxy_resolution_service_ = CrosDBusService::Create(\r\r\n kNetworkProxyServiceName, dbus::ObjectPath(kNetworkProxyServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<ProxyResolutionServiceProvider>(\r\r\n std::make_unique<\r\r\n ChromeProxyResolutionServiceProviderDelegate>())));\r\r\n\r\r\n kiosk_info_service_ = CrosDBusService::Create(\r\r\n kKioskAppServiceName, dbus::ObjectPath(kKioskAppServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<KioskInfoService>()));\r\r\n\r\r\n liveness_service_ = CrosDBusService::Create(\r\r\n kLivenessServiceName, dbus::ObjectPath(kLivenessServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<LivenessServiceProvider>()));\r\r\n\r\r\n screen_lock_service_ = CrosDBusService::Create(\r\r\n kScreenLockServiceName, dbus::ObjectPath(kScreenLockServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<ScreenLockServiceProvider>()));\r\r\n\r\r\n virtual_file_request_service_ = CrosDBusService::Create(\r\r\n kVirtualFileRequestServiceName,\r\r\n dbus::ObjectPath(kVirtualFileRequestServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<VirtualFileRequestServiceProvider>(\r\r\n std::make_unique<\r\r\n ChromeVirtualFileRequestServiceProviderDelegate>())));\r\r\n\r\r\n component_updater_service_ = CrosDBusService::Create(\r\r\n kComponentUpdaterServiceName,\r\r\n dbus::ObjectPath(kComponentUpdaterServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<ComponentUpdaterServiceProvider>(\r\r\n g_browser_process->platform_part()->cros_component_manager())));\r\r\n\r\r\n finch_features_service_ = CrosDBusService::Create(\r\r\n kChromeFeaturesServiceName,\r\r\n dbus::ObjectPath(kChromeFeaturesServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<ChromeFeaturesServiceProvider>(\r\r\n std::make_unique<FinchFeaturesServiceProviderDelegate>())));\r\r\n\r\r\n vm_applications_service_ = CrosDBusService::Create(\r\r\n vm_tools::apps::kVmApplicationsServiceName,\r\r\n dbus::ObjectPath(vm_tools::apps::kVmApplicationsServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<VmApplicationsServiceProvider>(\r\r\n std::make_unique<VmApplicationsServiceProviderDelegate>())));\r\r\n\r\r\n drive_file_stream_service_ = CrosDBusService::Create(\r\r\n drivefs::kDriveFileStreamServiceName,\r\r\n dbus::ObjectPath(drivefs::kDriveFileStreamServicePath),\r\r\n CrosDBusService::CreateServiceProviderList(\r\r\n std::make_unique<DriveFileStreamServiceProvider>(\r\r\n std::make_unique<\r\r\n drivefs::DriveFileStreamServiceProviderDelegate>())));\r\r\n\r\r\n PowerDataCollector::Initialize();\r\r\n\r\r\n LoginState::Initialize();\r\r\n TPMTokenLoader::Initialize();\r\r\n CertLoader::Initialize();\r\r\n\r\r\n disks::DiskMountManager::Initialize();\r\r\n cryptohome::AsyncMethodCaller::Initialize();\r\r\n cryptohome::HomedirMethods::Initialize();\r\r\n\r\r\n NetworkHandler::Initialize();\r\r\n CertLibrary::Initialize();\r\r\n\r\r\n NetworkChangeNotifierFactoryChromeos::GetInstance()->Initialize();\r\r\n\r\r\n UpgradeDetectorChromeos::GetInstance()->Init();\r\r\n\r\r\n DeviceSettingsService::Get()->SetSessionManager(\r\r\n DBusThreadManager::Get()->GetSessionManagerClient(),\r\r\n OwnerSettingsServiceChromeOSFactory::GetInstance()->GetOwnerKeyUtil());\r\r\n }\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.No Vulnerabilities|D.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-34:Path Traversal: '....//'\nC.No Vulnerabilities\nD.CWE-500:Public Static Field Not Marked Final\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\ntypedef struct _My_int_listen_socket_divide_67_structType\r\n{\r\n int structFirst;\r\n} My_int_listen_socket_divide_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_listen_socket_divide_67bSink(My_int_listen_socket_divide_67_structType myStruct);\r\n\r\nvoid My_int_listen_socket_divide_67()\r\n{\r\n int data;\r\n My_int_listen_socket_divide_67_structType myStruct;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_listen_socket_divide_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_listen_socket_divide_67bG2BSink(My_int_listen_socket_divide_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_int_listen_socket_divide_67_structType myStruct;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n myStruct.structFirst = data;\r\n My_int_listen_socket_divide_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_int_listen_socket_divide_67bB2GSink(My_int_listen_socket_divide_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_int_listen_socket_divide_67_structType myStruct;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_listen_socket_divide_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_int_listen_socket_divide_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_listen_socket_divide_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_listen_socket_divide_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-369:Divide By Zero|A.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-23:Relative Path Traversal\nC.CWE-768:Incorrect Short Circuit Evaluation\nD.CWE-521:Weak Password Requirements\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_char_environment_open_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_open_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-23:Relative Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-427:Uncontrolled Search Path Element\nD.CWE-1164:Irrelevant Code\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_fputc_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n fputwc((wchar_t)L'A', stdout);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n if (fputwc((wchar_t)L'A', stdout) == WEOF)\r\n {\r\n printLine(\"fputwc failed!\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n if (fputwc((wchar_t)L'A', stdout) == WEOF)\r\n {\r\n printLine(\"fputwc failed!\");\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wchar_t_fputc_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_fputc_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_fputc_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-252:Unchecked Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-467:Use of sizeof() on a Pointer Type\nB.CWE-295:Improper Certificate Validation\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_accept_bind_listen_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n \r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_accept_bind_listen_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_accept_bind_listen_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_accept_bind_listen_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-666:Operation on Resource in Wrong Phase of Lifetime|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "666"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.No Vulnerabilities\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-43:Path Equivalence: 'filename....' (Multiple Trailing Dot)\nE.CWE-1121:Excessive McCabe Cyclomatic Complexity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_66bSink(wchar_t * cryptoKeyArray[]);\r\n\r\nvoid My_w32_wchar_t_66()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t * cryptoKeyArray[5];\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n \r\n cryptoKeyArray[2] = cryptoKey;\r\n My_w32_wchar_t_66bSink(cryptoKeyArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_66bG2BSink(wchar_t * cryptoKeyArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t * cryptoKeyArray[5];\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n cryptoKeyArray[2] = cryptoKey;\r\n My_w32_wchar_t_66bG2BSink(cryptoKeyArray);\r\n}\r\n\r\nvoid My_w32_wchar_t_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|A.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.CWE-153:Improper Neutralization of Substitution Characters\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-1107:Insufficient Isolation of Symbolic Constant Definitions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#define SLEEP Sleep\r\n#else\r\n#include <unistd.h>\r\n#define SLEEP usleep\r\n#endif\r\n\r\nnamespace My_rand_sleep_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int count;\r\n int &countRef = count;\r\n \r\n count = -1;\r\n \r\n count = RAND32();\r\n {\r\n int count = countRef;\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n int &countRef = count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n {\r\n int count = countRef;\r\n \r\n SLEEP(count);\r\n printLine(\"Sleep time possibly too long\");\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n int &countRef = count;\r\n \r\n count = -1;\r\n \r\n count = RAND32();\r\n {\r\n int count = countRef;\r\n \r\n if (count > 0 && count <= 2000)\r\n {\r\n SLEEP(count);\r\n printLine(\"Sleep time OK\");\r\n }\r\n else\r\n {\r\n printLine(\"Sleep time too long\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_rand_sleep_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-377:Insecure Temporary File\nB.CWE-657:Violation of Secure Design Principles\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.No Vulnerabilities\nE.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_w32GetTempFileName_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n if (GetTempFileNameW(L\".\", L\"m\", 0, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n \r\n if (GetTempFileNameW(L\".\", L\"n\", rand() + 1, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t filename[MAX_PATH] = L\"\";\r\n int fileDesc;\r\n \r\n \r\n if (GetTempFileNameW(L\".\", L\"n\", rand() + 1, filename) == 0)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_w32GetTempFileName_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_w32GetTempFileName_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_w32GetTempFileName_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-377:Insecure Temporary File|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nC.CWE-345:Insufficient Verification of Data Authenticity\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-484:Omitted Break Statement in Switch\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_41\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(list<int> data)\r\n{\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(list<int> data)\r\n{\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(list<int> data)\r\n{\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_41; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-672:Operation on a Resource after Expiration or Release|B.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-152:Improper Neutralization of Macro Symbols\nB.CWE-511:Logic/Time Bomb\nC.No Vulnerabilities\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_no_close_15()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n CloseHandle(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_no_close_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_no_close_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_no_close_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-547:Use of Hard-coded, Security-relevant Constants\nB.CWE-300:Channel Accessible by Non-Endpoint\nC.CWE-805:Buffer Access with Incorrect Length Value\nD.No Vulnerabilities\nE.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint tortillas_hianakoto = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\nstruct struct {\r\n char buffer[8];\r\n char * buff_pointer;\r\n};\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int oc_i = 0;\r\n int ptr_deref;\r\n struct struct * data = 0;\r\n char *cognomina_cyanitic = 0;\r\n int pseudo_redominating;\r\n void **electrogalvanic_unsun = 0;\r\n void **mimically_bearsville = 0;\r\n void *bonny_brachycome = 0;\r\n int deadhouse_shawwal = 53;\r\n char *gladiest_rhapsodizes;;\r\n if (__sync_bool_compare_and_swap(&tortillas_hianakoto,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&gladiest_rhapsodizes,\"1652\",deadhouse_shawwal);\r\n if (gladiest_rhapsodizes != 0) {;\r\n bonny_brachycome = ((void *)gladiest_rhapsodizes);\r\n pseudo_redominating = 1;\r\n electrogalvanic_unsun = &bonny_brachycome;\r\n mimically_bearsville = ((void **)(((unsigned long )electrogalvanic_unsun) * pseudo_redominating * pseudo_redominating)) + 5;\r\n cognomina_cyanitic = ((char *)((char *)( *(mimically_bearsville - 5))));\r\n \r\n data = (struct struct*) malloc(sizeof (struct struct));\r\n if (data != NULL) {\r\n data->buff_pointer = data->buffer;\r\n \r\n \r\n \r\n \r\n \r\n strncpy(data->buffer, cognomina_cyanitic, strlen(cognomina_cyanitic) + 1);\r\n ptr_deref = strlen( data->buff_pointer);\r\n for (; oc_i < ptr_deref; ++oc_i) {\r\n data->buffer[oc_i] = toupper(data->buffer[oc_i]);\r\n }\r\n printf(\"%s\\n\", data->buffer);\r\n \r\n \r\n free(data);\r\n }\r\n \r\n;\r\n if (((char *)( *(mimically_bearsville - 5))) != 0) \r\n free(((char *)((char *)( *(mimically_bearsville - 5)))));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-805:Buffer Access with Incorrect Length Value|E.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer", "cwe": "805"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nB.CWE-506:Embedded Malicious Code\nC.CWE-194:Unexpected Sign Extension\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fscanf_memcpy_08()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n fscanf (stdin, \"%hd\", &data);\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_fscanf_memcpy_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_memcpy_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_memcpy_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-123:Write-what-where Condition\nE.CWE-580:clone() Method Without super.clone()\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\ntypedef struct _My_fgets_67_structType\r\n{\r\n mStruct structFirst;\r\n} My_fgets_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fgets_67bSink(My_fgets_67_structType myStruct);\r\n\r\nvoid My_fgets_67()\r\n{\r\n mStruct data;\r\n My_fgets_67_structType myStruct;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n myStruct.structFirst = data;\r\n My_fgets_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fgets_67bG2BSink(My_fgets_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n My_fgets_67_structType myStruct;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n myStruct.structFirst = data;\r\n My_fgets_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_fgets_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-123:Write-what-where Condition|C.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-282:Improper Ownership Management\nB.No Vulnerabilities\nC.CWE-662:Improper Synchronization\nD.CWE-667:Improper Locking\nE.CWE-113:Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(mLock);\r\n \r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_basic_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-667:Improper Locking|C.CWE-662:Improper Synchronization", "cwe": "667"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nB.No Vulnerabilities\nC.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nD.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\nE.CWE-1076:Insufficient Adherence to Expected Conventions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_free_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_free_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_free_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_free_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|A.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nC.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\ntypedef struct _My_w32_wchar_t_listen_socket_67_structType\r\n{\r\n wchar_t * structFirst;\r\n} My_w32_wchar_t_listen_socket_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_67bSink(My_w32_wchar_t_listen_socket_67_structType myStruct);\r\n\r\nvoid My_w32_wchar_t_listen_socket_67()\r\n{\r\n wchar_t * data;\r\n My_w32_wchar_t_listen_socket_67_structType myStruct;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_w32_wchar_t_listen_socket_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_wchar_t_listen_socket_67bG2BSink(My_w32_wchar_t_listen_socket_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n My_w32_wchar_t_listen_socket_67_structType myStruct;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"Doe, XXXXX\");\r\n myStruct.structFirst = data;\r\n My_w32_wchar_t_listen_socket_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_w32_wchar_t_listen_socket_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_listen_socket_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_listen_socket_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-510:Trapdoor\nB.CWE-400:Uncontrolled Resource Consumption\nC.CWE-112:Missing XML Validation\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_for_loop_01()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = RAND32();\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = RAND32();\r\n {\r\n size_t i = 0;\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_rand_for_loop_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_for_loop_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_for_loop_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nB.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nC.CWE-602:Client-Side Enforcement of Server-Side Security\nD.CWE-409:Improper Handling of Highly Compressed Data (Data Amplification)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include <libpq-fe.h> \r\n#include </trace.h> \r\n#include <dlfcn.h> \r\n#include <sys/stat.h> \r\nint reloaded_outshow = 0;\r\nint global_variable;\r\nvoid handle_taint(char *naemorhedus_doggoning);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid glaire_corticated(int geoaesthesia_chaunting,void **emancipatations_sleets);\r\nvoid consarn_unsequentially(int flankwise_ciscoes,void **aboiteaux_complain);\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&reloaded_outshow,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *naemorhedus_doggoning)\r\n{\r\n int sphyraena_henneries = 7;\r\n void **nonassenting_unmistakably = 0;\r\n void *gop_calomorphic = 0;\r\n ++global_variable;;\r\n if (naemorhedus_doggoning != 0) {;\r\n gop_calomorphic = ((void *)naemorhedus_doggoning);\r\n nonassenting_unmistakably = &gop_calomorphic;\r\n glaire_corticated(sphyraena_henneries,nonassenting_unmistakably);\r\n }\r\n}\r\n\r\nvoid glaire_corticated(int geoaesthesia_chaunting,void **emancipatations_sleets)\r\n{\r\n PGresult *res = 0;\r\n char query[1000];\r\n PGconn *conn = 0;\r\n char dbconn_str[150];\r\n char *dbport = 0;\r\n char *dbpassword = 0;\r\n char *dbuser = 0;\r\n char *dbhost = 0;\r\n char *dbdatabase = 0;\r\n int nFields;\r\n int i;\r\n int j = 0;\r\n char *orenda_mendication = 0;\r\n ++global_variable;\r\n geoaesthesia_chaunting--;\r\n if (geoaesthesia_chaunting > 0) {\r\n consarn_unsequentially(geoaesthesia_chaunting,emancipatations_sleets);\r\n return ;\r\n }\r\n orenda_mendication = ((char *)((char *)( *emancipatations_sleets)));\r\n \r\n dbhost = getenv(\"DBPGHOST\");\r\n dbuser = getenv(\"DBPGUSER\");\r\n dbpassword = getenv(\"DBPGPASSWORD\");\r\n dbport = getenv(\"DBPGPORT\");\r\n dbdatabase = getenv(\"SS_DBPGDATABASE\");\r\n \r\n \r\n \r\n \r\n \r\n if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\r\n snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\r\n dbdatabase, dbhost, dbuser, dbpassword, dbport);\r\n conn = PQconnectdb(dbconn_str);\r\n if (PQstatus(conn) != 0) {\r\n \r\n printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", orenda_mendication);\r\n \r\n \r\n \r\n \r\n res = PQexec(conn,query);\r\n if (PQresultStatus(res) != 2) {\r\n \r\n printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\r\n PQclear(res);\r\n PQfinish(conn);\r\n exit(1);\r\n }\r\n \r\n \r\n nFields = PQnfields(res);\r\n for (i = 0; i < nFields; i++)\r\n printf(\"%-15s\", PQfname(res, i));\r\n printf(\"\\n\\n\");\r\n \r\n for (i = 0; i < PQntuples(res); i++)\r\n {\r\n for (j = 0; j < nFields; j++)\r\n printf(\"%-15s\", PQgetvalue(res, i, j));\r\n printf(\"\\n\");\r\n }\r\n PQclear(res);\r\n PQfinish(conn);\r\n }\r\n \r\n;\r\n if (((char *)( *emancipatations_sleets)) != 0) \r\n free(((char *)((char *)( *emancipatations_sleets))));\r\nclose_printf_context();\r\n}\r\n\r\nvoid consarn_unsequentially(int flankwise_ciscoes,void **aboiteaux_complain)\r\n{\r\n ++global_variable;\r\n glaire_corticated(flankwise_ciscoes,aboiteaux_complain);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|A.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "89"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-707:Improper Neutralization\nB.CWE-787:Out-of-bounds Write\nC.CWE-576:EJB Bad Practices: Use of Java I/O\nD.CWE-121:Stack-based Buffer Overflow\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_dest_wchar_t_alloca_cat_12()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = dataMBuffer;\r\n data[0] = L'\\0'; \r\n }\r\n else\r\n {\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataMBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\r\n wchar_t * dataNBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n }\r\n else\r\n {\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n }\r\n {\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n \r\n wcscat(data, source);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_dest_wchar_t_alloca_cat_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_dest_wchar_t_alloca_cat_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_dest_wchar_t_alloca_cat_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-121:Stack-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1079:Parent Class without Virtual Destructor Method\nC.CWE-522:Insufficiently Protected Credentials\nD.CWE-570:Expression is Always False\nE.CWE-256:Plaintext Storage of a Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nnamespace My_w32_wchar_t_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32_wchar_t_84\r\n{\r\npublic:\r\n My_w32_wchar_t_84(wchar_t * dataCopy);\r\n ~My_w32_wchar_t_84();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32_wchar_t_84G2B\r\n{\r\npublic:\r\n My_w32_wchar_t_84G2B(wchar_t * dataCopy);\r\n ~My_w32_wchar_t_84G2B();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\nclass My_w32_wchar_t_84B2G\r\n{\r\npublic:\r\n My_w32_wchar_t_84B2G(wchar_t * dataCopy);\r\n ~My_w32_wchar_t_84B2G();\r\n\r\nprivate:\r\n wchar_t * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-256:Plaintext Storage of a Password|C.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-197:Numeric Truncation Error\nB.No Vulnerabilities\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-143:Improper Neutralization of Record Delimiters\nE.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint castora_shiism = 0;\r\n\r\nstruct subiodide_ussher \r\n{\r\n char *nonpoet_domatium;\r\n double monkeyed_cantoner;\r\n char *lymphology_anodonta;\r\n char contralateral_bedfoot;\r\n int krusenstern_insweeping;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nstruct struct_data {\r\n char *buffer_member;\r\n unsigned short size_member;\r\n};\r\nstruct struct_data *init_data(long number_param)\r\n{\r\n \r\n struct struct_data *init_data_ptr = 0;\r\n init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\r\n if (init_data_ptr == 0)\r\n return 0;\r\n init_data_ptr -> size_member = 0;\r\n \r\n\r\n init_data_ptr -> size_member = number_param;\r\n init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\r\n \r\n \r\n \r\n if (init_data_ptr -> buffer_member == 0) {\r\n free(init_data_ptr);\r\n return 0;\r\n }\r\n memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\r\n init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\r\n return init_data_ptr;\r\n}\r\n\r\nunsigned int avdevice_version()\r\n{\r\n long number;\r\n struct struct_data *data = 0;\r\n char *banding_unriddles = 0;\r\n int overwing_approbations;\r\n int graecise_replaced;\r\n int tangences_skeans;\r\n struct subiodide_ussher *sibelle_sabbathlike = {0};\r\n struct subiodide_ussher *morphotic_nos = {0};\r\n struct subiodide_ussher disillusive_amroc;\r\n char *securifera_kvinter;;\r\n if (__sync_bool_compare_and_swap(&castora_shiism,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&securifera_kvinter,\"NONFEUDALLY_GALACTOGOGUE\");\r\n if (securifera_kvinter != 0) {;\r\n disillusive_amroc . nonpoet_domatium = ((char *)securifera_kvinter);\r\n tangences_skeans = 1;\r\n sibelle_sabbathlike = &disillusive_amroc;\r\n morphotic_nos = ((struct subiodide_ussher *)(((unsigned long )sibelle_sabbathlike) * tangences_skeans * tangences_skeans)) + 5;\r\n graecise_replaced = 5;\r\n while(1 == 1){\r\n graecise_replaced = graecise_replaced * 2;\r\n graecise_replaced = graecise_replaced + 2;\r\n if (graecise_replaced > 1000) {\r\n break; \r\n }\r\n }\r\n overwing_approbations = graecise_replaced;\r\n banding_unriddles = ((char *)( *(morphotic_nos - 5)) . nonpoet_domatium);\r\n \r\n number = strtol(banding_unriddles,0U,10);\r\n if (number > 0) {\r\n data = init_data(number);\r\n if (data != 0) {\r\n \r\n\r\n memset(data -> buffer_member, 98, number);\r\n \r\n data -> buffer_member[number - 1] = 0;\r\n printf(\"%s\\n\", data -> buffer_member);\r\n if (data -> buffer_member != 0U)\r\n free(data -> buffer_member);\r\n if (data != 0U)\r\n free(data);\r\n }\r\n } else {\r\n printf(\"Input is less than or equal to 0\\n\");\r\n }\r\n \r\n;\r\n if (( *(morphotic_nos - 5)) . nonpoet_domatium != 0) \r\n free(((char *)( *(morphotic_nos - 5)) . nonpoet_domatium));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-197:Numeric Truncation Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-328:Use of Weak Hash\nC.CWE-1220:Insufficient Granularity of Access Control\nD.CWE-831:Signal Handler Function Associated with Multiple Signals\nE.CWE-326:Inadequate Encryption Strength\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD5_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD5_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD5_SUM_SIZE], calcHash[MD5_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD5_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD5_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD5_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD5_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD5_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD5_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-328:Use of Weak Hash|E.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-704:Incorrect Type Conversion or Cast\nC.CWE-1314:Missing Write Protection for Parametric Data Values\nD.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nE.CWE-258:Empty Password in Configuration File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_11()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n }\r\n \r\n printIntLine(*((int*)data));\r\n}\r\n\r\nvoid My_short_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1087:Class with Virtual Method without a Virtual Destructor\nB.No Vulnerabilities\nC.CWE-390:Detection of Error Condition Without Action\nD.CWE-755:Improper Handling of Exceptional Conditions\nE.CWE-333:Improper Handling of Insufficient Entropy in TRNG\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-390:Detection of Error Condition Without Action|D.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-696:Incorrect Behavior Order\nC.CWE-755:Improper Handling of Exceptional Conditions\nD.CWE-390:Detection of Error Condition Without Action\nE.CWE-288:Authentication Bypass Using an Alternate Path or Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-390:Detection of Error Condition Without Action|C.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-267:Privilege Defined With Unsafe Actions\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-400:Uncontrolled Resource Consumption\nD.CWE-1257:Improper Access Control Applied to Mirrored or Aliased Memory Regions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fscanf_for_loop_54bSink(int count);\r\n\r\nvoid My_fscanf_for_loop_54()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n My_fscanf_for_loop_54bSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fscanf_for_loop_54bG2BSink(int count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n My_fscanf_for_loop_54bG2BSink(count);\r\n}\r\n\r\n\r\nvoid My_fscanf_for_loop_54bB2GSink(int count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n fscanf(stdin, \"%d\", &count);\r\n My_fscanf_for_loop_54bB2GSink(count);\r\n}\r\n\r\nvoid My_fscanf_for_loop_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_for_loop_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_for_loop_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1074:Class with Excessively Deep Inheritance\nC.CWE-788:Access of Memory Location After End of Buffer\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-682:Incorrect Calculation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_connect_socket_sub_65bSink(int data);\r\n\r\nvoid My_int_connect_socket_sub_65()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = My_int_connect_socket_sub_65bSink;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_connect_socket_sub_65bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_int_connect_socket_sub_65bG2BSink;\r\n \r\n data = 0;\r\n \r\n data = -2;\r\n funcPtr(data);\r\n}\r\n\r\n\r\nvoid My_int_connect_socket_sub_65bB2GSink(int data);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_int_connect_socket_sub_65bB2GSink;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_int_connect_socket_sub_65()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_sub_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_sub_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-241:Improper Handling of Unexpected Data Type\nD.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nE.CWE-523:Unprotected Transport of Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_42\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic list<int> mSource(list<int> data)\r\n{\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n return data;\r\n}\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n data = mSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic list<int> nG2BSource(list<int> data)\r\n{\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n data = nG2BSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n\r\nstatic list<int> nB2GSource(list<int> data)\r\n{\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n data = nB2GSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_42; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-672:Operation on a Resource after Expiration or Release|D.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-156:Improper Neutralization of Whitespace\nB.CWE-370:Missing Check for Certificate Revocation after Initial Check\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-377:Insecure Temporary File\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define TEMPNAM tempnam\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TEMPNAM tempnam\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_tempnam_01()\r\n{\r\n {\r\n char * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_tempnam_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_tempnam_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_tempnam_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-377:Insecure Temporary File|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-291:Reliance on IP Address for Authentication\nC.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nD.No Vulnerabilities\nE.CWE-297:Improper Validation of Certificate with Host Mismatch\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_file_10()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (256-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[256] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n strcat(data, \"Doe, XXXXX\");\r\n }\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n char filter[256];\r\n \r\n _snprintf(filter, 256-1, \"(cn=%s)\", data);\r\n pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sA(\r\n pLdapConnection,\r\n \"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid My_w32_char_file_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_file_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_file_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-36:Absolute Path Traversal\nC.No Vulnerabilities\nD.CWE-476:NULL Pointer Dereference\nE.CWE-293:Using Referer Field for Authentication\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <sys/types.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint trindle_emerged = 0;\r\nint global_variable;\r\n\r\nstruct flakier_cherkesser \r\n{\r\n char *jiffs_thiophosphate;\r\n double pulsatively_platycercinae;\r\n char *shintoist_photoflash;\r\n char dab_unpledged;\r\n int coracoscapular_antistes;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid *my_malloc(unsigned int size)\r\n{\r\n if (size > 512)\r\n\r\n return 0;\r\n return malloc(size);\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n unsigned int size_buffer;\r\n int buffer_value;\r\n char *malloc_buffer = 0;\r\n char *mortgager_anatomising = 0;\r\n struct flakier_cherkesser pointedly_maculated;\r\n int boutons_udometries = 5;\r\n char *remotions_exchanger;;\r\n if (__sync_bool_compare_and_swap(&trindle_emerged,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&remotions_exchanger,\"5378\",boutons_udometries);\r\n if (remotions_exchanger != 0) {;\r\n pointedly_maculated . jiffs_thiophosphate = ((char *)remotions_exchanger);\r\n if (pointedly_maculated . jiffs_thiophosphate != 0) {\r\n goto nutation_raunchiest;\r\n }\r\n ++global_variable;\r\n nutation_raunchiest:;\r\n mortgager_anatomising = ((char *)pointedly_maculated . jiffs_thiophosphate);\r\n \r\n buffer_value = atoi(mortgager_anatomising);\r\n \r\n if (buffer_value < 0)\r\n buffer_value = 0;\r\n size_buffer = ((unsigned int )buffer_value);\r\n \r\n malloc_buffer = my_malloc(size_buffer);\r\n \r\n \r\n \r\n\r\n memset(malloc_buffer,0,size_buffer);\r\n printf(\"Buffer size is %d\\n\", size_buffer);\r\n \r\n if (malloc_buffer != 0) {\r\n free(malloc_buffer);\r\n }\r\n \r\n;\r\n if (pointedly_maculated . jiffs_thiophosphate != 0) \r\n free(((char *)pointedly_maculated . jiffs_thiophosphate));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-476:NULL Pointer Dereference|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-1066:Missing Serialization Control Element\nC.No Vulnerabilities\nD.CWE-174:Double Decoding of the Same Data\nE.CWE-194:Unexpected Sign Extension\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_negative_malloc_14()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n data = -1;\r\n }\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(globalFive==5)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\nvoid My_negative_malloc_14()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_negative_malloc_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_negative_malloc_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-194:Unexpected Sign Extension|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-787:Out-of-bounds Write\nC.CWE-123:Write-what-where Condition\nD.CWE-1055:Multiple Inheritance from Concrete Classes\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nusing namespace std;\r\n\r\nnamespace My_listen_socket_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, mStruct> dataMap);\r\n\r\nvoid m()\r\n{\r\n mStruct data;\r\n map<int, mStruct> dataMap;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, mStruct> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n map<int, mStruct> dataMap;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_listen_socket_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-123:Write-what-where Condition|B.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1231:Improper Prevention of Lock Bit Modification\nB.CWE-1066:Missing Serialization Control Element\nC.CWE-223:Omission of Security-relevant Information\nD.No Vulnerabilities\nE.CWE-221:Information Loss or Omission\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SZ 15\r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login\\n\");\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login by %s\\n\", username);\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login by %s\\n\", username);\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n char username[USERNAME_SZ+1];\r\n HANDLE pHandle;\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SZ] = '\\0';\r\n \r\n \r\n fprintf(stderr, \"Attempted login by %s\\n\", username);\r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-223:Omission of Security-relevant Information|E.CWE-221:Information Loss or Omission", "cwe": "223"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1332:Improper Handling of Faults that Lead to Instruction Skips\nB.CWE-585:Empty Synchronized Block\nC.No Vulnerabilities\nD.CWE-788:Access of Memory Location After End of Buffer\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_declare_loop_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<char *> dataVector);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char dataMBuffer[50];\r\n char dataNBuffer[100];\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataMBuffer;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<char *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n vector<char *> dataVector;\r\n char dataMBuffer[50];\r\n char dataNBuffer[100];\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataNBuffer;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_declare_loop_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|D.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.No Vulnerabilities\nC.CWE-665:Improper Initialization\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_ncat_09()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data[0] = L'\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n wchar_t source[100];\r\n wmemset(source, L'C', 100-1); \r\n source[100-1] = L'\\0'; \r\n sourceLen = wcslen(source);\r\n \r\n wcsncat(data, source, sourceLen);\r\n printWLine(data);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_ncat_09()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_ncat_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_ncat_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nB.No Vulnerabilities\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-259:Use of Hard-coded Password\nE.CWE-1254:Incorrect Comparison Logic Granularity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD L\"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_17()\r\n{\r\n int i;\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n wcscpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h;\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n for(h = 0; h < 1; h++)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_17()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-510:Trapdoor\nC.CWE-600:Uncaught Exception in Servlet \nD.CWE-506:Embedded Malicious Code\nE.CWE-1220:Insufficient Granularity of Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_connection_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(80);\r\n \r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_connection_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|D.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-732:Incorrect Permission Assignment for Critical Resource\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-303:Incorrect Implementation of Authentication Algorithm\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_fscanf_multiply_01()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n if(data > 0) \r\n {\r\n \r\n int result = data * 2;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n if(data > 0) \r\n {\r\n \r\n int result = data * 2;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n if(data > 0) \r\n {\r\n \r\n if (data < (INT_MAX/2))\r\n {\r\n int result = data * 2;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_int_fscanf_multiply_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fscanf_multiply_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fscanf_multiply_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|A.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1075:Unconditional Control Flow Transfer outside of Switch Block\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.No Vulnerabilities\nD.CWE-427:Uncontrolled Search Path Element\nE.CWE-198:Use of Incorrect Byte Ordering\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\nnamespace My_char_connect_socket_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_char_connect_socket_84\r\n{\r\npublic:\r\n My_char_connect_socket_84(char * dataCopy);\r\n ~My_char_connect_socket_84();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_char_connect_socket_84G2B\r\n{\r\npublic:\r\n My_char_connect_socket_84G2B(char * dataCopy);\r\n ~My_char_connect_socket_84G2B();\r\n\r\nprivate:\r\n char * data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-385:Covert Timing Channel\nC.CWE-156:Improper Neutralization of Whitespace\nD.CWE-511:Logic/Time Bomb\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define NUM_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n srand((unsigned)time(NULL));\r\n \r\n if (rand() == NUM_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_rand_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-511:Logic/Time Bomb|A.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-416:Use After Free\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-1283:Mutable Attestation or Measurement Reporting Data\nE.CWE-263:Password Aging with Long Expiration\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nstatic char * helperM(char * aString)\r\n{\r\n size_t i = 0;\r\n size_t j;\r\n char * reversedString = NULL;\r\n if (aString != NULL)\r\n {\r\n i = strlen(aString);\r\n reversedString = (char *) malloc(i+1);\r\n if (reversedString == NULL) {exit(-1);}\r\n for (j = 0; j < i; j++)\r\n {\r\n reversedString[j] = aString[i-j-1];\r\n }\r\n reversedString[i] = '\\0';\r\n \r\n free(reversedString);\r\n return reversedString;\r\n }\r\n else\r\n {\r\n return NULL;\r\n }\r\n}\r\n\r\nstatic char * helperN(char * aString)\r\n{\r\n size_t i = 0;\r\n size_t j;\r\n char * reversedString = NULL;\r\n if (aString != NULL)\r\n {\r\n i = strlen(aString);\r\n reversedString = (char *) malloc(i+1);\r\n if (reversedString == NULL) {exit(-1);}\r\n for (j = 0; j < i; j++)\r\n {\r\n reversedString[j] = aString[i-j-1];\r\n }\r\n reversedString[i] = '\\0';\r\n \r\n return reversedString;\r\n }\r\n else\r\n {\r\n return NULL;\r\n }\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_return_freed_ptr_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char * reversedString = helperM(\"MSink\");\r\n printLine(reversedString);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n \r\n char * reversedString = helperN(\"NSink\");\r\n printLine(reversedString);\r\n \r\n }\r\n}\r\n\r\nvoid My_return_freed_ptr_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_return_freed_ptr_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_return_freed_ptr_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-1286:Improper Validation of Syntactic Correctness of Input\nC.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nD.CWE-439:Behavioral Change in New Version or Environment\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, list<int> > dataMap);\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n map<int, list<int> > dataMap;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, list<int> > dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n map<int, list<int> > dataMap;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, list<int> > dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n map<int, list<int> > dataMap;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-672:Operation on a Resource after Expiration or Release|C.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nB.CWE-400:Uncontrolled Resource Consumption\nC.CWE-693:Protection Mechanism Failure\nD.No Vulnerabilities\nE.CWE-258:Empty Password in Configuration File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_RC5_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_RC5_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_RC5_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_RC5_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|C.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-912:Hidden Functionality\nB.No Vulnerabilities\nC.CWE-506:Embedded Malicious Code\nD.CWE-213:Exposure of Sensitive Information Due to Incompatible Policies\nE.CWE-128:Wrap-around Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_base64_encoded_payload_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n char * encodedPayload = \"Y2FsYy5leGU=\";\r\n BYTE * decodedPayload = NULL;\r\n DWORD requiredLength;\r\n do\r\n {\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n NULL,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload = (BYTE*) malloc(requiredLength + 1);\r\n if (decodedPayload == NULL)\r\n {\r\n break;\r\n }\r\n \r\n if (!CryptStringToBinaryA(encodedPayload,\r\n strlen(encodedPayload),\r\n CRYPT_STRING_BASE64,\r\n decodedPayload,\r\n &requiredLength,\r\n NULL,\r\n NULL))\r\n {\r\n break;\r\n }\r\n \r\n decodedPayload[requiredLength] = '\\0';\r\n if (system((char*)decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n while (0);\r\n free(decodedPayload);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n char * decodedPayload = \"calc.exe\";\r\n if (system(decodedPayload) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_base64_encoded_payload_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_base64_encoded_payload_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_base64_encoded_payload_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-506:Embedded Malicious Code|A.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-546:Suspicious Comment\nB.CWE-1078:Inappropriate Source Code Style or Formatting\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-204:Observable Response Discrepancy\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_FIXME_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_FIXME_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_FIXME_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_FIXME_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-546:Suspicious Comment|B.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-322:Key Exchange without Entity Authentication\nB.CWE-761:Free of Pointer not at Start of Buffer\nC.No Vulnerabilities\nD.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe\nE.CWE-364:Signal Handler Race Condition\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\n#include <fcntl.h> \r\n#include <math.h> \r\n#include <signal.h> \r\nint imamship_arbalister = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nchar *faker_creolizing(char *finely_sciatica);\r\nvoid primely_autobiographies(char *micropodous_bombycidae);\r\nint SIZE = 50;\r\nchar *playful_platypus;\r\nstruct data {\r\n char *data;\r\n};\r\nstruct data *Data;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid sig_handler (int sig) {\r\n printf(\"In sig_handler\\n\");\r\n \r\n \r\n \r\n \r\n \r\n if (playful_platypus[0] != '\\0') { \r\n printf(playful_platypus);\r\n }\r\n \r\n}\r\nvoid waitForSig(char *sleepFile) {\r\n int fd;\r\n char outStr[25] = {0};\r\n char filename[500] = {0};\r\n \r\n printf(\"In waitForSig\\n\");\r\n sprintf(outStr, \"%d.pid\", getpid());\r\n strcat(filename, \"/opt//workspace/testData/\");\r\n strcat(filename, outStr);\r\n if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\r\n \r\n printf(\"Error opening file.\");\r\n }\r\n else {\r\n if (write(fd, \"q\", sizeof(char)) == -1) {\r\n \r\n printf(\"Error writing to file.\");\r\n }\r\n if (close(fd) == -1) {\r\n \r\n printf(\"Error closing file.\");\r\n }\r\n \r\n readFile(sleepFile);\r\n }\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n#define MAJORCAN_CHASSEPOTS(x) primely_autobiographies((char *) x)\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n char *pisces_bundelkhand = 0;\r\n int dictions_gloiosiphonia = 0;\r\n char *bulldozed_pentaploidy = 0;\r\n int affreighter_shoneen = 119;\r\n char *limnobium_festers;;\r\n if (__sync_bool_compare_and_swap(&imamship_arbalister,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&limnobium_festers,\"8958\",affreighter_shoneen);\r\n if (limnobium_festers != 0) {;\r\n dictions_gloiosiphonia = ((int )(strlen(limnobium_festers)));\r\n bulldozed_pentaploidy = ((char *)(malloc(dictions_gloiosiphonia + 1)));\r\n if (bulldozed_pentaploidy == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(bulldozed_pentaploidy,0,dictions_gloiosiphonia + 1);\r\n memcpy(bulldozed_pentaploidy,limnobium_festers,dictions_gloiosiphonia);\r\n if (limnobium_festers != 0) \r\n free(((char *)limnobium_festers));\r\n pisces_bundelkhand = faker_creolizing(bulldozed_pentaploidy);\r\n\tMAJORCAN_CHASSEPOTS(pisces_bundelkhand);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nchar *faker_creolizing(char *finely_sciatica)\r\n{\r\n ++global_variable;\r\n return finely_sciatica;\r\n}\r\n\r\nvoid primely_autobiographies(char *micropodous_bombycidae)\r\n{\r\n int i;\r\n char *temp;\r\n char *sleepFile;\r\n char *impelled_ringle = 0;\r\n ++global_variable;;\r\n impelled_ringle = ((char *)micropodous_bombycidae);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n sleepFile = malloc(sizeof(char) * (strlen(impelled_ringle) + 1));\r\n Data->data = malloc(sizeof(char) * (strlen(impelled_ringle) + 1));\r\n if (Data->data) {\r\n if ((sscanf(impelled_ringle, \"%s %s\",\r\n sleepFile,\r\n Data->data) == 2) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(sleepFile) != 0))\r\n {\r\n \r\n \r\n if (signal(SIGUSR1, sig_handler) == SIG_ERR) {\r\n \r\n printf (\"Error catching SIGNUSR1!\\n\");\r\n }\r\n playful_platypus = malloc(sizeof(char) * (SIZE + 1));\r\n i = 0;\r\n while (Data->data[i] != '\\0') { \r\n if (i < SIZE) {\r\n playful_platypus[i] = Data->data[i];\r\n i++;\r\n } else { \r\n playful_platypus[SIZE] = '\\0';\r\n \r\n \r\n SIZE *= 2;\r\n temp = malloc(sizeof(char) * SIZE);\r\n strcpy(temp, playful_platypus);\r\n free(playful_platypus);\r\n playful_platypus = NULL; \r\n \r\n waitForSig(sleepFile);\r\n \r\n playful_platypus = temp;\r\n \r\n }\r\n }\r\n free (playful_platypus);\r\n signal(SIGUSR1, SIG_IGN); \r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free (Data);\r\n }\r\n \r\n;\r\n if (micropodous_bombycidae != 0) \r\n free(((char *)micropodous_bombycidae));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe|E.CWE-364:Signal Handler Race Condition", "cwe": "828"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nB.CWE-773:Missing Reference to Active File Descriptor or Handle\nC.CWE-1193:Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\nD.No Vulnerabilities\nE.CWE-771:Missing Reference to Active Allocated Resource\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_31()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n {\r\n int dataCopy = data;\r\n int data = dataCopy;\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_31()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-773:Missing Reference to Active File Descriptor or Handle|E.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.No Vulnerabilities\nC.CWE-190:Integer Overflow or Wraparound\nD.CWE-375:Returning a Mutable Object to an Untrusted Caller\nE.CWE-222:Truncation of Security-relevant Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(int data)\r\n{\r\n {\r\n \r\n data++;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\nvoid My_int_fscanf_postinc_41()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(int data)\r\n{\r\n {\r\n \r\n data++;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(int data)\r\n{\r\n \r\n if (data < INT_MAX)\r\n {\r\n data++;\r\n int result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n nB2GSink(data);\r\n}\r\n\r\nvoid My_int_fscanf_postinc_41()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fscanf_postinc_41();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fscanf_postinc_41();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-190:Integer Overflow or Wraparound|A.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1107:Insufficient Isolation of Symbolic Constant Definitions\nB.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')\nC.CWE-704:Incorrect Type Conversion or Cast\nD.No Vulnerabilities\nE.CWE-1296:Incorrect Chaining or Granularity of Debug Components\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_31()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n short shortBuffer = 8;\r\n data = &shortBuffer;\r\n }\r\n {\r\n void * dataCopy = data;\r\n void * data = dataCopy;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n \r\n data = NULL;\r\n {\r\n \r\n int intBuffer = 8;\r\n data = &intBuffer;\r\n }\r\n {\r\n void * dataCopy = data;\r\n void * data = dataCopy;\r\n \r\n printIntLine(*((int*)data));\r\n }\r\n}\r\n\r\nvoid My_short_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-843:Access of Resource Using Incompatible Type ('Type Confusion')|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "843"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.CWE-301:Reflection Attack in an Authentication Protocol\nC.CWE-354:Improper Validation of Integrity Check Value\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_declare_loop_04()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = dataBuffer - 8;\r\n }\r\n {\r\n size_t i;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n size_t i;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n data = dataBuffer;\r\n }\r\n {\r\n size_t i;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n for (i = 0; i < 100; i++)\r\n {\r\n data[i] = source[i];\r\n }\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_declare_loop_04()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_loop_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_loop_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-124:Buffer Underwrite ('Buffer Underflow')|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-474:Use of Function with Inconsistent Implementations\nB.No Vulnerabilities\nC.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nD.CWE-252:Unchecked Return Value\nE.CWE-51:Path Equivalence: '/multiple//internal/slash'\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef union\r\n{\r\n FILE * unionFirst;\r\n FILE * unionSecond;\r\n} My_fopen_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_34()\r\n{\r\n FILE * data;\r\n My_fopen_34_unionType myUnion;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"file.txt\", \"w+\");\r\n myUnion.unionFirst = data;\r\n {\r\n FILE * data = myUnion.unionSecond;\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n My_fopen_34_unionType myUnion;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"file.txt\", \"w+\");\r\n myUnion.unionFirst = data;\r\n {\r\n FILE * data = myUnion.unionSecond;\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_34()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-690:Unchecked Return Value to NULL Pointer Dereference|D.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-674:Uncontrolled Recursion\nC.CWE-259:Use of Hard-coded Password\nD.CWE-761:Free of Pointer not at Start of Buffer\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_listen_socket_32()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t * *dataPtr1 = &data;\r\n wchar_t * *dataPtr2 = &data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n {\r\n wchar_t * data = *dataPtr1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n *dataPtr1 = data;\r\n }\r\n {\r\n wchar_t * data = *dataPtr2;\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_listen_socket_32()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_listen_socket_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_listen_socket_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-761:Free of Pointer not at Start of Buffer|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-617:Reachable Assertion\nC.CWE-568:finalize() Method Without super.finalize()\nD.No Vulnerabilities\nE.CWE-402:Transmission of Private Resources into a New Sphere ('Resource Leak')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\ntypedef union\r\n{\r\n int unionFirst;\r\n int unionSecond;\r\n} My_fixed_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fixed_34()\r\n{\r\n int data;\r\n My_fixed_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE-1;\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n assert(data > ASSERT_VALUE);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_fixed_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n assert(data > ASSERT_VALUE);\r\n }\r\n}\r\n\r\nvoid My_fixed_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fixed_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fixed_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-617:Reachable Assertion|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-796:Only Filtering Special Elements Relative to a Marker\nB.CWE-52:Path Equivalence: '/multiple/trailing/slash//'\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.No Vulnerabilities\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\nnamespace My_wchar_t_file_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(wchar_t * &data)\r\n{\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n mSource(data);\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2GSource(wchar_t * &data)\r\n{\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n nB2GSource(data);\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_file_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.No Vulnerabilities\nC.CWE-14:Compiler Removal of Code to Clear Buffers\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-1176:Inefficient CPU Computation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_connect_socket_sub_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_int_connect_socket_sub_64()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_int_connect_socket_sub_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_connect_socket_sub_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n \r\n data = -2;\r\n My_int_connect_socket_sub_64bG2BSink(&data);\r\n}\r\n\r\n\r\nvoid My_int_connect_socket_sub_64bB2GSink(void * dataVoidPtr);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_int_connect_socket_sub_64bB2GSink(&data);\r\n}\r\n\r\nvoid My_int_connect_socket_sub_64()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_sub_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_sub_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-646:Reliance on File Name or Extension of Externally-Supplied File\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.CWE-23:Relative Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_file_ofstream_01\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n \r\n strcat(data, \"file.txt\");\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_ofstream_01; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-23:Relative Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-620:Unverified Password Change\nC.CWE-1390:Weak Authentication\nD.CWE-55:Path Equivalence: '/./' (Single Dot Directory)\nE.CWE-921:Storage of Sensitive Data in a Mechanism without Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <lm.h>\r\n#pragma comment(lib, \"netapi32.lib\")\r\n#define USERNAME L\"cwe620testuser\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n wchar_t newPassword[256];\r\n USER_INFO_1003 myUserInfo;\r\n NET_API_STATUS status;\r\n myUserInfo.usri1003_password = newPassword;\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", myUserInfo.usri1003_password) != 1)\r\n {\r\n myUserInfo.usri1003_password[0] = L'\\0';\r\n }\r\n \r\n status = NetUserSetInfo(NULL, USERNAME, 1003, (LPBYTE)&myUserInfo, NULL);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserSetInfo failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n wchar_t oldPassword[256];\r\n wchar_t newPassword[256];\r\n NET_API_STATUS status;\r\n printWLine(L\"Enter old password: \");\r\n if (fwscanf(stdin, L\"%255s\", oldPassword) != 1)\r\n {\r\n oldPassword[0] = L'\\0';\r\n }\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", newPassword) != 1)\r\n {\r\n newPassword[0] = L'\\0';\r\n }\r\n \r\n status = NetUserChangePassword(NULL, USERNAME, oldPassword, newPassword);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserChangePassword failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n wchar_t oldPassword[256];\r\n wchar_t newPassword[256];\r\n NET_API_STATUS status;\r\n printWLine(L\"Enter old password: \");\r\n if (fwscanf(stdin, L\"%255s\", oldPassword) != 1)\r\n {\r\n oldPassword[0] = L'\\0';\r\n }\r\n printWLine(L\"Enter new password: \");\r\n if (fwscanf(stdin, L\"%255s\", newPassword) != 1)\r\n {\r\n newPassword[0] = L'\\0';\r\n }\r\n \r\n status = NetUserChangePassword(NULL, USERNAME, oldPassword, newPassword);\r\n if(status == NERR_Success)\r\n {\r\n printWLine(L\"Success!\");\r\n }\r\n else\r\n {\r\n wprintf(L\"NetUserChangePassword failed. Status = %u = 0x%x\\n\", status, status);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-620:Unverified Password Change|C.CWE-1390:Weak Authentication", "cwe": "620"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-768:Incorrect Short Circuit Evaluation\nB.No Vulnerabilities\nC.CWE-1122:Excessive Halstead Complexity\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_new_delete_wchar_t_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t;\r\n *data = L'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWcharLine(*data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t;\r\n *data = L'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t;\r\n *data = L'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new wchar_t;\r\n *data = L'A';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWcharLine(*data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new wchar_t;\r\n *data = L'A';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printWcharLine(*data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_wchar_t_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-822:Untrusted Pointer Dereference\nB.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\nC.CWE-1261:Improper Handling of Single Event Upsets\nD.No Vulnerabilities\nE.CWE-912:Hidden Functionality\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint broadness_isi = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid eulytine_duplon(char **const noneuphonious_afips);\r\nvoid whereto_desktops(int ergotinine_itabuna,char **cosmos_contemporize);\r\ntypedef int (*fct_ptr)(const char *, const char *);\r\nfct_ptr switch_func(char *param)\r\n{\r\n \r\n int var_len = 0;\r\n fct_ptr fct_ptr_addr = (fct_ptr )0;\r\n var_len = strlen(param) % 3;\r\n if (var_len == 0) {\r\n return strcmp;\r\n }\r\n else if (var_len == 1) {\r\n return strcoll;\r\n }\r\n else {\r\n sscanf(param,\"%p\",&fct_ptr_addr);\r\n return fct_ptr_addr;\r\n }\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n char *vintnership_kaufman[27] = {0};\r\n char *norpinic_orpington;;\r\n if (__sync_bool_compare_and_swap(&broadness_isi,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n norpinic_orpington = getenv(\"SOMNAMBULOUS_ILYSIOID\");\r\n if (norpinic_orpington != 0) {;\r\n vintnership_kaufman[2] = norpinic_orpington;\r\n eulytine_duplon(vintnership_kaufman);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid eulytine_duplon(char **const noneuphonious_afips)\r\n{\r\n int pentoic_toupet = 7;\r\n ++global_variable;;\r\n whereto_desktops(pentoic_toupet,noneuphonious_afips);\r\n}\r\n\r\nvoid whereto_desktops(int ergotinine_itabuna,char **cosmos_contemporize)\r\n{\r\n int cmp_flag = 0;\r\n char *centrechinoida_jenei = 0;\r\n ++global_variable;\r\n ergotinine_itabuna--;\r\n if (ergotinine_itabuna > 0) {\r\n whereto_desktops(ergotinine_itabuna,cosmos_contemporize);\r\n return ;\r\n }\r\n centrechinoida_jenei = ((char *)((char **)cosmos_contemporize)[2]);\r\n \r\n \r\n \r\n fct_ptr fp;\r\n const char *rand_word = \"criticisms_metallide\";\r\n fp = switch_func(centrechinoida_jenei);\r\n \r\n \r\n \r\n \r\n cmp_flag = ( *fp)(rand_word,centrechinoida_jenei);\r\n \r\n if (cmp_flag == 0)\r\n printf(\"strings are equal\\n\");\r\n else\r\n printf(\"strings are not equal\\n\");\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-822:Untrusted Pointer Dereference|B.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer", "cwe": "822"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1240:Use of a Cryptographic Primitive with a Risky Implementation\nB.CWE-36:Absolute Path Traversal\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-484:Omitted Break Statement in Switch\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-484:Omitted Break Statement in Switch|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "484"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-628:Function Call with Incorrectly Specified Arguments\nC.CWE-685:Function Call With Incorrect Number of Arguments\nD.CWE-643:Improper Neutralization of Data within XPath Expressions ('XPath Injection')\nE.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 100 \r\n#define SOURCE_STRING \"AAA\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n \r\n sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-685:Function Call With Incorrect Number of Arguments|B.CWE-628:Function Call with Incorrectly Specified Arguments", "cwe": "685"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-240:Improper Handling of Inconsistent Structural Elements\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.No Vulnerabilities\nD.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_realloc_08()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (int *)realloc(data, 100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n \r\n data[0] = 5;\r\n printIntLine(data[0]);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (int *)realloc(data, 100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n \r\n data[0] = 5;\r\n printIntLine(data[0]);\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (int *)realloc(data, 100*sizeof(int));\r\n if (data == NULL) {exit(-1);}\r\n \r\n data[0] = 5;\r\n printIntLine(data[0]);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = (int *)ALLOCA(100*sizeof(int));\r\n \r\n data[0] = 5;\r\n printIntLine(data[0]);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = (int *)ALLOCA(100*sizeof(int));\r\n \r\n data[0] = 5;\r\n printIntLine(data[0]);\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid My_int_realloc_08()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_realloc_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_realloc_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-311:Missing Encryption of Sensitive Data\nB.No Vulnerabilities\nC.CWE-61:UNIX Symbolic Link (Symlink) Following\nD.CWE-1234:Hardware Internal or Debug Modes Allow Override of Locks\nE.CWE-319:Cleartext Transmission of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_listen_socket_10()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t passwordLen = strlen(password);\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n password[passwordLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(char)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(char));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(char)] = '\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(globalTrue)\r\n {\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_listen_socket_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_listen_socket_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_listen_socket_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-319:Cleartext Transmission of Sensitive Information|A.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.No Vulnerabilities\nC.CWE-590:Free of Memory not on the Heap\nD.CWE-1280:Access Control Check Implemented After Asset is Accessed\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_delete_char_placement_new_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL; \r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n char buffer[sizeof(char)];\r\n char * dataBuffer = new(buffer) char;\r\n *dataBuffer = 'A';\r\n data = dataBuffer;\r\n }\r\n }\r\n printHexCharLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL; \r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char * dataBuffer = new char;\r\n *dataBuffer = 'A';\r\n data = dataBuffer;\r\n }\r\n }\r\n printHexCharLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL; \r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n \r\n char * dataBuffer = new char;\r\n *dataBuffer = 'A';\r\n data = dataBuffer;\r\n }\r\n }\r\n printHexCharLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_char_placement_new_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-590:Free of Memory not on the Heap|E.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-122:Heap-based Buffer Overflow\nB.CWE-297:Improper Validation of Certificate with Host Mismatch\nC.CWE-787:Out-of-bounds Write\nD.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\nnamespace My_c_My_c_CWE193_char_memmove_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-122:Heap-based Buffer Overflow|C.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-151:Improper Neutralization of Comment Delimiters\nC.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nD.CWE-252:Unchecked Return Value\nE.CWE-690:Unchecked Return Value to NULL Pointer Dereference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_long_realloc_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(long * &data);\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n data = NULL; \r\n mSource(data);\r\n \r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(long * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n long * data;\r\n data = NULL; \r\n nB2GSource(data);\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_long_realloc_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-690:Unchecked Return Value to NULL Pointer Dereference|D.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-479:Signal Handler Use of a Non-reentrant Function\nB.No Vulnerabilities\nC.CWE-426:Untrusted Search Path\nD.CWE-300:Channel Accessible by Non-Endpoint\nE.CWE-673:External Influence of Sphere Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND \"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND \"ls -la\"\r\n#define N_OS_COMMAND \"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM system\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_system_15()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcpy(data, M_OS_COMMAND);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n break;\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcpy(data, N_OS_COMMAND);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_char_system_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_system_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_system_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-426:Untrusted Search Path|E.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-786:Access of Memory Location Before Start of Buffer\nC.CWE-127:Buffer Under-read\nD.CWE-311:Missing Encryption of Sensitive Data\nE.CWE-1069:Empty Exception Block\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_alloca_ncpy_52bSink(char * data);\r\n\r\nvoid My_char_alloca_ncpy_52()\r\n{\r\n char * data;\r\n char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n My_char_alloca_ncpy_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_alloca_ncpy_52bG2BSink(char * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n My_char_alloca_ncpy_52bG2BSink(data);\r\n}\r\n\r\nvoid My_char_alloca_ncpy_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_alloca_ncpy_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_alloca_ncpy_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|B.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-346:Origin Validation Error\nE.CWE-1283:Mutable Attestation or Measurement Reporting Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_strdup_delete_array_wchar_t_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n {\r\n wchar_t myString[] = L\"myString\";\r\n \r\n data = wcsdup(myString);\r\n }\r\n }\r\n if(1)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n {\r\n wchar_t myString[] = L\"myString\";\r\n \r\n data = wcsdup(myString);\r\n }\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n {\r\n wchar_t myString[] = L\"myString\";\r\n \r\n data = wcsdup(myString);\r\n }\r\n }\r\n if(1)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new wchar_t[100];\r\n }\r\n if(1)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n \r\n data = new wchar_t[100];\r\n }\r\n if(1)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_strdup_delete_array_wchar_t_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-123:Write-what-where Condition\nB.No Vulnerabilities\nC.CWE-787:Out-of-bounds Write\nD.CWE-437:Incomplete Model of Endpoint Features\nE.CWE-695:Use of Low-Level Functionality\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nnamespace My_listen_socket_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(mStruct &data)\r\n{\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n mSource(data);\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(mStruct &data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n nG2BSource(data);\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_listen_socket_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-123:Write-what-where Condition|C.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-587:Assignment of a Fixed Address to a Pointer\nB.CWE-426:Untrusted Search Path\nC.No Vulnerabilities\nD.CWE-344:Use of Invariant Value in Dynamically Changing Context\nE.CWE-1188:Initialization of a Resource with an Insecure Default\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n char *charPointer = (char*)0x400000;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-587:Assignment of a Fixed Address to a Pointer|D.CWE-344:Use of Invariant Value in Dynamically Changing Context", "cwe": "587"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-404:Improper Resource Shutdown or Release\nE.CWE-600:Uncaught Exception in Servlet \n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CreateFile_fclose_14()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalFive==5)\r\n {\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n fclose((FILE *)data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n \r\n data = INVALID_HANDLE_VALUE;\r\n \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n if(globalFive==5)\r\n {\r\n if (data != INVALID_HANDLE_VALUE)\r\n {\r\n \r\n CloseHandle(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_fclose_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_fclose_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_fclose_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-404:Improper Resource Shutdown or Release|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-820:Missing Synchronization\nB.CWE-522:Insufficiently Protected Credentials\nC.No Vulnerabilities\nD.CWE-662:Improper Synchronization\nE.CWE-798:Use of Hard-coded Credentials\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint pommeller_cataphracted = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid *kingu_lionizable(void *seisable_interrupter);\r\nvoid peckville_thiocarbanilide(int sprattling_ballocks,void *edmondson_nonelectrolyte);\r\nstruct data {\r\n int inc_amount;\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcIncamount(void *data) {\r\n struct data *dataStruct = (struct data*)data;\r\n printf(\"In calcInamount\\n\");\r\n \r\n \r\n \r\n dataStruct->inc_amount = dataStruct->data[0] - 'A'; \r\n \r\n readFile(dataStruct->file2);\r\n if (dataStruct->inc_amount < 0) { \r\n dataStruct->inc_amount *= -1; \r\n }\r\n else if (dataStruct->inc_amount == 0) { \r\n dataStruct->inc_amount += 1;\r\n }\r\n \r\n \r\n return NULL;\r\n}\r\nvoid *toPound(void *data) {\r\n int i;\r\n struct data *dataStruct = (struct data*)data;\r\n int *arr = NULL;\r\n \r\n printf(\"In toPound\\n\");\r\n \r\n arr = malloc(sizeof(int) * dataStruct->qsize);\r\n for (i = 0; i < dataStruct->qsize; i++) {\r\n arr[i] = dataStruct->qsize - i;\r\n }\r\n qsort(arr, dataStruct->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(dataStruct->file1);\r\n \r\n \r\n \r\n for (i = 0; i < (int)strlen(dataStruct->data) - 1;\r\n i += dataStruct->inc_amount) \r\n {\r\n dataStruct->data[i] = '#'; \r\n }\r\n \r\n return NULL;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n int declamations_petromyzontes = 7;\r\n void *procellose_edneyville = 0;\r\n void *vexedly_spondyle = 0;\r\n int surficial_vibrations = 149;\r\n char *procarnival_bme;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&pommeller_cataphracted,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&procarnival_bme,\"5105\",surficial_vibrations);\r\n if (procarnival_bme != 0) {;\r\n vexedly_spondyle = ((void *)procarnival_bme);\r\n procellose_edneyville = kingu_lionizable(vexedly_spondyle);\r\n peckville_thiocarbanilide(declamations_petromyzontes,procellose_edneyville);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid *kingu_lionizable(void *seisable_interrupter)\r\n{\r\n ++global_variable;\r\n return seisable_interrupter;\r\n}\r\n\r\nvoid peckville_thiocarbanilide(int sprattling_ballocks,void *edmondson_nonelectrolyte)\r\n{\r\n pthread_t t0, t1;\r\n struct data *dataStruct = malloc(sizeof(struct data));\r\n char *cretinistic_phonematic = 0;\r\n ++global_variable;\r\n sprattling_ballocks--;\r\n if (sprattling_ballocks > 0) {\r\n peckville_thiocarbanilide(sprattling_ballocks,edmondson_nonelectrolyte);\r\n return ;\r\n }\r\n cretinistic_phonematic = ((char *)((char *)edmondson_nonelectrolyte));\r\n \r\n if (dataStruct) {\r\n dataStruct->inc_amount = 1;\r\n dataStruct->data = malloc(sizeof(char) * (strlen(cretinistic_phonematic) + 1));\r\n dataStruct->file1 = malloc(sizeof(char) * (strlen(cretinistic_phonematic) + 1));\r\n dataStruct->file2 = malloc(sizeof(char) * (strlen(cretinistic_phonematic) + 1));\r\n if (dataStruct->data) {\r\n if ((sscanf(cretinistic_phonematic, \"%d %s %s %s\",\r\n &(dataStruct->qsize),\r\n dataStruct->file1,\r\n dataStruct->file2,\r\n dataStruct->data) == 4) &&\r\n (strlen(dataStruct->data) != 0) &&\r\n (strlen(dataStruct->file1) != 0) &&\r\n (strlen(dataStruct->file2) != 0)) {\r\n \r\n \r\n \r\n \r\n \r\n if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\r\n printf(\"Error initializing thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n }\r\n free(dataStruct->data);\r\n } else {\r\n \r\n printf(\"Error parsing data.\\n\");\r\n }\r\n free (dataStruct);\r\n } else {\r\n \r\n printf(\"Error malloc()ing space for struct.\\n\");\r\n }\r\n \r\n;\r\n if (((char *)edmondson_nonelectrolyte) != 0) \r\n free(((char *)((char *)edmondson_nonelectrolyte)));\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-820:Missing Synchronization|D.CWE-662:Improper Synchronization", "cwe": "820"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-138:Improper Neutralization of Special Elements\nC.CWE-224:Obscured Security-relevant Information by Alternate Name\nD.CWE-696:Incorrect Behavior Order\nE.CWE-464:Addition of Data Structure Sentinel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n char data;\r\n data = ' ';\r\n if(1)\r\n {\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char data;\r\n data = ' ';\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char data;\r\n data = ' ';\r\n if(1)\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-464:Addition of Data Structure Sentinel|B.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-489:Active Debug Code\nC.CWE-357:Insufficient UI Warning of Dangerous Operations\nD.CWE-391:Unchecked Error Condition\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_strtol_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n long longNumber;\r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n long longNumber;\r\n errno = 0; \r\n longNumber = strtol(\"0xfffffffff\", NULL, 0);\r\n \r\n if (errno == ERANGE)\r\n {\r\n printLine(\"strtol() failed\");\r\n exit(1);\r\n }\r\n printf(\"%li\\n\", longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_strtol_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_strtol_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_strtol_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-391:Unchecked Error Condition|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nC.CWE-584:Return Inside Finally Block\nD.CWE-761:Free of Pointer not at Start of Buffer\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_environment_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(map<int, char *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n data = (char *)malloc(100*sizeof(char));\r\n data[0] = '\\0';\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_environment_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-761:Free of Pointer not at Start of Buffer|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-791:Incomplete Filtering of Special Elements\nB.No Vulnerabilities\nC.CWE-396:Declaration of Catch for Generic Exception\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-925:Improper Verification of Intent by Broadcast Receiver\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_and_domain_error_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(1)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n catch (domain_error &)\r\n {\r\n \r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_and_domain_error_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-396:Declaration of Catch for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1191:On-Chip Debug and Test Interface With Improper Access Control\nC.CWE-332:Insufficient Entropy in PRNG\nD.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nE.CWE-459:Incomplete Cleanup\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_declare_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_declare_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_declare_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_declare_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|E.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-352:Cross-Site Request Forgery (CSRF)\nB.CWE-791:Incomplete Filtering of Special Elements\nC.No Vulnerabilities\nD.CWE-1272:Sensitive Information Uncleared Before Debug/Power State Transition\nE.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\n", "input": "void AppLauncherHandler::Observe(int type,\r\r\n const content::NotificationSource& source,\r\r\n const content::NotificationDetails& details) {\r\r\n if (type == chrome::NOTIFICATION_APP_INSTALLED_TO_NTP) {\r\r\n highlight_app_id_ = *content::Details<const std::string>(details).ptr();\r\r\n if (has_loaded_apps_)\r\r\n SetAppToBeHighlighted();\r\r\n return;\r\r\n }\r\r\n\r\r\n if (ignore_changes_ || !has_loaded_apps_)\r\r\n return;\r\r\n\r\r\n switch (type) {\r\r\n case chrome::NOTIFICATION_EXTENSION_LOADED_DEPRECATED: {\r\r\n const Extension* extension =\r\r\n content::Details<const Extension>(details).ptr();\r\r\n if (!extension->is_app())\r\r\n return;\r\r\n\r\r\n if (!extensions::ui_util::ShouldDisplayInNewTabPage(\r\r\n extension, Profile::FromWebUI(web_ui()))) {\r\r\n return;\r\r\n }\r\r\n\r\r\n scoped_ptr<base::DictionaryValue> app_info(GetAppInfo(extension));\r\r\n if (app_info.get()) {\r\r\n visible_apps_.insert(extension->id());\r\r\n\r\r\n ExtensionPrefs* prefs =\r\r\n ExtensionPrefs::Get(extension_service_->profile());\r\r\n scoped_ptr<base::FundamentalValue> highlight(\r\r\n base::Value::CreateBooleanValue(\r\r\n prefs->IsFromBookmark(extension->id()) &&\r\r\n attempted_bookmark_app_install_));\r\r\n attempted_bookmark_app_install_ = false;\r\r\n web_ui()->CallJavascriptFunction(\r\r\n \"ntp.appAdded\", *app_info, *highlight);\r\r\n }\r\r\n\r\r\n break;\r\r\n }\r\r\n case chrome::NOTIFICATION_EXTENSION_UNLOADED_DEPRECATED:\r\r\n case chrome::NOTIFICATION_EXTENSION_UNINSTALLED: {\r\r\n const Extension* extension = NULL;\r\r\n bool uninstalled = false;\r\r\n if (type == chrome::NOTIFICATION_EXTENSION_UNINSTALLED) {\r\r\n extension = content::Details<const Extension>(details).ptr();\r\r\n uninstalled = true;\r\r\n } else { // NOTIFICATION_EXTENSION_UNLOADED_DEPRECATED\r\r\n if (content::Details<UnloadedExtensionInfo>(details)->reason ==\r\r\n UnloadedExtensionInfo::REASON_UNINSTALL) {\r\r\n return;\r\r\n }\r\r\n extension = content::Details<extensions::UnloadedExtensionInfo>(\r\r\n details)->extension;\r\r\n uninstalled = false;\r\r\n }\r\r\n if (!extension->is_app())\r\r\n return;\r\r\n\r\r\n if (!extensions::ui_util::ShouldDisplayInNewTabPage(\r\r\n extension, Profile::FromWebUI(web_ui()))) {\r\r\n return;\r\r\n }\r\r\n\r\r\n scoped_ptr<base::DictionaryValue> app_info(GetAppInfo(extension));\r\r\n if (app_info.get()) {\r\r\n if (uninstalled)\r\r\n visible_apps_.erase(extension->id());\r\r\n\r\r\n scoped_ptr<base::FundamentalValue> uninstall_value(\r\r\n base::Value::CreateBooleanValue(uninstalled));\r\r\n scoped_ptr<base::FundamentalValue> from_page(\r\r\n base::Value::CreateBooleanValue(!extension_id_prompting_.empty()));\r\r\n web_ui()->CallJavascriptFunction(\r\r\n \"ntp.appRemoved\", *app_info, *uninstall_value, *from_page);\r\r\n }\r\r\n break;\r\r\n }\r\r\n case chrome::NOTIFICATION_EXTENSION_LAUNCHER_REORDERED: {\r\r\n const std::string* id =\r\r\n content::Details<const std::string>(details).ptr();\r\r\n if (id) {\r\r\n const Extension* extension =\r\r\n extension_service_->GetInstalledExtension(*id);\r\r\n if (!extension) {\r\r\n return;\r\r\n }\r\r\n\r\r\n base::DictionaryValue app_info;\r\r\n CreateAppInfo(extension,\r\r\n extension_service_,\r\r\n &app_info);\r\r\n web_ui()->CallJavascriptFunction(\"ntp.appMoved\", app_info);\r\r\n } else {\r\r\n HandleGetApps(NULL);\r\r\n }\r\r\n break;\r\r\n }\r\r\n case chrome::NOTIFICATION_EXTENSION_INSTALL_ERROR: {\r\r\n CrxInstaller* crx_installer = content::Source<CrxInstaller>(source).ptr();\r\r\n if (!Profile::FromWebUI(web_ui())->IsSameProfile(\r\r\n crx_installer->profile())) {\r\r\n return;\r\r\n }\r\r\n }\r\r\n case chrome::NOTIFICATION_EXTENSION_LOAD_ERROR: {\r\r\n attempted_bookmark_app_install_ = false;\r\r\n break;\r\r\n }\r\r\n default:\r\r\n NOTREACHED();\r\r\n }\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.No Vulnerabilities|C.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-832:Unlock of a Resource that is not Locked\nB.CWE-667:Improper Locking\nC.No Vulnerabilities\nD.CWE-1087:Class with Virtual Method without a Virtual Destructor\nE.CWE-351:Insufficient Type Distinction\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-832:Unlock of a Resource that is not Locked|B.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-409:Improper Handling of Highly Compressed Data (Data Amplification)\nC.CWE-617:Reachable Assertion\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-688:Function Call With Incorrect Variable or Reference as Argument\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_08()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fgets_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-617:Reachable Assertion|D.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-587:Assignment of a Fixed Address to a Pointer\nB.CWE-20:Improper Input Validation\nC.CWE-563:Assignment to Variable without Use\nD.No Vulnerabilities\nE.CWE-1164:Irrelevant Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_init_variable_int64_t_17()\r\n{\r\n int j;\r\n int64_t data;\r\n \r\n data = 5LL;\r\n for(j = 0; j < 1; j++)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int k;\r\n int64_t data;\r\n \r\n data = 5LL;\r\n for(k = 0; k < 1; k++)\r\n {\r\n \r\n printLongLongLine(data);\r\n }\r\n}\r\n\r\nvoid My_unused_init_variable_int64_t_17()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_init_variable_int64_t_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_init_variable_int64_t_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|E.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-914:Improper Control of Dynamically-Identified Variables\nB.No Vulnerabilities\nC.CWE-609:Double-Checked Locking\nD.CWE-667:Improper Locking\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nint unmythical_discreated = 0;\r\nint global_variable;\r\ntypedef char *meningomalacia_coadmires;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nstruct data {\r\n int qsize;\r\n int data_size;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\nstruct data2 {\r\n int qsize;\r\n int data_size;\r\n int data_size2;\r\n char *data;\r\n char *data2;\r\n};\r\npthread_mutex_t mutex;\r\nint comp (const void * a, const void * b)\r\n{\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b)\r\n{\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nstruct data2 *ssD2 = 0;\r\nstruct data2 *init_data2 (struct data *ssD) {\r\n \r\n \r\n printf(\"Checking for initalization\\n\");\r\n \r\n if (ssD2 == NULL) {\r\n pthread_mutex_lock(&mutex);\r\n if (ssD2 == NULL) {\r\n printf(\"Initializing\\n\");\r\n ssD2 = calloc(1, sizeof(struct data2));\r\n readFile(ssD->file2);\r\n ssD2->data = ssD->data;\r\n ssD2->qsize = ssD->qsize;\r\n ssD2->data_size = ssD->data_size;\r\n ssD2->data2 = ssD->data;\r\n ssD2->data_size2 = ssD->data_size;\r\n } else {\r\n printf(\"No need to initialize\\n\");\r\n }\r\n pthread_mutex_unlock(&mutex);\r\n } else {\r\n printf(\"Data is already initialized\\n\");\r\n }\r\n \r\n return ssD2;\r\n}\r\nvoid *doStuff(void *ssD) {\r\n struct data2 *ssD2;\r\n \r\n printf(\"Inside doStuff\\n\");\r\n ssD2 = init_data2((struct data*)ssD);\r\n return NULL;\r\n}\r\nvoid *doStuff2(void *Data) {\r\n struct data2 *ssD2;\r\n struct data *ssD = Data;\r\n int i;\r\n int *arr;\r\n \r\n printf(\"Inside doStuff2\\n\");\r\n arr = malloc(sizeof(int) * ssD->qsize);\r\n for (i = 0; i < ssD->qsize; i++) {\r\n arr[i] = ssD->qsize - i;\r\n }\r\n qsort(arr, ssD->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(ssD->file1);\r\n ssD2 = init_data2((struct data*)ssD);\r\n \r\n \r\n \r\n \r\n if (ssD2->data2[0] != '\\0') {\r\n printf(\"%s\\n\", ssD2->data2);\r\n }\r\n \r\n return NULL;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n pthread_t t0, t1;\r\n struct data *Data;\r\n char *herakles_mucorioid = 0;\r\n meningomalacia_coadmires xyleborus_overglazing = 0;\r\n int bonnibel_sniffily = 120;\r\n char *undeflowered_abastardize;;\r\n if (__sync_bool_compare_and_swap(&unmythical_discreated,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&undeflowered_abastardize,\"1882\",bonnibel_sniffily);\r\n if (undeflowered_abastardize != 0) {;\r\n xyleborus_overglazing = undeflowered_abastardize;\r\n if (xyleborus_overglazing != 0) {\r\n goto motlier_behoove;\r\n }\r\n ++global_variable;\r\n motlier_behoove:;\r\n herakles_mucorioid = ((char *)xyleborus_overglazing);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(herakles_mucorioid) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(herakles_mucorioid) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(herakles_mucorioid) + 1));\r\n if (Data->data) {\r\n if ((sscanf(herakles_mucorioid, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n \r\n \r\n \r\n \r\n Data->data_size = strlen(Data->data);\r\n if (pthread_mutex_init(&mutex, NULL) != 0) {\r\n printf(\"Mutex failed to initilize.\");\r\n }\r\n \r\n if (pthread_create(&t0, NULL, doStuff, (void *)Data) != 0) {\r\n printf(\"Error creating thread 0.\");\r\n }\r\n if (pthread_create(&t1, NULL, doStuff2, (void *)Data) != 0) {\r\n printf(\"Error creating thread 1.\");\r\n }\r\n pthread_join(t0, NULL);\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex);\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n } else {\r\n \r\n printf(\"Error parsing input.\\n\");\r\n }\r\n if (ssD2) {\r\n free (ssD2);\r\n }\r\n \r\n;\r\n if (xyleborus_overglazing != 0) \r\n free(((char *)xyleborus_overglazing));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-609:Double-Checked Locking|D.CWE-667:Improper Locking", "cwe": "609"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-563:Assignment to Variable without Use\nB.No Vulnerabilities\nC.CWE-1164:Irrelevant Code\nD.CWE-1073:Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_value_int_15()\r\n{\r\n int data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 5;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n data = 10;\r\n printIntLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 5;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(8)\r\n {\r\n case 7:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n printIntLine(data);\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 5;\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n printIntLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n data = 5;\r\n printIntLine(data);\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n data = 10;\r\n printIntLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n data = 5;\r\n printIntLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n switch(7)\r\n {\r\n case 7:\r\n \r\n data = 10;\r\n printIntLine(data);\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_unused_value_int_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_value_int_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_value_int_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-563:Assignment to Variable without Use|C.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1076:Insufficient Adherence to Expected Conventions\nB.CWE-87:Improper Neutralization of Alternate XSS Syntax\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.No Vulnerabilities\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic int mSource(int data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_connect_socket_malloc_21()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mStatic = 1; \r\n data = mSource(data);\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic int nG2B1Source(int data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\n\r\nstatic int nG2B2Source(int data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n \r\n if (data < 100)\r\n {\r\n \r\n char * dataBuffer = (char *)malloc(data);\r\n if (dataBuffer == NULL) {exit(-1);}\r\n \r\n memset(dataBuffer, 'A', data-1);\r\n dataBuffer[data-1] = '\\0';\r\n printLine(dataBuffer);\r\n free(dataBuffer);\r\n }\r\n}\r\n\r\nvoid My_connect_socket_malloc_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_malloc_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_malloc_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nC.CWE-506:Embedded Malicious Code\nD.CWE-471:Modification of Assumed-Immutable Data (MAID)\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_ip_based_logic_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"192.168.30.123\", inet_ntoa(acceptService.sin_addr)) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_ip_based_logic_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_ip_based_logic_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_ip_based_logic_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-510:Trapdoor|C.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-377:Insecure Temporary File\nB.CWE-1065:Runtime Resource Management Control Element in a Component Built to Run on Application Servers\nC.No Vulnerabilities\nD.CWE-656:Reliance on Security Through Obscurity\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define TEMPNAM tempnam\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TEMPNAM tempnam\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_tempnam_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_tempnam_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_tempnam_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_tempnam_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-377:Insecure Temporary File|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1110:Incomplete Design Documentation\nC.CWE-126:Buffer Over-read\nD.CWE-788:Access of Memory Location After End of Buffer\nE.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_My_My_My_CWE170_wchar_t_loop_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|D.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-508:Non-Replicating Malicious Code\nC.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\nD.No Vulnerabilities\nE.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n\r\n#pragma comment(lib, \"shlwapi\")\r\n\r\n#define M_PATH_SIZE (MAX_PATH / 2) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char path[M_PATH_SIZE];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(M_PATH_SIZE, path);\r\n if (length == 0 || length >= M_PATH_SIZE) \r\n {\r\n exit(1);\r\n }\r\n \r\n \r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printSizeTLine(strlen(path));\r\n printIntLine(M_PATH_SIZE);\r\n printLine(path);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|E.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cwe": "785"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.No Vulnerabilities\nC.CWE-771:Missing Reference to Active Allocated Resource\nD.CWE-1278:Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nE.CWE-1390:Weak Authentication\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint everard_spasmatic = 0;\r\nint global_variable;\r\n\r\nstruct archostegnosis_nablus \r\n{\r\n char *ecuadorian_perling;\r\n double stairwell_glucuronidase;\r\n char *biker_binodous;\r\n char amphitropous_unritual;\r\n int squishier_smallware;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid minsteryard_unwealsomeness(const struct archostegnosis_nablus trisects_caulophyllum);\r\nvoid cleanup(char **ptrs,int size)\r\n{\r\n int i = 0;\r\n \r\n for (; i < size; ++i) {\r\n if (ptrs[i] != 0) {\r\n free(ptrs[i]);\r\n }\r\n }\r\n}\r\nint isalnum(int c)\r\n{\r\n if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\r\n return 1;\r\n }\r\n return 0;\r\n}\r\nchar *isAlphaNum(char *str,int size_param)\r\n{\r\n int index = 0;\r\n \r\n for (index = 0; index < size_param; index++) {\r\n if (!isalnum(str[index])) {\r\n \r\n\r\n return 0;\r\n }\r\n }\r\n return str;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n struct archostegnosis_nablus postdating_unlawfulness;\r\n char *skagerrak_tabacum;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&everard_spasmatic,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n skagerrak_tabacum = getenv(\"SHOPBOYS_LYNDES\");\r\n if (skagerrak_tabacum != 0) {;\r\n postdating_unlawfulness . ecuadorian_perling = ((char *)skagerrak_tabacum);\r\n minsteryard_unwealsomeness(postdating_unlawfulness);\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid minsteryard_unwealsomeness(const struct archostegnosis_nablus trisects_caulophyllum)\r\n{\r\n char *contents;\r\n char filename[80];\r\n FILE *file;\r\n FILE **file_list;\r\n FILE *files;\r\n int str_list_index;\r\n char **str_list;\r\n int num_files = 10;\r\n int size;\r\n int ssi = 0;\r\n char *palici_extroitive = 0;\r\n jmp_buf upclimb_signficant;\r\n int badalona_mauldin;\r\n ++global_variable;;\r\n badalona_mauldin = setjmp(upclimb_signficant);\r\n if (badalona_mauldin == 0) {\r\n longjmp(upclimb_signficant,1);\r\n }\r\n palici_extroitive = ((char *)((struct archostegnosis_nablus )trisects_caulophyllum) . ecuadorian_perling);\r\n \r\n str_list = malloc(sizeof(char *) * num_files);\r\n if (str_list != 0) {\r\n for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\r\n str_list[str_list_index] = 0;\r\n files = fopen(palici_extroitive,\"rb\");\r\n if (files != 0) {\r\n file_list = malloc(num_files * sizeof(FILE *));\r\n if (file_list == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n for (ssi = 0; ssi < num_files; ++ssi) {\r\n if (fscanf(files,\"%79s\",filename) == 1) {\r\n file_list[ssi] = fopen(filename,\"rb\");\r\n }\r\n }\r\n ssi = 0;\r\n while(ssi < num_files){\r\n file = file_list[ssi];\r\n if (file == 0) {\r\n ++ssi;\r\n continue;\r\n }\r\n fseek(file,0,2);\r\n size = ftell(file);\r\n rewind(file);\r\n contents = malloc((size + 1) * sizeof(char ));\r\n \r\n \r\n if (contents == 0 && errno == 12) {\r\n \r\n printf(\"Malloc error due to ulimit\\n\");\r\n }\r\n if (contents == 0) {\r\n fclose(file);\r\n break;\r\n }\r\n \r\n memset(contents,0,(size + 1) * sizeof(char ));\r\n fread(contents,1,size,file);\r\n \r\n contents = isAlphaNum(contents,size);\r\n \r\n str_list[ssi] = contents;\r\n fclose(file);\r\n ssi++;\r\n }\r\n fclose(files);\r\n if (file_list != 0) {\r\n free(file_list);\r\n }\r\n }\r\n cleanup(str_list,num_files);\r\n free(str_list);\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-771:Missing Reference to Active Allocated Resource|A.CWE-400:Uncontrolled Resource Consumption", "cwe": "771"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-759:Use of a One-Way Hash without a Salt\nD.CWE-427:Uncontrolled Search Path Element\nE.CWE-1290:Incorrect Decoding of Security Identifiers \n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_connect_socket_06()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n wcscat(data, NEW_PATH);\r\n }\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-13:ASP.NET Misconfiguration: Password in Configuration File\nC.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nD.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nE.CWE-646:Reliance on File Name or Extension of Externally-Supplied File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_free_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_free_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_free_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_free_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|D.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-97:Improper Neutralization of Server-Side Includes (SSI) Within a Web Page\nD.CWE-628:Function Call with Incorrectly Specified Arguments\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <windows.h>\r\n#define BUFSIZE 1024\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_w32CreateMutex_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n HANDLE hMutex = NULL;\r\n hMutex = CreateMutexW(NULL, FALSE, NULL);\r\n \r\n \r\n CloseHandle(hMutex);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hMutex = NULL;\r\n hMutex = CreateMutexW(NULL, FALSE, NULL);\r\n \r\n if (hMutex == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n CloseHandle(hMutex);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n HANDLE hMutex = NULL;\r\n hMutex = CreateMutexW(NULL, FALSE, NULL);\r\n \r\n if (hMutex == NULL)\r\n {\r\n exit(1);\r\n }\r\n \r\n CloseHandle(hMutex);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_w32CreateMutex_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_w32CreateMutex_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_w32CreateMutex_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-252:Unchecked Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-331:Insufficient Entropy\nB.No Vulnerabilities\nC.CWE-668:Exposure of Resource to Wrong Sphere\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.CWE-134:Use of Externally-Controlled Format String\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define SNPRINTF _snprintf\r\n#else\r\n#define SNPRINTF snprintf\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_environment_snprintf_12()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char dest[100] = \"\";\r\n \r\n SNPRINTF(dest, 100-1, data);\r\n printLine(dest);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char dest[100] = \"\";\r\n \r\n SNPRINTF(dest, 100-1, \"%s\", data);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char dest[100] = \"\";\r\n \r\n SNPRINTF(dest, 100-1, \"%s\", data);\r\n printLine(dest);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char dest[100] = \"\";\r\n \r\n SNPRINTF(dest, 100-1, \"%s\", data);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char dest[100] = \"\";\r\n \r\n SNPRINTF(dest, 100-1, data);\r\n printLine(dest);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char dest[100] = \"\";\r\n \r\n SNPRINTF(dest, 100-1, data);\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_environment_snprintf_12()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_snprintf_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_snprintf_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-134:Use of Externally-Controlled Format String|C.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.CWE-762:Mismatched Memory Management Routines\nC.CWE-797:Only Filtering Special Elements at an Absolute Position\nD.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_int_alloca_15\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n int * dataBuffer = (int *)ALLOCA(sizeof(int));\r\n *dataBuffer = 5;\r\n data = dataBuffer;\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n printIntLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int * data;\r\n data = NULL; \r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n \r\n int * dataBuffer = new int;\r\n *dataBuffer = 5;\r\n data = dataBuffer;\r\n }\r\n break;\r\n }\r\n printIntLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int * data;\r\n data = NULL; \r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n int * dataBuffer = new int;\r\n *dataBuffer = 5;\r\n data = dataBuffer;\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n printIntLine(*data);\r\n \r\n delete data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_int_alloca_15; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-590:Free of Memory not on the Heap|B.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-258:Empty Password in Configuration File\nC.CWE-535:Exposure of Information Through Shell Error Message\nD.CWE-484:Omitted Break Statement in Switch\nE.CWE-211:Externally-Generated Error Message Containing Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-535:Exposure of Information Through Shell Error Message|E.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-122:Heap-based Buffer Overflow\nC.CWE-1097:Persistent Storable Data Element without Associated Comparison Control Element\nD.CWE-787:Out-of-bounds Write\nE.CWE-1177:Use of Prohibited Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_cpp_My_cpp_CWE805_int_memmove_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-122:Heap-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nD.CWE-143:Improper Neutralization of Record Delimiters\nE.CWE-116:Improper Encoding or Escaping of Output\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_open_no_close_08()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if(staticReturnsTrue())\r\n {\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_open_no_close_08()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_no_close_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_no_close_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-558:Use of getlogin() in Multithreaded Application\nB.CWE-675:Multiple Operations on Resource in Single-Operation Context\nC.No Vulnerabilities\nD.CWE-573:Improper Following of Specification by Caller\nE.CWE-43:Path Equivalence: 'filename....' (Multiple Trailing Dot)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_freopen_65bSink(FILE * data);\r\n\r\nvoid My_freopen_65()\r\n{\r\n FILE * data;\r\n \r\n void (*funcPtr) (FILE *) = My_freopen_65bSink;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_freopen_65bG2BSink(FILE * data);\r\n\r\nstatic void nG2B()\r\n{\r\n FILE * data;\r\n void (*funcPtr) (FILE *) = My_freopen_65bG2BSink;\r\n data = NULL; \r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n funcPtr(data);\r\n}\r\n\r\n\r\nvoid My_freopen_65bB2GSink(FILE * data);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n void (*funcPtr) (FILE *) = My_freopen_65bB2GSink;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_freopen_65()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-675:Multiple Operations on Resource in Single-Operation Context|D.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-1390:Weak Authentication\nC.CWE-36:Absolute Path Traversal\nD.No Vulnerabilities\nE.CWE-156:Improper Neutralization of Whitespace\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_file_ofstream_44\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n void (*funcPtr) (wchar_t *) = mSink;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n void (*funcPtr) (wchar_t *) = nG2BSink;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n funcPtr(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_file_ofstream_44; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-391:Unchecked Error Condition\nE.CWE-83:Improper Neutralization of Script in Attributes in a Web Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n#include <math.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_sqrt_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n double doubleNumber;\r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n double doubleNumber;\r\n errno = 0; \r\n doubleNumber = (double)sqrt((double)-1);\r\n \r\n if (errno == EDOM)\r\n {\r\n printLine(\"sqrt() failed\");\r\n exit(1);\r\n }\r\n printDoubleLine(doubleNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_sqrt_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_sqrt_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_sqrt_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-391:Unchecked Error Condition|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1023:Incomplete Comparison with Missing Factors\nB.CWE-1053:Missing Documentation for Design\nC.No Vulnerabilities\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-478:Missing Default Case in Multiple Condition Expression\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n }\r\n printLine(charString);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n}\r\n\r\nvoid My_basic_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-478:Missing Default Case in Multiple Condition Expression|A.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "478"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1085:Invokable Control Element with Excessive Volume of Commented-out Code\nB.CWE-127:Buffer Under-read\nC.No Vulnerabilities\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-353:Missing Support for Integrity Check\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_declare_ncpy_32()\r\n{\r\n char * data;\r\n char * *dataPtr1 = &data;\r\n char * *dataPtr2 = &data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n {\r\n char * data = *dataPtr1;\r\n \r\n data = dataBuffer - 8;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n char * data = *dataPtr2;\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n strncpy(dest, data, strlen(dest));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * *dataPtr1 = &data;\r\n char * *dataPtr2 = &data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n {\r\n char * data = *dataPtr1;\r\n \r\n data = dataBuffer;\r\n *dataPtr1 = data;\r\n }\r\n {\r\n char * data = *dataPtr2;\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1); \r\n dest[100-1] = '\\0'; \r\n \r\n strncpy(dest, data, strlen(dest));\r\n \r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_declare_ncpy_32()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_ncpy_32();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_ncpy_32();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-282:Improper Ownership Management\nC.CWE-600:Uncaught Exception in Servlet \nD.CWE-573:Improper Following of Specification by Caller\nE.CWE-675:Multiple Operations on Resource in Single-Operation Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_freopen_13()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\nvoid My_freopen_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-675:Multiple Operations on Resource in Single-Operation Context|D.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-676:Use of Potentially Dangerous Function\nC.CWE-135:Incorrect Calculation of Multi-Byte String Length\nD.No Vulnerabilities\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_char_02\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n data = new char[100];\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n delete [] data;\r\n }\r\n if(1)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n data = new char[100];\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n delete [] data;\r\n }\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n data = new char[100];\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n delete [] data;\r\n }\r\n if(1)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new char[100];\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n }\r\n if(1)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(1)\r\n {\r\n data = new char[100];\r\n memset(data, 'A', 100-1);\r\n data[100-1] = '\\0';\r\n \r\n }\r\n if(1)\r\n {\r\n \r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_char_02; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.No Vulnerabilities\nC.CWE-75:Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)\nD.CWE-508:Non-Replicating Malicious Code\nE.CWE-763:Release of Invalid Pointer or Reference\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_array_class_malloc_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(TwoIntsClass * * dataPtr);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = (TwoIntsClass *)malloc(100*sizeof(TwoIntsClass));\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(TwoIntsClass * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass[100];\r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(TwoIntsClass * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = (TwoIntsClass *)malloc(100*sizeof(TwoIntsClass));\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_array_class_malloc_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-762:Mismatched Memory Management Routines|E.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.No Vulnerabilities\nC.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\nD.CWE-680:Integer Overflow to Buffer Overflow\nE.CWE-212:Improper Removal of Sensitive Information Before Storage or Transfer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_connect_socket_84\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nclass My_new_connect_socket_84\r\n{\r\npublic:\r\n My_new_connect_socket_84(int dataCopy);\r\n ~My_new_connect_socket_84();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_new_connect_socket_84G2B\r\n{\r\npublic:\r\n My_new_connect_socket_84G2B(int dataCopy);\r\n ~My_new_connect_socket_84G2B();\r\n\r\nprivate:\r\n int data;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-680:Integer Overflow to Buffer Overflow|A.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-252:Unchecked Return Value\nC.CWE-478:Missing Default Case in Multiple Condition Expression\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define SRC L\"sscanf\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_sscanf_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n swscanf(SRC, L\"%99s\\0\", data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_sscanf_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_sscanf_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_sscanf_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-834:Excessive Iteration\nB.CWE-471:Modification of Assumed-Immutable Data (MAID)\nC.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nD.CWE-420:Unprotected Alternate Channel\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint unpanoplied_plagiotropism = 0;\r\n\r\nstruct retrogresses_unviewable \r\n{\r\n char *unsuspect_clonal;\r\n double ethiope_musketade;\r\n char *coelomatous_psammite;\r\n char podilegous_gurr;\r\n int protracheata_chlorides;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n int ss_i = 0;\r\n char *tressia_egads = 0;\r\n struct retrogresses_unviewable *coemption_baculites = {0};\r\n struct retrogresses_unviewable *galempong_protium = {0};\r\n struct retrogresses_unviewable hee_varicoloured;\r\n char *prebilling_maryann;;\r\n if (__sync_bool_compare_and_swap(&unpanoplied_plagiotropism,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n prebilling_maryann = getenv(\"PHILOSOPHIZER_INTERTWISTINGLY\");\r\n if (prebilling_maryann != 0) {;\r\n hee_varicoloured . unsuspect_clonal = ((char *)prebilling_maryann);\r\n coemption_baculites = &hee_varicoloured;\r\n galempong_protium = coemption_baculites + 5;\r\n tressia_egads = ((char *)( *(galempong_protium - 5)) . unsuspect_clonal);\r\n \r\n printf(\"checking input\\n\");\r\n \r\n \r\n \r\n while(ss_i < strlen(tressia_egads)){\r\n \r\n if (tressia_egads[ss_i] >= 48) {\r\n \r\n ++ss_i;\r\n }\r\n }\r\n \r\n \r\n printf(\"finished evaluating\\n\");\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')|A.CWE-834:Excessive Iteration", "cwe": "835"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-1295:Debug Messages Revealing Unnecessary Information\nC.CWE-400:Uncontrolled Resource Consumption\nD.CWE-682:Incorrect Calculation\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include <sys/ipc.h> \r\n#include <sys/shm.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint gilliver_reenlisted = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\r\n int shmid;\r\n key_t key;\r\n char *shm, *s;\r\n char* envSize = NULL;\r\n *tainted_buff = NULL;\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n if(envKey != NULL) {\r\n if(sscanf(envKey, \"%d\", &key) > 0) {\r\n if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\r\n if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\r\n *tainted_buff = (char*)calloc(shmsz, sizeof(char));\r\n \r\n for (s = shm; *s != (char)0; s++) {\r\n (*tainted_buff)[s - shm] = *s;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *deputy_oopodal = 0;\r\n jmp_buf remonstratively_apprehended;\r\n int proegumenal_idosaccharic;\r\n void *sassoon_sla = 0;\r\n long situs_mistimes[10];\r\n void *phegeus_sheepcrook[10] = {0};\r\n void *unsatirical_nito = 0;\r\n int indifferent_porchlike = 5;\r\n char *diyarbakir_combiners;\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&gilliver_reenlisted,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&diyarbakir_combiners,\"3127\",indifferent_porchlike);\r\n if (diyarbakir_combiners != 0) {;\r\n unsatirical_nito = ((void *)diyarbakir_combiners);\r\n phegeus_sheepcrook[5] = unsatirical_nito;\r\n situs_mistimes[1] = 5;\r\n sassoon_sla = *(phegeus_sheepcrook + situs_mistimes[1]);\r\n proegumenal_idosaccharic = setjmp(remonstratively_apprehended);\r\n if (proegumenal_idosaccharic == 0) {\r\n longjmp(remonstratively_apprehended,1);\r\n }\r\n deputy_oopodal = ((char *)((char *)sassoon_sla));\r\n \r\n input = atoi(deputy_oopodal);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\n if (((char *)sassoon_sla) != 0) \r\n free(((char *)((char *)sassoon_sla)));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-215:Insertion of Sensitive Information Into Debugging Code\nB.No Vulnerabilities\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.CWE-506:Embedded Malicious Code\nE.CWE-511:Logic/Time Bomb\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#define COUNT_CHECK 20000\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_counter_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n int count = 0;\r\n do\r\n {\r\n \r\n if (count == COUNT_CHECK)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n count++;\r\n }\r\n while(1 == 1); \r\n }\r\n }\r\n}\r\n\r\nvoid My_counter_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_counter_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_counter_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-511:Logic/Time Bomb|D.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-1274:Improper Access Control for Volatile Memory Containing Boot Code\nC.CWE-196:Unsigned to Signed Conversion Error\nD.No Vulnerabilities\nE.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include </trace.h> \r\nint combinator_interrhyme = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid rajahs_patentor(int roe_ags,char *gyratory_bout);\r\nunsigned int get_size(char *ss_tainted)\r\n{\r\n \r\n unsigned long uns_int = 0UL;\r\n uns_int = strtoul(ss_tainted,0,0);\r\n if (uns_int > ((unsigned long )4294967295U) ||\r\n uns_int == 0)\r\n uns_int = 1U;\r\n return (unsigned int )uns_int;\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{\r\n int poisonberry_cyanotic = 7;\r\n int behaviors_lyric = 0;\r\n char *gramash_enchoric = 0;\r\n char *unordered_ibiza;;\r\n if (__sync_bool_compare_and_swap(&combinator_interrhyme,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n unordered_ibiza = getenv(\"BSEE_ENGOUE\");\r\n if (unordered_ibiza != 0) {;\r\n behaviors_lyric = ((int )(strlen(unordered_ibiza)));\r\n gramash_enchoric = ((char *)(malloc(behaviors_lyric + 1)));\r\n if (gramash_enchoric == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(gramash_enchoric,0,behaviors_lyric + 1);\r\n memcpy(gramash_enchoric,unordered_ibiza,behaviors_lyric);\r\n rajahs_patentor(poisonberry_cyanotic,gramash_enchoric);\r\n }\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid rajahs_patentor(int roe_ags,char *gyratory_bout)\r\n{\r\n char *other_buff = 0;\r\n int size = 0;\r\n int num = 0;\r\n char buff[200] = {0};\r\n int output_counter = 0;\r\n char *edriasteroidea_microliter = 0;\r\n ++global_variable;\r\n roe_ags--;\r\n if (roe_ags > 0) {\r\n rajahs_patentor(roe_ags,gyratory_bout);\r\n return ;\r\n }\r\n edriasteroidea_microliter = ((char *)gyratory_bout);\r\n \r\n if (strlen(edriasteroidea_microliter) > 0 &&\r\n edriasteroidea_microliter[0] == '-') {\r\n printf(\"Negative number given as input\\n\");\r\n } else {\r\n \r\n \r\n num = get_size(edriasteroidea_microliter);\r\n other_buff = getenv(\"SS_BUFF\");\r\n \r\n \r\n \r\n if (other_buff != 0) {\r\n strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\r\n size = ((int )(strlen(buff)));\r\n \r\n \r\n while (num < size) {\r\n \r\n if (output_counter == 0) {\r\n printf(\"evaluating input\\n\");\r\n }\r\n output_counter++;\r\n if (output_counter == 1000000) {\r\n output_counter = 0;\r\n }\r\n if (num > 0)\r\n ++num;\r\n }\r\n \r\n } else {\r\n printf(\"Missing value for other_buff\\n\");\r\n }\r\n printf(\"finished evaluating\\n\");\r\n }\r\n \r\n;\r\n if (gyratory_bout != 0) \r\n free(((char *)gyratory_bout));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-196:Unsigned to Signed Conversion Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "196"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-208:Observable Timing Discrepancy\nB.CWE-15:External Control of System or Configuration Setting\nC.CWE-172:Encoding Error\nD.No Vulnerabilities\nE.CWE-176:Improper Handling of Unicode Encoding\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_16()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n while(1)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_16()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-176:Improper Handling of Unicode Encoding|C.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-512:Spyware\nB.CWE-606:Unchecked Input for Loop Condition\nC.CWE-273:Improper Check for Dropped Privileges\nD.No Vulnerabilities\nE.CWE-1284:Improper Validation of Specified Quantity in Input\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_connect_socket_07()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(staticFive==5)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_07()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-606:Unchecked Input for Loop Condition|E.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-460:Improper Cleanup on Thrown Exception\nB.CWE-366:Race Condition within a Thread\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.No Vulnerabilities\nE.CWE-798:Use of Hard-coded Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_05()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|E.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-198:Use of Incorrect Byte Ordering\nB.CWE-482:Comparing instead of Assigning\nC.CWE-232:Improper Handling of Undefined Values\nD.CWE-480:Use of Incorrect Operator\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n int intMSink = 0;\r\n \r\n printIntLine(intMSink);\r\n \r\n intMSink == 5;\r\n printIntLine(intMSink);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intNSink = 0;\r\n \r\n printIntLine(intNSink);\r\n \r\n intNSink = 5;\r\n printIntLine(intNSink);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n int intNSink = 0;\r\n \r\n printIntLine(intNSink);\r\n \r\n intNSink = 5;\r\n printIntLine(intNSink);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-482:Comparing instead of Assigning|D.CWE-480:Use of Incorrect Operator", "cwe": "482"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-586:Explicit Call to Finalize()\nB.No Vulnerabilities\nC.CWE-770:Allocation of Resources Without Limits or Throttling\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.CWE-641:Improper Restriction of Names for Files and Other Resources\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\nnamespace My_new_wchar_t_fscanf_17\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int i,j;\r\n size_t data;\r\n \r\n data = 0;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int i,k;\r\n size_t data;\r\n \r\n data = 0;\r\n for(i = 0; i < 1; i++)\r\n {\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n }\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int h,j;\r\n size_t data;\r\n \r\n data = 0;\r\n for(h = 0; h < 1; h++)\r\n {\r\n \r\n data = 20;\r\n }\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = new wchar_t[data];\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_fscanf_17; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-789:Memory Allocation with Excessive Size Value|C.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-710:Improper Adherence to Coding Standards\nB.No Vulnerabilities\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_int_63\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(int * * dataPtr);\r\n\r\nvoid m()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n data = new int[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n delete [] data;\r\n mSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(int * * data);\r\n\r\nstatic void nG2B()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n data = new int[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n nG2BSink(&data);\r\n}\r\n\r\n\r\nvoid nB2GSink(int * * data);\r\n\r\nstatic void nB2G()\r\n{\r\n int * data;\r\n \r\n data = NULL;\r\n data = new int[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i] = 5;\r\n }\r\n }\r\n \r\n delete [] data;\r\n nB2GSink(&data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_int_63; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-464:Addition of Data Structure Sentinel\nC.CWE-138:Improper Neutralization of Special Elements\nD.CWE-1328:Security Version Number Mutable to Older Versions\nE.CWE-1024:Comparison of Incompatible Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_12()\r\n{\r\n char data;\r\n data = ' ';\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n }\r\n else\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = 'a';\r\n }\r\n else\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\nvoid My_basic_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-464:Addition of Data Structure Sentinel|C.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.No Vulnerabilities\nC.CWE-427:Uncontrolled Search Path Element\nD.CWE-926:Improper Export of Android Application Components\nE.CWE-1060:Excessive Number of Inefficient Server-Side Data Accesses\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#define ENV_VARIABLE \"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV getenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(char * data)\r\n{\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_environment_44()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = mSink;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n char * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n strncat(data+dataLen, environment, 250-dataLen-1);\r\n }\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(char * data)\r\n{\r\n \r\n PUTENV(data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = nG2BSink;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n \r\n strcat(data, NEW_PATH);\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_environment_44()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_environment_44();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_environment_44();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-427:Uncontrolled Search Path Element|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-469:Use of Pointer Subtraction to Determine Size\nC.CWE-1114:Inappropriate Whitespace Style\nD.CWE-23:Relative Path Traversal\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH L\"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH L\"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_listen_socket_ifstream_41\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSink(wchar_t * data)\r\n{\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nvoid nG2BSink(wchar_t * data)\r\n{\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"file.txt\");\r\n nG2BSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_listen_socket_ifstream_41; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-23:Relative Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-585:Empty Synchronized Block\nB.CWE-763:Release of Invalid Pointer or Reference\nC.No Vulnerabilities\nD.CWE-484:Omitted Break Statement in Switch\nE.CWE-761:Free of Pointer not at Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_environment_52bSink(wchar_t * data);\r\n\r\nvoid My_wchar_t_environment_52()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n My_wchar_t_environment_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_environment_52bB2GSink(wchar_t * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n My_wchar_t_environment_52bB2GSink(data);\r\n}\r\n\r\nvoid My_wchar_t_environment_52()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_environment_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_environment_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-761:Free of Pointer not at Start of Buffer|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-84:Improper Neutralization of Encoded URI Schemes in a Web Page\nB.No Vulnerabilities\nC.CWE-588:Attempt to Access Child of a Non-structure Pointer\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-1257:Improper Access Control Applied to Mirrored or Aliased Memory Regions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_31()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n {\r\n void * dataCopy = data;\r\n void * data = dataCopy;\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n {\r\n void * dataCopy = data;\r\n void * data = dataCopy;\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n }\r\n}\r\n\r\nvoid My_struct_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-588:Attempt to Access Child of a Non-structure Pointer|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-778:Insufficient Logging\nB.No Vulnerabilities\nC.CWE-796:Only Filtering Special Elements Relative to a Marker\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-253:Incorrect Check of Function Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fprintf_01()\r\n{\r\n \r\n if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\r\n {\r\n printLine(\"fprintf failed!\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n \r\n if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\r\n {\r\n printLine(\"fprintf failed!\");\r\n }\r\n}\r\n\r\nvoid My_char_fprintf_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fprintf_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fprintf_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-253:Incorrect Check of Function Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1327:Binding to an Unrestricted IP Address\nB.No Vulnerabilities\nC.CWE-546:Suspicious Comment\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_BUG_03()\r\n{\r\n if(5==5)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(5==5)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_BUG_03()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_BUG_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_BUG_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1173:Improper Use of Validation Framework\nB.CWE-404:Improper Resource Shutdown or Release\nC.No Vulnerabilities\nD.CWE-1220:Insufficient Granularity of Access Control\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_new_array_wchar_t_41\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(wchar_t * data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = new wchar_t[100];\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(wchar_t * data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n wchar_t dataNBuffer[100];\r\n data = dataNBuffer;\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(wchar_t * data)\r\n{\r\n \r\n delete[] data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n \r\n data = new wchar_t[100];\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_array_wchar_t_41; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\nC.CWE-477:Use of Obsolete Function\nD.No Vulnerabilities\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_char_memmove_01()\r\n{\r\n char * data;\r\n data = NULL;\r\n \r\n data = (char *)malloc(50*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 50-1); \r\n data[50-1] = '\\0'; \r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memmove(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = NULL;\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memmove(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_malloc_char_memmove_01()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_char_memmove_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_char_memmove_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.No Vulnerabilities\nC.CWE-182:Collapse of Data into Unsafe Value\nD.CWE-293:Using Referer Field for Authentication\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint stray_underplain = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid carnegiea_representee(int unakites_proglottides,... );\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n void *indignation_cristina = 0;\r\n char *substantialized_gripers;;\r\n if (__sync_bool_compare_and_swap(&stray_underplain,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&substantialized_gripers,\"VILITY_MARCHAL\");\r\n if (substantialized_gripers != 0) {;\r\n indignation_cristina = ((void *)substantialized_gripers);\r\n carnegiea_representee(1,indignation_cristina);\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid carnegiea_representee(int unakites_proglottides,... )\r\n{\r\n int i = 0;\r\n int buff_size = 63;\r\n int taint_len;\r\n char *heap_buff_64 = 0;\r\n char *spongins_electrotypic = 0;\r\n void *sandan_attainableness = 0;\r\n va_list germanophilist_dipsomaniac;\r\n ++global_variable;;\r\n if (unakites_proglottides > 0) {\r\n __builtin_va_start(germanophilist_dipsomaniac,unakites_proglottides);\r\n sandan_attainableness = (va_arg(germanophilist_dipsomaniac,void *));\r\n __builtin_va_end(germanophilist_dipsomaniac);\r\n }\r\n spongins_electrotypic = ((char *)((char *)sandan_attainableness));\r\n \r\n \r\n \r\n heap_buff_64 = (char*) malloc(64 * sizeof(char));\r\n if (heap_buff_64 != NULL) {\r\n memset(heap_buff_64, 'A' ,64);\r\n heap_buff_64[64 - 1] = '\\0';\r\n \r\n \r\n \r\n taint_len = ((int )(strlen(spongins_electrotypic)));\r\n for (; taint_len >= 0; (--buff_size , --taint_len)) {\r\n \r\n \r\n heap_buff_64[buff_size] = spongins_electrotypic[taint_len];\r\n }\r\n \r\n for (; i < 64; ++i) {\r\n heap_buff_64[i] = toupper(heap_buff_64[i]);\r\n }\r\n \r\n \r\n printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\r\n free(heap_buff_64);\r\n \r\n \r\n \r\n }\r\n;\r\n if (((char *)sandan_attainableness) != 0) \r\n free(((char *)((char *)sandan_attainableness)));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-124:Buffer Underwrite ('Buffer Underflow')|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-821:Incorrect Synchronization\nC.CWE-627:Dynamic Variable Evaluation\nD.CWE-662:Improper Synchronization\nE.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\n#include <pthread.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint encodement_forecastleman = 0;\r\n\r\nunion thorough_cavit \r\n{\r\n char *fleam_stickball;\r\n double depilatory_pseudoethically;\r\n char *sprayfully_underlinemen;\r\n char belgravian_buddleias;\r\n int misrepresents_confection;\r\n}\r\n;\r\nint global_variable;\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *));\r\nstruct data {\r\n int qsize;\r\n char *data;\r\n char *file1;\r\n char *file2;\r\n};\r\npthread_t t0, t1;\r\npthread_mutex_t mutex_0, mutex_1;\r\nint dev_amount = 1;\r\nint comp (const void * a, const void * b) {\r\n if (a > b) {\r\n return -1;\r\n }\r\n else if (a < b) {\r\n return 1;\r\n }\r\n else {\r\n return 0;\r\n }\r\n}\r\nint pmoc (const void * a, const void * b) {\r\n return -1 * comp(a, b);\r\n}\r\nvoid readFile(char *filename) {\r\n FILE *fifo;\r\n char ch;\r\n \r\n fifo = fopen(filename, \"r\");\r\n if (fifo != NULL) {\r\n while ((ch = fgetc(fifo)) != EOF) {\r\n printf(\"%c\", ch);\r\n }\r\n fclose(fifo);\r\n }\r\n \r\n}\r\nvoid *calcDevamount(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int qsize;\r\n \r\n printf(\"Inside calcDevAmount\\n\");\r\n pthread_mutex_lock(&mutex_0);\r\n \r\n \r\n dev_amount = Data->data[0] - 'A'; \r\n qsize = Data->qsize;\r\n if (dev_amount < 0) { \r\n dev_amount *= -1; \r\n }\r\n \r\n readFile(Data->file2);\r\n if (dev_amount == 0) { \r\n dev_amount += 1; \r\n }\r\n \r\n \r\n pthread_mutex_unlock(&mutex_0);\r\n return NULL;\r\n}\r\nvoid *devChar(void *data) {\r\n struct data *Data = (struct data*)data;\r\n int i;\r\n int i;\r\n int *arr = NULL;\r\n \r\n printf(\"Inside devChar\\n\");\r\n \r\n arr = malloc(sizeof(int) * Data->qsize);\r\n pthread_mutex_lock(&mutex_1);\r\n for (i = 0; i < Data->qsize; i++) {\r\n arr[i] = Data->qsize - i;\r\n }\r\n qsort(arr, Data->qsize, sizeof(int), &comp);\r\n free(arr);\r\n readFile(Data->file1);\r\n \r\n \r\n \r\n for (i = 0; i < strlen(Data->data); i++) { \r\n Data->data[i] /= dev_amount; \r\n }\r\n \r\n pthread_mutex_unlock(&mutex_1);\r\n return NULL;\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&encodement_forecastleman,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n opisthodont_cyanin(bend_godded);\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid bend_godded(union thorough_cavit *belugite_parnellite)\r\n{\r\n union thorough_cavit trainways_superinduction;\r\n char *dulsea_cupriferous;\r\n ++global_variable;;\r\n setup_printf_context();\r\n read_taint(&dulsea_cupriferous,\"MATRICULATING_WADESTOWN\");\r\n if (dulsea_cupriferous != 0) {;\r\n trainways_superinduction . fleam_stickball = dulsea_cupriferous;\r\n *belugite_parnellite = trainways_superinduction;\r\n }\r\n}\r\n\r\nvoid opisthodont_cyanin(void (*message_zygopterous)(union thorough_cavit *))\r\n{\r\n struct data* Data;\r\n char *airmail_masculineness = 0;\r\n union thorough_cavit melammdim_chaffinch = {0};\r\n int *subprostatic_honora = 0;\r\n int indistinctly_enthusiasm;\r\n union thorough_cavit hyperite_gonium[10] = {0};\r\n ++global_variable;\r\n union thorough_cavit venison_elasticate = {0};\r\n message_zygopterous(&venison_elasticate);\r\n if (venison_elasticate . fleam_stickball != 0) {;\r\n hyperite_gonium[5] = venison_elasticate;\r\n indistinctly_enthusiasm = 5;\r\n subprostatic_honora = &indistinctly_enthusiasm;\r\n melammdim_chaffinch = *(hyperite_gonium + *subprostatic_honora);\r\n airmail_masculineness = ((char *)melammdim_chaffinch . fleam_stickball);\r\n \r\n Data = malloc(sizeof(struct data));\r\n if (Data) {\r\n Data->data = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file1 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n Data->file2 = malloc(sizeof(char) * (strlen(airmail_masculineness) + 1));\r\n if (Data->data) {\r\n if ((sscanf(airmail_masculineness, \"%d %s %s %s\",\r\n &(Data->qsize),\r\n Data->file1,\r\n Data->file2,\r\n Data->data) == 4) &&\r\n (strlen(Data->data) != 0) &&\r\n (strlen(Data->file1) != 0) &&\r\n (strlen(Data->file2) != 0))\r\n {\r\n pthread_mutex_init(&mutex_0, NULL);\r\n pthread_mutex_init(&mutex_1, NULL);\r\n \r\n \r\n \r\n \r\n \r\n if (strlen(Data->data) > 50) { \r\n \r\n if (pthread_create(&t0, NULL, calcDevamount, Data) != 0) { \r\n printf(\"Error initializing thread 0.\");\r\n }\r\n }\r\n if (pthread_create(&t1, NULL, devChar, Data) != 0) {\r\n printf(\"Error initializing thread 1.\");\r\n }\r\n if (strlen(Data->data) > 50) {\r\n pthread_join(t0, NULL);\r\n }\r\n pthread_join(t1, NULL);\r\n \r\n pthread_mutex_destroy(&mutex_0);\r\n pthread_mutex_destroy(&mutex_1);\r\n } else {\r\n \r\n printf(\"Error parsing data\\n\");\r\n }\r\n free(Data->data);\r\n }\r\n free(Data);\r\n }\r\n \r\n;\r\n if (melammdim_chaffinch . fleam_stickball != 0) \r\n free(((char *)melammdim_chaffinch . fleam_stickball));\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-821:Incorrect Synchronization|D.CWE-662:Improper Synchronization", "cwe": "821"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_new_wchar_t_memmove_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t * dataBuffer = new wchar_t[100];\r\n wmemset(dataBuffer, L'A', 100-1);\r\n dataBuffer[100-1] = L'\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n wchar_t dest[100];\r\n wmemset(dest, L'C', 100-1); \r\n dest[100-1] = L'\\0'; \r\n \r\n memmove(dest, data, 100*sizeof(wchar_t));\r\n \r\n dest[100-1] = L'\\0';\r\n printWLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_wchar_t_memmove_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nB.CWE-252:Unchecked Return Value\nC.CWE-590:Free of Memory not on the Heap\nD.CWE-42:Path Equivalence: 'filename.' (Trailing Dot)\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_wfopen_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<FILE *> dataList);\r\n\r\nvoid m()\r\n{\r\n FILE * data;\r\n list<FILE *> dataList;\r\n \r\n data = NULL;\r\n \r\n data = _wfopen(L\"file.txt\", L\"w+\");\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(list<FILE *> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n list<FILE *> dataList;\r\n \r\n data = NULL;\r\n \r\n data = _wfopen(L\"file.txt\", L\"w+\");\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wfopen_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-690:Unchecked Return Value to NULL Pointer Dereference|B.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1087:Class with Virtual Method without a Virtual Destructor\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.CWE-396:Declaration of Catch for Generic Exception\nE.CWE-705:Incorrect Control Flow Scoping\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_exception_and_domain_error_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(staticFive==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n catch (domain_error &)\r\n {\r\n \r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_and_domain_error_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-396:Declaration of Catch for Generic Exception|E.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1024:Comparison of Incompatible Types\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.No Vulnerabilities\nD.CWE-520:.NET Misconfiguration: Use of Impersonation\nE.CWE-427:Uncontrolled Search Path Element\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH L\"%SystemRoot%\\\\system32\"\r\n#define PUTENV _wputenv\r\n#else\r\n#define NEW_PATH L\"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_wchar_t_connect_socket_66bSink(wchar_t * dataArray[]);\r\n\r\nvoid My_wchar_t_connect_socket_66()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataArray[2] = data;\r\n My_wchar_t_connect_socket_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_wchar_t_connect_socket_66bG2BSink(wchar_t * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * dataArray[5];\r\n wchar_t dataBuffer[250] = L\"PATH=\";\r\n data = dataBuffer;\r\n \r\n wcscat(data, NEW_PATH);\r\n dataArray[2] = data;\r\n My_wchar_t_connect_socket_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-427:Uncontrolled Search Path Element|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-164:Improper Neutralization of Internal Special Elements\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.No Vulnerabilities\nD.CWE-476:NULL Pointer Dereference\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_16()\r\n{\r\n char * data;\r\n while(1)\r\n {\r\n \r\n data = NULL;\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n while(1)\r\n {\r\n \r\n data = NULL;\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n \r\n printHexCharLine(data[0]);\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n while(1)\r\n {\r\n \r\n data = \"N\";\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n \r\n printHexCharLine(data[0]);\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_16()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-476:NULL Pointer Dereference|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-771:Missing Reference to Active Allocated Resource\nB.No Vulnerabilities\nC.CWE-1269:Product Released in Non-Release Configuration\nD.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nE.CWE-773:Missing Reference to Active File Descriptor or Handle\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_open_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(int &data)\r\n{\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n}\r\n\r\nvoid m()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mSource(data);\r\n \r\n data = OPEN(\"MSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2GSource(int &data)\r\n{\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nB2GSource(data);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n data = OPEN(\"NSink_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n if (data != -1)\r\n {\r\n CLOSE(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_open_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-926:Improper Export of Android Application Components\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.No Vulnerabilities\nD.CWE-184:Incomplete List of Disallowed Inputs\nE.CWE-377:Insecure Temporary File\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define MKTEMP _wmktemp\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_mktemp_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_mktemp_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_mktemp_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_mktemp_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-377:Insecure Temporary File|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1077:Floating Point Comparison with Incorrect Operator\nB.No Vulnerabilities\nC.CWE-400:Uncontrolled Resource Consumption\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fgets_fwrite_82\r\n{\r\n\r\nclass My_fgets_fwrite_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(int count) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_fgets_fwrite_82 : public My_fgets_fwrite_82_base\r\n{\r\npublic:\r\n void action(int count);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_fgets_fwrite_82G2B : public My_fgets_fwrite_82_base\r\n{\r\npublic:\r\n void action(int count);\r\n};\r\n\r\nclass My_fgets_fwrite_82B2G : public My_fgets_fwrite_82_base\r\n{\r\npublic:\r\n void action(int count);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-400:Uncontrolled Resource Consumption|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-628:Function Call with Incorrectly Specified Arguments\nC.CWE-1190:DMA Device Enabled Too Early in Boot Phase\nD.No Vulnerabilities\nE.CWE-590:Free of Memory not on the Heap\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_int64_t_alloca_34\r\n{\r\n\r\ntypedef union\r\n{\r\n int64_t * unionFirst;\r\n int64_t * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n unionType myUnion;\r\n data = NULL; \r\n {\r\n \r\n int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));\r\n *dataBuffer = 5LL;\r\n data = dataBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n int64_t * data = myUnion.unionSecond;\r\n printLongLongLine(*data);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n unionType myUnion;\r\n data = NULL; \r\n {\r\n \r\n int64_t * dataBuffer = new int64_t;\r\n *dataBuffer = 5LL;\r\n data = dataBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n int64_t * data = myUnion.unionSecond;\r\n printLongLongLine(*data);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_int64_t_alloca_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-590:Free of Memory not on the Heap|A.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-344:Use of Invariant Value in Dynamically Changing Context\nB.No Vulnerabilities\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-396:Declaration of Catch for Generic Exception\nE.CWE-703:Improper Check or Handling of Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalTrue)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-396:Declaration of Catch for Generic Exception|C.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-415:Double Free\nC.CWE-1269:Product Released in Non-Release Configuration\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-925:Improper Verification of Intent by Broadcast Receiver\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_free_wchar_t_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(wchar_t * &data)\r\n{\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(wchar_t * &data)\r\n{\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n free(data);\r\n}\r\n\r\n\r\nstatic void nB2GSource(wchar_t * &data)\r\n{\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n free(data);\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_free_wchar_t_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-415:Double Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-645:Overly Restrictive Account Lockout Mechanism\nB.CWE-578:EJB Bad Practices: Use of Class Loader\nC.No Vulnerabilities\nD.CWE-786:Access of Memory Location Before Start of Buffer\nE.CWE-124:Buffer Underwrite ('Buffer Underflow')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\nnamespace My_new_char_memmove_06\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n }\r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n memmove(data, source, 100*sizeof(char));\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n memmove(data, source, 100*sizeof(char));\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char * dataBuffer = new char[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n }\r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n memmove(data, source, 100*sizeof(char));\r\n \r\n data[100-1] = '\\0';\r\n printLine(data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_memmove_06; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-124:Buffer Underwrite ('Buffer Underflow')|D.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-1045:Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.CWE-628:Function Call with Incorrectly Specified Arguments\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#define SEARCH_CHAR 'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_connect_socket_14()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(globalFive==5)\r\n {\r\n \r\n for (; *data != '\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = '\\0';\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n if(globalFive==5)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < strlen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_connect_socket_14()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-761:Free of Pointer not at Start of Buffer|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-99:Improper Control of Resource Identifiers ('Resource Injection')\nB.CWE-665:Improper Initialization\nC.No Vulnerabilities\nD.CWE-326:Inadequate Encryption Strength\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ncat_13()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n size_t sourceLen;\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n sourceLen = strlen(source);\r\n \r\n strncat(data, source, sourceLen);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_ncat_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ncat_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ncat_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-357:Insufficient UI Warning of Dangerous Operations\nC.CWE-416:Use After Free\nD.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nE.CWE-672:Operation on a Resource after Expiration or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_int64_t_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n else\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n else\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n }\r\n else\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n }\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n else\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int64_t_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|E.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-154:Improper Neutralization of Variable Name Delimiters\nB.No Vulnerabilities\nC.CWE-36:Absolute Path Traversal\nD.CWE-1283:Mutable Attestation or Measurement Reporting Data\nE.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_wchar_t_console_w32CreateFile_81\r\n{\r\n\r\nclass My_wchar_t_console_w32CreateFile_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_wchar_t_console_w32CreateFile_81 : public My_wchar_t_console_w32CreateFile_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_wchar_t_console_w32CreateFile_81G2B : public My_wchar_t_console_w32CreateFile_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|E.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-248:Uncaught Exception\nB.CWE-761:Free of Pointer not at Start of Buffer\nC.CWE-763:Release of Invalid Pointer or Reference\nD.CWE-612:Improper Authorization of Index Containing Sensitive Information\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_file_03()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(5==5)\r\n {\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n data[0] = L'\\0';\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (100-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n if(5==5)\r\n {\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_file_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_file_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_file_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-761:Free of Pointer not at Start of Buffer|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1293:Missing Source Correlation of Multiple Independent Data\nB.CWE-685:Function Call With Incorrect Number of Arguments\nC.CWE-126:Buffer Over-read\nD.CWE-788:Access of Memory Location After End of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_My_CWE129_fscanf_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-126:Buffer Over-read|D.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nC.CWE-349:Acceptance of Extraneous Untrusted Data With Trusted Data\nD.CWE-590:Free of Memory not on the Heap\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_class_alloca_11\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n data = NULL; \r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n data = NULL; \r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n TwoIntsClass * dataBuffer = new TwoIntsClass;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n data = NULL; \r\n if(globalReturnsTrue())\r\n {\r\n {\r\n \r\n TwoIntsClass * dataBuffer = new TwoIntsClass;\r\n dataBuffer->intOne = 2;\r\n dataBuffer->intTwo = 2;\r\n data = dataBuffer;\r\n }\r\n }\r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_class_alloca_11; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-590:Free of Memory not on the Heap|E.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-627:Dynamic Variable Evaluation\nD.CWE-36:Absolute Path Traversal\nE.CWE-14:Compiler Removal of Code to Clear Buffers\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_console_ifstream_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalTrue)\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n ifstream inputFile;\r\n \r\n inputFile.open((char *)data);\r\n inputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_console_ifstream_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-36:Absolute Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1070:Serializable Data Element Containing non-Serializable Item Elements\nB.CWE-616:Incomplete Identification of Uploaded File Variables (PHP)\nC.No Vulnerabilities\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-617:Reachable Assertion\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_02()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(1)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fgets_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-617:Reachable Assertion|D.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-912:Hidden Functionality\nB.No Vulnerabilities\nC.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data\nD.CWE-51:Path Equivalence: '/multiple//internal/slash'\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define FILENAME \"conf.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_file_transfer_listen_socket_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char contents[65536]; \r\n FILE * pFile;\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgets(contents, (int)(65535), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n contents[0] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, contents, strlen(contents), 0) != strlen(contents))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_file_transfer_listen_socket_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-506:Embedded Malicious Code|A.CWE-912:Hidden Functionality", "cwe": "506"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-348:Use of Less Trusted Source\nB.CWE-1106:Insufficient Use of Symbolic Constants\nC.No Vulnerabilities\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-666:Operation on Resource in Wrong Phase of Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_45\r\n{\r\n\r\nstatic list<int> mData;\r\nstatic list<int> nG2BData;\r\nstatic list<int> nB2GData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n list<int> data = mData;\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n mData = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n list<int> data = nG2BData;\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n nG2BData = data;\r\n nG2BSink();\r\n}\r\n\r\n\r\nstatic void nB2GSink()\r\n{\r\n list<int> data = nB2GData;\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n nB2GData = data;\r\n nB2GSink();\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_45; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-672:Operation on a Resource after Expiration or Release|E.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1292:Incorrect Conversion of Security Identifiers\nB.No Vulnerabilities\nC.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nD.CWE-787:Out-of-bounds Write\nE.CWE-122:Heap-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_cpp_My_cpp_CWE805_int64_t_memcpy_66; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-122:Heap-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "122"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1023:Incomplete Comparison with Missing Factors\nB.CWE-768:Incorrect Short Circuit Evaluation\nC.CWE-478:Missing Default Case in Multiple Condition Expression\nD.CWE-1263:Improper Physical Access Control\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-478:Missing Default Case in Multiple Condition Expression|A.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "478"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-401:Missing Release of Memory after Effective Lifetime\nB.CWE-512:Spyware\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-325:Missing Cryptographic Step\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <stdio.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint reunited_semiminess = 0;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int ss_j;\r\n int ss_i;\r\n size_t taint_size;\r\n char **malloced_buff = 0;\r\n int trace_flag = 0;\r\n char *pebworth_woolwich = 0;\r\n jmp_buf commemorable_muliebrity;\r\n int suppedit_forfeited;\r\n char *outrapped_lesli = 0;\r\n int *postvorta_stolkjaerre = 0;\r\n int animalizing_verdure;\r\n char *kopeks_superlunar[10] = {0};\r\n int vetchiest_unavoidableness = 0;\r\n char *handicrafts_khis = 0;\r\n char *comedo_cephalology;;\r\n if (__sync_bool_compare_and_swap(&reunited_semiminess,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n comedo_cephalology = getenv(\"SATSUMA_BLAMES\");\r\n if (comedo_cephalology != 0) {;\r\n vetchiest_unavoidableness = ((int )(strlen(comedo_cephalology)));\r\n handicrafts_khis = ((char *)(malloc(vetchiest_unavoidableness + 1)));\r\n if (handicrafts_khis == 0) {\r\n printf(\"Error: Failed to allocate memory\\n\");\r\n exit(1);\r\n }\r\n memset(handicrafts_khis,0,vetchiest_unavoidableness + 1);\r\n memcpy(handicrafts_khis,comedo_cephalology,vetchiest_unavoidableness);\r\n animalizing_verdure = 5;\r\n postvorta_stolkjaerre = &animalizing_verdure;\r\n kopeks_superlunar[ *postvorta_stolkjaerre] = handicrafts_khis;\r\n outrapped_lesli = kopeks_superlunar[ *postvorta_stolkjaerre];\r\n suppedit_forfeited = setjmp(commemorable_muliebrity);\r\n if (suppedit_forfeited == 0) {\r\n longjmp(commemorable_muliebrity,1);\r\n }\r\n pebworth_woolwich = ((char *)outrapped_lesli);\r\n \r\n taint_size = strlen(pebworth_woolwich);\r\n \r\n if (taint_size >= 1600) {\r\n taint_size = 1599U;\r\n }\r\n malloced_buff = malloc(taint_size * sizeof(char *));\r\n \r\n \r\n if (malloced_buff != 0) {\r\n \r\n \r\n for (ss_i = 0; ss_i < taint_size; ++ss_i) {\r\n malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\r\n \r\n \r\n if (malloced_buff[ss_i] == 0 && errno == 12) {\r\n printf(\"Malloc error due to ulimit\\n\");\r\n if (trace_flag == 0) {\r\n \r\n \r\n trace_flag = 1;\r\n }\r\n }\r\n if (malloced_buff[ss_i] != 0) {\r\n for (ss_j = 0; ss_j < taint_size; ++ss_j) {\r\n memcpy(malloced_buff[ss_i] + ss_j * taint_size,pebworth_woolwich,taint_size);\r\n }\r\n }\r\n \r\n \r\n if (taint_size % 2 == 0) {\r\n if (malloced_buff[ss_i] != 0) {\r\n free(malloced_buff[ss_i]);\r\n \r\n }\r\n }\r\n }\r\n free(malloced_buff);\r\n \r\n }\r\n;\r\n if (outrapped_lesli != 0) \r\n free(((char *)outrapped_lesli));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-401:Missing Release of Memory after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nB.No Vulnerabilities\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-76:Improper Neutralization of Equivalent Special Elements\nE.CWE-704:Incorrect Type Conversion or Cast\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2int_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2int_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2int_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2int_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-681:Incorrect Conversion between Numeric Types|E.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-588:Attempt to Access Child of a Non-structure Pointer\nC.CWE-230:Improper Handling of Missing Values\nD.CWE-1318:Missing Support for Security Features in On-chip Fabrics or Buses\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_struct_54bSink(void * data);\r\n\r\nvoid My_struct_54()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n My_struct_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_struct_54bG2BSink(void * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n My_struct_54bG2BSink(data);\r\n}\r\n\r\nvoid My_struct_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-588:Attempt to Access Child of a Non-structure Pointer|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-221:Information Loss or Omission\nD.CWE-222:Truncation of Security-relevant Information\nE.CWE-274:Improper Handling of Insufficient Privileges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n#define USERNAME_SIZE 15\r\n#define TRUNCATED_USERNAME_SIZE 4 \r\n#define DOMAIN \"Domain\"\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n char truncatedUsername[TRUNCATED_USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n memcpy(truncatedUsername, username, sizeof(truncatedUsername));\r\n truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0';\r\n \r\n if (LogonUserA(\r\n truncatedUsername,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n HANDLE pHandle;\r\n char username[USERNAME_SIZE+1];\r\n do\r\n {\r\n if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\r\n {\r\n break;\r\n }\r\n wsaDataInit = TRUE;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\r\n {\r\n break;\r\n }\r\n username[USERNAME_SIZE] = '\\0';\r\n \r\n \r\n \r\n if (LogonUserA(\r\n username,\r\n DOMAIN,\r\n PASSWORD, \r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-222:Truncation of Security-relevant Information|C.CWE-221:Information Loss or Omission", "cwe": "222"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1342:Information Exposure through Microarchitectural State after Transient Execution\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-1125:Excessive Attack Surface\nD.No Vulnerabilities\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT L\"cmd.exe\"\r\n#define COMMAND_ARG1 L\"/c\"\r\n#define COMMAND_ARG2 L\"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH L\"/bin/sh\"\r\n#define COMMAND_INT L\"sh\"\r\n#define COMMAND_ARG1 L\"-c\"\r\n#define COMMAND_ARG2 L\"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <process.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_connect_socket_w32_spawnlp_02()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n \r\n _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n \r\n \r\n _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(1)\r\n {\r\n \r\n wcscat(data, L\"*.*\");\r\n }\r\n \r\n \r\n _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_wchar_t_connect_socket_w32_spawnlp_02()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_connect_socket_w32_spawnlp_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_connect_socket_w32_spawnlp_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-648:Incorrect Use of Privileged APIs\nC.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.No Vulnerabilities\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint bastinado_pityproof = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid reglazes_clericalists(int zarathustra_reshowing,char **wielding_remex);\r\nint 191_global_var = 0;\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n int formalization_allegan = 7;\r\n char **gamas_craniocele = 0;\r\n char **jfif_unwinder = 0;\r\n char *chitchatty_dianilide;;\r\n if (__sync_bool_compare_and_swap(&bastinado_pityproof,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n chitchatty_dianilide = getenv(\"PELORIZED_MUTCHKINS\");\r\n if (chitchatty_dianilide != 0) {;\r\n gamas_craniocele = &chitchatty_dianilide;\r\n jfif_unwinder = gamas_craniocele + 5;\r\n reglazes_clericalists(formalization_allegan,jfif_unwinder);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid reglazes_clericalists(int zarathustra_reshowing,char **wielding_remex)\r\n{\r\n FILE * random_data = 0;\r\n char * buff = 0;\r\n unsigned long long num = 0;\r\n unsigned long long i = 0;\r\n char *singhalese_pinkany = 0;\r\n ++global_variable;\r\n zarathustra_reshowing--;\r\n if (zarathustra_reshowing > 0) {\r\n reglazes_clericalists(zarathustra_reshowing,wielding_remex);\r\n return ;\r\n }\r\n singhalese_pinkany = ((char *)( *(wielding_remex - 5)));\r\n \r\n random_data = fopen(\"/dev/urandom\", \"r\");\r\n if(random_data != NULL){\r\n num = strtoull(singhalese_pinkany, NULL, 10);\r\n if(num > (unsigned long long) 0 ){\r\n if(num > (unsigned long long) 100 ){\r\n num = (unsigned long long) 100;\r\n }\r\n \r\n \r\n \r\n \r\n \r\n buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\r\n for(i = 0; i < num - (unsigned long long) 10; i++){\r\n buff[i] = fgetc(random_data);\r\n }\r\n \r\n \r\n }\r\n printf(\"data is: %s\", buff);\r\n fclose(random_data);\r\n if(buff != NULL){\r\n free(buff);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-682:Incorrect Calculation\nC.CWE-1073:Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses\nD.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(short data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_rand_predec_21()\r\n{\r\n short data;\r\n data = 0;\r\n \r\n data = (short)RAND32();\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(short data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n short data;\r\n data = 0;\r\n \r\n data = (short)RAND32();\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(short data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n if (data > SHRT_MIN)\r\n {\r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n short data;\r\n data = 0;\r\n \r\n data = (short)RAND32();\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(short data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n {\r\n \r\n --data;\r\n short result = data;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n data = 0;\r\n \r\n data = -2;\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_short_rand_predec_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_rand_predec_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_rand_predec_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|B.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-468:Incorrect Pointer Scaling\nB.CWE-682:Incorrect Calculation\nC.No Vulnerabilities\nD.CWE-455:Non-exit on Failed Initialization\nE.CWE-300:Channel Accessible by Non-Endpoint\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_ptr_to_int_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+2));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n int intArray[5] = { 1, 2, 3, 4, 5 };\r\n char *charPointer = (char *)intArray; \r\n \r\n \r\n int toPrint = (int) (*(charPointer+(2*sizeof(int))));\r\n printIntLine(toPrint);\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_ptr_to_int_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ptr_to_int_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ptr_to_int_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-468:Incorrect Pointer Scaling|B.CWE-682:Incorrect Calculation", "cwe": "468"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-126:Buffer Over-read\nB.No Vulnerabilities\nC.CWE-1277:Firmware Not Updateable\nD.CWE-1118:Insufficient Documentation of Error Handling Techniques\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_declare_memmove_65bSink(char * data);\r\n\r\nvoid My_char_declare_memmove_65()\r\n{\r\n char * data;\r\n \r\n void (*funcPtr) (char *) = My_char_declare_memmove_65bSink;\r\n char dataMBuffer[50];\r\n char dataNBuffer[100];\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataMBuffer;\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_declare_memmove_65bG2BSink(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n void (*funcPtr) (char *) = My_char_declare_memmove_65bG2BSink;\r\n char dataMBuffer[50];\r\n char dataNBuffer[100];\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataNBuffer;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_char_declare_memmove_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_memmove_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_memmove_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-131:Incorrect Calculation of Buffer Size\nB.CWE-467:Use of sizeof() on a Pointer Type\nC.No Vulnerabilities\nD.CWE-705:Incorrect Control Flow Scoping\nE.CWE-470:Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n short * mShort = NULL;\r\n \r\n mShort = (short *)malloc(sizeof(mShort));\r\n if (mShort == NULL) {exit(-1);}\r\n *mShort = 5;\r\n printShortLine(*mShort);\r\n free(mShort);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n short * nShort = NULL;\r\n \r\n nShort = (short *)malloc(sizeof(*nShort));\r\n if (nShort == NULL) {exit(-1);}\r\n *nShort = 6;\r\n printShortLine(*nShort);\r\n free(nShort);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n short * nShort = NULL;\r\n \r\n nShort = (short *)malloc(sizeof(*nShort));\r\n if (nShort == NULL) {exit(-1);}\r\n *nShort = 6;\r\n printShortLine(*nShort);\r\n free(nShort);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n short * nShort = NULL;\r\n \r\n nShort = (short *)malloc(sizeof(*nShort));\r\n if (nShort == NULL) {exit(-1);}\r\n *nShort = 6;\r\n printShortLine(*nShort);\r\n free(nShort);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-467:Use of sizeof() on a Pointer Type|A.CWE-131:Incorrect Calculation of Buffer Size", "cwe": "467"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-606:Unchecked Input for Loop Condition\nC.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nD.CWE-1284:Improper Validation of Specified Quantity in Input\nE.CWE-757:Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\nstatic char * mSource(char * data)\r\n{\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_char_connect_socket_42()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic char * nG2BSource(char * data)\r\n{\r\n \r\n strcpy(data, \"15\");\r\n return data;\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic char * nB2GSource(char * data)\r\n{\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n data = nB2GSource(data);\r\n {\r\n int i, n, intVariable;\r\n if (sscanf(data, \"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_connect_socket_42()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-606:Unchecked Input for Loop Condition|D.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1111:Incomplete I/O Documentation\nB.No Vulnerabilities\nC.CWE-665:Improper Initialization\nD.CWE-332:Insufficient Entropy in PRNG\nE.CWE-457:Use of Uninitialized Variable\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double_array_alloca_no_init_16()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n while(1)\r\n {\r\n \r\n ; \r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n while(1)\r\n {\r\n \r\n ; \r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n double * data;\r\n data = (double *)ALLOCA(10*sizeof(double));\r\n while(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n data[i] = (double)i;\r\n }\r\n }\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n {\r\n int i;\r\n for(i=0; i<10; i++)\r\n {\r\n printDoubleLine(data[i]);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_double_array_alloca_no_init_16()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double_array_alloca_no_init_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double_array_alloca_no_init_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-457:Use of Uninitialized Variable|C.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nB.No Vulnerabilities\nC.CWE-613:Insufficient Session Expiration\nD.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\nE.CWE-273:Improper Check for Dropped Privileges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define STAT _stat\r\n#define OPEN _open\r\n#define WRITE _write\r\n#define O_RDWR _O_RDWR\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define STAT stat\r\n#define OPEN open\r\n#define WRITE write\r\n#define CLOSE close\r\n#endif\r\n\r\n#define M_SINK_STRING \"M Sink...\"\r\n#define N_SINK_STRING \"N Sink...\"\r\n\r\n#ifdef _WIN32\r\n#define ACCESS _access\r\n#define W_OK 02\r\n#else\r\n#define ACCESS access\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_access_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n if (ACCESS(filename, W_OK) == -1)\r\n {\r\n exit(1);\r\n }\r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, M_SINK_STRING, strlen(M_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n char filename[100] = \"\";\r\n int fileDesc = -1;\r\n if (fgets(filename, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n filename[0] = '\\0';\r\n }\r\n if (strlen(filename) > 0)\r\n {\r\n filename[strlen(filename)-1] = '\\0'; \r\n }\r\n \r\n fileDesc = OPEN(filename, O_RDWR);\r\n if (fileDesc == -1)\r\n {\r\n exit(1);\r\n }\r\n if (WRITE(fileDesc, N_SINK_STRING, strlen(N_SINK_STRING)) == -1)\r\n {\r\n exit(1);\r\n }\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_access_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_access_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_access_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|D.CWE-362:Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cwe": "367"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.No Vulnerabilities\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-627:Dynamic Variable Evaluation\nE.CWE-270:Privilege Context Switching Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\ntypedef union\r\n{\r\n int unionFirst;\r\n int unionSecond;\r\n} My_rand_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_rand_34()\r\n{\r\n int data;\r\n My_rand_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n assert(data > ASSERT_VALUE);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_rand_34_unionType myUnion;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n myUnion.unionFirst = data;\r\n {\r\n int data = myUnion.unionSecond;\r\n \r\n assert(data > ASSERT_VALUE);\r\n }\r\n}\r\n\r\nvoid My_rand_34()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-617:Reachable Assertion|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-627:Dynamic Variable Evaluation\nE.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_wchar_t_malloc_54\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(wchar_t * data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n \r\n data = new wchar_t;\r\n nG2BSink_b(data);\r\n}\r\n\r\n\r\nvoid nB2GSink_b(wchar_t * data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n \r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n nB2GSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_wchar_t_malloc_54; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1103:Use of Platform-Dependent Third Party Components\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-455:Non-exit on Failed Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_w32_close_15()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(6)\r\n {\r\n case 6:\r\n if (data != NULL)\r\n {\r\n \r\n _close((int)data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n \r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n switch(6)\r\n {\r\n case 6:\r\n if (data != NULL)\r\n {\r\n \r\n fclose(data);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_fopen_w32_close_15()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_w32_close_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_w32_close_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-404:Improper Resource Shutdown or Release|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-588:Attempt to Access Child of a Non-structure Pointer\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-704:Incorrect Type Conversion or Cast\nD.No Vulnerabilities\nE.CWE-1262:Improper Access Control for Register Interface\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_18\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n goto source;\r\nsource:\r\n \r\n data = &dataMBuffer;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n TwoIntsClass dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n goto source;\r\nsource:\r\n \r\n data = &dataNBuffer;\r\n \r\n printIntLine((reinterpret_cast<TwoIntsClass *>(data))->intTwo);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_18; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-588:Attempt to Access Child of a Non-structure Pointer|C.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-114:Process Control\nB.No Vulnerabilities\nC.CWE-636:Not Failing Securely ('Failing Open')\nD.CWE-73:External Control of File Name or Path\nE.CWE-257:Storing Passwords in a Recoverable Format\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n\r\nnamespace My_w32_wchar_t_relativePath_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryW(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_relativePath_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-114:Process Control|D.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.No Vulnerabilities\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef struct _My_struct_67_structType\r\n{\r\n twoIntsStruct * structFirst;\r\n} My_struct_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_struct_67bSink(My_struct_67_structType myStruct);\r\n\r\nvoid My_struct_67()\r\n{\r\n twoIntsStruct * data;\r\n My_struct_67_structType myStruct;\r\n \r\n data = NULL;\r\n myStruct.structFirst = data;\r\n My_struct_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_struct_67bG2BSink(My_struct_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n twoIntsStruct * data;\r\n My_struct_67_structType myStruct;\r\n \r\n {\r\n twoIntsStruct tmpData;\r\n tmpData.intOne = 0;\r\n tmpData.intTwo = 0;\r\n data = &tmpData;\r\n }\r\n myStruct.structFirst = data;\r\n My_struct_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_struct_67bB2GSink(My_struct_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n twoIntsStruct * data;\r\n My_struct_67_structType myStruct;\r\n \r\n data = NULL;\r\n myStruct.structFirst = data;\r\n My_struct_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_struct_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-691:Insufficient Control Flow Management\nB.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-400:Uncontrolled Resource Consumption\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_for_loop_10()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(globalTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(globalTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(globalTrue)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n if (count > 0 && count <= 20)\r\n {\r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n count = 20;\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n if(globalTrue)\r\n {\r\n \r\n count = 20;\r\n }\r\n if(globalTrue)\r\n {\r\n {\r\n size_t i = 0;\r\n \r\n for (i = 0; i < (size_t)count; i++)\r\n {\r\n printLine(\"Hello\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_for_loop_10()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_for_loop_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_for_loop_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-400:Uncontrolled Resource Consumption|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-834:Excessive Iteration\nC.CWE-416:Use After Free\nD.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_new_delete_char_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printHexCharLine(*data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n delete data;\r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printHexCharLine(*data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n data = new char;\r\n *data = 'A';\r\n \r\n }\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printHexCharLine(*data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_char_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-400:Uncontrolled Resource Consumption\nB.No Vulnerabilities\nC.CWE-1059:Insufficient Technical Documentation\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-1269:Product Released in Non-Release Configuration\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\nusing namespace std;\r\n\r\nnamespace My_connect_socket_for_loop_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int> countMap);\r\n\r\nvoid m()\r\n{\r\n int count;\r\n map<int, int> countMap;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n countMap[0] = count;\r\n countMap[1] = count;\r\n countMap[2] = count;\r\n mSink(countMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, int> countMap);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n map<int, int> countMap;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n \r\n countMap[0] = count;\r\n countMap[1] = count;\r\n countMap[2] = count;\r\n nG2BSink(countMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, int> countMap);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n map<int, int> countMap;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n countMap[0] = count;\r\n countMap[1] = count;\r\n countMap[2] = count;\r\n nB2GSink(countMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_connect_socket_for_loop_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-400:Uncontrolled Resource Consumption|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-626:Null Byte Interaction Error (Poison Null Byte)\nB.CWE-665:Improper Initialization\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-103:Struts: Incomplete validate() Method Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_cat_13()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_cat_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_cat_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_cat_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-510:Trapdoor\nC.CWE-691:Insufficient Control Flow Management\nD.CWE-645:Overly Restrictive Account Lockout Mechanism\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_listen_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(30000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_listen_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|E.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-277:Insecure Inherited Permissions\nB.CWE-138:Improper Neutralization of Special Elements\nC.No Vulnerabilities\nD.CWE-1094:Excessive Index Range Scan for a Data Resource\nE.CWE-464:Addition of Data Structure Sentinel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_10()\r\n{\r\n char data;\r\n data = ' ';\r\n if(globalTrue)\r\n {\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char data;\r\n data = ' ';\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char data;\r\n data = ' ';\r\n if(globalTrue)\r\n {\r\n \r\n data = 'a';\r\n }\r\n {\r\n char charArraySink[4];\r\n charArraySink[0] = 'x';\r\n \r\n charArraySink[1] = data;\r\n charArraySink[2] = 'z';\r\n charArraySink[3] = '\\0';\r\n printLine(charArraySink);\r\n }\r\n}\r\n\r\nvoid My_basic_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-464:Addition of Data Structure Sentinel|B.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-450:Multiple Interpretations of UI Input\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-459:Incomplete Cleanup\nE.CWE-81:Improper Neutralization of Script in an Error Message Web Page\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _wunlink\r\n#define FOPEN _wfopen\r\n#define MKTEMP _wmktemp\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#define FOPEN fopen\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"mXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-459:Incomplete Cleanup|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-161:Improper Neutralization of Multiple Leading Special Elements\nC.CWE-616:Incomplete Identification of Uploaded File Variables (PHP)\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-546:Suspicious Comment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_TODO_01()\r\n{\r\n \r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic void n1()\r\n{\r\n \r\n printLine(\"Hello\");\r\n}\r\n\r\nvoid My_TODO_01()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_TODO_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_TODO_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-494:Download of Code Without Integrity Check\nD.CWE-791:Incomplete Filtering of Special Elements\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(int data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n printIntLine(100 % data);\r\n }\r\n}\r\n\r\nvoid My_int_fscanf_modulo_21()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(int data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 % data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(int data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 % data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(int data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n \r\n printIntLine(100 % data);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 7;\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_int_fscanf_modulo_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_fscanf_modulo_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_fscanf_modulo_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-369:Divide By Zero|B.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-672:Operation on a Resource after Expiration or Release\nB.CWE-416:Use After Free\nC.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nD.No Vulnerabilities\nE.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_int64_t_03\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n if(5==5)\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n delete data;\r\n }\r\n if(5==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n }\r\n if(5==5)\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(5==5)\r\n {\r\n data = new int64_t;\r\n *data = 5LL;\r\n \r\n }\r\n if(5==5)\r\n {\r\n \r\n printLongLongLine(*data);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int64_t_03; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-416:Use After Free|A.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-154:Improper Neutralization of Variable Name Delimiters\nB.CWE-1177:Use of Prohibited Code\nC.No Vulnerabilities\nD.CWE-242:Use of Inherently Dangerous Function\nE.CWE-1327:Binding to an Unrestricted IP Address\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define DEST_SIZE 10\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n \r\n result = gets(dest);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n result = fgets(dest, DEST_SIZE, stdin);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n char dest[DEST_SIZE];\r\n char *result;\r\n \r\n result = fgets(dest, DEST_SIZE, stdin);\r\n \r\n if (result == NULL)\r\n {\r\n \r\n printLine(\"Error Condition: alter control flow to indicate action taken\");\r\n exit(1);\r\n }\r\n dest[DEST_SIZE-1] = '\\0';\r\n printLine(dest);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_10()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-242:Use of Inherently Dangerous Function|B.CWE-1177:Use of Prohibited Code", "cwe": "242"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-427:Uncontrolled Search Path Element\nB.No Vulnerabilities\nC.CWE-489:Active Debug Code\nD.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define NEW_PATH \"%SystemRoot%\\\\system32\"\r\n#define PUTENV _putenv\r\n#else\r\n#define NEW_PATH \"/bin\"\r\n#define PUTENV putenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar * My_char_listen_socket_61bSource(char * data);\r\n\r\nvoid My_char_listen_socket_61()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n data = My_char_listen_socket_61bSource(data);\r\n \r\n PUTENV(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar * My_char_listen_socket_61bG2BSource(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[250] = \"PATH=\";\r\n data = dataBuffer;\r\n data = My_char_listen_socket_61bG2BSource(data);\r\n \r\n PUTENV(data);\r\n}\r\n\r\nvoid My_char_listen_socket_61()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_61();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_61();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-427:Uncontrolled Search Path Element|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "427"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-395:Use of NullPointerException Catch to Detect NULL Pointer Dereference\nB.CWE-681:Incorrect Conversion between Numeric Types\nC.CWE-167:Improper Handling of Additional Special Element\nD.No Vulnerabilities\nE.CWE-195:Signed to Unsigned Conversion Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_listen_socket_strncpy_53bSink(int data);\r\n\r\nvoid My_listen_socket_strncpy_53()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_listen_socket_strncpy_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_listen_socket_strncpy_53bG2BSink(int data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 100-1;\r\n My_listen_socket_strncpy_53bG2BSink(data);\r\n}\r\n\r\nvoid My_listen_socket_strncpy_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_strncpy_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_strncpy_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-195:Signed to Unsigned Conversion Error|B.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-641:Improper Restriction of Names for Files and Other Resources\nB.CWE-15:External Control of System or Configuration Setting\nC.CWE-93:Improper Neutralization of CRLF Sequences ('CRLF Injection')\nD.No Vulnerabilities\nE.CWE-642:External Control of Critical State Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\nstatic char * My_w32_45Data;\r\nstatic char * My_w32_45G2BData;\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink()\r\n{\r\n char * data = My_w32_45Data;\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_45()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n My_w32_45Data = data;\r\n mSink();\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink()\r\n{\r\n char * data = My_w32_45G2BData;\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"hostname\");\r\n My_w32_45G2BData = data;\r\n nG2BSink();\r\n}\r\n\r\nvoid My_w32_45()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_45();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_45();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-15:External Control of System or Configuration Setting|E.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-459:Incomplete Cleanup\nC.CWE-404:Improper Resource Shutdown or Release\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _wunlink\r\n#define FOPEN _wfopen\r\n#define MKTEMP _wmktemp\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#define FOPEN fopen\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"mXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n filename = MKTEMP(tmpl);\r\n if (filename != NULL)\r\n {\r\n pFile = FOPEN(filename, L\"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-459:Incomplete Cleanup|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-511:Logic/Time Bomb\nB.CWE-203:Observable Discrepancy\nC.CWE-697:Incorrect Comparison\nD.CWE-506:Embedded Malicious Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32CompareFileTime_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n UNLINK(\"important_file.txt\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n SYSTEMTIME setTime, currentTime;\r\n FILETIME setTimeAsFileTime, currentTimeAsFileTime;\r\n \r\n setTime.wYear = 2008; \r\n setTime.wMonth = 1; \r\n setTime.wDayOfWeek = 0; \r\n setTime.wDay = 1; \r\n setTime.wHour = 12; \r\n setTime.wMinute = 0; \r\n setTime.wSecond = 0; \r\n setTime.wMilliseconds = 0; \r\n GetSystemTime(&currentTime);\r\n \r\n SystemTimeToFileTime(&currentTime, &currentTimeAsFileTime);\r\n SystemTimeToFileTime(&setTime, &setTimeAsFileTime);\r\n \r\n if (CompareFileTime(&currentTimeAsFileTime, &setTimeAsFileTime) == 1)\r\n {\r\n printLine(\"Happy New Year!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32CompareFileTime_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CompareFileTime_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CompareFileTime_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-511:Logic/Time Bomb|D.CWE-506:Embedded Malicious Code", "cwe": "511"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-119:Improper Restriction of Operations within the Bounds of a Memory Buffer\nB.CWE-453:Insecure Default Variable Initialization\nC.No Vulnerabilities\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-273:Improper Check for Dropped Privileges\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-273:Improper Check for Dropped Privileges|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-326:Inadequate Encryption Strength\nB.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nC.No Vulnerabilities\nD.CWE-328:Use of Weak Hash\nE.CWE-284:Improper Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD5_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD5_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD5_SUM_SIZE], calcHash[MD5_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD5_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD5_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD5_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD5_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD5_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD5_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-328:Use of Weak Hash|A.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-456:Missing Initialization of a Variable\nB.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nC.CWE-188:Reliance on Data/Memory Layout\nD.No Vulnerabilities\nE.CWE-96:Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_union_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n union\r\n {\r\n struct\r\n {\r\n char charFirst, charSecond, charThird, charFourth;\r\n } structChars;\r\n long longNumber;\r\n } unionStructLong;\r\n unionStructLong.longNumber = 0x10203040;\r\n \r\n unionStructLong.structChars.charFourth |= 0x80; \r\n printIntLine(unionStructLong.longNumber);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n long longNumber;\r\n longNumber = 0x10203040;\r\n \r\n longNumber |= LONG_MIN;\r\n printIntLine(longNumber);\r\n }\r\n }\r\n}\r\n\r\nvoid My_union_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_union_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_union_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-188:Reliance on Data/Memory Layout|B.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality", "cwe": "188"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-439:Behavioral Change in New Version or Environment\nC.CWE-368:Context Switching Race Condition\nD.No Vulnerabilities\nE.CWE-590:Free of Memory not on the Heap\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_delete_wchar_t_declare_34\r\n{\r\n\r\ntypedef union\r\n{\r\n wchar_t * unionFirst;\r\n wchar_t * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n unionType myUnion;\r\n data = NULL; \r\n {\r\n \r\n wchar_t dataBuffer;\r\n dataBuffer = L'A';\r\n data = &dataBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n printWcharLine(*data);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n unionType myUnion;\r\n data = NULL; \r\n {\r\n \r\n wchar_t * dataBuffer = new wchar_t;\r\n *dataBuffer = L'A';\r\n data = dataBuffer;\r\n }\r\n myUnion.unionFirst = data;\r\n {\r\n wchar_t * data = myUnion.unionSecond;\r\n printWcharLine(*data);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_wchar_t_declare_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-590:Free of Memory not on the Heap|A.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1292:Incorrect Conversion of Security Identifiers\nC.CWE-416:Use After Free\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-1263:Improper Physical Access Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_malloc_free_wchar_t_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(wchar_t * &data)\r\n{\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n free(data);\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n printWLine(data);\r\n \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(wchar_t * &data)\r\n{\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n printWLine(data);\r\n \r\n}\r\n\r\n\r\nstatic void nB2GSource(wchar_t * &data)\r\n{\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n wmemset(data, L'A', 100-1);\r\n data[100-1] = L'\\0';\r\n \r\n free(data);\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n \r\n \r\n ; \r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_free_wchar_t_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-416:Use After Free|D.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nB.CWE-578:EJB Bad Practices: Use of Class Loader\nC.CWE-1289:Improper Validation of Unsafe Equivalence in Input\nD.CWE-413:Improper Resource Locking\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_54bSink(char * password);\r\n\r\nvoid My_w32_char_54()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_54bSink(password);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_54bG2BSink(char * password);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n My_w32_char_54bG2BSink(password);\r\n}\r\n\r\nvoid My_w32_char_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-591:Sensitive Data Storage in Improperly Locked Memory|D.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1284:Improper Validation of Specified Quantity in Input\nB.CWE-1078:Inappropriate Source Code Style or Formatting\nC.No Vulnerabilities\nD.CWE-1092:Use of Same Invokable Control Element in Multiple Architectural Layers\nE.CWE-606:Unchecked Input for Loop Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define MAX_LOOP 10000\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_listen_socket_05()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n if (n < MAX_LOOP)\r\n {\r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticTrue)\r\n {\r\n \r\n wcscpy(data, L\"15\");\r\n }\r\n if(staticTrue)\r\n {\r\n {\r\n int i, n, intVariable;\r\n if (swscanf(data, L\"%d\", &n) == 1)\r\n {\r\n \r\n intVariable = 0;\r\n for (i = 0; i < n; i++)\r\n {\r\n \r\n intVariable++; \r\n }\r\n printIntLine(intVariable);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_listen_socket_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_listen_socket_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_listen_socket_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-606:Unchecked Input for Loop Condition|A.CWE-1284:Improper Validation of Specified Quantity in Input", "cwe": "606"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm\nB.CWE-1067:Excessive Execution of Sequential Searches of Data Resource\nC.CWE-693:Protection Mechanism Failure\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_3DES_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char password[100];\r\n size_t passwordLen;\r\n char toBeDecrypted[100];\r\n DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\r\n \r\n printLine(\"Enter the password: \");\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n pFile = fopen(\"encrypted.txt\", \"rb\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n toBeDecrypted[99] = '\\0';\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\r\n {\r\n printLine(\"Error in hashing password\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\r\n {\r\n printLine(\"Error in decryption\");\r\n exit(1);\r\n }\r\n \r\n toBeDecrypted[toBeDecryptedLen] = '\\0';\r\n printLine(toBeDecrypted);\r\n \r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_3DES_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_3DES_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_3DES_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-327:Use of a Broken or Risky Cryptographic Algorithm|C.CWE-693:Protection Mechanism Failure", "cwe": "327"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.No Vulnerabilities\nC.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\nD.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nE.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n", "input": "\r\n\r\n\r\n#ifndef HEADER_BSS_FILE_C\r\n#define HEADER_BSS_FILE_C\r\n#if defined(__linux) || defined(__sun) || defined(__hpux)\r\n\r\n#ifndef _FILE_OFFSET_BITS\r\n#define _FILE_OFFSET_BITS 64\r\n#endif\r\n#endif\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include \"cryptlib.h\"\r\n#include \"bio_lcl.h\"\r\n#include <openssl/err.h>\r\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n#include <nwfileio.h>\r\n#endif\r\n#if !defined(OPENSSL_NO_STDIO)\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int file_write(BIO *b,const char *in,int inl);\r\nstatic int file_read(BIO *b,char *out,int outl);\r\nstatic int file_puts(BIO *bp,const char *str);\r\nstatic int file_gets(BIO *bp,char *buf,int size);\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\r\nstatic int file_new(BIO *bi);\r\nstatic int file_free(BIO *a);\r\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\r\nint spaits_frisco = 0;\r\n\r\nstruct eptatretus_gonfanons \r\n{\r\n char *trochophore_causticized;\r\n double topkick_cryosurgical;\r\n char *sortilege_unqualified;\r\n char lauder_laurus;\r\n int moulder_intendancy;\r\n}\r\n;\r\nint global_variable;\r\nvoid ricketier_usl(struct eptatretus_gonfanons *burned_flinthead);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid passement_abhenry(void (*operational_donsky)(struct eptatretus_gonfanons *));\r\nint toupper(int c)\r\n{\r\n if (c >= 97 && c <= 122) {\r\n return c - 32;\r\n }\r\n return c;\r\n}\r\n\r\nBIO *BIO_new_file(const char *filename,const char *mode)\r\n{\r\n BIO *ret;\r\n FILE *file = ((void *)0);\r\n#if defined(_WIN32) && defined(CP_UTF8)\r\n\r\n\r\n#else\r\n file = fopen(filename,mode);\r\n#endif\r\n if (file == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\r\n ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\r\n if ( *__errno_location() == 2) {\r\n ERR_put_error(32,109,128,\"bss_file.c\",172);\r\n }\r\n else {\r\n ERR_put_error(32,109,2,\"bss_file.c\",174);\r\n }\r\n return ((void *)0);\r\n }\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n fclose(file);\r\n return ((void *)0);\r\n }\r\n\r\n BIO_clear_flags(ret,0);\r\n BIO_ctrl(ret,106,0x01,((char *)file));\r\n return ret;\r\n}\r\n\r\nBIO *BIO_new_fp(FILE *stream,int close_flag)\r\n{\r\n BIO *ret;\r\n if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\r\n return ((void *)0);\r\n }\r\n\r\n BIO_set_flags(ret,0);\r\n BIO_ctrl(ret,106,close_flag,((char *)stream));\r\n return ret;\r\n}\r\n\r\nBIO_METHOD *BIO_s_file()\r\n{\r\n return &methods_filep;\r\n}\r\n\r\nstatic int file_new(BIO *bi)\r\n{\r\n bi -> init = 0;\r\n bi -> num = 0;\r\n bi -> ptr = ((void *)0);\r\n\r\n bi -> flags = 0;\r\n return 1;\r\n}\r\n\r\nstatic int file_free(BIO *a)\r\n{\r\n if (a == ((void *)0)) {\r\n return 0;\r\n }\r\n if (a -> shutdown) {\r\n if (a -> init && a -> ptr != ((void *)0)) {\r\n if (a -> flags & 0) {\r\n fclose((a -> ptr));\r\n }\r\n else {\r\n fclose((a -> ptr));\r\n }\r\n a -> ptr = ((void *)0);\r\n a -> flags = 0;\r\n }\r\n a -> init = 0;\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int file_read(BIO *b,char *out,int outl)\r\n{\r\n int ret = 0;\r\n if (b -> init && out != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fread(out,1,((int )outl),(b -> ptr)));\r\n }\r\n else {\r\n ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\r\n }\r\n if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\r\n ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\r\n ERR_put_error(32,130,2,\"bss_file.c\",246);\r\n ret = - 1;\r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_write(BIO *b,const char *in,int inl)\r\n{\r\n int ret = 0;\r\n if (b -> init && in != ((void *)0)) {\r\n if (b -> flags & 0) {\r\n ret = (fwrite(in,((int )inl),1,(b -> ptr)));\r\n }\r\n else {\r\n ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\r\n }\r\n if (ret) {\r\n ret = inl;\r\n }\r\n\r\n\r\n }\r\n return ret;\r\n}\r\n\r\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\r\n{\r\n long ret = 1;\r\n FILE *fp = (FILE *)(b -> ptr);\r\n FILE **fpp;\r\n char p[4];\r\n if (__sync_bool_compare_and_swap(&spaits_frisco,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n passement_abhenry(ricketier_usl);\r\n }\r\n }\r\n switch(cmd){\r\n case 128:\r\n{\r\n }\r\n case 1:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(fseek((b -> ptr),num,0)));\r\n }\r\n else {\r\n ret = ((long )(fseek(fp,num,0)));\r\n }\r\n break; \r\n }\r\n case 2:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ((long )(feof(fp)));\r\n }\r\n else {\r\n ret = ((long )(feof(fp)));\r\n }\r\n break; \r\n }\r\n case 133:\r\n{\r\n }\r\n case 3:\r\n{\r\n if (b -> flags & 0) {\r\n ret = ftell((b -> ptr));\r\n }\r\n else {\r\n ret = ftell(fp);\r\n }\r\n break; \r\n }\r\n case 106:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n b -> ptr = ptr;\r\n b -> init = 1;\r\n#if BIO_FLAGS_UPLINK!=0\r\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\r\n#define _IOB_ENTRIES 20\r\n#endif\r\n#if defined(_IOB_ENTRIES)\r\n\r\n#endif\r\n#endif\r\n#ifdef UP_fsetmod\r\n#endif\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS)\r\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\r\n\r\n#elif defined(OPENSSL_SYS_MSDOS)\r\n\r\n\r\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n }\r\n break; \r\n }\r\n case 108:\r\n{\r\n file_free(b);\r\n b -> shutdown = ((int )num) & 0x01;\r\n if (num & 0x08) {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"a+\",sizeof(p));\r\n }\r\n else {\r\n BUF_strlcpy(p,\"a\",sizeof(p));\r\n }\r\n }\r\n else {\r\n if (num & 0x02 && num & 0x04) {\r\n BUF_strlcpy(p,\"r+\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x04) {\r\n BUF_strlcpy(p,\"w\",sizeof(p));\r\n }\r\n else {\r\n if (num & 0x02) {\r\n BUF_strlcpy(p,\"r\",sizeof(p));\r\n }\r\n else {\r\n ERR_put_error(32,116,101,\"bss_file.c\",379);\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n }\r\n }\r\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\r\n#endif\r\n#if defined(OPENSSL_SYS_NETWARE)\r\n#endif\r\n fp = fopen(ptr,p);\r\n if (fp == ((void *)0)) {\r\n ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\r\n ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\r\n ERR_put_error(32,116,2,\"bss_file.c\",400);\r\n ret = 0;\r\n break; \r\n }\r\n b -> ptr = fp;\r\n b -> init = 1;\r\n\r\n BIO_clear_flags(b,0);\r\n break; \r\n }\r\n case 107:\r\n{\r\n\r\n if (ptr != ((void *)0)) {\r\n fpp = ((FILE **)ptr);\r\n *fpp = ((FILE *)(b -> ptr));\r\n }\r\n break; \r\n }\r\n case 8:\r\n{\r\n ret = ((long )(b -> shutdown));\r\n break; \r\n }\r\n case 9:\r\n{\r\n b -> shutdown = ((int )num);\r\n break; \r\n }\r\n case 11:\r\n{\r\n if (b -> flags & 0) {\r\n fflush((b -> ptr));\r\n }\r\n else {\r\n fflush(((FILE *)(b -> ptr)));\r\n }\r\n break; \r\n }\r\n case 12:\r\n{\r\n ret = 1;\r\n break; \r\n }\r\n case 13:\r\n{\r\n }\r\n case 10:\r\n{\r\n }\r\n case 6:\r\n{\r\n }\r\n case 7:\r\n{\r\n }\r\n default:\r\n{\r\n ret = 0;\r\n break; \r\n }\r\n }\r\n return ret;\r\n}\r\n\r\nstatic int file_gets(BIO *bp,char *buf,int size)\r\n{\r\n int ret = 0;\r\n buf[0] = '\\0';\r\n if (bp -> flags & 0) {\r\n if (!fgets(buf,size,(bp -> ptr))) {\r\n goto err;\r\n }\r\n }\r\n else {\r\n if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\r\n goto err;\r\n }\r\n }\r\n if (buf[0] != '\\0') {\r\n ret = (strlen(buf));\r\n }\r\n err:\r\n return ret;\r\n}\r\n\r\nstatic int file_puts(BIO *bp,const char *str)\r\n{\r\n int n;\r\n int ret;\r\n n = (strlen(str));\r\n ret = file_write(bp,str,n);\r\n return ret;\r\n}\r\n\r\nvoid ricketier_usl(struct eptatretus_gonfanons *burned_flinthead)\r\n{\r\n struct eptatretus_gonfanons pusey_electricans;\r\n char *parson_outfieldsmen;\r\n ++global_variable;;\r\n setup_printf_context();\r\n parson_outfieldsmen = getenv(\"ARISTOGENICS_PREINDULGE\");\r\n if (parson_outfieldsmen != 0) {;\r\n pusey_electricans . trochophore_causticized = ((char *)parson_outfieldsmen);\r\n *burned_flinthead = pusey_electricans;\r\n }\r\n}\r\n\r\nvoid passement_abhenry(void (*operational_donsky)(struct eptatretus_gonfanons *))\r\n{\r\n int oc_i = 0;\r\n int opt_var = 0;\r\n char* buff = 0;\r\n char *harbourage_overearnest = 0;\r\n struct eptatretus_gonfanons *peribronchial_autocratorical = {0};\r\n ++global_variable;\r\n struct eptatretus_gonfanons eval_zervanism = {0};\r\n operational_donsky(&eval_zervanism);\r\n if (eval_zervanism . trochophore_causticized != 0) {;\r\n peribronchial_autocratorical = &eval_zervanism;\r\n harbourage_overearnest = ((char *)( *peribronchial_autocratorical) . trochophore_causticized);\r\n \r\n if (strlen(harbourage_overearnest) < 20) {;\r\n buff = (char *) malloc (sizeof(char) * 20);\r\n if (buff != NULL) {\r\n memset(buff, 0, 20);\r\n \r\n \r\n\r\n\r\n realpath(harbourage_overearnest, buff);\r\n opt_var = strlen( buff);\r\n \r\n for (; oc_i < opt_var; ++oc_i) {\r\n buff[oc_i] =\r\n toupper(buff[oc_i]);\r\n }\r\n printf(\"%s\\n\", buff);\r\n \r\n \r\n free (buff);\r\n }\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\n#endif \r\n#endif \r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|E.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cwe": "785"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-1125:Excessive Attack Surface\nD.CWE-190:Integer Overflow or Wraparound\nE.CWE-508:Non-Replicating Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int64_t_rand_preinc_16()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n while(1)\r\n {\r\n \r\n data = (int64_t)RAND64();\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n \r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n while(1)\r\n {\r\n \r\n data = (int64_t)RAND64();\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n if (data < LLONG_MAX)\r\n {\r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too large to perform arithmetic safely.\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t data;\r\n data = 0LL;\r\n while(1)\r\n {\r\n \r\n data = 2;\r\n break;\r\n }\r\n while(1)\r\n {\r\n {\r\n \r\n ++data;\r\n int64_t result = data;\r\n printLongLongLine(result);\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_int64_t_rand_preinc_16()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int64_t_rand_preinc_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int64_t_rand_preinc_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-190:Integer Overflow or Wraparound|B.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1052:Excessive Use of Hard-Coded Literals in Initialization\nB.No Vulnerabilities\nC.CWE-256:Plaintext Storage of a Password\nD.CWE-182:Collapse of Data into Unsafe Value\nE.CWE-522:Insufficiently Protected Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32\")\r\n#pragma comment(lib, \"crypt32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_09()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n char hashData[100] = HASH_INPUT;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n FILE *pFile;\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n pFile = fopen(\"passwords.txt\", \"r\");\r\n if (pFile != NULL)\r\n {\r\n if (fgetws(data, 100, pFile) == NULL)\r\n {\r\n data[0] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n else\r\n {\r\n data[0] = L'\\0';\r\n }\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), data);\r\n \r\n SecureZeroMemory(data, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(data, payload, payloadBytes);\r\n data[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n data,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_09()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-256:Plaintext Storage of a Password|E.CWE-522:Insufficiently Protected Credentials", "cwe": "256"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-580:clone() Method Without super.clone()\nC.No Vulnerabilities\nD.CWE-469:Use of Pointer Subtraction to Determine Size\nE.CWE-123:Write-what-where Condition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\ntypedef struct _My_connect_socket_67_structType\r\n{\r\n mStruct structFirst;\r\n} My_connect_socket_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_67bSink(My_connect_socket_67_structType myStruct);\r\n\r\nvoid My_connect_socket_67()\r\n{\r\n mStruct data;\r\n My_connect_socket_67_structType myStruct;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_connect_socket_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_67bG2BSink(My_connect_socket_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n mStruct data;\r\n My_connect_socket_67_structType myStruct;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n \r\n ; \r\n myStruct.structFirst = data;\r\n My_connect_socket_67bG2BSink(myStruct);\r\n}\r\n\r\nvoid My_connect_socket_67()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-344:Use of Invariant Value in Dynamically Changing Context\nB.No Vulnerabilities\nC.CWE-322:Key Exchange without Entity Authentication\nD.CWE-587:Assignment of a Fixed Address to a Pointer\nE.CWE-1295:Debug Messages Revealing Unnecessary Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n char *charPointer = (char*)0x400000;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n char charStack = 'a';\r\n char *charPointer = &charStack;\r\n printHexCharLine(*charPointer);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-587:Assignment of a Fixed Address to a Pointer|A.CWE-344:Use of Invariant Value in Dynamically Changing Context", "cwe": "587"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-707:Improper Neutralization\nB.CWE-670:Always-Incorrect Control Flow Implementation\nC.CWE-617:Reachable Assertion\nD.No Vulnerabilities\nE.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_65bSink(int data);\r\n\r\nvoid My_connect_socket_65()\r\n{\r\n int data;\r\n \r\n void (*funcPtr) (int) = My_connect_socket_65bSink;\r\n \r\n data = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n funcPtr(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_65bG2BSink(int data);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n void (*funcPtr) (int) = My_connect_socket_65bG2BSink;\r\n \r\n data = -1;\r\n \r\n data = ASSERT_VALUE+1;\r\n funcPtr(data);\r\n}\r\n\r\nvoid My_connect_socket_65()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_65();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_65();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-617:Reachable Assertion|B.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-448:Obsolete Feature in UI\nB.CWE-680:Integer Overflow to Buffer Overflow\nC.CWE-14:Compiler Removal of Code to Clear Buffers\nD.No Vulnerabilities\nE.CWE-190:Integer Overflow or Wraparound\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_malloc_fgets_54bSink(int data);\r\n\r\nvoid My_malloc_fgets_54()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n My_malloc_fgets_54bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_malloc_fgets_54bG2BSink(int data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 20;\r\n My_malloc_fgets_54bG2BSink(data);\r\n}\r\n\r\nvoid My_malloc_fgets_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_fgets_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_fgets_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-680:Integer Overflow to Buffer Overflow|E.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-269:Improper Privilege Management\nB.CWE-312:Cleartext Storage of Sensitive Information\nC.CWE-129:Improper Validation of Array Index\nD.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printLine(getenv(\"PATH\"));\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n printLine(\"Not in path\");\r\n }\r\n}\r\n\r\nvoid My_basic_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-526:Cleartext Storage of Sensitive Information in an Environment Variable|B.CWE-312:Cleartext Storage of Sensitive Information", "cwe": "526"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-427:Uncontrolled Search Path Element\nB.No Vulnerabilities\nC.CWE-138:Improper Neutralization of Special Elements\nD.CWE-1025:Comparison Using Wrong Factors\nE.CWE-464:Addition of Data Structure Sentinel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_basic_52bSink(char data);\r\n\r\nvoid My_basic_52()\r\n{\r\n char data;\r\n data = ' ';\r\n {\r\n char charArraySource[2];\r\n charArraySource[0] = (char)getc(stdin);\r\n charArraySource[1] = '\\0';\r\n \r\n data = (char)atoi(charArraySource);\r\n }\r\n My_basic_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_basic_52bG2BSink(char data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char data;\r\n data = ' ';\r\n \r\n data = 'a';\r\n My_basic_52bG2BSink(data);\r\n}\r\n\r\nvoid My_basic_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-464:Addition of Data Structure Sentinel|C.CWE-138:Improper Neutralization of Special Elements", "cwe": "464"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-134:Use of Externally-Controlled Format String\nC.No Vulnerabilities\nD.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nE.CWE-288:Authentication Bypass Using an Alternate Path or Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\nnamespace My_wchar_t_listen_socket_vfprintf_81\r\n{\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(wchar_t * data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81 : public My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81G2B : public My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\nclass My_wchar_t_listen_socket_vfprintf_81B2G : public My_wchar_t_listen_socket_vfprintf_81_base\r\n{\r\npublic:\r\n void action(wchar_t * data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-134:Use of Externally-Controlled Format String|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-369:Divide By Zero\nB.CWE-940:Improper Verification of Source of a Communication Channel\nC.CWE-425:Direct Request ('Forced Browsing')\nD.CWE-682:Incorrect Calculation\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nint overmagnified_subdeaconship = 0;\r\nint global_variable;\r\nvoid lossenite_sella(void **sinarquist_stichter);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **));\r\nvoid *erythrophage_bourdis(void *lenotre_amputation);\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&overmagnified_subdeaconship,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n receptible_recruitors(lossenite_sella);\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid lossenite_sella(void **sinarquist_stichter)\r\n{\r\n void *runfish_catalyzing = 0;\r\n char *cohere_monaghan;\r\n ++global_variable;;\r\n setup_printf_context();\r\n cohere_monaghan = getenv(\"PREFABRICATES_DOORSTEPS\");\r\n if (cohere_monaghan != 0) {;\r\n runfish_catalyzing = ((void *)cohere_monaghan);\r\n *sinarquist_stichter = runfish_catalyzing;\r\n }\r\n}\r\n\r\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **))\r\n{\r\n float quotient;\r\n int mod = 0;\r\n int input;\r\n char *ariadne_recent = 0;\r\n void *rimpi_arrode = 0;\r\n ++global_variable;\r\n void *math_epithelioma = 0;\r\n unestranged_bivalves(&math_epithelioma);\r\n if (((char *)math_epithelioma) != 0) {;\r\n rimpi_arrode = erythrophage_bourdis(math_epithelioma);\r\n ariadne_recent = ((char *)((char *)rimpi_arrode));\r\n \r\n input = atoi(ariadne_recent);\r\n if (input != 0) {\r\n \r\n \r\n mod = input % 4;\r\n \r\n \r\n \r\n \r\n \r\n quotient = 1024 / mod;\r\n \r\n printf(\"%f\\n\", quotient);\r\n } else {\r\n printf(\"Input value is 0, or not a number\\n\");\r\n }\r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\n\r\nvoid *erythrophage_bourdis(void *lenotre_amputation)\r\n{\r\n ++global_variable;\r\n return lenotre_amputation;\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-369:Divide By Zero|D.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-506:Embedded Malicious Code\nB.CWE-282:Improper Ownership Management\nC.No Vulnerabilities\nD.CWE-510:Trapdoor\nE.CWE-141:Improper Neutralization of Parameter/Argument Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_listen_10()\r\n{\r\n if(globalTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(30000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_listen_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|A.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nB.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\nC.CWE-11:ASP.NET Misconfiguration: Creating Debug Binary\nD.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n\r\n#pragma comment(lib, \"shlwapi\")\r\n\r\n#define M_PATH_SIZE (MAX_PATH / 2) \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char path[M_PATH_SIZE];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(M_PATH_SIZE, path);\r\n if (length == 0 || length >= M_PATH_SIZE) \r\n {\r\n exit(1);\r\n }\r\n \r\n \r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printSizeTLine(strlen(path));\r\n printIntLine(M_PATH_SIZE);\r\n printLine(path);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n \r\n char path[MAX_PATH];\r\n DWORD length;\r\n length = GetCurrentDirectoryA(MAX_PATH, path);\r\n if (length == 0 || length >= MAX_PATH)\r\n {\r\n exit(1); \r\n }\r\n if (!PathAppendA(path, \"AAAAAAAAAAAA\"))\r\n {\r\n exit(1);\r\n }\r\n printLine(path);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|A.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cwe": "785"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-795:Only Filtering Special Elements at a Specified Location\nB.CWE-252:Unchecked Return Value\nC.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nD.CWE-157:Failure to Sanitize Paired Delimiters\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_long_realloc_11()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)realloc(data, 1*sizeof(long));\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)realloc(data, 1*sizeof(long));\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n long * data;\r\n data = NULL; \r\n \r\n data = (long *)realloc(data, 1*sizeof(long));\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n data[0] = 5L;\r\n printLongLine(data[0]);\r\n free(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_long_realloc_11()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_long_realloc_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_long_realloc_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-690:Unchecked Return Value to NULL Pointer Dereference|B.CWE-252:Unchecked Return Value", "cwe": "690"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-1082:Class Instance Self Destruction Control Element\nC.No Vulnerabilities\nD.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nE.CWE-23:Relative Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_char_file_open_09\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n strcat(data, \"file.txt\");\r\n }\r\n {\r\n int fileDesc;\r\n \r\n fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_open_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-23:Relative Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-370:Missing Check for Certificate Revocation after Initial Check\nB.CWE-126:Buffer Over-read\nC.CWE-284:Improper Access Control\nD.CWE-788:Access of Memory Location After End of Buffer\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_declare_memcpy_12()\r\n{\r\n char * data;\r\n char dataMBuffer[50];\r\n char dataNBuffer[100];\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = dataMBuffer;\r\n }\r\n else\r\n {\r\n \r\n data = dataNBuffer;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataMBuffer[50];\r\n char dataNBuffer[100];\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n if(globalReturnsTrueOrFalse())\r\n {\r\n \r\n data = dataNBuffer;\r\n }\r\n else\r\n {\r\n \r\n data = dataNBuffer;\r\n }\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_char_declare_memcpy_12()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_memcpy_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_memcpy_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-126:Buffer Over-read|D.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-272:Least Privilege Violation\nB.CWE-27:Path Traversal: 'dir/../../filename'\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.No Vulnerabilities\nE.CWE-104:Struts: Form Bean Does Not Extend Validation Class\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n#pragma comment( lib, \"shlwapi\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n TRUE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char * keyName = \"TEST\\\\TestKey\";\r\n HUSKEY hKey;\r\n \r\n if (SHRegOpenUSKeyA(\r\n keyName,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n FALSE) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be opened\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key opened successfully\");\r\n SHRegCloseUSKey(hKey);\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_char_SHRegOpenUSKey_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_SHRegOpenUSKey_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_SHRegOpenUSKey_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-272:Least Privilege Violation|C.CWE-271:Privilege Dropping / Lowering Errors", "cwe": "272"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-554:ASP.NET Misconfiguration: Not Using Input Validation Framework\nB.CWE-459:Incomplete Cleanup\nC.No Vulnerabilities\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-546:Suspicious Comment\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_TODO_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_TODO_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_TODO_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_TODO_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-546:Suspicious Comment|D.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-9:J2EE Misconfiguration: Weak Access Permissions for EJB Methods\nB.CWE-128:Wrap-around Error\nC.CWE-396:Declaration of Catch for Generic Exception\nD.CWE-705:Incorrect Control Flow Scoping\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_exception_16\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n while(1)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (exception &)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n break;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_exception_16; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-396:Declaration of Catch for Generic Exception|D.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-430:Deployment of Wrong Handler\nC.No Vulnerabilities\nD.CWE-194:Unexpected Sign Extension\nE.CWE-419:Unprotected Primary Channel\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_negative_memcpy_05()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(staticTrue)\r\n {\r\n \r\n data = -1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(staticTrue)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n memcpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_negative_memcpy_05()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_negative_memcpy_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_negative_memcpy_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-194:Unexpected Sign Extension|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-351:Insufficient Type Distinction\nB.CWE-773:Missing Reference to Active File Descriptor or Handle\nC.No Vulnerabilities\nD.CWE-759:Use of a One-Way Hash without a Salt\nE.CWE-771:Missing Reference to Active Allocated Resource\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_fopen_51bSink(FILE * data);\r\n\r\nvoid My_fopen_51()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_fopen_51bB2GSink(FILE * data);\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n My_fopen_51bB2GSink(data);\r\n}\r\n\r\nvoid My_fopen_51()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-773:Missing Reference to Active File Descriptor or Handle|E.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-687:Function Call With Incorrectly Specified Argument Value\nB.No Vulnerabilities\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-771:Missing Reference to Active Allocated Resource\nE.CWE-618:Exposed Unsafe ActiveX Method\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\nnamespace My_w32CreateFile_81\r\n{\r\n\r\nclass My_w32CreateFile_81_base\r\n{\r\npublic:\r\n \r\n virtual void action(HANDLE data) const = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_w32CreateFile_81 : public My_w32CreateFile_81_base\r\n{\r\npublic:\r\n void action(HANDLE data) const;\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_w32CreateFile_81B2G : public My_w32CreateFile_81_base\r\n{\r\npublic:\r\n void action(HANDLE data) const;\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|D.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-469:Use of Pointer Subtraction to Determine Size\nC.CWE-1190:DMA Device Enabled Too Early in Boot Phase\nD.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nE.CWE-470:Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')\n", "input": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\r\r\n\t\t\t\tstruct ext4_ext_path *path,\r\r\n\t\t\t\tstruct ext4_extent *newext, int flag)\r\r\n{\r\r\n\tstruct ext4_extent_header *eh;\r\r\n\tstruct ext4_extent *ex, *fex;\r\r\n\tstruct ext4_extent *nearex; /* nearest extent */\r\r\n\tstruct ext4_ext_path *npath = NULL;\r\r\n\tint depth, len, err;\r\r\n\text4_lblk_t next;\r\r\n\tunsigned uninitialized = 0;\r\r\n\r\r\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\r\r\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\r\r\n\t\treturn -EIO;\r\r\n\t}\r\r\n\tdepth = ext_depth(inode);\r\r\n\tex = path[depth].p_ext;\r\r\n\tif (unlikely(path[depth].p_hdr == NULL)) {\r\r\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\r\r\n\t\treturn -EIO;\r\r\n\t}\r\r\n\r\r\n\t/* try to insert block into found extent and return */\r\r\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\r\r\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\r\r\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\r\r\n\t\t\t ext4_ext_is_uninitialized(newext),\r\r\n\t\t\t ext4_ext_get_actual_len(newext),\r\r\n\t\t\t le32_to_cpu(ex->ee_block),\r\r\n\t\t\t ext4_ext_is_uninitialized(ex),\r\r\n\t\t\t ext4_ext_get_actual_len(ex),\r\r\n\t\t\t ext4_ext_pblock(ex));\r\r\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\r\r\n\t\tif (err)\r\r\n\t\t\treturn err;\r\r\n\r\r\n\t\t/*\r\r\n\t\t * ext4_can_extents_be_merged should have checked that either\r\r\n\t\t * both extents are uninitialized, or both aren't. Thus we\r\r\n\t\t * need to check only one of them here.\r\r\n\t\t */\r\r\n\t\tif (ext4_ext_is_uninitialized(ex))\r\r\n\t\t\tuninitialized = 1;\r\r\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\r\r\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\r\r\n\t\tif (uninitialized)\r\r\n\t\t\text4_ext_mark_uninitialized(ex);\r\r\n\t\teh = path[depth].p_hdr;\r\r\n\t\tnearex = ex;\r\r\n\t\tgoto merge;\r\r\n\t}\r\r\n\r\r\nrepeat:\r\r\n\tdepth = ext_depth(inode);\r\r\n\teh = path[depth].p_hdr;\r\r\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\r\r\n\t\tgoto has_space;\r\r\n\r\r\n\t/* probably next leaf has space for us? */\r\r\n\tfex = EXT_LAST_EXTENT(eh);\r\r\n\tnext = ext4_ext_next_leaf_block(inode, path);\r\r\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\r\r\n\t && next != EXT_MAX_BLOCK) {\r\r\n\t\text_debug(\"next leaf block - %d\\n\", next);\r\r\n\t\tBUG_ON(npath != NULL);\r\r\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\r\r\n\t\tif (IS_ERR(npath))\r\r\n\t\t\treturn PTR_ERR(npath);\r\r\n\t\tBUG_ON(npath->p_depth != path->p_depth);\r\r\n\t\teh = npath[depth].p_hdr;\r\r\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\r\r\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\r\r\n\t\t\t\t le16_to_cpu(eh->eh_entries));\r\r\n\t\t\tpath = npath;\r\r\n\t\t\tgoto repeat;\r\r\n\t\t}\r\r\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\r\r\n\t\t\t le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\r\r\n\t}\r\r\n\r\r\n\t/*\r\r\n\t * There is no free space in the found leaf.\r\r\n\t * We're gonna add a new leaf in the tree.\r\r\n\t */\r\r\n\terr = ext4_ext_create_new_leaf(handle, inode, path, newext);\r\r\n\tif (err)\r\r\n\t\tgoto cleanup;\r\r\n\tdepth = ext_depth(inode);\r\r\n\teh = path[depth].p_hdr;\r\r\n\r\r\nhas_space:\r\r\n\tnearex = path[depth].p_ext;\r\r\n\r\r\n\terr = ext4_ext_get_access(handle, inode, path + depth);\r\r\n\tif (err)\r\r\n\t\tgoto cleanup;\r\r\n\r\r\n\tif (!nearex) {\r\r\n\t\t/* there is no extent in this leaf, create first one */\r\r\n\t\text_debug(\"first extent in the leaf: %d:%llu:[%d]%d\\n\",\r\r\n\t\t\t\tle32_to_cpu(newext->ee_block),\r\r\n\t\t\t\text4_ext_pblock(newext),\r\r\n\t\t\t\text4_ext_is_uninitialized(newext),\r\r\n\t\t\t\text4_ext_get_actual_len(newext));\r\r\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\r\r\n\t} else if (le32_to_cpu(newext->ee_block)\r\r\n\t\t\t > le32_to_cpu(nearex->ee_block)) {\r\r\n/*\t\tBUG_ON(newext->ee_block == nearex->ee_block); */\r\r\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\r\r\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\r\r\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\r\r\n\t\t\tlen = len < 0 ? 0 : len;\r\r\n\t\t\text_debug(\"insert %d:%llu:[%d]%d after: nearest 0x%p, \"\r\r\n\t\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\r\r\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\r\r\n\t\t\t\t\text4_ext_pblock(newext),\r\r\n\t\t\t\t\text4_ext_is_uninitialized(newext),\r\r\n\t\t\t\t\text4_ext_get_actual_len(newext),\r\r\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\r\r\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\r\r\n\t\t}\r\r\n\t\tpath[depth].p_ext = nearex + 1;\r\r\n\t} else {\r\r\n\t\tBUG_ON(newext->ee_block == nearex->ee_block);\r\r\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\r\r\n\t\tlen = len < 0 ? 0 : len;\r\r\n\t\text_debug(\"insert %d:%llu:[%d]%d before: nearest 0x%p, \"\r\r\n\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\r\r\n\t\t\t\tle32_to_cpu(newext->ee_block),\r\r\n\t\t\t\text4_ext_pblock(newext),\r\r\n\t\t\t\text4_ext_is_uninitialized(newext),\r\r\n\t\t\t\text4_ext_get_actual_len(newext),\r\r\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\r\r\n\t\tmemmove(nearex + 1, nearex, len);\r\r\n\t\tpath[depth].p_ext = nearex;\r\r\n\t}\r\r\n\r\r\n\tle16_add_cpu(&eh->eh_entries, 1);\r\r\n\tnearex = path[depth].p_ext;\r\r\n\tnearex->ee_block = newext->ee_block;\r\r\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\r\r\n\tnearex->ee_len = newext->ee_len;\r\r\n\r\r\nmerge:\r\r\n\t/* try to merge extents to the right */\r\r\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\r\r\n\t\text4_ext_try_to_merge(inode, path, nearex);\r\r\n\r\r\n\t/* try to merge extents to the left */\r\r\n\r\r\n\t/* time to correct all indexes above */\r\r\n\terr = ext4_ext_correct_indexes(handle, inode, path);\r\r\n\tif (err)\r\r\n\t\tgoto cleanup;\r\r\n\r\r\n\terr = ext4_ext_dirty(handle, inode, path + depth);\r\r\n\r\r\ncleanup:\r\r\n\tif (npath) {\r\r\n\t\text4_ext_drop_refs(npath);\r\r\n\t\tkfree(npath);\r\r\n\t}\r\r\n\text4_ext_invalidate_cache(inode);\r\r\n\treturn err;\r\r\n}\r\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.No Vulnerabilities|A.No Vulnerabilities", "cwe": "0"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-781:Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code\nE.CWE-665:Improper Initialization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_twointsclass_array_new_partial_init_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n data = new TwoIntsClass[10];\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n data = new TwoIntsClass[10];\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n data = new TwoIntsClass[10];\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<(10/2); i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n data = new TwoIntsClass[10];\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n data = new TwoIntsClass[10];\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n data[i].intOne = i;\r\n data[i].intTwo = i;\r\n }\r\n }\r\n if(staticReturnsTrue())\r\n {\r\n \r\n for(int i=0; i<10; i++)\r\n {\r\n printIntLine(data[i].intOne);\r\n printIntLine(data[i].intTwo);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_twointsclass_array_new_partial_init_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-457:Use of Uninitialized Variable|E.CWE-665:Improper Initialization", "cwe": "457"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1107:Insufficient Isolation of Symbolic Constant Definitions\nB.CWE-455:Non-exit on Failed Initialization\nC.CWE-401:Missing Release of Memory after Effective Lifetime\nD.CWE-404:Improper Resource Shutdown or Release\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <list>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_int64_t_realloc_73\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(list<int64_t *> dataList);\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n list<int64_t *> dataList;\r\n data = NULL;\r\n \r\n data = (int64_t *)realloc(data, 100*sizeof(int64_t));\r\n \r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n mSink(dataList);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(list<int64_t *> dataList);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n list<int64_t *> dataList;\r\n data = NULL;\r\n \r\n data = (int64_t *)ALLOCA(100*sizeof(int64_t));\r\n \r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n \r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nG2BSink(dataList);\r\n}\r\n\r\n\r\nvoid nB2GSink(list<int64_t *> dataList);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n list<int64_t *> dataList;\r\n data = NULL;\r\n \r\n data = (int64_t *)realloc(data, 100*sizeof(int64_t));\r\n \r\n data[0] = 5LL;\r\n printLongLongLine(data[0]);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n dataList.push_back(data);\r\n nB2GSink(dataList);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int64_t_realloc_73; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-401:Missing Release of Memory after Effective Lifetime|D.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-639:Authorization Bypass Through User-Controlled Key\nB.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-792:Incomplete Filtering of One or More Instances of Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <list>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_list_int_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid mSource(list<int> &data)\r\n{\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n}\r\n\r\nvoid m()\r\n{\r\n list<int> data;\r\n mSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(list<int> &data)\r\n{\r\n \r\n data.push_back(100);\r\n data.push_back(200);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n list<int> data;\r\n nG2BSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n if (!*i)\r\n {\r\n data.clear();\r\n }\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\n\r\nstatic void nB2GSource(list<int> &data)\r\n{\r\n \r\n data.push_back(100);\r\n data.push_back(0);\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n list<int> data;\r\n nB2GSource(data);\r\n {\r\n list<int> ::iterator i;\r\n cout << \"The list contains: \";\r\n for( i = data.begin(); i != data.end(); i++)\r\n {\r\n \r\n cout << \" \" << *i;\r\n }\r\n cout << endl;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_list_int_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-672:Operation on a Resource after Expiration or Release|B.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "672"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-762:Mismatched Memory Management Routines\nB.CWE-237:Improper Handling of Structural Elements\nC.CWE-763:Release of Invalid Pointer or Reference\nD.No Vulnerabilities\nE.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_strdup_delete_wchar_t_51\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n {\r\n wchar_t myString[] = L\"myString\";\r\n \r\n data = wcsdup(myString);\r\n }\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(wchar_t * data);\r\nvoid nB2GSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n \r\n data = new wchar_t;\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n \r\n data = NULL;\r\n {\r\n wchar_t myString[] = L\"myString\";\r\n \r\n data = wcsdup(myString);\r\n }\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_strdup_delete_wchar_t_51; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-762:Mismatched Memory Management Routines|C.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1224:Improper Restriction of Write-Once Bit Fields\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-675:Multiple Operations on Resource in Single-Operation Context\nD.No Vulnerabilities\nE.CWE-760:Use of a One-Way Hash with a Predictable Salt\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(FILE * data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\nvoid My_freopen_21()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(FILE * data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(FILE * data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n data = freopen(\"MSource_freopen.txt\",\"w+\",stdin);\r\n \r\n fclose(data);\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(FILE * data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n \r\n fclose(data);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n FILE * data;\r\n data = NULL; \r\n \r\n data = fopen(\"NSource_fopen.txt\", \"w+\");\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_freopen_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_freopen_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_freopen_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-675:Multiple Operations on Resource in Single-Operation Context|B.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1310:Missing Ability to Patch ROM Code\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.No Vulnerabilities\nD.CWE-23:Relative Path Traversal\nE.CWE-240:Improper Handling of Inconsistent Structural Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH L\"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH L\"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_wchar_t_connect_socket_ofstream_67\r\n{\r\n\r\ntypedef struct _structType\r\n{\r\n wchar_t * structFirst;\r\n} structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(structType myStruct);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n structType myStruct;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n wchar_t *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = wcslen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\r\n \r\n replace = wcschr(data, L'\\r');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n replace = wcschr(data, L'\\n');\r\n if (replace)\r\n {\r\n *replace = L'\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n mSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n structType myStruct;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n \r\n wcscat(data, L\"file.txt\");\r\n myStruct.structFirst = data;\r\n nG2BSink(myStruct);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_connect_socket_ofstream_67; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-23:Relative Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-172:Encoding Error\nB.No Vulnerabilities\nC.CWE-176:Improper Handling of Unicode Encoding\nD.CWE-1106:Insufficient Use of Symbolic Constants\nE.CWE-98:Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include <wchar.h>\r\n#include <string.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_06()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n if (requiredSize < 10)\r\n {\r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n else\r\n {\r\n printLine(\"Destination buffer not large enough to perform conversion.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100];\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n wcscpy(data, L\"\\\\u9580\");\r\n }\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n char convertedText[10] = \"\";\r\n int requiredSize;\r\n requiredSize = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, 0, 0, 0);\r\n \r\n WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, data, -1, convertedText, requiredSize , 0, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_06()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-176:Improper Handling of Unicode Encoding|A.CWE-172:Encoding Error", "cwe": "176"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-300:Channel Accessible by Non-Endpoint\nB.CWE-546:Suspicious Comment\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.CWE-693:Protection Mechanism Failure\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_HACK_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_HACK_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_HACK_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_HACK_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-546:Suspicious Comment|C.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-642:External Control of Critical State Data\nC.CWE-1332:Improper Handling of Faults that Lead to Instruction Skips\nD.CWE-263:Password Aging with Long Expiration\nE.CWE-15:External Control of System or Configuration Setting\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32\")\r\n\r\n#define LISTEN_PORT 999\r\n#define LISTEN_BACKLOG 5\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_03()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n {\r\n WSADATA wsaData;\r\n BOOL wsaDataInit = FALSE;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n struct sockaddr_in service;\r\n int recvResult;\r\n do\r\n {\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n listenSocket = socket(PF_INET, SOCK_STREAM, 0);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(LISTEN_PORT);\r\n if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\r\n {\r\n break;\r\n }\r\n if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(acceptSocket, data, 100 - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n data[recvResult] = '\\0';\r\n }\r\n while (0);\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n closesocket(acceptSocket);\r\n }\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n closesocket(listenSocket);\r\n }\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n }\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(5==5)\r\n {\r\n \r\n strcpy(data, \"hostname\");\r\n }\r\n \r\n if (!SetComputerNameA(data))\r\n {\r\n printLine(\"Failure setting computer name\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_w32_03()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-15:External Control of System or Configuration Setting|B.CWE-642:External Control of Critical State Data", "cwe": "15"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nB.CWE-413:Improper Resource Locking\nC.No Vulnerabilities\nD.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\nE.CWE-1106:Insufficient Use of Symbolic Constants\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_w32_char_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<char *> passwordVector);\r\n\r\nvoid m()\r\n{\r\n char * password;\r\n vector<char *> passwordVector;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n \r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n mSink(passwordVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<char *> passwordVector);\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n vector<char *> passwordVector;\r\n \r\n password = \"\";\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n \r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n passwordVector.insert(passwordVector.end(), 1, password);\r\n nG2BSink(passwordVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-591:Sensitive Data Storage in Improperly Locked Memory|B.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-127:Buffer Under-read\nB.CWE-347:Improper Verification of Cryptographic Signature\nC.No Vulnerabilities\nD.CWE-1078:Inappropriate Source Code Style or Formatting\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include <stdarg.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint aliya_imbreathe = 0;\r\nint global_variable;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid lullaby_retrochoir(int sild_snyes,... );\r\nvoid intellectualise_kenzie(char *tijuana_milleporous);\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{\r\n char *claves_paphus;;\r\n if (__sync_bool_compare_and_swap(&aliya_imbreathe,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n claves_paphus = getenv(\"OVERSPICED_PHYSIOLOGUE\");\r\n if (claves_paphus != 0) {;\r\n lullaby_retrochoir(1,claves_paphus);\r\n }\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid lullaby_retrochoir(int sild_snyes,... )\r\n{\r\n void (*diadochian_doughmaking)(char *) = intellectualise_kenzie;\r\n char *scriptural_connexional = 0;\r\n va_list nephrectasia_chorobates;\r\n ++global_variable;;\r\n if (sild_snyes > 0) {\r\n __builtin_va_start(nephrectasia_chorobates,sild_snyes);\r\n scriptural_connexional = (va_arg(nephrectasia_chorobates,char *));\r\n __builtin_va_end(nephrectasia_chorobates);\r\n }\r\n diadochian_doughmaking(scriptural_connexional);\r\n}\r\n\r\nvoid intellectualise_kenzie(char *tijuana_milleporous)\r\n{\r\n signed char *input_string = 0;\r\n int stack_buff[128];\r\n int other_buff[200];\r\n int ss_i = 0;\r\n char *previsor_beclothe = 0;\r\n ++global_variable;;\r\n previsor_beclothe = ((char *)tijuana_milleporous);\r\n \r\n input_string = (signed char *) getenv(\"INPUT_STRING\");\r\n \r\n \r\n \r\n if (input_string != 0) {\r\n memset(stack_buff,0,sizeof(stack_buff));\r\n for (ss_i = 0; ss_i < 200; ++ss_i) {\r\n other_buff[ss_i] = 5555;\r\n }\r\n for (ss_i = 0; ss_i < strlen((char *)input_string); ++ss_i) {\r\n if (input_string[ss_i] < 0)\r\n continue;\r\n ++stack_buff[input_string[ss_i]];\r\n }\r\n \r\n \r\n for (ss_i = 0; ss_i < strlen(previsor_beclothe); ++ss_i) {\r\n \r\n \r\n \r\n printf(\"value %c appears: %d times\\n\",\r\n previsor_beclothe[ss_i],\r\n stack_buff[(int) previsor_beclothe[ss_i]]);\r\n }\r\n \r\n \r\n }\r\n \r\n;\r\nclose_printf_context();\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-127:Buffer Under-read|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-646:Reliance on File Name or Extension of Externally-Supplied File\nB.CWE-510:Trapdoor\nC.CWE-756:Missing Custom Error Page\nD.No Vulnerabilities\nE.CWE-506:Embedded Malicious Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n#define IP_ADDRESS \"123.123.123.123\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_network_listen_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(30000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_network_listen_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-510:Trapdoor|E.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-204:Observable Response Discrepancy\nB.CWE-670:Always-Incorrect Control Flow Implementation\nC.No Vulnerabilities\nD.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')\nE.CWE-617:Reachable Assertion\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic int mSource(int data)\r\n{\r\n if(mStatic)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n }\r\n }\r\n return data;\r\n}\r\n\r\nvoid My_fgets_21()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n mStatic = 1; \r\n data = mSource(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nG2B1Static = 0;\r\nstatic int nG2B2Static = 0;\r\n\r\n\r\nstatic int nG2B1Source(int data)\r\n{\r\n if(nG2B1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2B1Static = 0; \r\n data = nG2B1Source(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic int nG2B2Source(int data)\r\n{\r\n if(nG2B2Static)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n return data;\r\n}\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n nG2B2Static = 1; \r\n data = nG2B2Source(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fgets_21()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-617:Reachable Assertion|B.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nC.CWE-329:Generation of Predictable IV with CBC Mode\nD.CWE-73:External Control of File Name or Path\nE.CWE-114:Process Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_connect_socket_11()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n }\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_connect_socket_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_connect_socket_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_connect_socket_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-114:Process Control|D.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.CWE-1290:Incorrect Decoding of Security Identifiers \nC.CWE-36:Absolute Path Traversal\nD.No Vulnerabilities\nE.CWE-510:Trapdoor\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#define FOPEN fopen\r\n#else\r\n#define FOPEN fopen\r\n#endif\r\n\r\nnamespace My_char_listen_socket_fopen_12\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n else\r\n {\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n }\r\n {\r\n FILE *pFile = NULL;\r\n \r\n pFile = FOPEN(data, \"wb+\");\r\n if (pFile != NULL)\r\n {\r\n fclose(pFile);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_fopen_12; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-36:Absolute Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-590:Free of Memory not on the Heap\nB.No Vulnerabilities\nC.CWE-1061:Insufficient Encapsulation\nD.CWE-762:Mismatched Memory Management Routines\nE.CWE-319:Cleartext Transmission of Sensitive Information\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_free_wchar_t_static_52bSink(wchar_t * data);\r\n\r\nvoid My_free_wchar_t_static_52()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n {\r\n \r\n static wchar_t dataBuffer[100];\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n My_free_wchar_t_static_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_free_wchar_t_static_52bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL; \r\n {\r\n \r\n wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (dataBuffer == NULL)\r\n {\r\n printLine(\"malloc() failed\");\r\n exit(1);\r\n }\r\n wmemset(dataBuffer, L'A', 100-1); \r\n dataBuffer[100-1] = L'\\0'; \r\n data = dataBuffer;\r\n }\r\n My_free_wchar_t_static_52bG2BSink(data);\r\n}\r\n\r\nvoid My_free_wchar_t_static_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_free_wchar_t_static_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_free_wchar_t_static_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-590:Free of Memory not on the Heap|D.CWE-762:Mismatched Memory Management Routines", "cwe": "590"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-787:Out-of-bounds Write\nB.CWE-123:Write-what-where Condition\nC.CWE-484:Omitted Break Statement in Switch\nD.No Vulnerabilities\nE.CWE-360:Trust of System Event Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_10()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(globalTrue)\r\n {\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n if(globalTrue)\r\n {\r\n \r\n ; \r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_fgets_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|A.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-525:Use of Web Browser Cache Containing Sensitive Information\nB.No Vulnerabilities\nC.CWE-563:Assignment to Variable without Use\nD.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nE.CWE-1164:Irrelevant Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_uninit_variable_int64_t_01()\r\n{\r\n int64_t data;\r\n \r\n ; \r\n \r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t data;\r\n \r\n ; \r\n \r\n data = 5LL;\r\n printLongLongLine(data);\r\n}\r\n\r\nvoid My_unused_uninit_variable_int64_t_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_uninit_variable_int64_t_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_uninit_variable_int64_t_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|E.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-459:Incomplete Cleanup\nB.CWE-404:Improper Resource Shutdown or Release\nC.No Vulnerabilities\nD.CWE-138:Improper Neutralization of Special Elements\nE.CWE-111:Direct Use of Unsafe JNI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define UNLINK _unlink\r\n#define FDOPEN fdopen\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#else\r\n#include <unistd.h>\r\n#define UNLINK unlink\r\n#define FDOPEN fdopen\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char filename[] = \"mXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n char filename[] = \"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n char filename[] = \"nXXXXXX\";\r\n FILE *pFile;\r\n \r\n int fileDesc = MKSTEMP(filename);\r\n if (fileDesc != -1)\r\n {\r\n pFile = FDOPEN(fileDesc, \"w\");\r\n if (pFile != NULL)\r\n {\r\n fprintf(pFile, \"Temporary file\");\r\n fclose(pFile);\r\n \r\n UNLINK(filename); \r\n }\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_char_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-459:Incomplete Cleanup|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "459"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-259:Use of Hard-coded Password\nC.CWE-798:Use of Hard-coded Credentials\nD.CWE-1104:Use of Unmaintained Third Party Components\nE.CWE-483:Incorrect Block Delimitation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nstatic char * mSource(char * password)\r\n{\r\n \r\n strcpy(password, PASSWORD);\r\n return password;\r\n}\r\n\r\nvoid My_w32_char_42()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n password = mSource(password);\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic char * nG2BSource(char * password)\r\n{\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n return password;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n password = nG2BSource(password);\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-259:Use of Hard-coded Password|C.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-581:Object Model Violation: Just One of Equals and Hashcode Defined\nB.CWE-190:Integer Overflow or Wraparound\nC.No Vulnerabilities\nD.CWE-1265:Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\nE.CWE-680:Integer Overflow to Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_malloc_rand_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int> dataMap);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = RAND32();\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(map<int, int> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = 20;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_malloc_rand_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-680:Integer Overflow to Buffer Overflow|B.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-673:External Influence of Sphere Definition\nC.CWE-393:Return of Wrong Status Code\nD.CWE-618:Exposed Unsafe ActiveX Method\nE.CWE-426:Untrusted Search Path\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#define M_OS_COMMAND L\"cmd.exe /c dir\"\r\n\r\n\r\n#define N_OS_COMMAND L\"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\"\r\n#else \r\n#define M_OS_COMMAND L\"ls -la\"\r\n#define N_OS_COMMAND L\"/usr/bin/ls -la\"\r\n#endif \r\n\r\n#ifdef _WIN32\r\n#define SYSTEM _wsystem\r\n#else \r\n#define SYSTEM system\r\n#endif\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_system_07()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n \r\n wcscpy(data, M_OS_COMMAND);\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n if(staticFive==5)\r\n {\r\n \r\n wcscpy(data, N_OS_COMMAND);\r\n }\r\n \r\n if (SYSTEM(data) <= 0)\r\n {\r\n printLine(\"command execution failed!\");\r\n exit(1);\r\n }\r\n}\r\n\r\nvoid My_wchar_t_system_07()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_system_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_system_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-426:Untrusted Search Path|B.CWE-673:External Influence of Sphere Definition", "cwe": "426"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.CWE-670:Always-Incorrect Control Flow Implementation\nC.CWE-535:Exposure of Information Through Shell Error Message\nD.No Vulnerabilities\nE.CWE-164:Improper Neutralization of Internal Special Elements\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_11()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_listen_socket_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-617:Reachable Assertion|B.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-543:Use of Singleton Pattern Without Synchronization in a Multithreaded Context\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-682:Incorrect Calculation\nD.No Vulnerabilities\nE.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#include <math.h>\r\n\r\ntypedef struct _My_int_connect_socket_square_67_structType\r\n{\r\n int structFirst;\r\n} My_int_connect_socket_square_67_structType;\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_int_connect_socket_square_67bSink(My_int_connect_socket_square_67_structType myStruct);\r\n\r\nvoid My_int_connect_socket_square_67()\r\n{\r\n int data;\r\n My_int_connect_socket_square_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_square_67bSink(myStruct);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_int_connect_socket_square_67bG2BSink(My_int_connect_socket_square_67_structType myStruct);\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n My_int_connect_socket_square_67_structType myStruct;\r\n \r\n data = 0;\r\n \r\n data = 2;\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_square_67bG2BSink(myStruct);\r\n}\r\n\r\n\r\nvoid My_int_connect_socket_square_67bB2GSink(My_int_connect_socket_square_67_structType myStruct);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n My_int_connect_socket_square_67_structType myStruct;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n myStruct.structFirst = data;\r\n My_int_connect_socket_square_67bB2GSink(myStruct);\r\n}\r\n\r\nvoid My_int_connect_socket_square_67()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_connect_socket_square_67();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_connect_socket_square_67();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-190:Integer Overflow or Wraparound|C.CWE-682:Incorrect Calculation", "cwe": "190"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-273:Improper Check for Dropped Privileges\nB.CWE-39:Path Traversal: 'C:dirname'\nC.CWE-563:Assignment to Variable without Use\nD.No Vulnerabilities\nE.CWE-1164:Irrelevant Code\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_unused_uninit_variable_char_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(char &data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nvoid m()\r\n{\r\n char data;\r\n mSource(data);\r\n \r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2GSource(char &data)\r\n{\r\n \r\n ; \r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n char data;\r\n nB2GSource(data);\r\n \r\n data = 'C';\r\n printHexCharLine(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_unused_uninit_variable_char_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-563:Assignment to Variable without Use|E.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.No Vulnerabilities\nC.CWE-174:Double Decoding of the Same Data\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-346:Origin Validation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <math.h>\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_doubleNaN2int_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)(sqrt(doubleNumber)));\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n \r\n if (doubleNumber < 0)\r\n {\r\n printLine(\"Value is negative\");\r\n }\r\n else\r\n {\r\n printIntLine((int)(sqrt(doubleNumber)));\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_doubleNaN2int_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_doubleNaN2int_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_doubleNaN2int_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-681:Incorrect Conversion between Numeric Types|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.No Vulnerabilities\nD.CWE-186:Overly Restrictive Regular Expression\nE.CWE-415:Double Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\nnamespace My_new_delete_int64_t_07\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n delete data;\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n delete data;\r\n }\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n delete data;\r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new int64_t;\r\n \r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int64_t * data;\r\n \r\n data = NULL;\r\n if(staticFive==5)\r\n {\r\n data = new int64_t;\r\n \r\n }\r\n if(staticFive==5)\r\n {\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_int64_t_07; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-415:Double Free|B.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-617:Reachable Assertion\nB.CWE-1209:Failure to Disable Reserved Bits\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-916:Use of Password Hash With Insufficient Computational Effort\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fixed_07()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n \r\n data = ASSERT_VALUE-1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(staticFive==5)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fixed_07()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fixed_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fixed_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-617:Reachable Assertion|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-135:Incorrect Calculation of Multi-Byte String Length\nB.CWE-617:Reachable Assertion\nC.CWE-45:Path Equivalence: 'file...name' (Multiple Internal Dot)\nD.No Vulnerabilities\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifndef OMITM\r\n\r\nstatic int mSource(int data)\r\n{\r\n \r\n data = RAND32();\r\n return data;\r\n}\r\n\r\nvoid My_rand_42()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = mSource(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic int nG2BSource(int data)\r\n{\r\n \r\n data = ASSERT_VALUE+1;\r\n return data;\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = nG2BSource(data);\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_rand_42()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_rand_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_rand_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-617:Reachable Assertion|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-703:Improper Check or Handling of Exceptional Conditions\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-6:J2EE Misconfiguration: Insufficient Session-ID Length\nD.No Vulnerabilities\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\nstatic int mSource(int data)\r\n{\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n return data;\r\n}\r\n\r\nvoid My_open_w32CloseHandle_42()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = mSource(data);\r\n if (data != -1)\r\n {\r\n \r\n CloseHandle((HANDLE)data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nstatic int nB2GSource(int data)\r\n{\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n return data;\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n data = nB2GSource(data);\r\n if (data != -1)\r\n {\r\n \r\n CLOSE(data);\r\n }\r\n}\r\n\r\nvoid My_open_w32CloseHandle_42()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_open_w32CloseHandle_42();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_open_w32CloseHandle_42();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-404:Improper Resource Shutdown or Release|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "404"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-675:Multiple Operations on Resource in Single-Operation Context\nB.CWE-1076:Insufficient Adherence to Expected Conventions\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.No Vulnerabilities\nE.CWE-483:Incorrect Block Delimitation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_15()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n}\r\n\r\nvoid My_semicolon_15()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-483:Incorrect Block Delimitation|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling\nC.CWE-160:Improper Neutralization of Leading Special Elements\nD.CWE-941:Incorrectly Specified Destination in a Communication Channel\nE.No Vulnerabilities\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <sys/stat.h> \r\n#include <setjmp.h> \r\n#include </trace.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint hyperorthodoxy_marketeers = 0;\r\n\r\nunion donsy_buchu \r\n{\r\n char *nonirritability_tigris;\r\n double unburning_transitival;\r\n char *peckville_yids;\r\n char burgwell_gegger;\r\n int wampus_geckotidae;\r\n}\r\n;\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid read_taint(char** tainted_buff, char* env_var_name) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n char* tainted_file_name = 0;\r\n FILE * tainted_file = 0;\r\n size_t result = 0;\r\n long lsize = 0;\r\n tainted_file_name = getenv(env_var_name);\r\n tainted_file = fopen(tainted_file_name,\"rb\");\r\n if (tainted_file != 0) {\r\n fseek(tainted_file,0L,2);\r\n lsize = ftell(tainted_file);\r\n rewind(tainted_file);\r\n *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\r\n if (*tainted_buff != 0) {\r\n \r\n result = fread(*tainted_buff,1,lsize,tainted_file);\r\n (*tainted_buff)[lsize] = '\\0';\r\n }\r\n }\r\n if (tainted_file != 0) {\r\n fclose(tainted_file);\r\n }\r\n } else {\r\n *tainted_buff = NULL;\r\n }\r\n}\r\nFILE *open_file(char *filename_param)\r\n{\r\n FILE *f;\r\n \r\n \r\n \r\n\r\n\r\n f = fopen(filename_param,\"w\");\r\n \r\n \r\n if (!f)\r\n return 0;\r\n else\r\n return f;\r\n fclose(f);\r\n}\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{\r\n char * filename = 0;\r\n int filename_len = 0;\r\n unsigned int num_files;\r\n FILE **filearray;\r\n int i;\r\n char *rotifers_tormae = 0;\r\n jmp_buf snefru_shama;\r\n int megapolis_terrazzos;\r\n int oligocholia_reswim;\r\n union donsy_buchu *gonfalonierate_cronying = {0};\r\n union donsy_buchu *influencive_requiescat = {0};\r\n union donsy_buchu levoglucose_stimuli;\r\n char *cityfolk_triumphancy;;\r\n if (__sync_bool_compare_and_swap(&hyperorthodoxy_marketeers,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n setup_printf_context();\r\n read_taint(&cityfolk_triumphancy,\"RICHTON_SNEAKSBY\");\r\n if (cityfolk_triumphancy != 0) {;\r\n levoglucose_stimuli . nonirritability_tigris = cityfolk_triumphancy;\r\n oligocholia_reswim = 1;\r\n gonfalonierate_cronying = &levoglucose_stimuli;\r\n influencive_requiescat = ((union donsy_buchu *)(((unsigned long )gonfalonierate_cronying) * oligocholia_reswim * oligocholia_reswim)) + 5;\r\n megapolis_terrazzos = setjmp(snefru_shama);\r\n if (megapolis_terrazzos == 0) {\r\n longjmp(snefru_shama,1);\r\n }\r\n rotifers_tormae = ((char *)( *(influencive_requiescat - 5)) . nonirritability_tigris);\r\n \r\n if (strlen(rotifers_tormae) > 0 &&\r\n rotifers_tormae[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n printf(\"Getting input value\\n\");\r\n num_files = strtoul(rotifers_tormae,0,16);\r\n if (num_files > 0xffff)\r\n num_files = 0;\r\n filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\r\n filename_len = strlen(\"/opt//workspace/testData/temp\") + 10;\r\n filename = (char*) malloc(filename_len * sizeof(char));\r\n if (filearray != 0) {\r\n for (i = 0; i < num_files; ++i)\r\n filearray[i] = 0;\r\n printf(\"Creating files\\n\");\r\n for (i = 0; i < num_files; ++i) {\r\n snprintf(filename,filename_len,\"%s_%08x\", \"/opt//workspace/testData/temp\", i);\r\n filearray[i] = open_file(filename);\r\n if (filearray[i] == 0)\r\n break;\r\n }\r\n if (i < num_files)\r\n printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\r\n for (i = 0; i < num_files; ++i)\r\n if (filearray[i] != 0)\r\n fclose(filearray[i]);\r\n free(filearray);\r\n free(filename);\r\n }\r\n }\r\n \r\n;\r\n if (( *(influencive_requiescat - 5)) . nonirritability_tigris != 0) \r\n free(((char *)( *(influencive_requiescat - 5)) . nonirritability_tigris));\r\nclose_printf_context();\r\n }\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "774"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nB.CWE-181:Incorrect Behavior Order: Validate Before Filter\nC.CWE-535:Exposure of Information Through Shell Error Message\nD.CWE-1101:Reliance on Runtime Component in Generated Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access with password: %s\\n\", password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t password[100] = L\"\";\r\n size_t passwordLen = 0;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n fwprintf(stderr, L\"User attempted access\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-535:Exposure of Information Through Shell Error Message|A.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "cwe": "535"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.No Vulnerabilities\nC.CWE-1318:Missing Support for Security Features in On-chip Fabrics or Buses\nD.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nE.CWE-197:Numeric Truncation Error\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_large_to_char_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n int data;\r\n int &dataRef = data;\r\n \r\n data = -1;\r\n \r\n data = SHRT_MAX + 5;\r\n {\r\n int data = dataRef;\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n int &dataRef = data;\r\n \r\n data = -1;\r\n \r\n data = CHAR_MAX-5;\r\n {\r\n int data = dataRef;\r\n {\r\n \r\n char charData = (char)data;\r\n printHexCharLine(charData);\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_int_large_to_char_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-197:Numeric Truncation Error|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1164:Irrelevant Code\nB.CWE-563:Assignment to Variable without Use\nC.No Vulnerabilities\nD.CWE-1336:Improper Neutralization of Special Elements Used in a Template Engine\nE.CWE-80:Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_uninit_variable_char_05()\r\n{\r\n char data;\r\n \r\n ; \r\n if(staticTrue)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char data;\r\n \r\n ; \r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 'C';\r\n printHexCharLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char data;\r\n \r\n ; \r\n if(staticTrue)\r\n {\r\n \r\n data = 'C';\r\n printHexCharLine(data);\r\n }\r\n}\r\n\r\nvoid My_unused_uninit_variable_char_05()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_uninit_variable_char_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_uninit_variable_char_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-563:Assignment to Variable without Use|A.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-839:Numeric Range Comparison Without Minimum Check\nB.CWE-1109:Use of Same Variable for Multiple Purposes\nC.No Vulnerabilities\nD.CWE-126:Buffer Over-read\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_alloca_loop_53bSink(char * data);\r\n\r\nvoid My_char_alloca_loop_53()\r\n{\r\n char * data;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataMBuffer;\r\n My_char_alloca_loop_53bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_alloca_loop_53bG2BSink(char * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataMBuffer = (char *)ALLOCA(50*sizeof(char));\r\n char * dataNBuffer = (char *)ALLOCA(100*sizeof(char));\r\n memset(dataMBuffer, 'A', 50-1); \r\n dataMBuffer[50-1] = '\\0'; \r\n memset(dataNBuffer, 'A', 100-1); \r\n dataNBuffer[100-1] = '\\0'; \r\n \r\n data = dataNBuffer;\r\n My_char_alloca_loop_53bG2BSink(data);\r\n}\r\n\r\nvoid My_char_alloca_loop_53()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_alloca_loop_53();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_alloca_loop_53();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-190:Integer Overflow or Wraparound\nB.No Vulnerabilities\nC.CWE-368:Context Switching Race Condition\nD.CWE-680:Integer Overflow to Buffer Overflow\nE.CWE-648:Incorrect Use of Privileged APIs\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_malloc_fixed_52bSink(int data);\r\n\r\nvoid My_malloc_fixed_52()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = INT_MAX / 2 + 2; \r\n \r\n My_malloc_fixed_52bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_malloc_fixed_52bG2BSink(int data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n \r\n data = 20;\r\n My_malloc_fixed_52bG2BSink(data);\r\n}\r\n\r\nvoid My_malloc_fixed_52()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_fixed_52();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_fixed_52();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-680:Integer Overflow to Buffer Overflow|A.CWE-190:Integer Overflow or Wraparound", "cwe": "680"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1319:Improper Protection against Electromagnetic Fault Injection (EM-FI)\nB.CWE-368:Context Switching Race Condition\nC.CWE-786:Access of Memory Location Before Start of Buffer\nD.No Vulnerabilities\nE.CWE-127:Buffer Under-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_declare_cpy_64bSink(void * dataVoidPtr);\r\n\r\nvoid My_char_declare_cpy_64()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer - 8;\r\n My_char_declare_cpy_64bSink(&data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_declare_cpy_64bG2BSink(void * dataVoidPtr);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n memset(dataBuffer, 'A', 100-1);\r\n dataBuffer[100-1] = '\\0';\r\n \r\n data = dataBuffer;\r\n My_char_declare_cpy_64bG2BSink(&data);\r\n}\r\n\r\nvoid My_char_declare_cpy_64()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_declare_cpy_64();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_declare_cpy_64();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-127:Buffer Under-read|C.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-497:Exposure of Sensitive System Information to an Unauthorized Control Sphere\nB.CWE-386:Symbolic Name not Mapping to Correct Object\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-617:Reachable Assertion\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_listen_socket_10()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n if(globalTrue)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_listen_socket_10()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_listen_socket_10();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_listen_socket_10();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-617:Reachable Assertion|C.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-195:Signed to Unsigned Conversion Error\nB.CWE-839:Numeric Range Comparison Without Minimum Check\nC.No Vulnerabilities\nD.CWE-681:Incorrect Conversion between Numeric Types\nE.CWE-484:Omitted Break Statement in Switch\n", "input": "\r\n\r\n#include <stdio.h>\r\n#include \"cryptlib.h\"\r\n#ifndef OPENSSL_NO_BF\r\n#include <openssl/evp.h>\r\n#include \"evp_locl.h\"\r\n#include <openssl/objects.h>\r\n#include <openssl/blowfish.h>\r\n#include <sys/stat.h> \r\n#include </trace.h> \r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\r\ntypedef struct {\r\nBF_KEY ks;}EVP_BF_KEY;\r\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\r\nint syngenesia_subshaft = 0;\r\ntypedef char *mood_baittle;\r\nint global_variable;\r\nvoid quakily_auriculares(mood_baittle *osteitis_ectopistes);\r\nvoid* printf_context = NULL;\r\nvoid setup_printf_context() {\r\n struct stat st = {0};\r\n char * ss_tc_root = NULL;\r\n char * dirpath = NULL;\r\n int size_dirpath = 0;\r\n char * filepath = NULL;\r\n int size_filepath = 0;\r\n int retval = 0;\r\n ss_tc_root = getenv(\"SS_TC_ROOT\");\r\n if (ss_tc_root != NULL) {\r\n size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\r\n dirpath = (char*) malloc (size_dirpath * sizeof(char));\r\n if (dirpath != NULL) {\r\n sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\r\n retval = 0;\r\n if (stat(dirpath, &st) == -1) {\r\n retval = mkdir(dirpath, 0700);\r\n }\r\n if (retval == 0) {\r\n size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\r\n filepath = (char*) malloc (size_filepath * sizeof(char));\r\n if (filepath != NULL) {\r\n sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\r\n printf_context = fopen(filepath, \"w\");\r\n free(filepath);\r\n }\r\n }\r\n free(dirpath);\r\n }\r\n }\r\n if (printf_context == NULL) {\r\n printf_context = stderr;\r\n }\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n va_start(argptr, format);\r\n vfprintf(printf_context, format, argptr);\r\n va_end(argptr);\r\n fflush(printf_context);\r\n}\r\nvoid close_printf_context() {\r\n if (printf_context != NULL &&\r\n printf_context != stderr) {\r\n fclose(printf_context);\r\n }\r\n}\r\nvoid buttercups_tovar(void (*anisogamous_myotalpa)(mood_baittle *));\r\nint returnChunkSize(void *dest,void *src)\r\n{\r\n \r\n if (strlen(dest) < strlen(src)) {\r\n\r\n return -1;\r\n }\r\n return strlen(dest);\r\n}\r\n\r\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\r\n if (64 == 1) {\r\n chunk >>= 3;\r\n }\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n while(inl && inl >= chunk){\r\n BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\r\n inl -= chunk;\r\n in += chunk;\r\n out += chunk;\r\n if (inl < chunk) {\r\n chunk = inl;\r\n }\r\n }\r\n return 1;\r\n}\r\n\r\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n size_t i;\r\n size_t bl;\r\n bl = (ctx -> cipher -> block_size);\r\n if (inl < bl) {\r\n return 1;\r\n }\r\n inl -= bl;\r\n for (i = 0; i <= inl; i += bl) \r\n BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\r\n return 1;\r\n}\r\n\r\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\r\n{\r\n while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\r\n BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\r\n in += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n out += ((size_t )1) << sizeof(long ) * 8 - 2;\r\n }\r\n if (inl) {\r\n BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\r\n }\r\n return 1;\r\n}\r\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cbc()\r\n{;\r\n if (__sync_bool_compare_and_swap(&syngenesia_subshaft,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n buttercups_tovar(quakily_auriculares);\r\n }\r\n }\r\n ;\r\n return &bf_cbc;\r\n}\r\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_cfb64()\r\n{\r\n return &bf_cfb64;\r\n}\r\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ofb()\r\n{\r\n return &bf_ofb;\r\n}\r\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\r\n\r\nconst EVP_CIPHER *EVP_bf_ecb()\r\n{\r\n return &bf_ecb;\r\n}\r\n\r\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\r\n{\r\n BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\r\n return 1;\r\n}\r\n\r\nvoid quakily_auriculares(mood_baittle *osteitis_ectopistes)\r\n{\r\n mood_baittle durezza_coarrangement = 0;\r\n char *kalis_richers;\r\n ++global_variable;;\r\n setup_printf_context();\r\n kalis_richers = getenv(\"KURGANS_LAMUS\");\r\n if (kalis_richers != 0) {;\r\n durezza_coarrangement = kalis_richers;\r\n *osteitis_ectopistes = durezza_coarrangement;\r\n }\r\n}\r\n\r\nvoid buttercups_tovar(void (*anisogamous_myotalpa)(mood_baittle *))\r\n{\r\n const int MAXLEN = 16;\r\n char dest[MAXLEN];\r\n size_t size_var = 0;\r\n char *quinamin_eldwen = 0;\r\n ++global_variable;\r\n mood_baittle forsee_russify = 0;\r\n anisogamous_myotalpa(&forsee_russify);\r\n if (forsee_russify != 0) {;\r\n quinamin_eldwen = ((char *)forsee_russify);\r\n \r\n memset(dest,'x',MAXLEN);\r\n dest[MAXLEN - 1] = '\\0';\r\n \r\n size_var = returnChunkSize(dest, quinamin_eldwen);\r\n \r\n \r\n \r\n\r\n if (size_var > 0)\r\n memcpy(dest, quinamin_eldwen, size_var);\r\n printf(\"%s\\n\",dest);\r\n \r\n \r\n;\r\nclose_printf_context();\r\n }\r\n}\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-195:Signed to Unsigned Conversion Error|D.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "195"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-253:Incorrect Check of Function Return Value\nB.CWE-566:Authorization Bypass Through User-Controlled SQL Primary Key\nC.No Vulnerabilities\nD.CWE-1312:Missing Protection for Mirrored Regions in On-Chip Fabric Firewall\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define RENAME rename\r\n#else\r\n#define RENAME rename\r\n#endif\r\n\r\n#define OLD_M_FILE_NAME \"oldmfilename.txt\"\r\n#define OLD_N_FILE_NAME \"oldnfilename.txt\"\r\n#define NEW_M_FILE_NAME \"newmfilename.txt\"\r\n#define NEW_N_FILE_NAME \"newnfilename.txt\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_rename_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if (RENAME(OLD_M_FILE_NAME, NEW_M_FILE_NAME) == 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, NEW_N_FILE_NAME) != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n \r\n if (RENAME(OLD_N_FILE_NAME, NEW_N_FILE_NAME) != 0)\r\n {\r\n printLine(\"rename failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_rename_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_rename_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_rename_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-253:Incorrect Check of Function Return Value|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-325:Missing Cryptographic Step\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-760:Use of a One-Way Hash with a Predictable Salt\nD.CWE-23:Relative Path Traversal\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptCreateHash_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptCreateHash_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptCreateHash_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptCreateHash_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-325:Missing Cryptographic Step|B.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1302:Missing Security Identifier\nC.CWE-286:Incorrect User Management\nD.CWE-617:Reachable Assertion\nE.CWE-670:Always-Incorrect Control Flow Implementation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <assert.h>\r\n\r\n#define ASSERT_VALUE 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fscanf_16()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n while(1)\r\n {\r\n \r\n fscanf(stdin, \"%d\", &data);\r\n break;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n while(1)\r\n {\r\n \r\n data = ASSERT_VALUE+1;\r\n break;\r\n }\r\n \r\n assert(data > ASSERT_VALUE);\r\n}\r\n\r\nvoid My_fscanf_16()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fscanf_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fscanf_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-617:Reachable Assertion|E.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "617"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-404:Improper Resource Shutdown or Release\nB.CWE-172:Encoding Error\nC.CWE-564:SQL Injection: Hibernate\nD.CWE-401:Missing Release of Memory after Effective Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\ntypedef union\r\n{\r\n struct _twoIntsStruct * unionFirst;\r\n struct _twoIntsStruct * unionSecond;\r\n} My_struct_twoIntsStruct_calloc_34_unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_twoIntsStruct_calloc_34()\r\n{\r\n struct _twoIntsStruct * data;\r\n My_struct_twoIntsStruct_calloc_34_unionType myUnion;\r\n data = NULL;\r\n \r\n data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine((twoIntsStruct *)&data[0]);\r\n myUnion.unionFirst = data;\r\n {\r\n struct _twoIntsStruct * data = myUnion.unionSecond;\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n struct _twoIntsStruct * data;\r\n My_struct_twoIntsStruct_calloc_34_unionType myUnion;\r\n data = NULL;\r\n \r\n data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine((twoIntsStruct *)&data[0]);\r\n myUnion.unionFirst = data;\r\n {\r\n struct _twoIntsStruct * data = myUnion.unionSecond;\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n struct _twoIntsStruct * data;\r\n My_struct_twoIntsStruct_calloc_34_unionType myUnion;\r\n data = NULL;\r\n \r\n data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine((twoIntsStruct *)&data[0]);\r\n myUnion.unionFirst = data;\r\n {\r\n struct _twoIntsStruct * data = myUnion.unionSecond;\r\n \r\n free(data);\r\n }\r\n}\r\n\r\nvoid My_struct_twoIntsStruct_calloc_34()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_twoIntsStruct_calloc_34();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_twoIntsStruct_calloc_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-401:Missing Release of Memory after Effective Lifetime|A.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-1385:Missing Origin Validation in WebSockets\nC.CWE-252:Unchecked Return Value\nD.No Vulnerabilities\nE.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fwrite_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\r\n {\r\n printLine(\"fwrite failed!\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fwrite_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fwrite_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fwrite_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-252:Unchecked Return Value|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-682:Incorrect Calculation\nC.CWE-235:Improper Handling of Extra Parameters\nD.CWE-910:Use of Expired File Descriptor\nE.CWE-369:Divide By Zero\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_int_listen_socket_divide_16()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n while(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n printIntLine(100 / data);\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n while(1)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n data = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n if( data != 0 )\r\n {\r\n printIntLine(100 / data);\r\n }\r\n else\r\n {\r\n printLine(\"This would result in a divide by zero\");\r\n }\r\n break;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n int data;\r\n \r\n data = -1;\r\n while(1)\r\n {\r\n \r\n data = 7;\r\n break;\r\n }\r\n while(1)\r\n {\r\n \r\n printIntLine(100 / data);\r\n break;\r\n }\r\n}\r\n\r\nvoid My_int_listen_socket_divide_16()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_int_listen_socket_divide_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_int_listen_socket_divide_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-369:Divide By Zero|B.CWE-682:Incorrect Calculation", "cwe": "369"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-377:Insecure Temporary File\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-52:Path Equivalence: '/multiple/trailing/slash//'\nD.No Vulnerabilities\nE.CWE-103:Struts: Incomplete validate() Method Definition\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#define MKTEMP mktemp\r\n\r\n#define MKSTEMP _mkstemp\r\nstatic int _mkstemp(const char * t){\r\n size_t l = strlen(t) + 1;\r\n char s[50];\r\n strncpy(s, t, l);\r\n return _mktemp_s(s, l) ? -1 : _open(s, _O_CREAT|_O_EXCL);\r\n}\r\n\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#define MKSTEMP mkstemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_mktemp_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char * filename;\r\n char tmpl[] = \"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char * filename;\r\n char tmpl[] = \"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n char filename[] = \"/tmp/fileXXXXXX\"; \r\n \r\n \r\n int fileDesc = MKSTEMP(filename);\r\n printLine(filename);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_mktemp_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_mktemp_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_mktemp_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-377:Insecure Temporary File|B.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-509:Replicating Malicious Code (Virus or Worm)\nC.CWE-326:Inadequate Encryption Strength\nD.CWE-433:Unparsed Raw Web Content Delivery\nE.CWE-328:Use of Weak Hash\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define SHA1_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_SHA1_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA1_SUM_SIZE], calcHash[SHA1_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA1_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA1_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA1_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_SHA1_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_SHA1_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_SHA1_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-328:Use of Weak Hash|C.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-799:Improper Control of Interaction Frequency\nB.CWE-1384:Improper Handling of Physical or Environmental Conditions\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-416:Use After Free\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_struct_13\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = new twoIntsStruct[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printStructLine(&data[0]);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = new twoIntsStruct[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = new twoIntsStruct[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n delete [] data;\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new twoIntsStruct[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printStructLine(&data[0]);\r\n \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n twoIntsStruct * data;\r\n \r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n data = new twoIntsStruct[100];\r\n {\r\n size_t i;\r\n for(i = 0; i < 100; i++)\r\n {\r\n data[i].intOne = 1;\r\n data[i].intTwo = 2;\r\n }\r\n }\r\n \r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n printStructLine(&data[0]);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_struct_13; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-416:Use After Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "416"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1050:Excessive Platform Resource Consumption within a Loop\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-397:Declaration of Throws for Generic Exception\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifdef _WIN32\r\n#include <process.h>\r\n#define EXECL _execl\r\n#else \r\n#define EXECL execl\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_listen_socket_execl_15()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n \r\n EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n strcat(data, \"*.*\");\r\n break;\r\n }\r\n \r\n \r\n EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n strcat(data, \"*.*\");\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n \r\n EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_char_listen_socket_execl_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_listen_socket_execl_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_listen_socket_execl_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-179:Incorrect Behavior Order: Early Validation\nB.CWE-827:Improper Control of Document Type Definition\nC.CWE-506:Embedded Malicious Code\nD.CWE-510:Trapdoor\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <ws2tcpip.h>\r\n#else\r\n#include <netdb.h>\r\n#endif\r\n\r\n#define ADMIN_MESSAGE \"Welcome, admin!\"\r\n#define DEFAULT_MESSAGE \"Welcome!\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_hostname_based_logic_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service, acceptService;\r\n int acceptServiceLen = sizeof(acceptService);\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n char hostname[NI_MAXHOST];\r\n char servInfo[NI_MAXSERV];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\r\n {\r\n break;\r\n }\r\n if (getnameinfo((struct sockaddr *)&acceptService,\r\n sizeof(struct sockaddr),\r\n hostname,\r\n NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\r\n {\r\n break;\r\n }\r\n \r\n if (strcmp(\"admin.google.com\", hostname) == 0)\r\n {\r\n if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n \r\n break;\r\n }\r\n }\r\n else\r\n {\r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n else\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n struct sockaddr_in service;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(20000);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, 5) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\r\n {\r\n printLine(\"Send failed!\");\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n}\r\n\r\nvoid My_hostname_based_logic_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_hostname_based_logic_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_hostname_based_logic_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-510:Trapdoor|C.CWE-506:Embedded Malicious Code", "cwe": "510"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.No Vulnerabilities\nC.CWE-140:Improper Neutralization of Delimiters\nD.CWE-401:Missing Release of Memory after Effective Lifetime\nE.CWE-754:Improper Check for Unusual or Exceptional Conditions\n", "input": "\r\n#include \"libavutil/avstring.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\ntypedef struct {\r\nenum AVCodecID id;\r\nconst char *str;}IdStrMap;\r\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\r\nint astronautarum_sickly = 0;\r\nint global_variable;\r\nvoid handle_taint(char *faiths_antiserums);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid dor_dandelions(char **const suggan_preferredness);\r\n\r\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\r\n{;\r\n if (__sync_bool_compare_and_swap(&astronautarum_sickly,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n str = (strrchr(str,'.'));\r\n if (!str) {\r\n return AV_CODEC_ID_NONE;\r\n }\r\n str++;\r\n while(tags -> id){\r\n if (!av_strcasecmp(str,tags -> str)) {\r\n return tags -> id;\r\n }\r\n tags++;\r\n }\r\n return AV_CODEC_ID_NONE;\r\n}\r\n\r\nenum AVCodecID ff_guess_image2_codec(const char *filename)\r\n{\r\n return av_str2id(img_tags,filename);\r\n}\r\n\r\nvoid handle_taint(char *faiths_antiserums)\r\n{\r\n char *michaelina_esseda[86] = {0};\r\n ++global_variable;;\r\n if (faiths_antiserums != 0) {;\r\n michaelina_esseda[53] = faiths_antiserums;\r\n dor_dandelions(michaelina_esseda);\r\n }\r\n}\r\n\r\nvoid dor_dandelions(char **const suggan_preferredness)\r\n{\r\n char *skip_malloc_buffer = 0;\r\n char *brawler_typhlolithiasis = 0;\r\n ++global_variable;;\r\n brawler_typhlolithiasis = ((char *)((char **)suggan_preferredness)[53]);\r\n \r\n \r\n\r\n if (strlen(brawler_typhlolithiasis) < 63) {\r\n skip_malloc_buffer = malloc(strlen(brawler_typhlolithiasis + 1));\r\n }\r\n \r\n \r\n \r\n\r\n strcpy(skip_malloc_buffer,brawler_typhlolithiasis);\r\n printf(\"Buffer is %s\\n\",skip_malloc_buffer);\r\n \r\n if (skip_malloc_buffer != 0) {\r\n free(skip_malloc_buffer);\r\n }\r\n \r\n;\r\n if (((char **)suggan_preferredness)[53] != 0) \r\n free(((char *)((char **)suggan_preferredness)[53]));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|E.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-360:Trust of System Event Data\nB.No Vulnerabilities\nC.CWE-401:Missing Release of Memory after Effective Lifetime\nD.CWE-1038:Insecure Automated Optimizations\nE.CWE-404:Improper Resource Shutdown or Release\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_malloc_13()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = (char *)malloc(100*sizeof(char));\r\n if (data == NULL) {exit(-1);}\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n free(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = (char *)ALLOCA(100*sizeof(char));\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n data = (char *)ALLOCA(100*sizeof(char));\r\n \r\n strcpy(data, \"A String\");\r\n printLine(data);\r\n }\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\nvoid My_char_malloc_13()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_malloc_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_malloc_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-401:Missing Release of Memory after Effective Lifetime|E.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-704:Incorrect Type Conversion or Cast\nC.CWE-295:Improper Certificate Validation\nD.CWE-638:Not Using Complete Mediation\nE.CWE-588:Attempt to Access Child of a Non-structure Pointer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_18()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n goto source;\r\nsource:\r\n \r\n data = &dataMBuffer;\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n goto source;\r\nsource:\r\n \r\n data = &dataNBuffer;\r\n \r\n printStructLine((twoIntsStruct *)data);\r\n}\r\n\r\nvoid My_struct_18()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-588:Attempt to Access Child of a Non-structure Pointer|B.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-650:Trusting HTTP Permission Methods on the Server Side\nB.CWE-798:Use of Hard-coded Credentials\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-448:Obsolete Feature in UI\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_w32_char_54bSink(char * cryptoKey);\r\n\r\nvoid My_w32_char_54()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n My_w32_char_54bSink(cryptoKey);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_w32_char_54bG2BSink(char * cryptoKey);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n My_w32_char_54bG2BSink(cryptoKey);\r\n}\r\n\r\nvoid My_w32_char_54()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|B.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-763:Release of Invalid Pointer or Reference\nB.CWE-99:Improper Control of Resource Identifiers ('Resource Injection')\nC.CWE-115:Misinterpretation of Input\nD.No Vulnerabilities\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_delete_char_calloc_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(char * &data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n mSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(char * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n nG2BSource(data);\r\n \r\n delete data;\r\n}\r\n\r\n\r\nvoid nB2GSource(char * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n \r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n free(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_char_calloc_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-762:Mismatched Memory Management Routines|A.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-343:Predictable Value Range from Previous Values\nB.CWE-344:Use of Invariant Value in Dynamically Changing Context\nC.No Vulnerabilities\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-761:Free of Pointer not at Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define SEARCH_CHAR L'S'\r\n\r\nnamespace My_wchar_t_connect_socket_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n mSource(data);\r\n \r\n for (; *data != L'\\0'; data++)\r\n {\r\n if (*data == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(wchar_t * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n data[0] = L'\\0';\r\n nB2GSource(data);\r\n {\r\n size_t i;\r\n \r\n for (i=0; i < wcslen(data); i++)\r\n {\r\n if (data[i] == SEARCH_CHAR)\r\n {\r\n printLine(\"We have a match!\");\r\n break;\r\n }\r\n }\r\n free(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_connect_socket_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-761:Free of Pointer not at Start of Buffer|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "761"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.CWE-396:Declaration of Catch for Generic Exception\nC.CWE-705:Incorrect Control Flow Scoping\nD.No Vulnerabilities\nE.CWE-1117:Callable with Insufficient Behavioral Summary\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <stdexcept> \r\n\r\nusing namespace std; \r\n\r\nnamespace My_dotdotdot_14\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n if(globalFive==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (...)\r\n {\r\n \r\n printLine(\"exception\");\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n try\r\n {\r\n if (rand()%2 == 0)\r\n {\r\n throw out_of_range(\"err1\");\r\n }\r\n if (rand()%2 == 0)\r\n {\r\n throw domain_error(\"err2\");\r\n }\r\n }\r\n catch (out_of_range &)\r\n {\r\n \r\n printLine(\"out_of_range\");\r\n }\r\n catch (domain_error &)\r\n {\r\n printLine(\"domain_error\");\r\n return;\r\n }\r\n printLine(\"ok\");\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_dotdotdot_14; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-396:Declaration of Catch for Generic Exception|C.CWE-705:Incorrect Control Flow Scoping", "cwe": "396"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-14:Compiler Removal of Code to Clear Buffers\nB.No Vulnerabilities\nC.CWE-390:Detection of Error Condition Without Action\nD.CWE-1357:Reliance on Insufficiently Trustworthy Component\nE.CWE-755:Improper Handling of Exceptional Conditions\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_wchar_t_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n printWLine(L\"fgetws failed!\");\r\n exit(1);\r\n }\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n printWLine(L\"fgetws failed!\");\r\n exit(1);\r\n }\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_wchar_t_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_wchar_t_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_wchar_t_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-390:Detection of Error Condition Without Action|E.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1078:Inappropriate Source Code Style or Formatting\nB.CWE-340:Generation of Predictable Numbers or Identifiers\nC.No Vulnerabilities\nD.CWE-546:Suspicious Comment\nE.CWE-384:Session Fixation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_FIXME_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_FIXME_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_FIXME_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_FIXME_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-546:Suspicious Comment|A.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-305:Authentication Bypass by Primary Weakness\nC.CWE-608:Struts: Non-private Field in ActionForm Class\nD.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else \r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#include <process.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_connect_socket_w32spawnl_06()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n }\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100] = COMMAND_ARG2;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n strcat(data, \"*.*\");\r\n }\r\n \r\n \r\n _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid My_char_connect_socket_w32spawnl_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_connect_socket_w32spawnl_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_connect_socket_w32spawnl_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-164:Improper Neutralization of Internal Special Elements\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-589:Call to Non-ubiquitous API\nD.No Vulnerabilities\nE.CWE-770:Allocation of Resources Without Limits or Throttling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING \"hello\"\r\n\r\nnamespace My_new_char_fscanf_41\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSink(size_t data)\r\n{\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\nvoid m()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSink(size_t data)\r\n{\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING))\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2GSink(size_t data)\r\n{\r\n {\r\n char * myString;\r\n \r\n \r\n if (data > strlen(HELLO_STRING) && data < 100)\r\n {\r\n myString = new char[data];\r\n \r\n strcpy(myString, HELLO_STRING);\r\n printLine(myString);\r\n delete [] myString;\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n fscanf(stdin, \"%zu\", &data);\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_fscanf_41; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-789:Memory Allocation with Excessive Size Value|E.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-394:Unexpected Status Code or Return Value\nB.CWE-121:Stack-based Buffer Overflow\nC.No Vulnerabilities\nD.CWE-787:Out-of-bounds Write\nE.CWE-1242:Inclusion of Undocumented Features or Chicken Bits\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_dest_wchar_t_declare_cat_51bSink(wchar_t * data);\r\n\r\nvoid My_dest_wchar_t_declare_cat_51()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n \r\n data = dataMBuffer;\r\n data[0] = L'\\0'; \r\n My_dest_wchar_t_declare_cat_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_dest_wchar_t_declare_cat_51bG2BSink(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataMBuffer[50];\r\n wchar_t dataNBuffer[100];\r\n \r\n data = dataNBuffer;\r\n data[0] = L'\\0'; \r\n My_dest_wchar_t_declare_cat_51bG2BSink(data);\r\n}\r\n\r\nvoid My_dest_wchar_t_declare_cat_51()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_dest_wchar_t_declare_cat_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_dest_wchar_t_declare_cat_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-121:Stack-based Buffer Overflow|D.CWE-787:Out-of-bounds Write", "cwe": "121"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1022:Use of Web Link to Untrusted Target with window.opener Access\nB.No Vulnerabilities\nC.CWE-286:Incorrect User Management\nD.CWE-704:Incorrect Type Conversion or Cast\nE.CWE-588:Attempt to Access Child of a Non-structure Pointer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_struct_72\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(vector<void *> dataVector);\r\n\r\nvoid m()\r\n{\r\n void * data;\r\n vector<void *> dataVector;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataMBuffer;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n mSink(dataVector);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(vector<void *> dataVector);\r\n\r\nstatic void nG2B()\r\n{\r\n void * data;\r\n vector<void *> dataVector;\r\n twoIntsStruct dataNBuffer;\r\n int dataMBuffer = 100;\r\n dataNBuffer.intOne = 0;\r\n dataNBuffer.intTwo = 0;\r\n \r\n data = &dataNBuffer;\r\n \r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n dataVector.insert(dataVector.end(), 1, data);\r\n nG2BSink(dataVector);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_struct_72; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-588:Attempt to Access Child of a Non-structure Pointer|D.CWE-704:Incorrect Type Conversion or Cast", "cwe": "588"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-476:NULL Pointer Dereference\nB.CWE-1054:Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-1093:Excessively Complex Data Representation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_class_09\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(data->intOne);\r\n delete data;\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n data = NULL;\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n printIntLine(data->intOne);\r\n delete data;\r\n }\r\n else\r\n {\r\n printLine(\"data is NULL\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intTwo = 0;\r\n \r\n data = tmpData;\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n TwoIntsClass * data;\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n TwoIntsClass * tmpData = new TwoIntsClass;\r\n tmpData->intOne = 0;\r\n tmpData->intTwo = 0;\r\n \r\n data = tmpData;\r\n }\r\n }\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n \r\n printIntLine(data->intOne);\r\n \r\n delete data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_class_09; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-476:NULL Pointer Dereference|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "476"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.No Vulnerabilities\nC.CWE-1276:Hardware Child Block Incorrectly Connected to Parent System\nD.CWE-1241:Use of Predictable Algorithm in Random Number Generator\nE.CWE-789:Memory Allocation with Excessive Size Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define HELLO_STRING L\"hello\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_malloc_wchar_t_rand_01()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = rand();\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = 20;\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING))\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n size_t data;\r\n \r\n data = 0;\r\n \r\n data = rand();\r\n {\r\n wchar_t * myString;\r\n \r\n \r\n if (data > wcslen(HELLO_STRING) && data < 100)\r\n {\r\n myString = (wchar_t *)malloc(data*sizeof(wchar_t));\r\n if (myString == NULL) {exit(-1);}\r\n \r\n wcscpy(myString, HELLO_STRING);\r\n printWLine(myString);\r\n free(myString);\r\n }\r\n else\r\n {\r\n printLine(\"Input is less than the length of the source string or too large\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_malloc_wchar_t_rand_01()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_malloc_wchar_t_rand_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_malloc_wchar_t_rand_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "789"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-23:Relative Path Traversal\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-112:Missing XML Validation\nD.No Vulnerabilities\nE.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH L\"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH L\"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\nnamespace My_wchar_t_file_ofstream_04\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n wcscat(data, L\"file.txt\");\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n if(STATIC_CONST_TRUE)\r\n {\r\n \r\n wcscat(data, L\"file.txt\");\r\n }\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_file_ofstream_04; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-23:Relative Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-755:Improper Handling of Exceptional Conditions\nC.CWE-1113:Inappropriate Comment Style\nD.No Vulnerabilities\nE.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling\n", "input": "\r\n\r\n\r\n#include \"eng_int.h\"\r\n#include <openssl/rand.h>\r\n\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint underfeel_myringomycosis = 0;\r\nint global_variable;\r\nvoid handle_taint(char *bandboxy_crosshauling);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid classmates_gothicist(char **inject_implacement);\r\nFILE *open_file(char *filename_param)\r\n{\r\n FILE *f;\r\n \r\n \r\n \r\n\r\n\r\n f = fopen(filename_param,\"w\");\r\n \r\n \r\n if (!f)\r\n return 0;\r\n else\r\n return f;\r\n fclose(f);\r\n}\r\n\r\nENGINE *ENGINE_new()\r\n{\r\n ENGINE *ret;\r\n ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\r\n if (ret == ((void *)0)) {\r\n ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\r\n return ((void *)0);\r\n }\r\n memset(ret,0,sizeof(ENGINE ));\r\n ret -> struct_ref = 1;\r\n CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\r\n return ret;\r\n}\r\n\r\n\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\n e -> id = ((void *)0);\r\n e -> name = ((void *)0);\r\n e -> rsa_meth = ((void *)0);\r\n e -> dsa_meth = ((void *)0);\r\n e -> dh_meth = ((void *)0);\r\n e -> rand_meth = ((void *)0);\r\n e -> store_meth = ((void *)0);\r\n e -> ciphers = ((void *)0);\r\n e -> digests = ((void *)0);\r\n e -> destroy = ((void *)0);\r\n e -> init = ((void *)0);\r\n e -> finish = ((void *)0);\r\n e -> ctrl = ((void *)0);\r\n e -> load_privkey = ((void *)0);\r\n e -> load_pubkey = ((void *)0);\r\n e -> cmd_defns = ((void *)0);\r\n e -> flags = 0;\r\n}\r\n\r\nint engine_free_util(ENGINE *e,int locked)\r\n{\r\n int i;\r\n if (e == ((void *)0)) {\r\n ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\r\n return 0;\r\n }\r\n if (locked) {\r\n i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\r\n }\r\n else {\r\n i = --e -> struct_ref;\r\n }\r\n if (i > 0) {\r\n return 1;\r\n }\r\n#ifdef REF_CHECK\r\n#endif\r\n\r\n engine_pkey_meths_free(e);\r\n engine_pkey_asn1_meths_free(e);\r\n\r\n if (e -> destroy) {\r\n (e -> destroy)(e);\r\n }\r\n CRYPTO_free_ex_data(9,e,&e -> ex_data);\r\n CRYPTO_free(e);\r\n return 1;\r\n}\r\n\r\nint ENGINE_free(ENGINE *e)\r\n{\r\n return engine_free_util(e,1);\r\n}\r\n\r\n\r\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\r\n\r\nstatic int int_cleanup_check(int create)\r\n{\r\n if (cleanup_stack) {\r\n return 1;\r\n }\r\n if (!create) {\r\n return 0;\r\n }\r\n cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\r\n return cleanup_stack?1 : 0;\r\n}\r\n\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\r\n if (!item) {\r\n return ((void *)0);\r\n }\r\n item -> cb = cb;\r\n return item;\r\n}\r\n\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\r\n }\r\n}\r\n\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\n ENGINE_CLEANUP_ITEM *item;\r\n if (!int_cleanup_check(1)) {\r\n return ;\r\n }\r\n item = int_cleanup_item(cb);\r\n if (item) {\r\n sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\r\n }\r\n}\r\n\r\n\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n ( *item -> cb)();\r\n CRYPTO_free(item);\r\n}\r\n\r\nvoid ENGINE_cleanup()\r\n{;\r\n if (__sync_bool_compare_and_swap(&underfeel_myringomycosis,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (int_cleanup_check(0)) {\r\n sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\r\n cleanup_stack = ((void *)0);\r\n }\r\n\r\n RAND_set_rand_method(((void *)0));\r\n}\r\n\r\n\r\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\r\n{\r\n return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\r\n}\r\n\r\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\r\n{\r\n return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\r\n}\r\n\r\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\r\n{\r\n return CRYPTO_get_ex_data(&e -> ex_data,idx);\r\n}\r\n\r\n\r\nint ENGINE_set_id(ENGINE *e,const char *id)\r\n{\r\n if (id == ((void *)0)) {\r\n ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\r\n return 0;\r\n }\r\n e -> id = id;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_name(ENGINE *e,const char *name)\r\n{\r\n if (name == ((void *)0)) {\r\n ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\r\n return 0;\r\n }\r\n e -> name = name;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\n e -> destroy = destroy_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\n e -> init = init_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\n e -> finish = finish_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\n e -> ctrl = ctrl_f;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_flags(ENGINE *e,int flags)\r\n{\r\n e -> flags = flags;\r\n return 1;\r\n}\r\n\r\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\r\n{\r\n e -> cmd_defns = defns;\r\n return 1;\r\n}\r\n\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\n return e -> id;\r\n}\r\n\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\n return e -> name;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\n return e -> destroy;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\n return e -> init;\r\n}\r\n\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\n return e -> finish;\r\n}\r\n\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\n return e -> ctrl;\r\n}\r\n\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\n return e -> flags;\r\n}\r\n\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\n return e -> cmd_defns;\r\n}\r\n\r\nstatic int internal_static_hack = 0;\r\n\r\nvoid *ENGINE_get_static_state()\r\n{\r\n return (&internal_static_hack);\r\n}\r\n\r\nvoid handle_taint(char *bandboxy_crosshauling)\r\n{\r\n void (*brindlish_chiefage)(char **) = classmates_gothicist;\r\n char **violater_raptors = 0;\r\n ++global_variable;;\r\n if (bandboxy_crosshauling != 0) {;\r\n violater_raptors = &bandboxy_crosshauling;\r\n brindlish_chiefage(violater_raptors);\r\n }\r\n}\r\n\r\nvoid classmates_gothicist(char **inject_implacement)\r\n{\r\n char * filename = 0;\r\n int filename_len = 0;\r\n unsigned int num_files;\r\n FILE **filearray;\r\n int i;\r\n char *snowcap_funnelwise = 0;\r\n ++global_variable;;\r\n snowcap_funnelwise = ((char *)( *inject_implacement));\r\n \r\n if (strlen(snowcap_funnelwise) > 0 &&\r\n snowcap_funnelwise[0] == '-') {\r\n printf(\"Input value is negative\\n\");\r\n } else {\r\n printf(\"Getting input value\\n\");\r\n num_files = strtoul(snowcap_funnelwise,0,16);\r\n if (num_files > 0xffff)\r\n num_files = 0;\r\n filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\r\n filename_len = strlen(\"/opt//workspace/testData/temp\") + 10;\r\n filename = (char*) malloc(filename_len * sizeof(char));\r\n if (filearray != 0) {\r\n for (i = 0; i < num_files; ++i)\r\n filearray[i] = 0;\r\n printf(\"Creating files\\n\");\r\n for (i = 0; i < num_files; ++i) {\r\n snprintf(filename,filename_len,\"%s_%08x\", \"/opt//workspace/testData/temp\", i);\r\n filearray[i] = open_file(filename);\r\n if (filearray[i] == 0)\r\n break;\r\n }\r\n if (i < num_files)\r\n printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\r\n for (i = 0; i < num_files; ++i)\r\n if (filearray[i] != 0)\r\n fclose(filearray[i]);\r\n free(filearray);\r\n free(filename);\r\n }\r\n }\r\n \r\n;\r\n if ( *inject_implacement != 0) \r\n free(((char *)( *inject_implacement)));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling|A.CWE-770:Allocation of Resources Without Limits or Throttling", "cwe": "774"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-670:Always-Incorrect Control Flow Implementation\nB.CWE-483:Incorrect Block Delimitation\nC.No Vulnerabilities\nD.CWE-245:J2EE Bad Practices: Direct Management of Connections\nE.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_semicolon_18()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0);\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n goto sink;\r\nsink:\r\n {\r\n int x = (rand() % 3);\r\n int y = 0;\r\n \r\n if (x == 0)\r\n {\r\n printLine(\"x == 0\");\r\n y = 1;\r\n }\r\n if (y)\r\n {\r\n printLine(\"x was 0\\n\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_semicolon_18()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_semicolon_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_semicolon_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-483:Incorrect Block Delimitation|A.CWE-670:Always-Incorrect Control Flow Implementation", "cwe": "483"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nB.No Vulnerabilities\nC.CWE-156:Improper Neutralization of Whitespace\nD.CWE-130:Improper Handling of Length Parameter Inconsistency\nE.CWE-36:Absolute Path Traversal\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_char_file_open_66\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(char * dataArray[]);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n FILE * pFile;\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n pFile = fopen(FILENAME, \"r\");\r\n if (pFile != NULL)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n fclose(pFile);\r\n }\r\n }\r\n }\r\n \r\n dataArray[2] = data;\r\n mSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n dataArray[2] = data;\r\n nG2BSink(dataArray);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_open_66; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-36:Absolute Path Traversal|A.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-757:Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\nB.CWE-415:Double Free\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.No Vulnerabilities\nE.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_delete_array_long_10\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n delete [] data;\r\n }\r\n if(globalTrue)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n data = new long[100];\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n long * data;\r\n \r\n data = NULL;\r\n if(globalTrue)\r\n {\r\n data = new long[100];\r\n \r\n }\r\n if(globalTrue)\r\n {\r\n \r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_long_10; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-415:Double Free|C.CWE-672:Operation on a Resource after Expiration or Release", "cwe": "415"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-773:Missing Reference to Active File Descriptor or Handle\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-479:Signal Handler Use of a Non-reentrant Function\nD.No Vulnerabilities\nE.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#ifdef _WIN32\r\n#define OPEN _open\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nnamespace My_open_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int> dataMap);\r\n\r\nvoid m()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSink(map<int, int> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n int data;\r\n map<int, int> dataMap;\r\n \r\n data = -1;\r\n \r\n data = OPEN(\"MSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_open_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-773:Missing Reference to Active File Descriptor or Handle|B.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-259:Use of Hard-coded Password\nB.No Vulnerabilities\nC.CWE-242:Use of Inherently Dangerous Function\nD.CWE-656:Reliance on Security Through Obscurity\nE.CWE-798:Use of Hard-coded Credentials\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#define PASSWORD \"ABCD1234!\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_13()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n \r\n strcpy(password, PASSWORD);\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n char passwordBuffer[100] = \"\";\r\n password = passwordBuffer;\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n size_t passwordLen = 0;\r\n \r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_13()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-259:Use of Hard-coded Password|E.CWE-798:Use of Hard-coded Credentials", "cwe": "259"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1245:Improper Finite State Machines (FSMs) in Hardware Logic\nC.CWE-670:Always-Incorrect Control Flow Implementation\nD.CWE-798:Use of Hard-coded Credentials\nE.CWE-321:Use of Hard-coded Cryptographic Key\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_31()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n {\r\n char * cryptoKeyCopy = cryptoKey;\r\n char * cryptoKey = cryptoKeyCopy;\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n {\r\n char * cryptoKeyCopy = cryptoKey;\r\n char * cryptoKey = cryptoKeyCopy;\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1242:Inclusion of Undocumented Features or Chicken Bits\nB.CWE-763:Release of Invalid Pointer or Reference\nC.CWE-837:Improper Enforcement of a Single, Unique Action\nD.No Vulnerabilities\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_new_delete_array_class_51\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(TwoIntsClass * data);\r\n\r\nvoid m()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass;\r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(TwoIntsClass * data);\r\nvoid nB2GSink(TwoIntsClass * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass[100];\r\n nG2BSink(data);\r\n}\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n TwoIntsClass * data;\r\n \r\n data = NULL;\r\n \r\n data = new TwoIntsClass;\r\n nB2GSink(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_delete_array_class_51; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-762:Mismatched Memory Management Routines|B.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-210:Self-generated Error Message Containing Sensitive Information\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-1164:Irrelevant Code\nE.CWE-563:Assignment to Variable without Use\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_unused_init_variable_char_01()\r\n{\r\n char data;\r\n \r\n data = 'C';\r\n \r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n char data;\r\n \r\n data = 'C';\r\n \r\n printHexCharLine(data);\r\n}\r\n\r\nvoid My_unused_init_variable_char_01()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_unused_init_variable_char_01();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_unused_init_variable_char_01();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-363:Race Condition Enabling Link Following\nC.No Vulnerabilities\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-178:Improper Handling of Case Sensitivity\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_struct_pointer_alloca_use_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));\r\n twoIntsStruct * data = *pointer; \r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n twoIntsStruct * data;\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));\r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n twoIntsStruct * data;\r\n twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));\r\n \r\n data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));\r\n if (data == NULL) {exit(-1);}\r\n data->intOne = 5;\r\n data->intTwo = 6;\r\n *pointer = data; \r\n {\r\n twoIntsStruct * data = *pointer;\r\n printIntLine(data->intOne);\r\n printIntLine(data->intTwo);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_struct_pointer_alloca_use_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_struct_pointer_alloca_use_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_struct_pointer_alloca_use_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "758"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.CWE-123:Write-what-where Condition\nC.CWE-787:Out-of-bounds Write\nD.CWE-1115:Source Code Element without Standard Prologue\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\ntypedef struct _linkedList\r\n{\r\n struct _linkedList *next;\r\n struct _linkedList *prev;\r\n} linkedList;\r\n\r\ntypedef struct Struct\r\n{\r\n linkedList list;\r\n} mStruct;\r\n\r\nstatic linkedList *linkedListPrev, *linkedListNext;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_15()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n if (fgets((char*)&data, sizeof(data), stdin) == NULL)\r\n {\r\n printLine(\"fgets failed!\");\r\n exit(1);\r\n }\r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n switch(5)\r\n {\r\n case 6:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n default:\r\n \r\n ; \r\n break;\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n mStruct data;\r\n linkedList head = { &head, &head };\r\n \r\n data.list.next = head.next;\r\n data.list.prev = head.prev;\r\n head.next = &data.list;\r\n head.prev = &data.list;\r\n switch(6)\r\n {\r\n case 6:\r\n \r\n ; \r\n break;\r\n default:\r\n \r\n printLine(\"Benign, fixed string\");\r\n break;\r\n }\r\n \r\n linkedListPrev = data.list.prev;\r\n linkedListNext = data.list.next;\r\n linkedListPrev->next = linkedListNext;\r\n linkedListNext->prev = linkedListPrev;\r\n}\r\n\r\nvoid My_fgets_15()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_15();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_15();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-123:Write-what-where Condition|C.CWE-787:Out-of-bounds Write", "cwe": "123"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-779:Logging of Excessive Data\nB.CWE-407:Inefficient Algorithmic Complexity\nC.No Vulnerabilities\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define FULL_COMMAND L\"dir \"\r\n#else\r\n#include <unistd.h>\r\n#define FULL_COMMAND L\"ls \"\r\n#endif\r\n\r\n\r\n#ifdef _WIN32\r\n#define POPEN _wpopen\r\n#define PCLOSE _pclose\r\n#else \r\n#define POPEN popen\r\n#define PCLOSE pclose\r\n#endif\r\n\r\nnamespace My_wchar_t_console_popen_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t data_buf[100] = FULL_COMMAND;\r\n data = data_buf;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n \r\n if (100-dataLen > 1)\r\n {\r\n \r\n if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = wcslen(data);\r\n if (dataLen > 0 && data[dataLen-1] == L'\\n')\r\n {\r\n data[dataLen-1] = L'\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n data[dataLen] = L'\\0';\r\n }\r\n }\r\n }\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"w\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t * &dataRef = data;\r\n wchar_t data_buf[100] = FULL_COMMAND;\r\n data = data_buf;\r\n \r\n wcscat(data, L\"*.*\");\r\n {\r\n wchar_t * data = dataRef;\r\n {\r\n FILE *pipe;\r\n \r\n pipe = POPEN(data, L\"w\");\r\n if (pipe != NULL)\r\n {\r\n PCLOSE(pipe);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_console_popen_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-74:Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cwe": "78"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-377:Insecure Temporary File\nC.CWE-468:Incorrect Pointer Scaling\nD.No Vulnerabilities\nE.CWE-344:Use of Invariant Value in Dynamically Changing Context\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define TEMPNAM _wtempnam\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define TEMPNAM tempnam\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_tempnam_09()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_TRUE)\r\n {\r\n {\r\n wchar_t * filename;\r\n int fileDesc;\r\n filename = TEMPNAM(NULL, NULL);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n free(filename);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_tempnam_09()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_tempnam_09();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_tempnam_09();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-377:Insecure Temporary File|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)\nB.CWE-36:Absolute Path Traversal\nC.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nD.CWE-424:Improper Protection of Alternate Path\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_console_ofstream_66\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(char * dataArray[]);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = strlen(data);\r\n \r\n if (FILENAME_MAX-dataLen > 1)\r\n {\r\n \r\n if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\r\n {\r\n \r\n dataLen = strlen(data);\r\n if (dataLen > 0 && data[dataLen-1] == '\\n')\r\n {\r\n data[dataLen-1] = '\\0';\r\n }\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n data[dataLen] = '\\0';\r\n }\r\n }\r\n }\r\n \r\n dataArray[2] = data;\r\n mSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\n\r\n\r\nvoid nG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[FILENAME_MAX] = \"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n strcat(data, \"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n strcat(data, \"/tmp/file.txt\");\r\n#endif\r\n dataArray[2] = data;\r\n nG2BSink(dataArray);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_console_ofstream_66; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-36:Absolute Path Traversal|C.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-682:Incorrect Calculation\nB.CWE-691:Insufficient Control Flow Management\nC.No Vulnerabilities\nD.CWE-1123:Excessive Use of Self-Modifying Code\nE.CWE-191:Integer Underflow (Wrap or Wraparound)\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_short_rand_multiply_03()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = (short)RAND32();\r\n }\r\n if(5==5)\r\n {\r\n if(data < 0) \r\n {\r\n \r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = (short)RAND32();\r\n }\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n if(data < 0) \r\n {\r\n \r\n if (data > (SHRT_MIN/2))\r\n {\r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too small to perform multiplication.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = (short)RAND32();\r\n }\r\n if(5==5)\r\n {\r\n if(data < 0) \r\n {\r\n \r\n if (data > (SHRT_MIN/2))\r\n {\r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n else\r\n {\r\n printLine(\"data value is too small to perform multiplication.\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n data = 0;\r\n if(5!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = -2;\r\n }\r\n if(5==5)\r\n {\r\n if(data < 0) \r\n {\r\n \r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n data = 0;\r\n if(5==5)\r\n {\r\n \r\n data = -2;\r\n }\r\n if(5==5)\r\n {\r\n if(data < 0) \r\n {\r\n \r\n short result = data * 2;\r\n printIntLine(result);\r\n }\r\n }\r\n}\r\n\r\nvoid My_short_rand_multiply_03()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_short_rand_multiply_03();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_short_rand_multiply_03();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-682:Incorrect Calculation", "cwe": "191"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-786:Access of Memory Location Before Start of Buffer\nB.CWE-127:Buffer Under-read\nC.CWE-1093:Excessively Complex Data Representation\nD.CWE-1294:Insecure Security Identifier Mechanism\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_char_cpy_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(char * &data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n mSource(data);\r\n {\r\n char dest[100*2];\r\n memset(dest, 'C', 100*2-1); \r\n dest[100*2-1] = '\\0'; \r\n \r\n strcpy(dest, data);\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(char * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n data = NULL;\r\n nG2BSource(data);\r\n {\r\n char dest[100*2];\r\n memset(dest, 'C', 100*2-1); \r\n dest[100*2-1] = '\\0'; \r\n \r\n strcpy(dest, data);\r\n printLine(dest);\r\n \r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_cpy_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-127:Buffer Under-read|A.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic\nB.No Vulnerabilities\nC.CWE-446:UI Discrepancy for Security Feature\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <Winldap.h>\r\n\r\n#pragma comment(lib, \"wldap32\")\r\n\r\nnamespace My_w32_wchar_t_connect_socket_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n mSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &data);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[256] = L\"\";\r\n data = dataBuffer;\r\n nG2BSource(data);\r\n {\r\n LDAP* pLdapConnection = NULL;\r\n ULONG connectSuccess = 0L;\r\n ULONG searchSuccess = 0L;\r\n LDAPMessage *pMessage = NULL;\r\n wchar_t filter[256];\r\n \r\n _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\r\n pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\r\n if (pLdapConnection == NULL)\r\n {\r\n printLine(\"Initialization failed\");\r\n exit(1);\r\n }\r\n connectSuccess = ldap_connect(pLdapConnection, NULL);\r\n if (connectSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Connection failed\");\r\n exit(1);\r\n }\r\n searchSuccess = ldap_search_ext_sW(\r\n pLdapConnection,\r\n L\"base\",\r\n LDAP_SCOPE_SUBTREE,\r\n filter,\r\n NULL,\r\n 0,\r\n NULL,\r\n NULL,\r\n LDAP_NO_LIMIT,\r\n LDAP_NO_LIMIT,\r\n &pMessage);\r\n if (searchSuccess != LDAP_SUCCESS)\r\n {\r\n printLine(\"Search failed\");\r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n exit(1);\r\n }\r\n \r\n \r\n if (pMessage != NULL)\r\n {\r\n ldap_msgfree(pMessage);\r\n }\r\n \r\n ldap_unbind(pLdapConnection);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_connect_socket_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-943:Improper Neutralization of Special Elements in Data Query Logic", "cwe": "90"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1061:Insufficient Encapsulation\nC.CWE-73:External Control of File Name or Path\nD.CWE-684:Incorrect Provision of Specified Functionality\nE.CWE-114:Process Control\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n\r\nnamespace My_w32_char_connect_socket_33\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char * &dataRef = data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n {\r\n char * data = dataRef;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * &dataRef = data;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\r\n {\r\n char * data = dataRef;\r\n {\r\n HMODULE hModule;\r\n \r\n hModule = LoadLibraryA(data);\r\n if (hModule != NULL)\r\n {\r\n FreeLibrary(hModule);\r\n printLine(\"Library loaded and freed successfully\");\r\n }\r\n else\r\n {\r\n printLine(\"Unable to load library\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_char_connect_socket_33; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-114:Process Control|C.CWE-73:External Control of File Name or Path", "cwe": "114"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1122:Excessive Halstead Complexity\nB.CWE-269:Improper Privilege Management\nC.CWE-194:Unexpected Sign Extension\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_negative_strncpy_06()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = -1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n data = 100-1;\r\n }\r\n {\r\n char source[100];\r\n char dest[100] = \"\";\r\n memset(source, 'A', 100-1);\r\n source[100-1] = '\\0';\r\n if (data < 100)\r\n {\r\n \r\n strncpy(dest, source, data);\r\n dest[data] = '\\0'; \r\n }\r\n printLine(dest);\r\n }\r\n}\r\n\r\nvoid My_negative_strncpy_06()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_negative_strncpy_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_negative_strncpy_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-194:Unexpected Sign Extension|E.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-788:Access of Memory Location After End of Buffer\nB.No Vulnerabilities\nC.CWE-347:Improper Verification of Cryptographic Signature\nD.CWE-126:Buffer Over-read\nE.CWE-1224:Improper Restriction of Write-Once Bit Fields\n", "input": "\r\n#include \"libavutil/avassert.h\"\r\n#include \"avdevice.h\"\r\n#include \"config.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint veszelyite_treebeard = 0;\r\nint global_variable;\r\nvoid handle_taint(char *maimon_cooky);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid *netkeeper_danish(void *jacobina_haemamoeba);\r\nvoid stichoi_afforce(void *unstaid_disseising);\r\nstruct struct {\r\n char before[64];\r\n char buffer[64];\r\n char after[64];\r\n};\r\n\r\nunsigned int avdevice_version()\r\n{;\r\n if (__sync_bool_compare_and_swap(&veszelyite_treebeard,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n do {\r\n if (!(103 >= 100)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\r\n abort();\r\n }\r\n }while (0);\r\n return ('6' << 16 | 3 << 8 | 103);\r\n}\r\n\r\nconst char *avdevice_configuration()\r\n{\r\n return \"--prefix=/opt//workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\r\n}\r\n\r\nconst char *avdevice_license()\r\n{\r\n#define LICENSE_PREFIX \"libavdevice license: \"\r\n return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\r\n}\r\n\r\nvoid handle_taint(char *maimon_cooky)\r\n{\r\n void (*oxyhydric_angelizing)(void *) = stichoi_afforce;\r\n void *providentness_lesli = 0;\r\n void *cilicia_unspaded = 0;\r\n ++global_variable;;\r\n if (maimon_cooky != 0) {;\r\n cilicia_unspaded = ((void *)maimon_cooky);\r\n providentness_lesli = netkeeper_danish(cilicia_unspaded);\r\n oxyhydric_angelizing(providentness_lesli);\r\n }\r\n}\r\n\r\nvoid *netkeeper_danish(void *jacobina_haemamoeba)\r\n{\r\n ++global_variable;\r\n return jacobina_haemamoeba;\r\n}\r\n\r\nvoid stichoi_afforce(void *unstaid_disseising)\r\n{\r\n int i = 0;\r\n int buff_size = 0;\r\n struct struct data;\r\n char *hensler_diabetic = 0;\r\n ++global_variable;;\r\n hensler_diabetic = ((char *)((char *)unstaid_disseising));\r\n \r\n for (i = 0; i < 63; i++) {\r\n data.before[i] = 'A';\r\n }\r\n data.before[63] = '\\0';\r\n for (i = 0; i < 63; i++) {\r\n data.buffer[i] = 'Q';\r\n }\r\n data.buffer[63] = '\\0';\r\n for (i = 0; i < 63; i++) {\r\n data.after[i] = 'A';\r\n }\r\n data.after[63] = '\\0';\r\n \r\n \r\n \r\n \r\n \r\n buff_size = ((int )(strlen(hensler_diabetic)));\r\n memcpy(data.buffer, hensler_diabetic, 64);\r\n for (; i < buff_size; ++i){\r\n \r\n \r\n printf(\"%x\",data.buffer[i]);\r\n }\r\n \r\n \r\n \r\n printf(\"\\n\");\r\n \r\n \r\n;\r\n if (((char *)unstaid_disseising) != 0) \r\n free(((char *)((char *)unstaid_disseising)));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|A.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-197:Numeric Truncation Error\nB.CWE-291:Reliance on IP Address for Authentication\nC.CWE-681:Incorrect Conversion between Numeric Types\nD.CWE-252:Unchecked Return Value\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_int_rand_to_char_82\r\n{\r\n\r\nclass My_int_rand_to_char_82_base\r\n{\r\npublic:\r\n \r\n virtual void action(int data) = 0;\r\n};\r\n\r\n#ifndef OMITM\r\n\r\nclass My_int_rand_to_char_82 : public My_int_rand_to_char_82_base\r\n{\r\npublic:\r\n void action(int data);\r\n};\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\nclass My_int_rand_to_char_82G2B : public My_int_rand_to_char_82_base\r\n{\r\npublic:\r\n void action(int data);\r\n};\r\n\r\n#endif \r\n\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-197:Numeric Truncation Error|C.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "197"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.CWE-922:Insecure Storage of Sensitive Information\nC.CWE-391:Unchecked Error Condition\nD.No Vulnerabilities\nE.CWE-1251:Mirrored Regions with Different Values\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <errno.h>\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wcstombs_06()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n {\r\n size_t bytesTranslated = 0;\r\n char charString[100];\r\n charString[0] = '\\0';\r\n errno = 0; \r\n bytesTranslated = wcstombs((char *)&charString, L\"\\xffff\", 100);\r\n \r\n if (errno == EILSEQ)\r\n {\r\n printLine(\"wcstombs() failed\");\r\n exit(1);\r\n }\r\n printUnsignedLine(bytesTranslated);\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wcstombs_06()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wcstombs_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wcstombs_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-391:Unchecked Error Condition|A.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "391"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-544:Missing Standardized Error Handling Mechanism\nB.CWE-328:Use of Weak Hash\nC.CWE-14:Compiler Removal of Code to Clear Buffers\nD.CWE-326:Inadequate Encryption Strength\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define PASSWORD_INPUT_SIZE 128\r\n#define SHA512_SUM_SIZE (512 / 8)\r\n\r\n#define MD2_SUM_SIZE (128 / 8)\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_MD2_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[MD2_SUM_SIZE], calcHash[MD2_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < MD2_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n if (pFile)\r\n {\r\n fclose(pFile);\r\n }\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_MD2, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = MD2_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, MD2_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTHASH hHash;\r\n FILE *pFile = NULL;\r\n char password[PASSWORD_INPUT_SIZE];\r\n UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\r\n DWORD hashSize;\r\n char *replace;\r\n size_t i;\r\n pFile = fopen(\"password.txt\", \"r\");\r\n if (pFile == NULL)\r\n {\r\n exit(1);\r\n }\r\n for (i = 0; i < SHA512_SUM_SIZE; i++)\r\n {\r\n ULONG val;\r\n if (fscanf(pFile, \"%02x\", &val) != 1)\r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n if (val > 0xff) \r\n {\r\n fclose(pFile);\r\n exit(1);\r\n }\r\n savedHash[i] = (UCHAR)val;\r\n }\r\n fclose(pFile);\r\n if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\r\n {\r\n exit(1);\r\n }\r\n replace = strchr(password, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(password, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n \r\n if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n hashSize = SHA512_SUM_SIZE;\r\n if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\r\n {\r\n CryptDestroyHash(hHash);\r\n CryptReleaseContext(hCryptProv, 0);\r\n exit(1);\r\n }\r\n if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\r\n {\r\n printLine(\"Access granted\");\r\n }\r\n else\r\n {\r\n printLine(\"Access denied\");\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_MD2_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_MD2_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_MD2_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-328:Use of Weak Hash|D.CWE-326:Inadequate Encryption Strength", "cwe": "328"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-299:Improper Check for Certificate Revocation\nB.CWE-248:Uncaught Exception\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-401:Missing Release of Memory after Effective Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_calloc_18()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n goto source;\r\nsource:\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n goto sink;\r\nsink:\r\n \r\n ; \r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n goto source;\r\nsource:\r\n \r\n data = (wchar_t *)calloc(100, sizeof(wchar_t));\r\n if (data == NULL) {exit(-1);}\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n goto sink;\r\nsink:\r\n \r\n free(data);\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n data = NULL;\r\n goto source;\r\nsource:\r\n \r\n data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\r\n \r\n wcscpy(data, L\"A String\");\r\n printWLine(data);\r\n goto sink;\r\nsink:\r\n \r\n ; \r\n}\r\n\r\nvoid My_wchar_t_calloc_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_calloc_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_calloc_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-401:Missing Release of Memory after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-55:Path Equivalence: '/./' (Single Dot Directory)\nB.CWE-273:Improper Check for Dropped Privileges\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.CWE-572:Call to Thread run() instead of start()\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n#define BUFSIZE 1024\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n ImpersonateNamedPipeClient(hPipe);\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n HANDLE hPipe = INVALID_HANDLE_VALUE;\r\n hPipe = CreateNamedPipeA(\r\n \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\r\n PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\r\n PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\r\n PIPE_UNLIMITED_INSTANCES,\r\n BUFSIZE,\r\n BUFSIZE,\r\n NMPWAIT_USE_DEFAULT_WAIT,\r\n NULL);\r\n if (hPipe == INVALID_HANDLE_VALUE)\r\n {\r\n exit(1);\r\n }\r\n \r\n if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\r\n {\r\n CloseHandle(hPipe);\r\n exit(1);\r\n }\r\n \r\n if (!ImpersonateNamedPipeClient(hPipe))\r\n {\r\n printLine(\"Failed to impersonate\");\r\n }\r\n else\r\n {\r\n printLine(\"Impersonated\");\r\n if (!RevertToSelf())\r\n {\r\n exit(1);\r\n }\r\n }\r\n CloseHandle(hPipe);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_ImpersonateNamedPipeClient_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_ImpersonateNamedPipeClient_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_ImpersonateNamedPipeClient_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-273:Improper Check for Dropped Privileges|C.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "273"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-681:Incorrect Conversion between Numeric Types\nB.CWE-194:Unexpected Sign Extension\nC.CWE-238:Improper Handling of Incomplete Structural Elements\nD.CWE-232:Improper Handling of Undefined Values\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n\r\n#define CHAR_ARRAY_SIZE 8\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_memmove_51bSink(short data);\r\n\r\nvoid My_connect_socket_memmove_51()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n int tempInt;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n tempInt = atoi(inputBuffer);\r\n if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\r\n {\r\n data = -1;\r\n }\r\n else\r\n {\r\n data = tempInt;\r\n }\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_memmove_51bSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_memmove_51bG2BSink(short data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n short data;\r\n \r\n data = 0;\r\n \r\n data = 100-1;\r\n My_connect_socket_memmove_51bG2BSink(data);\r\n}\r\n\r\nvoid My_connect_socket_memmove_51()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_memmove_51();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_memmove_51();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-194:Unexpected Sign Extension|A.CWE-681:Incorrect Conversion between Numeric Types", "cwe": "194"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1302:Missing Security Identifier\nB.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nC.CWE-665:Improper Initialization\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_cat_08()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n ; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data[0] = '\\0'; \r\n }\r\n {\r\n char source[100];\r\n memset(source, 'C', 100-1); \r\n source[100-1] = '\\0'; \r\n \r\n strcat(data, source);\r\n printLine(data);\r\n }\r\n}\r\n\r\nvoid My_char_cat_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_cat_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_cat_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-665:Improper Initialization|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1302:Missing Security Identifier\nC.CWE-313:Cleartext Storage in a File or on Disk\nD.CWE-475:Undefined Behavior for Input to API\nE.CWE-573:Improper Following of Specification by Caller\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-475:Undefined Behavior for Input to API|E.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-262:Not Using Password Aging\nC.CWE-124:Buffer Underwrite ('Buffer Underflow')\nD.CWE-1098:Data Element containing Pointer Item without Proper Copy Control Element\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_My_My_My_My_My_My_My_My_My_CWE839_negative_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-124:Buffer Underwrite ('Buffer Underflow')|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "124"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-832:Unlock of a Resource that is not Locked\nB.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nC.No Vulnerabilities\nD.CWE-667:Improper Locking\nE.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include \"std_thread.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock mLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&mLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(mLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(mLock);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n static stdThreadLock nLock = NULL;\r\n printLine(\"Creating lock...\");\r\n if (!stdThreadLockCreate(&nLock))\r\n {\r\n printLine(\"Could not create lock\");\r\n exit(1);\r\n }\r\n \r\n printLine(\"Acquiring lock...\");\r\n stdThreadLockAcquire(nLock);\r\n printLine(\"Releasing lock...\");\r\n stdThreadLockRelease(nLock);\r\n printLine(\"Destroying lock...\");\r\n stdThreadLockDestroy(nLock);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-832:Unlock of a Resource that is not Locked|D.CWE-667:Improper Locking", "cwe": "832"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-73:External Control of File Name or Path\nB.CWE-507:Trojan Horse\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.CWE-798:Use of Hard-coded Credentials\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY L\"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_31()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n \r\n wcscpy(cryptoKey, CRYPTO_KEY);\r\n {\r\n wchar_t * cryptoKeyCopy = cryptoKey;\r\n wchar_t * cryptoKey = cryptoKeyCopy;\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * cryptoKey;\r\n wchar_t cryptoKeyBuffer[100] = L\"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n {\r\n size_t cryptoKeyLen = wcslen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = L'\\0';\r\n }\r\n \r\n cryptoKeyLen = wcslen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = L'\\0';\r\n }\r\n }\r\n }\r\n {\r\n wchar_t * cryptoKeyCopy = cryptoKey;\r\n wchar_t * cryptoKey = cryptoKeyCopy;\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n wchar_t toBeEncrypted[] = L\"String to be encrypted\";\r\n DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, wcslen(cryptoKey)*sizeof(wchar_t), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_31()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_31();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_31();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|D.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-234:Failure to Handle Missing Parameter\nB.CWE-401:Missing Release of Memory after Effective Lifetime\nC.CWE-404:Improper Resource Shutdown or Release\nD.No Vulnerabilities\nE.CWE-236:Improper Handling of Undefined Parameters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#include <wchar.h>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_struct_twoIntsStruct_malloc_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, struct _twoIntsStruct *> dataMap);\r\n\r\nvoid m()\r\n{\r\n struct _twoIntsStruct * data;\r\n map<int, struct _twoIntsStruct *> dataMap;\r\n data = NULL;\r\n \r\n data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine((twoIntsStruct *)&data[0]);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, struct _twoIntsStruct *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n struct _twoIntsStruct * data;\r\n map<int, struct _twoIntsStruct *> dataMap;\r\n data = NULL;\r\n \r\n data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine((twoIntsStruct *)&data[0]);\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, struct _twoIntsStruct *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n struct _twoIntsStruct * data;\r\n map<int, struct _twoIntsStruct *> dataMap;\r\n data = NULL;\r\n \r\n data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));\r\n \r\n data[0].intOne = 0;\r\n data[0].intTwo = 0;\r\n printStructLine((twoIntsStruct *)&data[0]);\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_struct_twoIntsStruct_malloc_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-401:Missing Release of Memory after Effective Lifetime|C.CWE-404:Improper Resource Shutdown or Release", "cwe": "401"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-691:Insufficient Control Flow Management\nB.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nC.CWE-23:Relative Path Traversal\nD.No Vulnerabilities\nE.CWE-447:Unimplemented or Unsupported Feature in UI\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#define BASEPATH \"c:\\\\temp\\\\\"\r\n#else\r\n#include <wchar.h>\r\n#define BASEPATH \"/tmp/\"\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\r\n#else\r\n#define FILENAME \"/tmp/file.txt\"\r\n#endif\r\n\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nnamespace My_char_file_ofstream_61\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nchar * mSource(char * data);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n data = mSource(data);\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nchar * nG2BSource(char * data);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char dataBuffer[FILENAME_MAX] = BASEPATH;\r\n data = dataBuffer;\r\n data = nG2BSource(data);\r\n {\r\n ofstream outputFile;\r\n \r\n outputFile.open((char *)data);\r\n outputFile.close();\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_file_ofstream_61; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-23:Relative Path Traversal|B.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "23"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-792:Incomplete Filtering of One or More Instances of Special Elements\nB.No Vulnerabilities\nC.CWE-1079:Parent Class without Virtual Destructor Method\nD.CWE-754:Improper Check for Unusual or Exceptional Conditions\nE.CWE-252:Unchecked Return Value\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_char_fscanf_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n fscanf(stdin, \"%99s\\0\", data);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fscanf(stdin, \"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"fscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fscanf(stdin, \"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"fscanf failed!\");\r\n }\r\n }\r\n }\r\n else\r\n {\r\n {\r\n \r\n char dataBuffer[100] = \"\";\r\n char * data = dataBuffer;\r\n \r\n if (fscanf(stdin, \"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"fscanf failed!\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_char_fscanf_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_fscanf_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_fscanf_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-252:Unchecked Return Value|D.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "252"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-754:Improper Check for Unusual or Exceptional Conditions\nC.CWE-160:Improper Neutralization of Leading Special Elements\nD.CWE-253:Incorrect Check of Function Return Value\nE.CWE-499:Serializable Class Containing Sensitive Data\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define SRC_STRING L\"string\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_sscanf_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n \r\n if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\r\n {\r\n printLine(\"swscanf failed!\");\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_wchar_t_sscanf_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_sscanf_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_sscanf_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-253:Incorrect Check of Function Return Value|B.CWE-754:Improper Check for Unusual or Exceptional Conditions", "cwe": "253"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-36:Absolute Path Traversal\nB.No Vulnerabilities\nC.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\nD.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nE.CWE-768:Incorrect Short Circuit Evaluation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#else\r\n#include <unistd.h>\r\n#define OPEN open\r\n#define CLOSE close\r\n#endif\r\n\r\nnamespace My_wchar_t_environment_open_53\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink_b(wchar_t * data);\r\n\r\nvoid m()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\r\n }\r\n }\r\n mSink_b(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink_b(wchar_t * data);\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[FILENAME_MAX] = L\"\";\r\n data = dataBuffer;\r\n#ifdef _WIN32\r\n \r\n wcscat(data, L\"c:\\\\temp\\\\file.txt\");\r\n#else\r\n \r\n wcscat(data, L\"/tmp/file.txt\");\r\n#endif\r\n nG2BSink_b(data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_wchar_t_environment_open_53; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-36:Absolute Path Traversal|D.CWE-22:Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "cwe": "36"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-484:Omitted Break Statement in Switch\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-471:Modification of Assumed-Immutable Data (MAID)\nE.CWE-300:Channel Accessible by Non-Endpoint\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n int x = (rand() % 3);\r\n \r\n switch (x)\r\n {\r\n case 0:\r\n printLine(\"0\");\r\n break;\r\n case 1:\r\n printLine(\"1\");\r\n break;\r\n case 2:\r\n printLine(\"2\");\r\n break;\r\n default:\r\n printLine(\"Invalid Number\");\r\n break;\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-484:Omitted Break Statement in Switch|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "484"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-704:Incorrect Type Conversion or Cast\nB.CWE-383:J2EE Bad Practices: Direct Use of Threads\nC.CWE-153:Improper Neutralization of Substitution Characters\nD.No Vulnerabilities\nE.CWE-681:Incorrect Conversion between Numeric Types\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CHAR_ARRAY_SIZE 256\r\n\r\n\r\nstatic const int STATIC_CONST_TRUE = 1; \r\nstatic const int STATIC_CONST_FALSE = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_double2int_04()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(STATIC_CONST_FALSE)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(STATIC_CONST_TRUE)\r\n {\r\n {\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n double doubleNumber = 0;\r\n \r\n if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\r\n {\r\n \r\n doubleNumber = atof(inputBuffer);\r\n }\r\n else\r\n {\r\n printLine(\"fgets() failed.\");\r\n }\r\n \r\n if (doubleNumber > INT_MAX || doubleNumber < INT_MIN)\r\n {\r\n printLine(\"Value is too small or large to be represented as an int\");\r\n }\r\n else\r\n {\r\n printIntLine((int)doubleNumber);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_double2int_04()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_double2int_04();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_double2int_04();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-681:Incorrect Conversion between Numeric Types|A.CWE-704:Incorrect Type Conversion or Cast", "cwe": "681"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1247:Improper Protection Against Voltage and Clock Glitches\nC.CWE-284:Improper Access Control\nD.CWE-502:Deserialization of Untrusted Data\nE.CWE-770:Allocation of Resources Without Limits or Throttling\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"advapi32\" )\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_RegCreateKeyEx_16()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_ALL_ACCESS,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n while(1)\r\n {\r\n {\r\n wchar_t * keyName = L\"TEST\\\\TestKey\";\r\n HKEY hKey;\r\n \r\n if (RegCreateKeyExW(\r\n HKEY_CURRENT_USER,\r\n keyName,\r\n 0,\r\n NULL,\r\n REG_OPTION_NON_VOLATILE,\r\n KEY_WRITE,\r\n NULL,\r\n &hKey,\r\n NULL) != ERROR_SUCCESS)\r\n {\r\n printLine(\"Registry key could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Registry key created successfully\");\r\n RegCloseKey(hKey);\r\n }\r\n }\r\n break;\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_RegCreateKeyEx_16()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_RegCreateKeyEx_16();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_RegCreateKeyEx_16();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-284:Improper Access Control|B.CWE-1247:Improper Protection Against Voltage and Clock Glitches", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-481:Assigning instead of Comparing\nB.CWE-804:Guessable CAPTCHA\nC.CWE-1268:Policy Privileges are not Assigned Consistently Between Control and Data Agents\nD.No Vulnerabilities\nE.CWE-480:Use of Incorrect Operator\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand = 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n int intRand = rand();\r\n \r\n if(intRand == 5)\r\n {\r\n printLine(\"i was 5\");\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-481:Assigning instead of Comparing|E.CWE-480:Use of Incorrect Operator", "cwe": "481"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-652:Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')\nC.CWE-475:Undefined Behavior for Input to API\nD.No Vulnerabilities\nE.CWE-638:Not Using Complete Mediation\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memcpy(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n {\r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");\r\n \r\n memmove(data + 6, data + 4, 10*sizeof(wchar_t));\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-475:Undefined Behavior for Input to API|A.CWE-573:Improper Following of Specification by Caller", "cwe": "475"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nC.CWE-177:Improper Handling of URL Encoding (Hex Encoding)\nD.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nE.CWE-620:Unverified Password Change\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_wchar_t_free_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n wchar_t * password = (wchar_t *)malloc(100*sizeof(wchar_t));\r\n if (password == NULL) {exit(-1);}\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n password[0] = L'\\0';\r\n if (fgetws(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgetws() failed\");\r\n \r\n password[0] = L'\\0';\r\n }\r\n \r\n passwordLen = wcslen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = L'\\0';\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = wcslen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(wchar_t));\r\n free(password);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_wchar_t_free_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_wchar_t_free_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_wchar_t_free_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')|B.CWE-226:Sensitive Information in Resource Not Removed Before Reuse", "cwe": "244"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-798:Use of Hard-coded Credentials\nB.CWE-173:Improper Handling of Alternate Encoding\nC.CWE-321:Use of Hard-coded Cryptographic Key\nD.No Vulnerabilities\nE.CWE-124:Buffer Underwrite ('Buffer Underflow')\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#define CRYPTO_KEY \"Hardcoded\"\r\n\r\n#include <windows.h>\r\n#include <wincrypt.h>\r\n\r\n\r\n#pragma comment (lib, \"Advapi32\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_11()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n \r\n strcpy(cryptoKey, CRYPTO_KEY);\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * cryptoKey;\r\n char cryptoKeyBuffer[100] = \"\";\r\n cryptoKey = cryptoKeyBuffer;\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n size_t cryptoKeyLen = strlen(cryptoKey);\r\n \r\n if(100-cryptoKeyLen > 1)\r\n {\r\n \r\n if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n cryptoKey[cryptoKeyLen] = '\\0';\r\n }\r\n \r\n cryptoKeyLen = strlen(cryptoKey);\r\n if (cryptoKeyLen > 0)\r\n {\r\n cryptoKey[cryptoKeyLen-1] = '\\0';\r\n }\r\n }\r\n }\r\n }\r\n {\r\n HCRYPTPROV hCryptProv;\r\n HCRYPTKEY hKey;\r\n HCRYPTHASH hHash;\r\n char toBeEncrypted[] = \"String to be encrypted\";\r\n DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\r\n BYTE encrypted[200]; \r\n \r\n memcpy(encrypted, toBeEncrypted, encryptedLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\r\n {\r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\r\n {\r\n printLine(\"Error in acquiring cryptographic context\");\r\n exit(1);\r\n }\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n printLine(\"Error in creating hash\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\r\n {\r\n printLine(\"Error in hashing cryptoKey\");\r\n exit(1);\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n printLine(\"Error in CryptDeriveKey\");\r\n exit(1);\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\r\n {\r\n printLine(\"Error in CryptEncrypt\");\r\n exit(1);\r\n }\r\n \r\n printBytesLine(encrypted, encryptedLen);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_11()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-321:Use of Hard-coded Cryptographic Key|A.CWE-798:Use of Hard-coded Credentials", "cwe": "321"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-1103:Use of Platform-Dependent Third Party Components\nC.CWE-127:Buffer Under-read\nD.CWE-1113:Inappropriate Comment Style\nE.CWE-786:Access of Memory Location Before Start of Buffer\n", "input": "\r\n#include <string.h>\r\n#include \"libavutil/avassert.h\"\r\n#include \"libavutil/mem.h\"\r\n#include \"avcodec.h\"\r\n#include \"bytestream.h\"\r\n#include \"internal.h\"\r\n#include <mongoose.h> \r\n#include </trace.h> \r\n#include <sys/stat.h> \r\nint concents_billen = 0;\r\nint global_variable;\r\nvoid handle_taint(char *menaccanite_prememorandum);\r\nvoid* printf_context;\r\nvoid setup_printf_context() {\r\n}\r\nvoid printf(char * format, ...) {\r\n va_list argptr;\r\n \r\n va_start(argptr, format);\r\n mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\r\n va_end(argptr);\r\n}\r\nvoid close_printf_context() {\r\n}\r\nstatic int exit_flag = 0;\r\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\r\n char * ifmatch_header;\r\n char* tainted_buff;\r\n int buffer_size = 1000;\r\n int data_size = 0;\r\n if (ev == MG_REQUEST) {\r\n ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\r\n if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\r\n while (1) {\r\n tainted_buff = (char*) malloc(buffer_size * sizeof(char));\r\n \r\n data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\r\n if (data_size < buffer_size) {\r\n exit_flag = 1;\r\n break;\r\n }\r\n buffer_size = buffer_size * 2;\r\n free(tainted_buff);\r\n }\r\n printf_context = conn;\r\n handle_taint(tainted_buff);\r\n \r\n }\r\n return MG_TRUE;\r\n } else if (ev == MG_AUTH) {\r\n return MG_TRUE;\r\n } else {\r\n return MG_FALSE;\r\n }\r\n}\r\nvoid read_taint(void) {\r\n if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\r\n strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\r\n struct mg_server *server = mg_create_server(NULL, ev_handler);\r\n mg_set_option(server, \"listening_port\", \"8887\");\r\n while (1) {\r\n if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\r\n break;\r\n }\r\n }\r\n mg_destroy_server(&server);\r\n }\r\n}\r\nvoid molehead_mesoprescutal(int conli_deerstalker,void **etymonic_jarra);\r\n\r\nvoid ff_packet_free_side_data(AVPacket *pkt)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nvoid av_destruct_packet(AVPacket *pkt)\r\n{\r\n av_free((pkt -> data));\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n}\r\n\r\nvoid av_init_packet(AVPacket *pkt)\r\n{\r\n pkt -> pts = ((int64_t )0x8000000000000000UL);\r\n pkt -> dts = ((int64_t )0x8000000000000000UL);\r\n pkt -> pos = (- 1);\r\n pkt -> duration = 0;\r\n pkt -> convergence_duration = 0;\r\n pkt -> flags = 0;\r\n pkt -> stream_index = 0;\r\n pkt -> destruct = ((void *)0);\r\n pkt -> side_data = ((void *)0);\r\n pkt -> side_data_elems = 0;\r\n}\r\n\r\nint av_new_packet(AVPacket *pkt,int size)\r\n{\r\n uint8_t *data = ((void *)0);\r\n if (((unsigned int )size) < ((unsigned int )size) + 16) {\r\n data = (av_malloc((size + 16)));\r\n }\r\n if (data) {\r\n memset((data + size),0,16);\r\n }\r\n else {\r\n size = 0;\r\n }\r\n av_init_packet(pkt);\r\n pkt -> data = data;\r\n pkt -> size = size;\r\n pkt -> destruct = av_destruct_packet;\r\n if (!data) {\r\n return - 12;\r\n }\r\n return 0;\r\n}\r\n\r\nvoid av_shrink_packet(AVPacket *pkt,int size)\r\n{\r\n if (pkt -> size <= size) {\r\n return ;\r\n }\r\n pkt -> size = size;\r\n memset((pkt -> data + size),0,16);\r\n}\r\n\r\nint av_grow_packet(AVPacket *pkt,int grow_by)\r\n{\r\n void *new_ptr;\r\n do {\r\n if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\r\n abort();\r\n }\r\n }while (0);\r\n if (!pkt -> size) {\r\n return av_new_packet(pkt,grow_by);\r\n }\r\n if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\r\n return - 1;\r\n }\r\n new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\r\n if (!new_ptr) {\r\n return - 12;\r\n }\r\n pkt -> data = new_ptr;\r\n pkt -> size += grow_by;\r\n memset((pkt -> data + pkt -> size),0,16);\r\n return 0;\r\n}\r\n#define DUP_DATA(dst, src, size, padding) \\\r\n do { \\\r\n void *data; \\\r\n if (padding) { \\\r\n if ((unsigned)(size) > \\\r\n (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE) \\\r\n goto failed_alloc; \\\r\n data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n } else { \\\r\n data = av_malloc(size); \\\r\n } \\\r\n if (!data) \\\r\n goto failed_alloc; \\\r\n memcpy(data, src, size); \\\r\n if (padding) \\\r\n memset((uint8_t *)data + size, 0, \\\r\n FF_INPUT_BUFFER_PADDING_SIZE); \\\r\n dst = data; \\\r\n } while (0)\r\n\r\n\r\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\r\n{\r\n dst -> data = ((void *)0);\r\n dst -> side_data = ((void *)0);\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> size + 16));\r\n }\r\n else {\r\n data = av_malloc((dst -> size));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> data),(dst -> size));\r\n if (1) {\r\n memset((((uint8_t *)data) + dst -> size),0,16);\r\n }\r\n dst -> data = data;\r\n }while (0);\r\n dst -> destruct = av_destruct_packet;\r\n if (dst -> side_data_elems) {\r\n int i;\r\n do {\r\n void *data;\r\n if (0) {\r\n if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\r\n }\r\n else {\r\n data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n if (0) {\r\n memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\r\n }\r\n dst -> side_data = data;\r\n }while (0);\r\n memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\r\n for (i = 0; i < dst -> side_data_elems; i++) {\r\n do {\r\n void *data;\r\n if (1) {\r\n if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\r\n goto failed_alloc;\r\n }\r\n data = av_malloc((src -> side_data[i] . size + 16));\r\n }\r\n else {\r\n data = av_malloc(src -> side_data[i] . size);\r\n }\r\n if (!data) {\r\n goto failed_alloc;\r\n }\r\n memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\r\n if (1) {\r\n memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\r\n }\r\n dst -> side_data[i] . data = data;\r\n }while (0);\r\n dst -> side_data[i] . size = src -> side_data[i] . size;\r\n dst -> side_data[i] . type = src -> side_data[i] . type;\r\n }\r\n }\r\n return 0;\r\n failed_alloc:\r\n av_destruct_packet(dst);\r\n return - 12;\r\n}\r\n\r\nint av_dup_packet(AVPacket *pkt)\r\n{\r\n AVPacket tmp_pkt;\r\n if (pkt -> destruct == ((void *)0) && pkt -> data) {\r\n tmp_pkt = *pkt;\r\n return copy_packet_data(pkt,&tmp_pkt);\r\n }\r\n return 0;\r\n}\r\n\r\nint av_copy_packet(AVPacket *dst,AVPacket *src)\r\n{\r\n *dst = *src;\r\n return copy_packet_data(dst,src);\r\n}\r\n\r\nvoid av_free_packet(AVPacket *pkt)\r\n{\r\n if (pkt) {\r\n int i;\r\n if (pkt -> destruct) {\r\n (pkt -> destruct)(pkt);\r\n }\r\n pkt -> data = ((void *)0);\r\n pkt -> size = 0;\r\n for (i = 0; i < pkt -> side_data_elems; i++) \r\n av_free(pkt -> side_data[i] . data);\r\n av_freep((&pkt -> side_data));\r\n pkt -> side_data_elems = 0;\r\n }\r\n}\r\n\r\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int elems = pkt -> side_data_elems;\r\n if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\r\n return ((void *)0);\r\n }\r\n if (((unsigned int )size) > (2147483647 - 16)) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . data = (av_malloc((size + 16)));\r\n if (!pkt -> side_data[elems] . data) {\r\n return ((void *)0);\r\n }\r\n pkt -> side_data[elems] . size = size;\r\n pkt -> side_data[elems] . type = type;\r\n pkt -> side_data_elems++;\r\n return pkt -> side_data[elems] . data;\r\n}\r\n\r\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size) {\r\n *size = pkt -> side_data[i] . size;\r\n }\r\n return pkt -> side_data[i] . data;\r\n }\r\n }\r\n return ((void *)0);\r\n}\r\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\r\n\r\nint av_packet_merge_side_data(AVPacket *pkt)\r\n{\r\n if (pkt -> side_data_elems) {\r\n int i;\r\n uint8_t *p;\r\n uint64_t size = ((pkt -> size) + 8LL + 16);\r\n AVPacket old = *pkt;\r\n for (i = 0; i < old . side_data_elems; i++) {\r\n size += (old . side_data[i] . size + 5);\r\n }\r\n if (size > 2147483647) {\r\n return - 22;\r\n }\r\n p = (av_malloc(size));\r\n if (!p) {\r\n return - 12;\r\n }\r\n pkt -> data = p;\r\n pkt -> destruct = av_destruct_packet;\r\n pkt -> size = (size - 16);\r\n bytestream_put_buffer(&p,old . data,old . size);\r\n for (i = old . side_data_elems - 1; i >= 0; i--) {\r\n bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\r\n bytestream_put_be32(&p,old . side_data[i] . size);\r\n *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\r\n }\r\n bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\r\n do {\r\n if (!(p - pkt -> data == (pkt -> size))) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\r\n abort();\r\n }\r\n }while (0);\r\n memset(p,0,16);\r\n av_free_packet(&old);\r\n pkt -> side_data_elems = 0;\r\n pkt -> side_data = ((void *)0);\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_split_side_data(AVPacket *pkt)\r\n{;\r\n if (__sync_bool_compare_and_swap(&concents_billen,0,1)) {;\r\n if (mkdir(\"/opt//workspace/lockDir\",509U) == 0) {;\r\n \r\n read_taint();\r\n }\r\n }\r\n ;\r\n if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\r\n int i;\r\n unsigned int size;\r\n uint8_t *p;\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 1; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n if (size > 2147483647 || p - pkt -> data < size) {\r\n return 0;\r\n }\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\r\n if (!pkt -> side_data) {\r\n return - 12;\r\n }\r\n p = pkt -> data + pkt -> size - 8 - 5;\r\n for (i = 0; ; i++) {\r\n size = av_bswap32(((const union unaligned_32 *)p) -> l);\r\n do {\r\n if (!(size <= 2147483647 && p - pkt -> data >= size)) {\r\n av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\r\n abort();\r\n }\r\n }while (0);\r\n pkt -> side_data[i] . data = (av_malloc((size + 16)));\r\n pkt -> side_data[i] . size = size;\r\n pkt -> side_data[i] . type = (p[4] & 127);\r\n if (!pkt -> side_data[i] . data) {\r\n return - 12;\r\n }\r\n memcpy(pkt -> side_data[i] . data,(p - size),size);\r\n pkt -> size -= size + 5;\r\n if (p[4] & 128) {\r\n break; \r\n }\r\n p -= size + 5;\r\n }\r\n pkt -> size -= 8;\r\n pkt -> side_data_elems = i + 1;\r\n return 1;\r\n }\r\n return 0;\r\n}\r\n\r\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\r\n{\r\n int i;\r\n for (i = 0; i < pkt -> side_data_elems; i++) {\r\n if (pkt -> side_data[i] . type == type) {\r\n if (size > pkt -> side_data[i] . size) {\r\n return - 12;\r\n }\r\n pkt -> side_data[i] . size = size;\r\n return 0;\r\n }\r\n }\r\n return - 2;\r\n}\r\n\r\nvoid handle_taint(char *menaccanite_prememorandum)\r\n{\r\n int sabin_loudish = 7;\r\n void **aeipathy_cassy = 0;\r\n void *chindee_precovering = 0;\r\n ++global_variable;;\r\n if (menaccanite_prememorandum != 0) {;\r\n chindee_precovering = ((void *)menaccanite_prememorandum);\r\n aeipathy_cassy = &chindee_precovering;\r\n molehead_mesoprescutal(sabin_loudish,aeipathy_cassy);\r\n }\r\n}\r\n\r\nvoid molehead_mesoprescutal(int conli_deerstalker,void **etymonic_jarra)\r\n{\r\n signed char *input_string = 0;\r\n int stack_buff[128];\r\n int other_buff[200];\r\n int ss_i = 0;\r\n char *toolings_creg = 0;\r\n ++global_variable;\r\n conli_deerstalker--;\r\n if (conli_deerstalker > 0) {\r\n molehead_mesoprescutal(conli_deerstalker,etymonic_jarra);\r\n return ;\r\n }\r\n toolings_creg = ((char *)((char *)( *etymonic_jarra)));\r\n \r\n input_string = (signed char *) getenv(\"INPUT_STRING\");\r\n \r\n \r\n \r\n if (input_string != 0) {\r\n memset(stack_buff,0,sizeof(stack_buff));\r\n for (ss_i = 0; ss_i < 200; ++ss_i) {\r\n other_buff[ss_i] = 5555;\r\n }\r\n for (ss_i = 0; ss_i < strlen((char *)input_string); ++ss_i) {\r\n if (input_string[ss_i] < 0)\r\n continue;\r\n ++stack_buff[input_string[ss_i]];\r\n }\r\n \r\n \r\n for (ss_i = 0; ss_i < strlen(toolings_creg); ++ss_i) {\r\n \r\n \r\n \r\n printf(\"value %c appears: %d times\\n\",\r\n toolings_creg[ss_i],\r\n stack_buff[(int) toolings_creg[ss_i]]);\r\n }\r\n \r\n \r\n }\r\n \r\n;\r\n if (((char *)( *etymonic_jarra)) != 0) \r\n free(((char *)((char *)( *etymonic_jarra))));\r\nclose_printf_context();\r\n}\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-127:Buffer Under-read|E.CWE-786:Access of Memory Location Before Start of Buffer", "cwe": "127"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-291:Reliance on IP Address for Authentication\nB.No Vulnerabilities\nC.CWE-262:Not Using Password Aging\nD.CWE-126:Buffer Over-read\nE.CWE-788:Access of Memory Location After End of Buffer\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\nnamespace My_new_char_loop_08\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = new char[50];\r\n memset(data, 'A', 50-1); \r\n data[50-1] = '\\0'; \r\n }\r\n {\r\n size_t i, destLen;\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n destLen = strlen(dest);\r\n \r\n for (i = 0; i < destLen; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n data = new char[100];\r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n }\r\n {\r\n size_t i, destLen;\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n destLen = strlen(dest);\r\n \r\n for (i = 0; i < destLen; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * data;\r\n data = NULL;\r\n if(staticReturnsTrue())\r\n {\r\n \r\n data = new char[100];\r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n }\r\n {\r\n size_t i, destLen;\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n destLen = strlen(dest);\r\n \r\n for (i = 0; i < destLen; i++)\r\n {\r\n dest[i] = data[i];\r\n }\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_loop_08; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-126:Buffer Over-read|E.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-573:Improper Following of Specification by Caller\nB.CWE-28:Path Traversal: '..\\filedir'\nC.CWE-703:Improper Check or Handling of Exceptional Conditions\nD.CWE-325:Missing Cryptographic Step\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptHashData_12()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsTrueOrFalse())\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptHashData_12()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptHashData_12();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptHashData_12();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-325:Missing Cryptographic Step|A.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-773:Missing Reference to Active File Descriptor or Handle\nB.No Vulnerabilities\nC.CWE-771:Missing Reference to Active Allocated Resource\nD.CWE-285:Improper Authorization\nE.CWE-154:Improper Neutralization of Variable Name Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\nnamespace My_fopen_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(FILE * &data);\r\n\r\nvoid m()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n mSource(data);\r\n \r\n data = fopen(\"MSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nB2GSource(FILE * &data);\r\n\r\nstatic void nB2G()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n nB2GSource(data);\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n data = fopen(\"NSink_fopen.txt\", \"w+\");\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_fopen_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-773:Missing Reference to Active File Descriptor or Handle|C.CWE-771:Missing Reference to Active Allocated Resource", "cwe": "773"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-134:Use of Externally-Controlled Format String\nC.CWE-925:Improper Verification of Intent by Broadcast Receiver\nD.CWE-425:Direct Request ('Forced Browsing')\nE.CWE-668:Exposure of Resource to Wrong Sphere\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\nusing namespace std;\r\n\r\nnamespace My_char_listen_socket_snprintf_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, char *> dataMap);\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, char *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n \r\n strcpy(data, \"fixedstringtest\");\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, char *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n char * data;\r\n map<int, char *> dataMap;\r\n char dataBuffer[100] = \"\";\r\n data = dataBuffer;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_char_listen_socket_snprintf_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-134:Use of Externally-Controlled Format String|E.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-342:Predictable Exact Value from Previous Values\nB.CWE-413:Improper Resource Locking\nC.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nD.CWE-1231:Improper Prevention of Lock Bit Modification\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_08()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(staticReturnsTrue())\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B1()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\n\r\nstatic void nG2B2()\r\n{\r\n char * password;\r\n \r\n password = \"\";\r\n if(staticReturnsTrue())\r\n {\r\n password = (char *)malloc(100*sizeof(char));\r\n if (password == NULL)\r\n {\r\n printLine(\"Memory could not be allocated\");\r\n exit(1);\r\n }\r\n \r\n if(!VirtualLock(password, 100*sizeof(char)))\r\n {\r\n printLine(\"Memory could not be locked\");\r\n exit(1);\r\n }\r\n \r\n strcpy(password, \"Password1234!\");\r\n }\r\n {\r\n HANDLE pHandle;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n free(password);\r\n }\r\n}\r\n\r\nvoid My_w32_char_08()\r\n{\r\n nG2B1();\r\n nG2B2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-591:Sensitive Data Storage in Improperly Locked Memory|B.CWE-413:Improper Resource Locking", "cwe": "591"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1263:Improper Physical Access Control\nB.CWE-788:Access of Memory Location After End of Buffer\nC.No Vulnerabilities\nD.CWE-1222:Insufficient Granularity of Address Regions Protected by Register Locks\nE.CWE-126:Buffer Over-read\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_new_char_memcpy_34\r\n{\r\n\r\ntypedef union\r\n{\r\n char * unionFirst;\r\n char * unionSecond;\r\n} unionType;\r\n\r\n#ifndef OMITM\r\n\r\nvoid m()\r\n{\r\n char * data;\r\n unionType myUnion;\r\n data = NULL;\r\n \r\n data = new char[50];\r\n memset(data, 'A', 50-1); \r\n data[50-1] = '\\0'; \r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n unionType myUnion;\r\n data = NULL;\r\n \r\n data = new char[100];\r\n memset(data, 'A', 100-1); \r\n data[100-1] = '\\0'; \r\n myUnion.unionFirst = data;\r\n {\r\n char * data = myUnion.unionSecond;\r\n {\r\n char dest[100];\r\n memset(dest, 'C', 100-1);\r\n dest[100-1] = '\\0'; \r\n \r\n memcpy(dest, data, strlen(dest)*sizeof(char));\r\n dest[100-1] = '\\0';\r\n printLine(dest);\r\n delete [] data;\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_new_char_memcpy_34; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-126:Buffer Over-read|B.CWE-788:Access of Memory Location After End of Buffer", "cwe": "126"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-325:Missing Cryptographic Step\nB.CWE-1321:Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\nC.CWE-573:Improper Following of Specification by Caller\nD.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#include <wincrypt.h>\r\n\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n#define PAYLOAD \"plaintext\"\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_CryptDeriveKey_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n BYTE payload[100];\r\n DWORD payloadLen = strlen(PAYLOAD);\r\n HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\r\n HCRYPTHASH hHash = (HCRYPTHASH)NULL;\r\n HCRYPTKEY hKey = (HCRYPTKEY)NULL;\r\n char hashData[100] = HASH_INPUT;\r\n do\r\n {\r\n \r\n memcpy(payload, PAYLOAD, payloadLen);\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload)))\r\n {\r\n break;\r\n }\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n printBytesLine(payload, payloadLen);\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_CryptDeriveKey_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_CryptDeriveKey_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_CryptDeriveKey_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-325:Missing Cryptographic Step|C.CWE-573:Improper Following of Specification by Caller", "cwe": "325"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-478:Missing Default Case in Multiple Condition Expression\nC.CWE-1095:Loop Condition Value Update within the Loop\nD.CWE-1023:Incomplete Comparison with Missing Factors\nE.CWE-259:Use of Hard-coded Password\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_17()\r\n{\r\n int j;\r\n for(j = 0; j < 1; j++)\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n int k;\r\n for(k = 0; k < 1; k++)\r\n {\r\n {\r\n const char *charString = \"shouldn\\'t see this value\";\r\n int x;\r\n x = (rand() % 3);\r\n switch (x)\r\n {\r\n case 0:\r\n charString = \"0\";\r\n break;\r\n case 1:\r\n charString = \"1\";\r\n break;\r\n \r\n default:\r\n return;\r\n }\r\n printLine(charString);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_17()\r\n{\r\n n1();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_17();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_17();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-478:Missing Default Case in Multiple Condition Expression|D.CWE-1023:Incomplete Comparison with Missing Factors", "cwe": "478"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-134:Use of Externally-Controlled Format String\nC.CWE-506:Embedded Malicious Code\nD.CWE-1231:Improper Prevention of Lock Bit Modification\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n#define ENV_VARIABLE L\"ADD\"\r\n\r\n#ifdef _WIN32\r\n#define GETENV _wgetenv\r\n#else\r\n#define GETENV getenv\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_environment_fprintf_18()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n fwprintf(stdout, data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n {\r\n \r\n size_t dataLen = wcslen(data);\r\n wchar_t * environment = GETENV(ENV_VARIABLE);\r\n \r\n if (environment != NULL)\r\n {\r\n \r\n wcsncat(data+dataLen, environment, 100-dataLen-1);\r\n }\r\n }\r\n goto sink;\r\nsink:\r\n \r\n fwprintf(stdout, L\"%s\\n\", data);\r\n}\r\n\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * data;\r\n wchar_t dataBuffer[100] = L\"\";\r\n data = dataBuffer;\r\n goto source;\r\nsource:\r\n \r\n wcscpy(data, L\"fixedstringtest\");\r\n goto sink;\r\nsink:\r\n \r\n fwprintf(stdout, data);\r\n}\r\n\r\nvoid My_wchar_t_environment_fprintf_18()\r\n{\r\n nB2G();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_environment_fprintf_18();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_environment_fprintf_18();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-134:Use of Externally-Controlled Format String|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "134"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-1325:Improperly Controlled Sequential Memory Allocation\nB.CWE-390:Detection of Error Condition Without Action\nC.CWE-770:Allocation of Resources Without Limits or Throttling\nD.CWE-755:Improper Handling of Exceptional Conditions\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticTrue = 1; \r\nstatic int staticFalse = 0; \r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fgets_wchar_t_05()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n \r\n }\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFalse)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n printWLine(L\"fgetws failed!\");\r\n exit(1);\r\n }\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticTrue)\r\n {\r\n {\r\n \r\n wchar_t dataBuffer[100] = L\"\";\r\n wchar_t * data = dataBuffer;\r\n printWLine(L\"Please enter a string: \");\r\n \r\n if (fgetws(data, 100, stdin) == NULL)\r\n {\r\n printWLine(L\"fgetws failed!\");\r\n exit(1);\r\n }\r\n printWLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fgets_wchar_t_05()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fgets_wchar_t_05();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fgets_wchar_t_05();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-390:Detection of Error Condition Without Action|D.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-284:Improper Access Control\nB.CWE-286:Incorrect User Management\nC.No Vulnerabilities\nD.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nE.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment( lib, \"user32\" )\r\n\r\n\r\nstatic int staticFive = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_CreateDesktop_07()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_ALL,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticFive==5)\r\n {\r\n {\r\n HDESK hDesk;\r\n char * desktopName = \"DesktopExample\";\r\n \r\n hDesk = CreateDesktopA(\r\n desktopName,\r\n NULL,\r\n NULL,\r\n 0,\r\n GENERIC_READ,\r\n NULL);\r\n if (hDesk == NULL)\r\n {\r\n printLine(\"Desktop could not be created\");\r\n }\r\n else\r\n {\r\n printLine(\"Desktop created successfully\");\r\n CloseDesktop(hDesk);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_CreateDesktop_07()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_CreateDesktop_07();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_CreateDesktop_07();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-284:Improper Access Control|D.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels", "cwe": "284"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-50:Path Equivalence: '//multiple/leading/slash'\nB.CWE-404:Improper Resource Shutdown or Release\nC.CWE-1189:Improper Isolation of Shared Resources on System-on-a-Chip (SoC)\nD.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic const int STATIC_CONST_FIVE = 5;\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_no_close_06()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n ; \r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nB2G1()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(STATIC_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void nB2G2()\r\n{\r\n FILE * data;\r\n data = NULL;\r\n \r\n data = fopen(\"MSource_fopen.txt\", \"w+\");\r\n if(STATIC_CONST_FIVE==5)\r\n {\r\n \r\n if (data != NULL)\r\n {\r\n fclose(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_no_close_06()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_no_close_06();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_no_close_06();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "D.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|B.CWE-404:Improper Resource Shutdown or Release", "cwe": "775"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-222:Truncation of Security-relevant Information\nB.No Vulnerabilities\nC.CWE-287:Improper Authentication\nD.CWE-1164:Irrelevant Code\nE.CWE-563:Assignment to Variable without Use\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\nnamespace My_unused_value_wchar_t_43\r\n{\r\n\r\n#ifndef OMITM\r\n\r\nstatic void mSource(wchar_t &data)\r\n{\r\n \r\n data = L'W';\r\n}\r\n\r\nvoid m()\r\n{\r\n wchar_t data;\r\n mSource(data);\r\n \r\n data = L'Z';\r\n printf(\"%02lx\\n\", data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void nG2BSource(wchar_t &data)\r\n{\r\n \r\n data = L'W';\r\n printf(\"%02lx\\n\", data);\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t data;\r\n nG2BSource(data);\r\n \r\n data = L'Z';\r\n printf(\"%02lx\\n\", data);\r\n}\r\n\r\n\r\nstatic void nB2GSource(wchar_t &data)\r\n{\r\n \r\n data = L'W';\r\n}\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t data;\r\n nB2GSource(data);\r\n \r\n printf(\"%02lx\\n\", data);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_unused_value_wchar_t_43; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-563:Assignment to Variable without Use|D.CWE-1164:Irrelevant Code", "cwe": "563"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-546:Suspicious Comment\nB.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nC.CWE-1078:Inappropriate Source Code Style or Formatting\nD.No Vulnerabilities\nE.CWE-140:Improper Neutralization of Delimiters\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n\r\nstatic int staticReturnsTrue()\r\n{\r\n return 1;\r\n}\r\n\r\nstatic int staticReturnsFalse()\r\n{\r\n return 0;\r\n}\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_FIXME_08()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(staticReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(staticReturnsTrue())\r\n {\r\n \r\n printLine(\"Hello\");\r\n }\r\n}\r\n\r\nvoid My_FIXME_08()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_FIXME_08();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_FIXME_08();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-546:Suspicious Comment|C.CWE-1078:Inappropriate Source Code Style or Formatting", "cwe": "546"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-665:Improper Initialization\nC.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nD.No Vulnerabilities\nE.CWE-841:Improper Enforcement of Behavioral Workflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_char_ncat_66bSink(char * dataArray[]);\r\n\r\nvoid My_char_ncat_66()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n ; \r\n \r\n dataArray[2] = data;\r\n My_char_ncat_66bSink(dataArray);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_char_ncat_66bG2BSink(char * dataArray[]);\r\n\r\nstatic void nG2B()\r\n{\r\n char * data;\r\n char * dataArray[5];\r\n char dataBuffer[100];\r\n data = dataBuffer;\r\n \r\n data[0] = '\\0'; \r\n dataArray[2] = data;\r\n My_char_ncat_66bG2BSink(dataArray);\r\n}\r\n\r\nvoid My_char_ncat_66()\r\n{\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_char_ncat_66();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_char_ncat_66();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-665:Improper Initialization|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "665"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-105:Struts: Form Field Without Validator\nB.CWE-226:Sensitive Information in Resource Not Removed Before Reuse\nC.CWE-1054:Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer\nD.CWE-459:Incomplete Cleanup\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_w32_char_declare_14()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n \r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalFive!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalFive==5)\r\n {\r\n {\r\n char password[100] = \"\";\r\n size_t passwordLen = 0;\r\n HANDLE hUser;\r\n char * username = \"User\";\r\n char * domain = \"Domain\";\r\n if (fgets(password, 100, stdin) == NULL)\r\n {\r\n printLine(\"fgets() failed\");\r\n \r\n password[0] = '\\0';\r\n }\r\n \r\n passwordLen = strlen(password);\r\n if (passwordLen > 0)\r\n {\r\n password[passwordLen-1] = '\\0';\r\n }\r\n \r\n if (LogonUserA(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &hUser) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(hUser);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n passwordLen = strlen(password);\r\n \r\n SecureZeroMemory(password, passwordLen * sizeof(char));\r\n }\r\n }\r\n}\r\n\r\nvoid My_w32_char_declare_14()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32_char_declare_14();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32_char_declare_14();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-226:Sensitive Information in Resource Not Removed Before Reuse|D.CWE-459:Incomplete Cleanup", "cwe": "226"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-778:Insufficient Logging\nB.CWE-755:Improper Handling of Exceptional Conditions\nC.CWE-562:Return of Stack Variable Address\nD.No Vulnerabilities\nE.CWE-390:Detection of Error Condition Without Action\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_fopen_11()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n \r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(globalReturnsFalse())\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(globalReturnsTrue())\r\n {\r\n {\r\n FILE * fileDesc = NULL;\r\n fileDesc = fopen(\"file.txt\", \"w+\");\r\n \r\n if (fileDesc == NULL)\r\n {\r\n printLine(\"fopen() failed\");\r\n exit(1);\r\n }\r\n fclose(fileDesc);\r\n }\r\n }\r\n}\r\n\r\nvoid My_fopen_11()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_fopen_11();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_fopen_11();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-390:Detection of Error Condition Without Action|B.CWE-755:Improper Handling of Exceptional Conditions", "cwe": "390"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-668:Exposure of Resource to Wrong Sphere\nB.CWE-117:Improper Output Neutralization for Logs\nC.CWE-377:Insecure Temporary File\nD.CWE-1310:Missing Ability to Patch ROM Code\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifndef _WIN32\r\n#include <unistd.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#define OPEN _wopen\r\n#define CLOSE _close\r\n#define MKTEMP _wmktemp\r\n#define O_RDWR _O_RDWR\r\n#define O_CREAT _O_CREAT\r\n#define O_EXCL _O_EXCL\r\n#define S_IREAD _S_IREAD\r\n#define S_IWRITE _S_IWRITE\r\n#else\r\n#define OPEN open\r\n#define CLOSE close\r\n#define MKTEMP mktemp\r\n#endif\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_wchar_t_mktemp_02()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(0)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(1)\r\n {\r\n {\r\n wchar_t * filename;\r\n wchar_t tmpl[] = L\"fnXXXXXX\";\r\n int fileDesc;\r\n filename = MKTEMP(tmpl);\r\n if (filename == NULL)\r\n {\r\n exit(1);\r\n }\r\n printWLine(filename);\r\n \r\n fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\r\n if (fileDesc != -1)\r\n {\r\n printLine(\"Temporary file was opened...now closing file\");\r\n CLOSE(fileDesc);\r\n }\r\n }\r\n }\r\n}\r\n\r\nvoid My_wchar_t_mktemp_02()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_wchar_t_mktemp_02();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_wchar_t_mktemp_02();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-377:Insecure Temporary File|A.CWE-668:Exposure of Resource to Wrong Sphere", "cwe": "377"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-605:Multiple Binds to the Same Port\nC.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nD.CWE-666:Operation on Resource in Wrong Phase of Lifetime\nE.CWE-333:Improper Handling of Insufficient Entropy in TRNG\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#define PATH_SZ 100\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define PATH_SZ PATH_MAX\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define LISTEN_BACKLOG 5\r\n\r\n#ifndef OMITM\r\n\r\nvoid My_basic_13()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n#ifdef _WIN32\r\n BOOL bOptVal = TRUE;\r\n int bOptLen = sizeof(BOOL);\r\n#else\r\n int bOptVal = 1;\r\n int bOptLen = sizeof(int);\r\n#endif\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic void n1()\r\n{\r\n if(GLOBAL_CONST_FIVE!=5)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\n\r\nstatic void n2()\r\n{\r\n if(GLOBAL_CONST_FIVE==5)\r\n {\r\n {\r\n char data[100] = \"\";\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n char *replace;\r\n SOCKET listenSocket = INVALID_SOCKET;\r\n SOCKET acceptSocket = INVALID_SOCKET;\r\n size_t dataLen = strlen(data);\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (listenSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n \r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = INADDR_ANY;\r\n service.sin_port = htons(TCP_PORT);\r\n if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n acceptSocket = accept(listenSocket, NULL, NULL);\r\n if (acceptSocket == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n data[recvResult] = '\\0';\r\n \r\n replace = strchr(data, '\\r');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n replace = strchr(data, '\\n');\r\n if (replace)\r\n {\r\n *replace = '\\0';\r\n }\r\n }\r\n while (0);\r\n if (listenSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(listenSocket);\r\n }\r\n if (acceptSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(acceptSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n printLine(data);\r\n }\r\n }\r\n}\r\n\r\nvoid My_basic_13()\r\n{\r\n n1();\r\n n2();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_basic_13();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_basic_13();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "B.CWE-605:Multiple Binds to the Same Port|D.CWE-666:Operation on Resource in Wrong Phase of Lifetime", "cwe": "605"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-696:Incorrect Behavior Order\nB.CWE-432:Dangerous Signal Handler not Disabled During Sensitive Operations\nC.CWE-400:Uncontrolled Resource Consumption\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") \r\n#define CLOSE_SOCKET closesocket\r\n#else \r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <unistd.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2)\r\n\r\n#define SENTENCE \"This is the sentence we are printing to the file. \"\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid My_connect_socket_fwrite_54bSink(int count);\r\n\r\nvoid My_connect_socket_fwrite_54()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_fwrite_54bSink(count);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid My_connect_socket_fwrite_54bG2BSink(int count);\r\n\r\nstatic void nG2B()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n \r\n count = 20;\r\n My_connect_socket_fwrite_54bG2BSink(count);\r\n}\r\n\r\n\r\nvoid My_connect_socket_fwrite_54bB2GSink(int count);\r\n\r\nstatic void nB2G()\r\n{\r\n int count;\r\n \r\n count = -1;\r\n {\r\n#ifdef _WIN32\r\n WSADATA wsaData;\r\n int wsaDataInit = 0;\r\n#endif\r\n int recvResult;\r\n struct sockaddr_in service;\r\n SOCKET connectSocket = INVALID_SOCKET;\r\n char inputBuffer[CHAR_ARRAY_SIZE];\r\n do\r\n {\r\n#ifdef _WIN32\r\n if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n {\r\n break;\r\n }\r\n wsaDataInit = 1;\r\n#endif\r\n \r\n connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n if (connectSocket == INVALID_SOCKET)\r\n {\r\n break;\r\n }\r\n memset(&service, 0, sizeof(service));\r\n service.sin_family = AF_INET;\r\n service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n service.sin_port = htons(TCP_PORT);\r\n if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n {\r\n break;\r\n }\r\n \r\n recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\r\n if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n {\r\n break;\r\n }\r\n \r\n inputBuffer[recvResult] = '\\0';\r\n \r\n count = atoi(inputBuffer);\r\n }\r\n while (0);\r\n if (connectSocket != INVALID_SOCKET)\r\n {\r\n CLOSE_SOCKET(connectSocket);\r\n }\r\n#ifdef _WIN32\r\n if (wsaDataInit)\r\n {\r\n WSACleanup();\r\n }\r\n#endif\r\n }\r\n My_connect_socket_fwrite_54bB2GSink(count);\r\n}\r\n\r\nvoid My_connect_socket_fwrite_54()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_connect_socket_fwrite_54();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_connect_socket_fwrite_54();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-400:Uncontrolled Resource Consumption|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-824:Access of Uninitialized Pointer\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-675:Multiple Operations on Resource in Single-Operation Context\nD.No Vulnerabilities\nE.CWE-1269:Product Released in Non-Release Configuration\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n\r\n#ifndef OMITM\r\n\r\n\r\nstatic int mStatic = 0;\r\n\r\nstatic void mSink(HANDLE data)\r\n{\r\n if(mStatic)\r\n {\r\n \r\n CloseHandle(data);\r\n }\r\n}\r\n\r\nvoid My_w32CreateFile_21()\r\n{\r\n HANDLE data;\r\n data = INVALID_HANDLE_VALUE; \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n CloseHandle(data);\r\n mStatic = 1; \r\n mSink(data);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nstatic int nB2G1Static = 0;\r\nstatic int nB2G2Static = 0;\r\nstatic int nG2BStatic = 0;\r\n\r\n\r\nstatic void nB2G1Sink(HANDLE data)\r\n{\r\n if(nB2G1Static)\r\n {\r\n \r\n printLine(\"Benign, fixed string\");\r\n }\r\n else\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\nstatic void nB2G1()\r\n{\r\n HANDLE data;\r\n data = INVALID_HANDLE_VALUE; \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n CloseHandle(data);\r\n nB2G1Static = 0; \r\n nB2G1Sink(data);\r\n}\r\n\r\n\r\nstatic void nB2G2Sink(HANDLE data)\r\n{\r\n if(nB2G2Static)\r\n {\r\n \r\n \r\n ; \r\n }\r\n}\r\n\r\nstatic void nB2G2()\r\n{\r\n HANDLE data;\r\n data = INVALID_HANDLE_VALUE; \r\n data = CreateFile(\"MSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n \r\n CloseHandle(data);\r\n nB2G2Static = 1; \r\n nB2G2Sink(data);\r\n}\r\n\r\n\r\nstatic void nG2BSink(HANDLE data)\r\n{\r\n if(nG2BStatic)\r\n {\r\n \r\n CloseHandle(data);\r\n }\r\n}\r\n\r\nstatic void nG2B()\r\n{\r\n HANDLE data;\r\n data = INVALID_HANDLE_VALUE; \r\n \r\n data = CreateFile(\"NSource_w32CreateFile.txt\",\r\n (GENERIC_WRITE|GENERIC_READ),\r\n 0,\r\n NULL,\r\n OPEN_ALWAYS,\r\n FILE_ATTRIBUTE_NORMAL,\r\n NULL);\r\n nG2BStatic = 1; \r\n nG2BSink(data);\r\n}\r\n\r\nvoid My_w32CreateFile_21()\r\n{\r\n nB2G1();\r\n nB2G2();\r\n nG2B();\r\n}\r\n\r\n#endif \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n My_w32CreateFile_21();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n My_w32CreateFile_21();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "C.CWE-675:Multiple Operations on Resource in Single-Operation Context|B.CWE-573:Improper Following of Specification by Caller", "cwe": "675"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-319:Cleartext Transmission of Sensitive Information\nB.CWE-832:Unlock of a Resource that is not Locked\nC.CWE-918:Server-Side Request Forgery (SSRF)\nD.CWE-311:Missing Encryption of Sensitive Data\nE.No Vulnerabilities\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <windows.h>\r\n#pragma comment(lib, \"advapi32.lib\")\r\n\r\n#define HASH_INPUT \"ABCDEFG123456\" \r\n\r\nnamespace My_w32_wchar_t_listen_socket_62\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSource(wchar_t * &password);\r\n\r\nvoid m()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n mSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSource(wchar_t * &password);\r\n\r\nstatic void nG2B()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n nG2BSource(password);\r\n {\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n \r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\n\r\nvoid nB2GSource(wchar_t * &password);\r\n\r\nstatic void nB2G()\r\n{\r\n wchar_t * password;\r\n wchar_t passwordBuffer[100] = L\"\";\r\n password = passwordBuffer;\r\n nB2GSource(password);\r\n {\r\n HCRYPTPROV hCryptProv = 0;\r\n HCRYPTHASH hHash = 0;\r\n HCRYPTKEY hKey = 0;\r\n char hashData[100] = HASH_INPUT;\r\n HANDLE pHandle;\r\n wchar_t * username = L\"User\";\r\n wchar_t * domain = L\"Domain\";\r\n do\r\n {\r\n BYTE payload[(100 - 1) * sizeof(wchar_t)]; \r\n DWORD payloadBytes;\r\n \r\n payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\r\n \r\n SecureZeroMemory(password, 100 * sizeof(wchar_t));\r\n \r\n if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\r\n {\r\n break;\r\n }\r\n \r\n if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\r\n {\r\n break;\r\n }\r\n \r\n memcpy(password, payload, payloadBytes);\r\n password[payloadBytes / sizeof(wchar_t)] = L'\\0';\r\n }\r\n while (0);\r\n if (hKey)\r\n {\r\n CryptDestroyKey(hKey);\r\n }\r\n if (hHash)\r\n {\r\n CryptDestroyHash(hHash);\r\n }\r\n if (hCryptProv)\r\n {\r\n CryptReleaseContext(hCryptProv, 0);\r\n }\r\n \r\n if (LogonUserW(\r\n username,\r\n domain,\r\n password,\r\n LOGON32_LOGON_NETWORK,\r\n LOGON32_PROVIDER_DEFAULT,\r\n &pHandle) != 0)\r\n {\r\n printLine(\"User logged in successfully.\");\r\n CloseHandle(pHandle);\r\n }\r\n else\r\n {\r\n printLine(\"Unable to login.\");\r\n }\r\n }\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_w32_wchar_t_listen_socket_62; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "A.CWE-319:Cleartext Transmission of Sensitive Information|D.CWE-311:Missing Encryption of Sensitive Data", "cwe": "319"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.No Vulnerabilities\nB.CWE-329:Generation of Predictable IV with CBC Mode\nC.CWE-799:Improper Control of Interaction Frequency\nD.CWE-763:Release of Invalid Pointer or Reference\nE.CWE-762:Mismatched Memory Management Routines\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nnamespace My_delete_int64_t_malloc_74\r\n{\r\n\r\n#ifndef OMITM\r\n\r\n\r\nvoid mSink(map<int, int64_t *> dataMap);\r\n\r\nvoid m()\r\n{\r\n int64_t * data;\r\n map<int, int64_t *> dataMap;\r\n \r\n data = NULL;\r\n \r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n mSink(dataMap);\r\n}\r\n\r\n#endif \r\n\r\n#ifndef OMITN\r\n\r\n\r\nvoid nG2BSink(map<int, int64_t *> dataMap);\r\n\r\nstatic void nG2B()\r\n{\r\n int64_t * data;\r\n map<int, int64_t *> dataMap;\r\n \r\n data = NULL;\r\n \r\n data = new int64_t;\r\n \r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nG2BSink(dataMap);\r\n}\r\n\r\n\r\nvoid nB2GSink(map<int, int64_t *> dataMap);\r\n\r\nstatic void nB2G()\r\n{\r\n int64_t * data;\r\n map<int, int64_t *> dataMap;\r\n \r\n data = NULL;\r\n \r\n data = (int64_t *)malloc(100*sizeof(int64_t));\r\n dataMap[0] = data;\r\n dataMap[1] = data;\r\n dataMap[2] = data;\r\n nB2GSink(dataMap);\r\n}\r\n\r\nvoid n()\r\n{\r\n nG2B();\r\n nB2G();\r\n}\r\n\r\n#endif \r\n\r\n} \r\n\r\n\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nusing namespace My_delete_int64_t_malloc_74; \r\n\r\nint main(int argc, char * argv[])\r\n{\r\n \r\n srand( (unsigned)time(NULL) );\r\n#ifndef OMITN\r\n printLine(\"Calling n()...\");\r\n n();\r\n printLine(\"Finished n()\");\r\n#endif \r\n#ifndef OMITM\r\n printLine(\"Calling m()...\");\r\n m();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-762:Mismatched Memory Management Routines|D.CWE-763:Release of Invalid Pointer or Reference", "cwe": "762"}
{"instruction": "You are an awkward robot.You are only able to pick up 1 answer from given choices.What is the vulnerability type of the code?(A/B/C/D/E)A.CWE-483:Incorrect Block Delimitation\nB.CWE-787:Out-of-bounds Write\nC.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nD.No Vulnerabilities\nE.CWE-122:Heap-based Buffer Overflow\n", "input": "\r\n\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#ifndef _WIN32\r\n#include <wchar.h>\r\n#endif\r\n\r\n\r\n#define SRC_STRING \"AAAAAAAAAA\"\r\n\r\ntypedef union\r\n{\r\n char * unionFirst;\r\n char * unionSecond;\r\n} My_c_My_c_My_c_My_c_My_c_My_c_My_c_CWE193_char_memcpy_34();\r\n printLine(\"Finished m()\");\r\n#endif \r\n return 0;\r\n}\r\n\r\n#endif\r\noutput 'A.' or 'B.' or 'C.' or 'D.' or 'E.' only.", "output": "E.CWE-122:Heap-based Buffer Overflow|B.CWE-787:Out-of-bounds Write", "cwe": "122"}
